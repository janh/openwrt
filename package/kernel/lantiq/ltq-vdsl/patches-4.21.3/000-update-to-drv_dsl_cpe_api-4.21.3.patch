--- a/ChangeLog
+++ b/ChangeLog
@@ -1,5 +1,31 @@
 NEXT VERSION
 
+V4.21.3 - 2019-05-20
+common:
+- VRX (CURTSYS-1243) API returns wrong number of values for BAT
+- VRX (CURTSYS-465) Simplify the error handling on SendMessage implementation
+- VRX (CURTSYS-1202) Extend OLR Statistic counters with missing SOS values
+- VRX (CURTSYS-499) SDL: configuration handling update, XTSE cfg introduced
+- VRX (DSLCPE_SW-1179) Additional security checks for ROC and SOS
+- VRX (DSLCPE_SW-1182) Optimization and cleanup of handling within Ctrl/API
+- VRX (DSLCPE_SW-1181) Switching BND->Single via WebUI results in kernel crash
+- VRX (UGW_SW-32871) Always send FW configuration message on InstanceControlSet
+  + Also send FW message unconditionally within context of ModemWriteConfig
+
+V4.21.2 - 2019-02-14
+common:
+- VRX (DSLCPE_SW-1177) Adding missing parameters for Robust Overhead Channel (ROC)
+- VRX (GFASTSW-621) SDL: capability checks introduced (ioctl,procfs)
+- VRX (DSLCPE_SW-1166) SDL: driver autoload, CDEV and hotplug
+- VRX (DSLCPE_SW-1159) [VRX518] Simplified Modem Recovery for PPE FW stucks
+- VRX (DSLCPE_SW-1142) Integrate fixes/patches for thread handling (PM + Autoboot)
+- VRX (DSLCPE_SW-1097) Message dump printout is not as expected
+- VRX (DSLCPE_SW-1170) [VRX518] Unnecessary ~10 sec delay before
+  emergency_restart
+- VRX (DSLCPE_SW-1171) [VRX] Update MCAT header files to latest revision (Rev.3.2)
+- VRX (DSLCPE_SW-1173) [VRX518][Power Saving] Switching BND->Single
+- VRX (DSLCPE_SW-1172) Functional extensions for Robust Overhead Channel (ROC)
+
 V4.21.1 - 2018-10-29
 - VRX (DSLCPE_SW-1162) Power down handling does not work for ADSL
 
--- a/configure
+++ b/configure
@@ -1,7 +1,7 @@
 #! /bin/sh
 # From configure.in Revision: 1.177 .
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.69 for DSL CPE API driver 4.21.1.
+# Generated by GNU Autoconf 2.69 for DSL CPE API driver 4.21.3.
 #
 #
 # Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
@@ -577,8 +577,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='DSL CPE API driver'
 PACKAGE_TARNAME='drv_dsl_cpe_api'
-PACKAGE_VERSION='4.21.1'
-PACKAGE_STRING='DSL CPE API driver 4.21.1'
+PACKAGE_VERSION='4.21.3'
+PACKAGE_STRING='DSL CPE API driver 4.21.3'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
@@ -1440,7 +1440,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures DSL CPE API driver 4.21.1 to adapt to many kinds of systems.
+\`configure' configures DSL CPE API driver 4.21.3 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1506,7 +1506,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of DSL CPE API driver 4.21.1:";;
+     short | recursive ) echo "Configuration of DSL CPE API driver 4.21.3:";;
    esac
   cat <<\_ACEOF
 
@@ -1697,7 +1697,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-DSL CPE API driver configure 4.21.1
+DSL CPE API driver configure 4.21.3
 generated by GNU Autoconf 2.69
 
 Copyright (C) 2012 Free Software Foundation, Inc.
@@ -1752,7 +1752,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by DSL CPE API driver $as_me 4.21.1, which was
+It was created by DSL CPE API driver $as_me 4.21.3, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
@@ -2618,7 +2618,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='drv_dsl_cpe_api'
- VERSION='4.21.1'
+ VERSION='4.21.3'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -8776,7 +8776,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_wri
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by DSL CPE API driver $as_me 4.21.1, which was
+This file was extended by DSL CPE API driver $as_me 4.21.3, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -8842,7 +8842,7 @@ _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-DSL CPE API driver config.status 4.21.1
+DSL CPE API driver config.status 4.21.3
 configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
--- a/configure.in
+++ b/configure.in
@@ -1,7 +1,7 @@
 
 AC_REVISION($Revision: 1.177 $)
 
-AC_INIT([DSL CPE API driver],[4.21.1],[],[drv_dsl_cpe_api])
+AC_INIT([DSL CPE API driver],[4.21.3],[],[drv_dsl_cpe_api])
 
 AC_CONFIG_SRCDIR(src/Makefile.am)
 AM_INIT_AUTOMAKE([tar-pax])
--- a/doc/doxyconfig.vrx
+++ b/doc/doxyconfig.vrx
@@ -22,7 +22,7 @@ PROJECT_NAME           = "DSL CPE API"
 # This could be handy for archiving the generated documentation or
 # if some version control system is used.
 
-PROJECT_NUMBER         = 4.21.1
+PROJECT_NUMBER         = 4.21.3
 
 # The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)
 # base path where the generated documentation will be put.
@@ -988,6 +988,10 @@ PREDEFINED             = __PACKED__= \
                          INCLUDE_DSL_CPE_API_VDSL_SUPPORT:=1 \
                          INCLUDE_DSL_CPE_API_ADSL_SUPPORT:=0 \
                          INCLUDE_DSL_CPE_API_VRX \
+                         DSL_VRX_DEVICE_VR9 \
+                         DSL_VRX_DEVICE_VR10 \
+                         DSL_VRX_DEVICE_VR10_320 \
+                         DSL_VRX_DEVICE_VR11 \
                          DSL_DOC_GENERATION_EXCLUDE_ADSL_MIB \
                          DSL_DOC_GENERATION_EXCLUDE_UNWANTED \
                          INCLUDE_DSL_API_G997 \
--- a/LICENSE
+++ b/LICENSE
@@ -3,7 +3,8 @@ Please choose the appropriate license fo
 
 1. BSD license (2-clause BSD license)
 
-Copyright 2017, Intel Corporation
+Copyright (c) 2009-2015, LANTIQ BETEILIGUNGS-GMBH & CO. KG
+All rights reserved.
 
 Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
--- a/src/bnd/drv_dsl_cpe_api_bnd.c
+++ b/src/bnd/drv_dsl_cpe_api_bnd.c
@@ -10,6 +10,9 @@
 #define DSL_INTERN
 
 #include "drv_dsl_cpe_api.h"
+#ifdef __LINUX__
+#include <linux/capability.h>
+#endif /* __LINUX__ */
 
 #ifdef __cplusplus
    extern "C" {
@@ -29,6 +32,14 @@ DSL_Error_t DSL_DRV_BND_HwInit(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -62,6 +73,14 @@ DSL_Error_t DSL_DRV_BND_ConfigSet(
    DSL_TcLayerSelection_t nTcMode = DSL_TC_UNKNOWN;
 #endif
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -156,6 +175,14 @@ DSL_Error_t DSL_DRV_BND_ConfigGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -187,6 +214,14 @@ DSL_Error_t DSL_DRV_BND_HsStatusGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -249,6 +284,14 @@ DSL_Error_t DSL_DRV_BND_HsContinue(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -276,6 +319,14 @@ DSL_Error_t DSL_DRV_BND_EthDbgCountersGe
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -303,6 +354,14 @@ DSL_Error_t DSL_DRV_BND_EthCountersGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -326,6 +385,14 @@ DSL_Error_t DSL_DRV_BND_PortModeSyncSet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
--- a/src/common/drv_dsl_cpe_api.c
+++ b/src/common/drv_dsl_cpe_api.c
@@ -1,7 +1,9 @@
 /******************************************************************************
 
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2016 - 2019 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
 
   For licensing information, see the file 'LICENSE' in the root folder of
   this software module.
@@ -12,6 +14,9 @@
 
 #include "drv_dsl_cpe_api.h"
 #include "drv_dsl_cpe_api_ioctl.h"
+#ifdef __LINUX__
+#include <linux/capability.h>
+#endif /* __LINUX__ */
 
 #ifdef __cplusplus
    extern "C" {
@@ -49,6 +54,73 @@ DSL_uint8_t g_XTSEposs[DSL_G997_NUM_XTSE
 /* G994 Vendor ID */
 static const DSL_uint8_t g_G994VendorID[DSL_G997_LI_MAXLEN_VENDOR_ID] = {DSL_G994_VENDOR_ID};
 
+#if defined(DSL_VRX_DEVICE_VR11)
+/* IOctls which are not sending any msg to FW.
+   Frequency usage order. */
+static DSL_uint32_t g_VRxPD_IOctlWhitelist[] =
+{
+   DSL_FIO_EVENT_STATUS_GET,
+   DSL_FIO_EVENT_STATUS_MASK_CONFIG_SET,
+   DSL_FIO_AUTOBOOT_STATUS_GET,
+   DSL_FIO_G997_LINE_INVENTORY_GET,
+   DSL_FIO_LINE_STATE_GET,
+   DSL_FIO_LINE_FEATURE_CONFIG_GET,
+   DSL_FIO_LINE_FEATURE_STATUS_GET,
+   DSL_FIO_G997_XTU_SYSTEM_ENABLING_STATUS_GET,
+   DSL_FIO_G997_LINE_INIT_STATUS_GET,
+   DSL_FIO_AUTOBOOT_CONFIG_GET,
+   DSL_FIO_AUTOBOOT_CONFIG_SET,
+   DSL_FIO_AUTOBOOT_CONTROL_SET,
+   DSL_FIO_FIRMWARE_DOWNLOAD_STATUS_GET,
+   DSL_FIO_G997_LAST_STATE_TRANSMITTED_GET,
+   DSL_FIO_G997_LINE_INVENTORY_SET,
+   DSL_FIO_G997_POWER_MANAGEMENT_STATUS_GET,
+   DSL_FIO_G997_RATE_ADAPTATION_CONFIG_SET,
+   DSL_FIO_G997_XTU_SYSTEM_ENABLING_CONFIG_GET,
+   DSL_FIO_G997_XTU_SYSTEM_ENABLING_CONFIG_SET,
+   DSL_FIO_LINE_FEATURE_CONFIG_SET,
+   DSL_FIO_SHOWTIME_LOGGING_DATA_GET,
+   DSL_FIO_SYSTEM_INTERFACE_CONFIG_GET,
+   DSL_FIO_SYSTEM_INTERFACE_CONFIG_SET,
+   DSL_FIO_SYSTEM_INTERFACE_STATUS_GET,
+   DSL_FIO_BAND_PLAN_SUPPORT_GET,
+   DSL_FIO_BAND_PLAN_STATUS_GET,
+   DSL_FIO_DBG_MODULE_LEVEL_GET,
+   DSL_FIO_DBG_MODULE_LEVEL_SET,
+   DSL_FIO_DBG_MODULE_DESTINATION_GET,
+   DSL_FIO_DBG_MODULE_DESTINATION_SET,
+   /* Delimeter only. Keep it! */
+   0xFFFFFFFF
+};
+#endif
+
+/* Macro used to check if configuration parameter is in valid range */
+#define CONFIG_PARAM_RANGE_VALIDATION(Param, nMinVal, nMaxVal) \
+   do { \
+      int val = Param; \
+      if (val == CONFIGURATION_VALUE_UNDEFINED) \
+      { \
+            break; \
+      } \
+      if ((val > nMaxVal) || (val < nMinVal)) \
+      { \
+         DSL_DEBUG(DSL_DBG_MSG, \
+            (pContext, SYS_DBG_MSG"DSL Configuration Parser: Param %s " \
+            "validation failed! (min = %d, max = %d, current = %d)!" \
+            DSL_DRV_CRLF, #Param, nMinVal, nMaxVal, val)); \
+         return DSL_ERROR; \
+      } \
+   } \
+   while(0)
+
+/* Macro used to check if parameter in DSL_CPE_Configuration_t (configParam)
+is undefined, if so use currentParam (from DSL_xxxGet function or any other source) */
+#define CONFIG_PARAM_APPLY(currentParam, configParam) \
+   do { \
+      currentParam = (configParam == CONFIGURATION_VALUE_UNDEFINED) ? currentParam : configParam; \
+   } \
+   while(0)
+
 /*
    For a detailed description of the function, its arguments and return value
    please refer to the description in the header file 'drv_dsl_cpe_intern.h'
@@ -121,6 +193,35 @@ DSL_Error_t DSL_DRV_HandleLinitValue(
    DSL_G997_LineInitStatusData_t lineInitStatus;
    DSL_uint32_t nCount = 0;
 
+   switch(nSub)
+   {
+      case LINIT_SUB_S_REBOOT_REQ:
+      {
+         DSL_DEBUG(DSL_DBG_ERR,
+            (pContext, SYS_DBG_ERR"DSL[%02d]: PPE-FW stuck detected. Calling emergency restart now!"
+            DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+
+         DSL_DRV_MSecSleep(200);
+
+         DSL_DRV_EMERGENCY_RESTART;
+
+         return nErrCode;
+      }
+      case LINIT_SUB_S_AUTOMSG:
+      {
+         DSL_DEBUG(DSL_DBG_WRN,
+            (pContext, SYS_DBG_WRN"DSL[%02d]: DSL-FW does not support autonomous messages." \
+            " Switching back to polling mode."
+            DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+         DSL_CTX_WRITE_SCALAR(pContext, nErrCode, bFwEventActivation, DSL_FALSE);
+
+         break;
+      }
+      default:
+         break;
+   }
+
+
    lineInitStatus.nLineInitStatus    = nLinit;
    lineInitStatus.nLineInitSubStatus = nSub;
 
@@ -297,6 +398,14 @@ static DSL_Error_t DSL_DRV_InstanceStatu
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
 
@@ -329,6 +438,106 @@ static DSL_Error_t DSL_DRV_InstanceStatu
 }
 
 /*
+   This function validates and applies Reboot configuration
+   taken from the config file
+
+   \param pContext      Pointer to dsl library context structure, [I]
+   \param pData         Pointer to the configuration structure, [I]
+
+   \return  Return values are defined within the \ref DSL_Error_t definition
+   - DSL_SUCCESS in case of success
+   - DSL_ERROR if operation failed
+*/
+static DSL_Error_t DSL_DRV_RebootCfgValidateAndApply(
+   DSL_IN DSL_Context_t *pContext,
+   DSL_IN_OUT DSL_Configuration_t *pData)
+{
+   DSL_Error_t nErrCode = DSL_SUCCESS;
+   DSL_RebootCriteriaConfig_t sRebootCriteriaConfig;
+   DSL_CFG_RebootCriteria_t sCpeRebootCriteriaConfig;
+
+   DSL_DEBUG(DSL_DBG_MSG, (pContext, SYS_DBG_MSG
+      "DSL[%02d]: IN - DSL_DRV_RebootCfgValidateAndApply"
+      DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+
+   sCpeRebootCriteriaConfig = pData->data.sRebootCriteriaConfig;
+
+   CONFIG_PARAM_RANGE_VALIDATION(
+      sCpeRebootCriteriaConfig.Adsl,
+      DSL_REBOOT_CRITERIA_CLEANED,
+      DSL_REBOOT_CRITERIA_LCD_BC1);
+   CONFIG_PARAM_RANGE_VALIDATION(
+      sCpeRebootCriteriaConfig.Vdsl,
+      DSL_REBOOT_CRITERIA_CLEANED,
+      DSL_REBOOT_CRITERIA_LCD_BC1);
+
+   sRebootCriteriaConfig.nDslMode = DSL_MODE_ADSL;
+
+   nErrCode = DSL_DRV_RebootCriteriaConfigGet(
+      pContext, &sRebootCriteriaConfig);
+
+   CONFIG_PARAM_APPLY(
+      sRebootCriteriaConfig.data.nRebootCriteria,
+      sCpeRebootCriteriaConfig.Adsl);
+
+   nErrCode = DSL_DRV_RebootCriteriaConfigSet(
+      pContext, &sRebootCriteriaConfig);
+
+#if defined(INCLUDE_DSL_CPE_API_VRX)
+   sRebootCriteriaConfig.nDslMode = DSL_MODE_VDSL;
+
+   nErrCode = DSL_DRV_RebootCriteriaConfigGet(
+      pContext, &sRebootCriteriaConfig);
+
+   CONFIG_PARAM_APPLY(
+      sRebootCriteriaConfig.data.nRebootCriteria,
+      sCpeRebootCriteriaConfig.Vdsl);
+
+   nErrCode = DSL_DRV_RebootCriteriaConfigSet(
+      pContext, &sRebootCriteriaConfig);
+#endif
+
+   DSL_DEBUG(DSL_DBG_MSG, (pContext, SYS_DBG_MSG
+      "DSL[%02d]: OUT - DSL_DRV_RebootCfgValidateAndApplyConfig, retCode=%d"
+      DSL_DRV_CRLF, DSL_DEV_NUM(pContext), nErrCode));
+
+   return nErrCode;
+}
+
+/*
+   This function applies XTSE configuration taken from the config file
+
+   \param pContext      Pointer to dsl library context structure, [I]
+   \param pData         Pointer to the configuration structure, [I]
+
+   \return  Return values are defined within the \ref DSL_Error_t definition
+   - DSL_SUCCESS in case of success
+   - DSL_ERROR if operation failed
+*/
+static DSL_Error_t DSL_DRV_XtseCfgValidateAndApply(
+   DSL_IN DSL_Context_t *pContext,
+   DSL_IN_OUT DSL_Configuration_t *pData)
+{
+   DSL_Error_t nErrCode = DSL_SUCCESS;
+   DSL_G997_XTUSystemEnabling_t sXtse = { 0 };
+   DSL_CFG_Common_t sCommonConfig = pData->data.sCommonConfig;
+   DSL_int_t i;
+
+   nErrCode = DSL_DRV_G997_XTUSystemEnablingConfigGet(pContext, &sXtse);
+   if (nErrCode == DSL_SUCCESS)
+   {
+      for (i = 0; i < DSL_G997_NUM_XTSE_OCTETS; i++)
+      {
+         sXtse.data.XTSE[i] = sCommonConfig.G997XtuVal[i];
+      }
+
+      nErrCode = DSL_DRV_G997_XTUSystemEnablingConfigSet(pContext, &sXtse);
+   }
+
+   return nErrCode;
+}
+
+/*
    For a detailed description of the function, its arguments and return value
    please refer to the description in the header file 'drv_dsl_cpe_intern.h'
 */
@@ -998,15 +1207,21 @@ DSL_Error_t DSL_DRV_Init(
    DSL_boolean_t bFwRequest = DSL_FALSE;
 #endif /* INCLUDE_FW_REQUEST_SUPPORT*/
    DSL_FirmwareRequestType_t nFwType = DSL_FW_REQUEST_NA;
-#ifndef DSL_DEBUG_DISABLE
-   #if defined(INCLUDE_DSL_CPE_API_VRX)
+#if defined(INCLUDE_DSL_CPE_API_VRX)
+   #ifndef DSL_DEBUG_DISABLE
       DSL_DBG_ModuleLevel_t dbgModLev;
    #endif /* #ifndef DSL_DEBUG_DISABLE*/
+   #if defined(DSL_VRX_DEVICE_VR11)
+      DSL_boolean_t bRocEnable = DSL_FALSE, bSosEnable = DSL_FALSE;
+      DSL_DEV_VersionCheck_t nVerCheck = DSL_VERSION_ERROR;
+      ACK_VDSL_FeatureMapGet_t nFeatureMapGetAck = { 0 };
+   #endif /* DSL_VRX_DEVICE_VR11 */
 #endif /* INCLUDE_DSL_CPE_API_VRX */
 #if (INCLUDE_DSL_CPE_API_VDSL_SUPPORT == 1)
    DSL_PortMode_t nPortMode;
 #endif /* (INCLUDE_DSL_CPE_API_VDSL_SUPPORT == 1)*/
 
+
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
 
@@ -1029,6 +1244,8 @@ DSL_Error_t DSL_DRV_Init(
       return DSL_WRN_ALREADY_INITIALIZED;
    }
 
+   pContext->bFeaturesEnabled = DSL_FALSE;
+
 #ifndef DSL_DEBUG_DISABLE
    #if defined(INCLUDE_DSL_CPE_API_VRX)
       /* Take care that initial value for low level (MEI) driver are configured */
@@ -1153,6 +1370,9 @@ DSL_Error_t DSL_DRV_Init(
 
    pContext->lineFeatureDataCfg[DSL_MODE_ADSL][DSL_UPSTREAM].b20BitSupport = DSL_FEATURE_NA;
 
+   pContext->lineFeatureDataCfg[DSL_MODE_ADSL][DSL_UPSTREAM].bRocEnable = DSL_FEATURE_DISABLED;
+   pContext->lineFeatureDataCfg[DSL_MODE_ADSL][DSL_DOWNSTREAM].bRocEnable = DSL_FEATURE_DISABLED;
+
 #ifdef INCLUDE_DSL_CPE_API_DANUBE
    pContext->lineFeatureDataCfg[DSL_MODE_ADSL][DSL_DOWNSTREAM].b20BitSupport = DSL_FEATURE_DISABLED;
 #else
@@ -1174,6 +1394,9 @@ DSL_Error_t DSL_DRV_Init(
 
    pContext->lineFeatureDataCfg[DSL_MODE_VDSL][DSL_UPSTREAM].bVirtualNoiseSupport = DSL_TRUE;
    pContext->lineFeatureDataCfg[DSL_MODE_VDSL][DSL_DOWNSTREAM].bVirtualNoiseSupport = DSL_TRUE;
+
+   pContext->lineFeatureDataCfg[DSL_MODE_VDSL][DSL_UPSTREAM].bRocEnable = DSL_FEATURE_DISABLED;
+   pContext->lineFeatureDataCfg[DSL_MODE_VDSL][DSL_DOWNSTREAM].bRocEnable = DSL_FEATURE_DISABLED;
 #endif /* INCLUDE_DSL_CPE_API_VRX*/
 
    pContext->powerMgmtStatus.nPowerManagementStatus = DSL_G997_PMS_L3;
@@ -1218,6 +1441,9 @@ DSL_Error_t DSL_DRV_Init(
 
    DSL_DRV_MUTEX_UNLOCK(pContext->dataMutex);
 
+   pContext->nFwEventLastReadErr = DSL_ERROR;
+   pContext->nFwEventLineState = DSL_LINESTATE_UNKNOWN;
+
    /* Initialize device specific parameters*/
    nErrCode = DSL_DRV_DEV_DeviceInit(pContext, pData);
    if( nErrCode != DSL_SUCCESS )
@@ -1300,6 +1526,80 @@ DSL_Error_t DSL_DRV_Init(
          return nErrCode;
       }
 
+#if defined(INCLUDE_DSL_CPE_API_VRX)
+#if defined(DSL_VRX_DEVICE_VR11)
+      /* Enable ROC and SOS, if supported by the FW and ReTx enabled */
+      if (pContext->
+         lineFeatureDataCfg[DSL_MODE_VDSL][DSL_UPSTREAM].bReTxEnable == DSL_TRUE ||
+         pContext->
+         lineFeatureDataCfg[DSL_MODE_VDSL][DSL_DOWNSTREAM].bReTxEnable == DSL_TRUE)
+      {
+         /* minimum FW version for ROC is R6 */
+         nErrCode = DSL_DRV_VRX_FirmwareVersionCheck(pContext, DSL_MIN_FW_VERSION_VR11_R6
+            , &nVerCheck);
+         if (nErrCode == DSL_SUCCESS)
+         {
+            if (nVerCheck >= DSL_VERSION_EQUAL)
+            {
+               nErrCode = DSL_DRV_VRX_SendMsgFeatureMapGet(pContext, (DSL_uint8_t *)&nFeatureMapGetAck);
+               if (nErrCode == DSL_SUCCESS)
+               {
+                  /* for ROC, related FeatureMap bit WOF15 has to be enabled */
+                  if (nFeatureMapGetAck.W0F15 == VRX_ENABLE)
+                  {
+                     bRocEnable = DSL_TRUE;
+                     /* for SOS, related FeatureMap bit WOF13 has to be enabled */
+                     if (nFeatureMapGetAck.W0F13 == VRX_ENABLE)
+                     {
+                        bSosEnable = DSL_TRUE;
+                     }
+                  }
+               }
+               else
+               {
+                  DSL_DEBUG(DSL_DBG_WRN,
+                     (pContext, SYS_DBG_WRN"DSL[%02d]: FeatureMap get failed!"
+                     DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+               }
+            }
+         }
+         else
+         {
+            DSL_DEBUG(DSL_DBG_ERR,
+               (pContext, SYS_DBG_ERR"DSL[%02d]: ERROR - FW version check failed!"
+               DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+         }
+      }
+
+      if (bRocEnable == DSL_TRUE)
+      {
+         /* US direction */
+         if (pContext->
+            lineFeatureDataCfg[DSL_MODE_VDSL][DSL_UPSTREAM].bReTxEnable == DSL_TRUE)
+         {
+            pContext->lineFeatureDataCfg[DSL_MODE_VDSL][DSL_UPSTREAM].bRocEnable = DSL_FEATURE_ENABLED;
+            if (bSosEnable == DSL_TRUE)
+            {
+               pContext->rateAdaptationMode[DSL_MODE_VDSL][DSL_UPSTREAM] = DSL_G997_RA_MODE_DYNAMIC_SOS;
+            }
+         }
+
+         /* DS direction */
+         if (pContext->
+            lineFeatureDataCfg[DSL_MODE_VDSL][DSL_DOWNSTREAM].bReTxEnable == DSL_TRUE)
+         {
+            pContext->lineFeatureDataCfg[DSL_MODE_VDSL][DSL_DOWNSTREAM].bRocEnable = DSL_FEATURE_ENABLED;
+            if (bSosEnable == DSL_TRUE)
+            {
+               pContext->rateAdaptationMode[DSL_MODE_VDSL][DSL_DOWNSTREAM] = DSL_G997_RA_MODE_DYNAMIC_SOS;
+            }
+         }
+
+         pContext->bFeaturesEnabled = DSL_TRUE;
+      }
+#endif /* DSL_VRX_DEVICE_VR11 */
+#endif /* INCLUDE_DSL_CPE_API_VRX */
+
       /* Start Autoboot handling if allowed*/
       if( pData->data.nAutobootStartupMode != DSL_AUTOBOOT_CTRL_STOP )
       {
@@ -1355,10 +1655,6 @@ DSL_Error_t DSL_DRV_Init(
    /* Set LINIT value to LINIT_UNKNOWN*/
    DSL_CTX_WRITE_SCALAR(pContext, nErrCode, lineInitStatus.nLineInitStatus, LINIT_UNKNOWN);
 
-#if defined(DSL_VRX_DEVICE_VR11)
-   DSL_CTX_WRITE_SCALAR(pContext, nErrCode, bFwEventActivation, DSL_TRUE);
-#endif
-
    pContext->bInitComplete = DSL_TRUE;
 
    /* Generate DSL_EVENT_S_INIT_READY event*/
@@ -1404,6 +1700,41 @@ DSL_Error_t DSL_DRV_Init(
    For a detailed description of the function, its arguments and return value
    please refer to the description in the header file 'drv_dsl_cpe_intern.h'
 */
+DSL_Error_t DSL_DRV_ValidateAndApplyConfig(
+   DSL_IN DSL_Context_t *pContext,
+   DSL_IN_OUT DSL_Configuration_t *pData)
+{
+   DSL_Error_t nRet = DSL_SUCCESS, nErrCode = DSL_SUCCESS;
+
+   DSL_DEBUG(DSL_DBG_MSG,
+      (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_ValidateAndApplyConfig"DSL_DRV_CRLF,
+         DSL_DEV_NUM(pContext)));
+
+   /* valida and apply reboot config */
+   nRet = DSL_DRV_RebootCfgValidateAndApply(pContext, pData);
+   if (nRet != DSL_SUCCESS)
+   {
+      nErrCode = nRet;
+   }
+
+   /* valida and apply XTSE config */
+   nRet = DSL_DRV_XtseCfgValidateAndApply(pContext, pData);
+   if (nRet != DSL_SUCCESS)
+   {
+      nErrCode = nRet;
+   }
+
+   DSL_DEBUG(DSL_DBG_MSG,
+      (pContext, SYS_DBG_MSG"DSL[%02d]: OUT - DSL_DRV_ValidateAndApplyConfig, retCode=%d"DSL_DRV_CRLF,
+      DSL_DEV_NUM(pContext) ,nErrCode));
+
+   return nErrCode;
+}
+
+/*
+   For a detailed description of the function, its arguments and return value
+   please refer to the description in the header file 'drv_dsl_cpe_intern.h'
+*/
 DSL_void_t DSL_DRV_Free(
    DSL_IN DSL_Context_t *pContext)
 {
@@ -1486,6 +1817,21 @@ DSL_Error_t DSL_DRV_AutobootLoadFirmware
    DSL_int32_t nWaitCount = 0;
    DSL_Autoboot_State_t nState = DSL_AUTOBOOTSTATE_UNKNOWN;
    DSL_uint8_t *pFirmware = DSL_NULL, *pFirmware2 = DSL_NULL;
+#if defined(INCLUDE_DSL_CPE_API_VRX)
+   DSL_boolean_t bRocSupported = DSL_FALSE, bSosSupported = DSL_FALSE;
+#if defined(DSL_VRX_DEVICE_VR11)
+   DSL_DEV_VersionCheck_t nVerCheck = DSL_VERSION_ERROR;
+   ACK_VDSL_FeatureMapGet_t nFeatureMapGetAck = { 0 };
+#endif /* DSL_VRX_DEVICE_VR11 */
+#endif /* INCLUDE_DSL_CPE_API_VRX */
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
 
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
@@ -1696,6 +2042,95 @@ DSL_Error_t DSL_DRV_AutobootLoadFirmware
          }
 #endif /* INCLUDE_FW_REQUEST_SUPPORT*/
 
+         /* Check if ROC and SOS are still supported by the FW, disable if not */
+#if defined(INCLUDE_DSL_CPE_API_VRX)
+#if defined(DSL_VRX_DEVICE_VR11)
+         if (pContext->
+            lineFeatureDataCfg[DSL_MODE_VDSL][DSL_UPSTREAM].bReTxEnable == DSL_TRUE ||
+            pContext->
+            lineFeatureDataCfg[DSL_MODE_VDSL][DSL_DOWNSTREAM].bReTxEnable == DSL_TRUE)
+         {
+            /* Minimum FW version for ROC is R6 */
+            nErrCode = DSL_DRV_VRX_FirmwareVersionCheck(pContext,
+               DSL_MIN_FW_VERSION_VR11_R6, &nVerCheck);
+            if (nErrCode == DSL_SUCCESS)
+            {
+               if (nVerCheck >= DSL_VERSION_EQUAL)
+               {
+                  /* set the features only once */
+                  if (pContext->bFeaturesEnabled == DSL_FALSE)
+                  {
+                     nErrCode = DSL_DRV_VRX_SendMsgFeatureMapGet(pContext, (DSL_uint8_t *)&nFeatureMapGetAck);
+                     if (nErrCode == DSL_SUCCESS)
+                     {
+                        /* For ROC, related FeatureMap bit WOF15 has to be enabled */
+                        if (nFeatureMapGetAck.W0F15 == VRX_ENABLE)
+                        {
+                           bRocSupported = DSL_TRUE;
+                           /* For SOS, related FeatureMap bit WOF13 has to be enabled */
+                           if (nFeatureMapGetAck.W0F13 == VRX_ENABLE)
+                           {
+                              bSosSupported = DSL_TRUE;
+                           }
+                        }
+                     }
+                     else
+                     {
+                        DSL_DEBUG(DSL_DBG_ERR,
+                           (pContext, SYS_DBG_ERR"DSL[%02d]: ERROR - FeatureMap get failed!"
+                              DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+                     }
+                  }
+               }
+            }
+            else
+            {
+               DSL_DEBUG(DSL_DBG_ERR,
+                  (pContext, SYS_DBG_ERR"DSL[%02d]: ERROR - FW version check failed!"
+                  DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+            }
+         }
+#endif /* DSL_VRX_DEVICE_VR11 */
+
+         /* if supported, enable by default */
+         if (bRocSupported == DSL_TRUE)
+         {
+            /* Enable ROC */
+            pContext->lineFeatureDataCfg[DSL_MODE_VDSL][DSL_UPSTREAM].bRocEnable = DSL_FEATURE_ENABLED;
+            pContext->lineFeatureDataCfg[DSL_MODE_VDSL][DSL_DOWNSTREAM].bRocEnable = DSL_FEATURE_ENABLED;
+
+            if (bSosSupported == DSL_TRUE)
+            {
+               pContext->rateAdaptationMode[DSL_MODE_VDSL][DSL_UPSTREAM] = DSL_G997_RA_MODE_DYNAMIC_SOS;
+               pContext->rateAdaptationMode[DSL_MODE_VDSL][DSL_DOWNSTREAM] = DSL_G997_RA_MODE_DYNAMIC_SOS;
+            }
+            else
+            {
+               /* Restore rateAdaptationMode to its default */
+               pContext->rateAdaptationMode[DSL_MODE_VDSL][DSL_UPSTREAM] =
+                  DSL_G997_RA_MODE_DYNAMIC;
+               pContext->rateAdaptationMode[DSL_MODE_VDSL][DSL_DOWNSTREAM] =
+                  DSL_G997_RA_MODE_DYNAMIC;
+            }
+
+            pContext->bFeaturesEnabled = DSL_TRUE;
+         }
+         else /* disable sequence: SOS->ROC */
+         {
+            /* Restore rateAdaptationMode to its default */
+            pContext->rateAdaptationMode[DSL_MODE_VDSL][DSL_UPSTREAM] =
+               DSL_G997_RA_MODE_DYNAMIC;
+            pContext->rateAdaptationMode[DSL_MODE_VDSL][DSL_DOWNSTREAM] =
+               DSL_G997_RA_MODE_DYNAMIC;
+
+            /* Disable ROC */
+            pContext->lineFeatureDataCfg[DSL_MODE_VDSL][DSL_UPSTREAM].bRocEnable =
+               DSL_FEATURE_DISABLED;
+            pContext->lineFeatureDataCfg[DSL_MODE_VDSL][DSL_DOWNSTREAM].bRocEnable =
+               DSL_FEATURE_DISABLED;
+         }
+#endif /* INCLUDE_DSL_CPE_API_VRX */
+
          /* Get Autoboot pending start flag*/
          DSL_CTX_READ(pContext, nErrCode, bAutobootStartPending, bAutobootStartPending);
 
@@ -1757,6 +2192,14 @@ DSL_Error_t DSL_DRV_AutobootControlSet(
    DSL_uint32_t nOppositeLine;
    DSL_uint32_t nRemotePafAvailable = 0;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_AutobootControlSet(%d)"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext), pData->data.nCommand));
@@ -2069,6 +2512,14 @@ DSL_Error_t DSL_DRV_AutobootConfigGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -2097,6 +2548,14 @@ DSL_Error_t DSL_DRV_AutobootConfigSet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -2124,6 +2583,14 @@ DSL_Error_t DSL_DRV_FirmwareDownloadStat
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -2177,6 +2644,14 @@ DSL_Error_t DSL_DRV_AutobootStatusGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -2284,6 +2759,14 @@ DSL_Error_t DSL_DRV_ResourceUsageStatist
    DSL_OpenContext_t *pOpenContext = DSL_NULL;
    DSL_ResourceUsageStatisticsData_t devResourceUsageStatisticsData;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -2535,6 +3018,14 @@ DSL_Error_t DSL_DRV_VersionInformationGe
    DSL_boolean_t bFirmwareReady = DSL_FALSE;
    DSL_uint32_t verNum = 0;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -2593,6 +3084,14 @@ DSL_Error_t DSL_DRV_LineStateGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_LineStateGet"DSL_DRV_CRLF,
       DSL_DEV_NUM(pContext)));
@@ -2619,7 +3118,21 @@ DSL_Error_t DSL_DRV_LineFeatureConfigSet
    DSL_IN_OUT DSL_LineFeature_t *pData)
 {
    DSL_boolean_t bReTxEnableDs = DSL_FALSE;
+   DSL_boolean_t bRocEnable = DSL_FALSE;
    DSL_Error_t nErrCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
+   DSL_G997_RA_MODE_t raMode = DSL_G997_RA_MODE_AT_INIT;
+#if defined (DSL_VRX_DEVICE_VR11)
+   DSL_DEV_VersionCheck_t nVerCheck = DSL_VERSION_ERROR;
+   ACK_VDSL_FeatureMapGet_t nFeatureMapGetAck = { 0 };
+#endif
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
 
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_LineFeatureConfigSet"
@@ -2679,6 +3192,142 @@ DSL_Error_t DSL_DRV_LineFeatureConfigSet
       }
    }
 
+   if (pData->data.bRocEnable != DSL_FEATURE_NA)
+   {
+      if (pData->nDslMode == DSL_MODE_VDSL)
+      {
+         if (pData->data.bRocEnable == DSL_FEATURE_ENABLED)
+         {
+            /* ReTx has to be enabled */
+            if (pData->data.bReTxEnable == DSL_TRUE)
+            {
+               /* enable only if disabled */
+               if (pContext->
+                  lineFeatureDataCfg[pData->nDslMode][pData->nDirection].bRocEnable ==
+                  DSL_FEATURE_DISABLED)
+               {
+#if defined (DSL_VRX_DEVICE_VR11)
+                  /* minimum FW version for ROC is R6 */
+                  nErrCode = DSL_DRV_VRX_FirmwareVersionCheck(pContext,
+                     DSL_MIN_FW_VERSION_VR11_R6, &nVerCheck);
+                  if (nErrCode == DSL_SUCCESS)
+                  {
+                     if (nVerCheck >= DSL_VERSION_EQUAL)
+                     {
+                        /* related FeatureMap bit WOF15 has to be enabled */
+                        nErrCode = DSL_DRV_VRX_SendMsgFeatureMapGet(pContext,
+                           (DSL_uint8_t *)&nFeatureMapGetAck);
+                        if (nErrCode == DSL_SUCCESS)
+                        {
+
+                           if (nFeatureMapGetAck.W0F15 == VRX_ENABLE)
+                           {
+                              bRocEnable = DSL_TRUE;
+                           }
+                        }
+                        else
+                        {
+                           DSL_DEBUG(DSL_DBG_ERR,
+                              (pContext, SYS_DBG_ERR"DSL[%02d]: ERROR - "
+                                 "FeatureMap get failed!" DSL_DRV_CRLF,
+                                 DSL_DEV_NUM(pContext)));
+
+                           nRet = DSL_WRN_CONFIG_PARAM_IGNORED;
+                        }
+                     }
+                     else
+                     {
+                        DSL_DEBUG(DSL_DBG_WRN,
+                           (pContext, SYS_DBG_WRN"DSL[%02d]: minimum FW version R6 "
+                              "is required for requested configuration." DSL_DRV_CRLF,
+                              DSL_DEV_NUM(pContext)));
+
+                        nRet = DSL_WRN_CONFIG_PARAM_IGNORED;
+                     }
+                  }
+                  else
+                  {
+                     DSL_DEBUG(DSL_DBG_ERR,
+                        (pContext, SYS_DBG_ERR"DSL[%02d]: ERROR - FW version check failed!"
+                           DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+
+                     nRet = DSL_WRN_CONFIG_PARAM_IGNORED;
+                  }
+#else
+                  nRet = DSL_WRN_CONFIG_PARAM_IGNORED;
+#endif /* defined (DSL_VRX_DEVICE_VR11) */
+               }
+               else
+               {
+                  /* do not disable */
+                  bRocEnable = DSL_TRUE;
+               }
+            }
+            else
+            {
+               /* if ROC already enabled, ReTx cannot be disabled
+                  (required disable sequence: ROC -> ReTx) */
+               if (pContext->
+                  lineFeatureDataCfg[pData->nDslMode][pData->nDirection].bRocEnable ==
+                  DSL_FEATURE_ENABLED)
+               {
+                  DSL_DEBUG(DSL_DBG_WRN,
+                     (pContext, SYS_DBG_WRN"DSL[%02d]: insufficient dependency - "
+                     "Roc depends on ReTx." DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+
+                  pData->data.bReTxEnable = DSL_TRUE;
+                  bRocEnable = DSL_TRUE;
+               }
+               else
+               {
+                  DSL_DEBUG(DSL_DBG_WRN,
+                     (pContext, SYS_DBG_WRN"DSL[%02d]: ReTx is required for "
+                     "requested configuration." DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+               }
+
+               nRet = DSL_WRN_CONFIG_ONLY_SUPPORTED_WITH_RTX_ENABLED;
+            }
+         }
+
+         /* disable ROC */
+         if (bRocEnable == DSL_FALSE)
+         {
+            /* Disable only if SOS is not enabled
+               (required disable sequence: SOS -> ROC) */
+            DSL_CTX_READ(pContext, nErrCode,
+               rateAdaptationMode[pData->nDslMode][pData->nDirection],
+               raMode);
+            if (raMode != DSL_G997_RA_MODE_DYNAMIC_SOS)
+            {
+               pData->data.bRocEnable = DSL_FEATURE_DISABLED;
+            }
+            else
+            {
+               DSL_DEBUG(DSL_DBG_WRN,
+                  (pContext, SYS_DBG_WRN"DSL[%02d]: insufficient dependency - "
+                  "rate adaptation config depends on Roc (and Roc on ReTx)."
+                  DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+               /* if ReTx was to be disabled, it has to stay enabled */
+               pData->data.bReTxEnable = DSL_TRUE;
+               pData->data.bRocEnable = DSL_FEATURE_ENABLED;
+
+               nRet = DSL_WRN_CONFIG_PARAM_IGNORED;
+            }
+         }
+      }
+      else
+      {
+         pData->data.bRocEnable = DSL_FEATURE_DISABLED;
+         nRet = DSL_WRN_CONFIG_PARAM_IGNORED;
+      }
+   }
+   else
+   {
+      DSL_CTX_READ_SCALAR(pContext, nErrCode,
+         lineFeatureDataCfg[pData->nDslMode][pData->nDirection].bRocEnable,
+         pData->data.bRocEnable);
+   }
+
    DSL_CTX_WRITE(pContext, nErrCode,
       lineFeatureDataCfg[pData->nDslMode][pData->nDirection], pData->data);
 
@@ -2700,6 +3349,14 @@ DSL_Error_t DSL_DRV_LineFeatureConfigGet
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_LineFeatureConfigGet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
@@ -2736,6 +3393,14 @@ DSL_Error_t DSL_DRV_LineFeatureStatusGet
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_LineStateValue_t nCurrentState = DSL_LINESTATE_UNKNOWN;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_LineFeatureStatusGet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
@@ -2780,6 +3445,14 @@ DSL_Error_t DSL_DRV_InteropFeatureConfig
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_InteropFeatureConfigSet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
@@ -2818,6 +3491,14 @@ DSL_Error_t DSL_DRV_InteropFeatureConfig
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_InteropFeatureConfigGet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
@@ -2846,6 +3527,14 @@ DSL_Error_t DSL_DRV_LoopLengthStatusGet(
    DSL_Error_t nLoopLengthErrCode = DSL_SUCCESS;
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -2915,6 +3604,14 @@ DSL_Error_t DSL_DRV_RetxStatisticsGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
    DSL_CHECK_DIRECTION(pData->nDirection);
@@ -3023,6 +3720,15 @@ DSL_Error_t DSL_DRV_SystemInterfaceConfi
    DSL_SystemInterfaceConfig_t *pData)
 {
    DSL_Error_t nErrCode = DSL_SUCCESS, nRetCode = DSL_SUCCESS;
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -3062,6 +3768,15 @@ DSL_Error_t DSL_DRV_SystemInterfaceConfi
    DSL_SystemInterfaceConfig_t *pData)
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -3093,6 +3808,15 @@ DSL_Error_t DSL_DRV_SystemInterfaceStatu
    DSL_SystemInterfaceStatus_t *pData)
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -3239,6 +3963,15 @@ DSL_Error_t DSL_DRV_BandBorderStatusGet(
    DSL_BandBorderStatus_t *pData)
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
    DSL_CHECK_DIRECTION(pData->nDirection);
@@ -3267,6 +4000,15 @@ DSL_Error_t DSL_DRV_MiscLineStatusGet(
    DSL_MiscLineStatus_t *pData)
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -3297,6 +4039,15 @@ DSL_Error_t DSL_DRV_LineOptionsConfigSet
 #ifdef INCLUDE_DSL_CPE_API_DANUBE
    DSL_boolean_t bTrustMeBit;
 #endif /* INCLUDE_DSL_CPE_API_DANUBE*/
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -3390,6 +4141,15 @@ DSL_Error_t DSL_DRV_LineOptionsConfigGet
    DSL_LineOptionsConfig_t *pData)
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -3442,6 +4202,15 @@ DSL_Error_t DSL_LastExceptionCodesGet(
    DSL_LastExceptionCodes_t *pData)
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -3469,6 +4238,15 @@ DSL_Error_t DSL_DRV_LowLevelConfiguratio
    DSL_LowLevelConfiguration_t *pData)
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -3501,6 +4279,15 @@ DSL_Error_t DSL_DRV_LowLevelConfiguratio
    DSL_LowLevelConfiguration_t *pData)
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -3529,6 +4316,15 @@ DSL_Error_t DSL_DRV_AuxLineInventoryGet(
    DSL_AuxLineInventory_t *pData)
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
    DSL_CHECK_ATU_DIRECTION(pData->nDirection);
@@ -3559,6 +4355,14 @@ DSL_Error_t DSL_DRV_BandPlanStatusGet(
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_LineStateValue_t nCurrentState = DSL_LINESTATE_UNKNOWN;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -3599,6 +4403,15 @@ DSL_Error_t DSL_DRV_BandPlanSupportedGet
    DSL_BandPlanSupport_t *pData)
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -3626,6 +4439,14 @@ DSL_Error_t DSL_DRV_VdslProfileConfigSet
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -3653,6 +4474,14 @@ DSL_Error_t DSL_DRV_VdslProfileConfigGet
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -3685,6 +4514,14 @@ DSL_Error_t DSL_DRV_EventStatusMaskConfi
    DSL_uint32_t nEventMask;
    DSL_boolean_t bFwEv = DSL_FALSE;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -3814,6 +4651,14 @@ DSL_Error_t DSL_DRV_EventStatusMaskConfi
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_uint32_t nEventMask;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -3892,6 +4737,14 @@ DSL_Error_t DSL_DRV_FramingParameterStat
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -3923,6 +4776,14 @@ DSL_Error_t DSL_DRV_PilotTonesStatusGet(
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_LineStateValue_t nCurrentState = DSL_LINESTATE_UNKNOWN;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -3967,6 +4828,14 @@ DSL_Error_t DSL_DRV_RebootCriteriaConfig
 {
    DSL_Error_t nErrCode = DSL_SUCCESS, nRet = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -4006,6 +4875,14 @@ DSL_Error_t DSL_DRV_RebootCriteriaConfig
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -4044,6 +4921,14 @@ DSL_Error_t DSL_DRV_DBG_ModuleLevelSet(
    IOCTL_MEI_dbgLevel_t fioVrxDrvDbgLevelSet;
 #endif /* INCLUDE_DSL_CPE_API_VRX */
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -4251,6 +5136,14 @@ DSL_Error_t DSL_DRV_DBG_ModuleLevelGet(
    DSL_debugLevelEntry_t *pDbgLvlNames = DSL_NULL;
    DSL_int_t i = 0;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -4318,6 +5211,14 @@ DSL_Error_t DSL_DRV_DBG_ModuleDestinatio
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -4343,6 +5244,14 @@ DSL_Error_t DSL_DRV_DBG_ModuleDestinatio
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -4386,6 +5295,15 @@ DSL_Error_t DSL_DRV_DBG_DebugFeatureConf
    DSL_IN DSL_DBG_DebugFeatureConfig_t *pData)
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -4402,6 +5320,15 @@ DSL_Error_t DSL_DRV_DBG_DebugFeatureConf
    DSL_IN DSL_DBG_DebugFeatureConfig_t *pData)
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -4422,6 +5349,15 @@ DSL_Error_t DSL_DRV_FilterDetectionDataG
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_boolean_t bFilterDetectionCompleted = DSL_FALSE;
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -4472,6 +5408,14 @@ DSL_Error_t DSL_DRV_HybridSelectionDataG
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -4526,6 +5470,14 @@ DSL_Error_t DSL_DRV_OlrStatisticsGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
    DSL_CHECK_DIRECTION(pData->nDirection);
@@ -4740,6 +5692,14 @@ DSL_Error_t DSL_DRV_RTT_Init(
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_boolean_t bRttEnabled = DSL_FALSE;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -4777,6 +5737,14 @@ DSL_Error_t DSL_DRV_RTT_ConfigSet(
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_boolean_t bRttEnabled = DSL_FALSE;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -4814,6 +5782,14 @@ DSL_Error_t DSL_DRV_RTT_ConfigGet(
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_boolean_t bRttEnabled = DSL_FALSE;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -4850,6 +5826,14 @@ DSL_Error_t DSL_DRV_RTT_StatusGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -4881,6 +5865,14 @@ DSL_Error_t DSL_DRV_RTT_ControlSet(
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_boolean_t bRttEnabled = DSL_FALSE;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -4918,6 +5910,14 @@ DSL_Error_t DSL_DRV_RTT_StatisticsGet(
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_boolean_t bRttEnabled = DSL_FALSE;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -4953,6 +5953,14 @@ DSL_Error_t DSL_DRV_T1413_XTUO_RevisionS
    DSL_uint8_t XTSE1 = 0;
    DSL_LineStateValue_t nCurrentState = DSL_LINESTATE_UNKNOWN;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -5032,6 +6040,14 @@ DSL_Error_t DSL_DRV_T1413_XTUR_RevisionS
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_uint8_t XTSE1 = 0;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -5081,6 +6097,14 @@ DSL_Error_t DSL_DRV_T1413_XTUO_VendorRev
    DSL_uint8_t XTSE1 = 0;
    DSL_LineStateValue_t nCurrentState = DSL_LINESTATE_UNKNOWN;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -5160,6 +6184,14 @@ DSL_Error_t DSL_DRV_T1413_XTUR_VendorRev
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_uint8_t XTSE1 = 0;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -5206,6 +6238,15 @@ DSL_Error_t DSL_DRV_PSDCalibrationConfig
    DSL_IN_OUT DSL_PSDCalibration_t *pData)
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
    DSL_CHECK_DIRECTION(pData->nDirection);
@@ -5233,6 +6274,14 @@ DSL_Error_t DSL_DRV_PSDCalibrationConfig
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -5270,7 +6319,10 @@ DSL_IOCTL_REGISTER(DSL_FIO_AUTOBOOT_STAT
 DSL_IOCTL_REGISTER(DSL_FIO_LINE_STATE_GET, DSL_IOCTL_HELPER_GET,
                    DSL_FALSE, DSL_DRV_LineStateGet,
                    sizeof(DSL_LineState_t)),
-
+/* DSL_FIO_CONFIGURATION_RELOAD */
+DSL_IOCTL_REGISTER(DSL_FIO_CONFIGURATION_RELOAD, DSL_IOCTL_HELPER_SET,
+                   DSL_FALSE, DSL_DRV_ValidateAndApplyConfig,
+                   sizeof(DSL_Configuration_t)),
 /* DSL_FIO_AUTOBOOT_CONFIG_SET */
 DSL_IOCTL_REGISTER(DSL_FIO_AUTOBOOT_CONFIG_SET, DSL_IOCTL_HELPER_SET,
                    DSL_FALSE, DSL_DRV_AutobootConfigSet,
@@ -6274,6 +7326,7 @@ DSL_Error_t DSL_DRV_IoctlHandle(
    DSL_DEV_Handle_t dev;
 #if defined (DSL_VRX_DEVICE_VR11)
    DSL_DEV_VersionCheck_t nVerCheck = DSL_VERSION_ERROR;
+   DSL_boolean_t bPowerDownInaccessibleFW = DSL_FALSE;
 #endif
    DSL_uint32_t nOppositeLine;
 
@@ -6284,6 +7337,36 @@ DSL_Error_t DSL_DRV_IoctlHandle(
       nCommand, DSL_DBG_IoctlName(nCommand)));
 #endif /* DSL_DEBUG_DISABLE*/
 
+#if defined (DSL_VRX_DEVICE_VR11)
+   DSL_CTX_READ_SCALAR(pContext, nErrCode, bPowerDownInaccessibleFW, bPowerDownInaccessibleFW);
+
+   if (bPowerDownInaccessibleFW == DSL_TRUE)
+   {
+      /* Handle VRX IOctl white list*/
+      i = 0;
+      while (g_VRxPD_IOctlWhitelist[i] != 0xFFFFFFFF)
+      {
+         if (nCommand == g_VRxPD_IOctlWhitelist[i])
+            break;
+         ++i;
+      }
+
+      if (g_VRxPD_IOctlWhitelist[i] == 0xFFFFFFFF)
+      {
+         nErrCode = DSL_ERR_NOT_SUPPORTED_IN_CURRENT_AUTOBOOT_STATE;
+         DSL_IoctlMemCpyTo( bIsInKernel, (DSL_void_t*)nArg, &nErrCode,
+            sizeof(DSL_Error_t));
+
+         DSL_DEBUG(DSL_DBG_WRN,
+            (pContext, SYS_DBG_WRN"DSL[%02d]: Unsupported in PD mode IOctl=0x%08X (%s)!"
+            DSL_DRV_CRLF, DSL_DEV_NUM(pContext), nCommand, DSL_DBG_IoctlName(nCommand)));
+
+         return nErrCode;
+      }
+   }
+#endif
+
+   /* VRx message white list handling END*/
    switch (nCommand)
    {
       case DSL_FIO_INIT:
@@ -6869,11 +7952,6 @@ DSL_Error_t DSL_DRV_IoctlHandle(
                         SYS_DBG_ERR"DSL[%02d]: ERROR - VRx NFC set callback failed!"
                         DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
                   }
-                  else
-                  {
-                     /* Try to send but do not forward error in case of very early cli ics execute */
-                     DSL_DRV_VRX_SendMsgModemFSMEventConfigure(pContext, bFwEventActivation);
-                  }
                }
                else
                {
@@ -6889,6 +7967,9 @@ DSL_Error_t DSL_DRV_IoctlHandle(
                   }
                }
 
+               /* Try to send but do not forward error in case of very early cli ics execute */
+               DSL_DRV_VRX_SendMsgModemFSMEventConfigure(pContext, bFwEventActivation);
+
                if (DSL_DRV_BONDING_ENABLED && DSL_DRV_LINES_PER_DEVICE == 1)
                {
                   nOppositeLine = (DSL_DEV_NUM(pContext) + 1) % DSL_DRV_ENTITIES;
@@ -7047,6 +8128,14 @@ DSL_Error_t DSL_DRV_TestModeControlSet(
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_TestModeControlSet_t nTestModeControl = DSL_TESTMODE_DISABLE;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_TestModeControlSet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
@@ -7099,6 +8188,14 @@ DSL_Error_t DSL_DRV_TestModeStatusGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_TestModeStatusGet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
@@ -8043,6 +9140,14 @@ DSL_Error_t DSL_DRV_DeltSNRGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
--- a/src/common/drv_dsl_cpe_autoboot.c
+++ b/src/common/drv_dsl_cpe_autoboot.c
@@ -74,7 +74,6 @@ DSL_Error_t DSL_DRV_AutobootSignalDevice
    if(pContext && pContext->bFwEventActivation)
    {
       pContext->bFwEventRcvd = DSL_TRUE;
-      DSL_DRV_WAKEUP_EVENT(pContext->autobootEvent);
    }
    else
    {
@@ -1131,7 +1130,7 @@ static DSL_Error_t DSL_DRV_AutobootHandl
 
    DSL_DEBUG(DSL_DBG_MSG, (pContext, SYS_DBG_MSG
       "DSL[%02d]: OUT - DSL_DRV_AutobootHandleOrderlyShutdownWait, retCode=%d"
-      DSL_DRV_CRLF, nErrCode, DSL_DEV_NUM(pContext)));
+      DSL_DRV_CRLF, DSL_DEV_NUM(pContext), nErrCode));
 
    return nErrCode;
 }
--- a/src/common/drv_dsl_cpe_debug.c
+++ b/src/common/drv_dsl_cpe_debug.c
@@ -131,6 +131,8 @@ DSL_char_t* DSL_DBG_IoctlName(DSL_uint_t
    {
    case DSL_FIO_INIT:
       return "DSL_FIO_INIT";
+   case DSL_FIO_CONFIGURATION_RELOAD:
+      return "DSL_FIO_CONFIGURATION_RELOAD";
    case DSL_FIO_AUTOBOOT_LOAD_FIRMWARE:
       return "DSL_FIO_AUTOBOOT_LOAD_FIRMWARE";
    case DSL_FIO_AUTOBOOT_CONTROL_SET:
--- a/src/common/drv_dsl_cpe_os_linux.c
+++ b/src/common/drv_dsl_cpe_os_linux.c
@@ -1,7 +1,7 @@
 /******************************************************************************
 
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
+           Copyright (c) 2018      Intel Corporation
+           Copyright (c) 2007-2015 Lantiq Beteiligungs-GmbH & Co. KG
 
   For licensing information, see the file 'LICENSE' in the root folder of
   this software module.
@@ -20,6 +20,7 @@
 #include "drv_dsl_cpe_debug.h"
 
 #include <linux/device.h>
+#include <linux/cdev.h>
 
 #include "drv_mei_cpe_api_intern.h" /* MEI_InternalDevLayout */
 
@@ -93,6 +94,7 @@ DSL_uint8_t g_MaxEntieties = 1;
 /* the major number of this driver */
 static int nMajorNum = DRV_DSL_CPE_API_DEV_MAJOR;
 static struct class *dsl_class;
+static struct cdev *p_dsl_api_cdevs[DSL_DRV_MAX_SUPPORTED_ENTITIES];
 
 #ifndef _lint
 static struct file_operations dslCpeApiOperations = {
@@ -371,11 +373,17 @@ static DSL_uint_t DSL_DRV_Poll(DSL_DRV_f
 
 static int DSL_DRV_DevNodeInit(DSL_void_t)
 {
+   int result;
    DSL_int_t i;
    static dev_t dsl_devt;
+   struct device *tmp_dev = NULL;
 
-   if (register_chrdev(nMajorNum, DRV_DSL_CPE_API_DEV_NAME,
-                        &dslCpeApiOperations) != 0)
+   memset(&(p_dsl_api_cdevs), 0x00, sizeof(struct cdev *) * DSL_DRV_MAX_SUPPORTED_ENTITIES);
+
+   dsl_devt = MKDEV(nMajorNum, 0);
+   result = register_chrdev_region(dsl_devt, DSL_DRV_ENTITIES, DRV_DSL_CPE_API_DEV_NAME);
+
+   if (result < 0)
    {
       DSL_DEBUG(DSL_DBG_ERR,
          (DSL_NULL, SYS_DBG_ERR""DSL_DRV_CRLF DSL_DRV_CRLF"unable to register "
@@ -392,14 +400,65 @@ static int DSL_DRV_DevNodeInit(DSL_void_
       return PTR_ERR(dsl_class);
    }
 
-   /* create /dev/ entry for each device */
-   for (i=0; i < DSL_DRV_ENTITIES; i++)
+   for (i = 0; i < DSL_DRV_ENTITIES; ++i)
    {
       dsl_devt = MKDEV(nMajorNum, i);
-      device_create(dsl_class, NULL, dsl_devt, NULL, "%s/%i", "dsl_cpe_api", i);
+
+      p_dsl_api_cdevs[i] = cdev_alloc();
+      if (p_dsl_api_cdevs[i] != NULL)
+      {
+         p_dsl_api_cdevs[i]->ops = &dslCpeApiOperations;
+         p_dsl_api_cdevs[i]->owner = THIS_MODULE;
+      }
+      else
+      {
+         DSL_DEBUG(DSL_DBG_ERR,
+            (DSL_NULL, SYS_DBG_ERR""DSL_DRV_CRLF DSL_DRV_CRLF
+             "cannot allocate cdev <dev_node=%d>", MINOR(dsl_devt)));
+         goto DRV_DSL_API_DEV_NODE_INIT_ERR;
+      }
+
+      result = cdev_add(p_dsl_api_cdevs[i], dsl_devt, 1);
+      if (result < 0)
+      {
+         DSL_DEBUG(DSL_DBG_ERR,
+            (DSL_NULL, SYS_DBG_ERR""DSL_DRV_CRLF DSL_DRV_CRLF
+             "cannot add cdev <dev_node=%d> to system (result=%d)", MINOR(dsl_devt), result));
+         goto DRV_DSL_API_DEV_NODE_INIT_ERR;
+      }
+
+      tmp_dev = device_create(dsl_class, NULL, dsl_devt, NULL,
+                              "%s/%i",
+                              "dsl_cpe_api", i);
+
+      if (IS_ERR(tmp_dev))
+      {
+         DSL_DEBUG(DSL_DBG_ERR,
+            (DSL_NULL, SYS_DBG_ERR""DSL_DRV_CRLF DSL_DRV_CRLF"cannot create device node <%s/%i>",
+             "dsl_cpe_api", i));
+         goto DRV_DSL_API_DEV_NODE_INIT_ERR;
+      }
    }
 
    return 0;
+
+DRV_DSL_API_DEV_NODE_INIT_ERR:
+   for (i = 0; i < DSL_DRV_ENTITIES; ++i)
+   {
+      cdev_del(p_dsl_api_cdevs[i]);
+      p_dsl_api_cdevs[i] = NULL;
+   }
+
+   if (!IS_ERR(dsl_class))
+   {
+      class_destroy(dsl_class);
+      dsl_class = NULL;
+   }
+
+   dsl_devt = MKDEV(nMajorNum, 0);
+   unregister_chrdev_region(dsl_devt, DSL_DRV_ENTITIES);
+
+   return result;
 }
 
 /*
@@ -1335,12 +1394,20 @@ void __exit DSL_ModuleCleanup(void)
    {
       dsl_devt = MKDEV(nMajorNum, i);
       device_destroy(dsl_class, dsl_devt);
+
+      if (p_dsl_api_cdevs[i])
+      {
+         cdev_del(p_dsl_api_cdevs[i]);
+         p_dsl_api_cdevs[i] = NULL;
+      }
    }
+
    class_destroy(dsl_class);
    dsl_class = NULL;
 
-   unregister_chrdev(nMajorNum, DRV_DSL_CPE_API_DEV_NAME);
-   
+   dsl_devt = MKDEV(nMajorNum, 0);
+   unregister_chrdev_region(dsl_devt, DSL_DRV_ENTITIES);
+
    DSL_DRV_Cleanup();
 
    return;
--- a/src/device/drv_dsl_cpe_device_vrx.c
+++ b/src/device/drv_dsl_cpe_device_vrx.c
@@ -1,7 +1,9 @@
 /******************************************************************************
 
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2016 - 2019 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
 
   For licensing information, see the file 'LICENSE' in the root folder of
   this software module.
@@ -335,7 +337,7 @@ DSL_Error_t DSL_DRV_VRX_CamExceptionHand
          /* Update FW reinit counter*/
          if (
 #ifdef DSL_VRX_DEVICE_VR11
-             (lineInitStatus.nLineInitSubStatus == LINIT_SUB_S_PP_CLOCK_NEW) ||
+             (lineInitStatus.nLineInitSubStatus == LINIT_SUB_S_AUTOMSG) ||
 #endif /* DSL_VRX_DEVICE_VR11 */
              (lineInitStatus.nLineInitSubStatus == LINIT_SUB_FW_RETRY) ||
              (lineInitStatus.nLineInitSubStatus == LINIT_SUB_S_PP_DRIVER))
@@ -1820,12 +1822,15 @@ DSL_Error_t DSL_DRV_VRX_FailReasonGet(
       lineInitSubStatus = LINIT_SUB_S_INTENDED_LOCAL_SHUTDOWN;
       break;
 #if defined (DSL_VRX_DEVICE_VR11)
-   case ALM_ModemFSM_FailReasonGet_S_PP_CLOCK_NEW:
-      lineInitSubStatus = LINIT_SUB_S_PP_CLOCK_NEW;
+   case ALM_ModemFSM_FailReasonGet_S_AUTOMSG:
+      lineInitSubStatus = LINIT_SUB_S_AUTOMSG;
       break;
    case ALM_ModemFSM_FailReasonGet_S_PP_ERB_INIT:
       lineInitSubStatus = LINIT_SUB_S_PP_ERB_INIT;
       break;
+   case ALM_ModemFSM_FailReasonGet_S_REBOOT_REQ:
+      lineInitSubStatus = LINIT_SUB_S_REBOOT_REQ;
+      break;
 #endif /* defined (DSL_VRX_DEVICE_VR11) */
    default:
       lineInitSubStatus = LINIT_SUB_UNKNOWN;
@@ -2212,6 +2217,10 @@ DSL_Error_t DSL_DRV_VRX_LineStatusGet(
       ACK_LineStatusUS_Get_t FUS;
       ACK_LineStatusDS_Get_t FDS;
    } sAck;
+#if defined (DSL_VRX_DEVICE_VR11)
+   DSL_DEV_VersionCheck_t nVerCheck = DSL_VERSION_ERROR;
+   ACK_VDSL_FeatureMapGet_t nFeatureMapGetAck = { 0 };
+#endif
 
    DSL_CHECK_POINTER(pContext,pData);
    DSL_CHECK_ERR_CODE();
@@ -2265,6 +2274,36 @@ DSL_Error_t DSL_DRV_VRX_LineStatusGet(
       /* FW special value equals API special value */
       pData->ACTATP  = nDirection == DSL_DOWNSTREAM ? sAck.FDS.ACTATPds:
                                                       sAck.FUS.ACTATPus;
+
+      /* if not supported, SNR_ROC and ACTINP_ROC return special values */
+      pData->SNR_ROC = -641;
+      pData->ACTINP_ROC = 255;
+#if defined (DSL_VRX_DEVICE_VR11)
+      if (DSL_DRV_VRX_FirmwareXdslModeCheck(pContext, DSL_VRX_FW_VDSL2))
+      {
+         /* minimum FW version for ROC is R6 */
+         nErrCode = DSL_DRV_VRX_FirmwareVersionCheck(pContext, DSL_MIN_FW_VERSION_VR11_R6, &nVerCheck);
+         if (nErrCode == DSL_SUCCESS && nVerCheck >= DSL_VERSION_EQUAL)
+         {
+            /* related FeatureMap bit WOF15 has to be enabled */
+            nErrCode = DSL_DRV_VRX_SendMsgFeatureMapGet(pContext, (DSL_uint8_t *)&nFeatureMapGetAck);
+            if (nErrCode == DSL_SUCCESS && nFeatureMapGetAck.W0F15 == VRX_ENABLE)
+            {
+               /* Downstream/Upstream actual SNR margin of ROC */
+               pData->SNR_ROC = nDirection == DSL_DOWNSTREAM ? (DSL_int16_t)sAck.FDS.SNRM_ROCds :
+                  (DSL_int16_t)sAck.FUS.SNRM_ROCus;
+               /* Check for special FW value (-512) and map it to special API value (-641) */
+               pData->SNR_ROC = pData->SNR_ROC == -512 ? -641 : pData->SNR_ROC;
+
+               /* Downstream/Upstream actual impulse noise protection of ROC */
+               DSL_CTX_READ_SCALAR(pContext, nErrCode,
+                  ActualImpulseNoiseProtectionRoc[nDirection][0],
+                  pData->ACTINP_ROC);
+            }
+         }
+      }
+#endif /* defined (DSL_VRX_DEVICE_VR11) */
+
    }
 
    return (nErrCode);
@@ -2445,6 +2484,7 @@ static DSL_Error_t DSL_DRV_VRX_BearerChS
    DSL_uint32_t ActInp = 0;
    DSL_uint32_t ActInpRein = 0;
    DSL_uint32_t ActInpNoErasure = 0;
+   DSL_uint32_t ActInpRoc = 0;
    DSL_uint32_t newDataRate = 0, newNetDataRate = 0;
    DSL_boolean_t bTrellisEnable = DSL_FALSE;
    DSL_uint32_t ActualInterleaveDelay = 0;
@@ -2607,6 +2647,7 @@ static DSL_Error_t DSL_DRV_VRX_BearerChS
    /*                    ActualImpulseNoiseProtection                         */
    /*                  ActualImpulseNoiseProtectionRein                       */
    /*                ActualImpulseNoiseProtectionNoErasure                    */
+   /*                  ActualImpulseNoiseProtectionRoc                        */
    /* *********************************************************************** */
    if (nVerCheck >= DSL_VERSION_EQUAL)
    {
@@ -2635,6 +2676,10 @@ static DSL_Error_t DSL_DRV_VRX_BearerChS
       ActInp = (sAckBchRtx.ActInpSHINE >= 1023) ? 1023 : sAckBchRtx.ActInpSHINE;
    }
 
+   ActInpRoc = (nDir == DSL_UPSTREAM) ?
+      DSL_MAX(sAckBch.FUS.actInpNoErasure_LP0, sAckBch.FUS.actInpErasure_LP0) :
+      DSL_MAX(sAckBch.FDS.actInpNoErasure_LP0, sAckBch.FDS.actInpErasure_LP0);
+
    DSL_CTX_WRITE_SCALAR(pContext, nErrCode,
                         ActualImpulseNoiseProtection[nDir][0], ActInp);
 
@@ -2645,6 +2690,10 @@ static DSL_Error_t DSL_DRV_VRX_BearerChS
                         ActualImpulseNoiseProtectionNoErasure[nDir][0],
                         ActInpNoErasure);
 
+   DSL_CTX_WRITE_SCALAR(pContext, nErrCode,
+                        ActualImpulseNoiseProtectionRoc[nDir][0],
+                        ActInpRoc);
+
    return (nErrCode);
 }
 
@@ -2657,6 +2706,9 @@ static DSL_Error_t DSL_DRV_VRX_ChannelSt
    DSL_uint32_t newDataRate = 0;
    DSL_boolean_t bTrellisEnable = DSL_FALSE, bBitswapEnable = DSL_FALSE,
                  bVirtualNoiseEnable = DSL_FALSE;
+   DSL_FeatureSupport_t bRocEnable = DSL_FEATURE_DISABLED;
+   DSL_DEV_VersionCheck_t nVerCheck = DSL_VERSION_ERROR;
+
    union
    {
       ACK_LineStatusUS_Get_t FUS;
@@ -2703,6 +2755,29 @@ static DSL_Error_t DSL_DRV_VRX_ChannelSt
       DSL_CTX_WRITE_SCALAR(
          pContext, nErrCode, lineFeatureDataSts[nDirection].bVirtualNoiseSupport,
          bVirtualNoiseEnable);
+
+      nErrCode = DSL_DRV_VRX_FirmwareVersionCheck(pContext,
+               DSL_MIN_FW_VERSION_VR11_R6, &nVerCheck);
+
+      if (nErrCode != DSL_SUCCESS)
+      {
+         DSL_DEBUG(DSL_DBG_ERR,
+            (pContext, SYS_DBG_ERR"DSL[%02d]: ERROR - FW version check failed - "
+             "ROC feature unavailable!"
+            DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+         return nErrCode;
+      }
+
+      if (nVerCheck >= DSL_VERSION_EQUAL)
+      {
+         bRocEnable = nDirection == DSL_UPSTREAM ?
+                     (DSL_boolean_t)sAckLs.FUS.ROCstatus_us :
+                     (DSL_boolean_t)sAckLs.FDS.ROCstatus_ds;
+
+         DSL_CTX_WRITE_SCALAR(
+            pContext, nErrCode, lineFeatureDataSts[nDirection].bRocEnable,
+            bRocEnable);
+      }
    }
 
    nErrCode = DSL_DRV_VRX_SendMsgOlrStatusGet(pContext, nDirection, (DSL_uint8_t*)&sAckOlr.FUS);
@@ -4462,18 +4537,14 @@ DSL_Error_t DSL_DRV_DEV_ModemWriteConfig
    }
 
    DSL_CTX_READ_SCALAR(pContext, nErrCode, bFwEventActivation, bFwEventActivation);
-   if (bFwEventActivation)
+   nErrCode = DSL_DRV_VRX_SendMsgModemFSMEventConfigure(pContext, bFwEventActivation);
+   if( nErrCode != DSL_SUCCESS )
    {
-      nErrCode = DSL_DRV_VRX_SendMsgModemFSMEventConfigure(pContext, bFwEventActivation);
-
-      if( nErrCode != DSL_SUCCESS )
-      {
-         DSL_DEBUG( DSL_DBG_ERR,
-            (pContext, SYS_DBG_ERR"DSL[%02d]: ERROR - ModemFSMEventConfigure send failed!"
-            DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+      DSL_DEBUG( DSL_DBG_ERR,
+         (pContext, SYS_DBG_ERR"DSL[%02d]: ERROR - ModemFSMEventConfigure send failed!"
+         DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
 
-          return nErrCode;
-      }
+      return nErrCode;
    }
 
    return DSL_SUCCESS;
@@ -4533,9 +4604,11 @@ DSL_Error_t DSL_DRV_DEV_FwDownload(
    DSL_FirmwareType_t nNextMode;
 #if defined (DSL_VRX_DEVICE_VR11)
    DSL_DEV_VersionCheck_t nVerCheck = DSL_VERSION_ERROR;
+   ACK_VDSL_FeatureMapGet_t nFeatureMapGetAck = { 0 };
 #endif /* defined (DSL_VRX_DEVICE_VR11) */
    DSL_boolean_t bFwEventActivation;
    DSL_uint32_t nOppositeLine;
+   DSL_HybridType_t nHybridType;
 
    DSL_CHECK_POINTER(pContext, pContext->pDevCtx->lowHandle);
    DSL_CHECK_ERR_CODE();
@@ -4828,6 +4901,7 @@ DSL_Error_t DSL_DRV_DEV_FwDownload(
 
       DSL_CTX_WRITE_SCALAR(pContext, nErrCode, pDevCtx->bFirmwareReady, DSL_TRUE);
 
+      DSL_CTX_WRITE_SCALAR(pContext, nErrCode, VersionInformation.bFWVerNumSet, DSL_FALSE);
       /* Get the downloaded FW version information*/
       if( DSL_DRV_VRX_SendMsgFwVerInfoGet(pContext, &verNum) != DSL_SUCCESS)
       {
@@ -4852,7 +4926,37 @@ DSL_Error_t DSL_DRV_DEV_FwDownload(
          return nErrCode;
       }
 
-      #if defined (DSL_VRX_DEVICE_VR11)
+      DSL_CTX_WRITE_SCALAR(pContext, nErrCode, VersionInformation.bChipHWVerNumSet, DSL_FALSE);
+      if( DSL_DRV_VRX_SendMsgHwVerInfoGet(pContext, &verNum) != DSL_SUCCESS)
+      {
+         DSL_DEBUG( DSL_DBG_ERR,
+            (pContext, SYS_DBG_ERR"DSL[%02d]: ERROR - HW version get failed, msg send error!"
+            DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+
+         return DSL_ERROR;
+      }
+
+      DSL_CTX_WRITE_SCALAR(pContext, nErrCode, VersionInformation.bHybridTypeSet, DSL_FALSE);
+      if( DSL_DRV_VRX_SendMsgHybridTypeGet(pContext, &nHybridType) != DSL_SUCCESS)
+      {
+         DSL_DEBUG( DSL_DBG_ERR,
+            (pContext, SYS_DBG_ERR"DSL[%02d]: ERROR - Hybrid type get failed, msg send error!"
+            DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+
+         return DSL_ERROR;
+      }
+
+      #if defined(DSL_VRX_DEVICE_VR11)
+      DSL_CTX_WRITE_SCALAR(pContext, nErrCode, VersionInformation.bFeatureMapSet, DSL_FALSE);
+      if( DSL_DRV_VRX_SendMsgFeatureMapGet(pContext, (DSL_uint8_t *)(&nFeatureMapGetAck)) != DSL_SUCCESS)
+      {
+         DSL_DEBUG( DSL_DBG_ERR,
+            (pContext, SYS_DBG_ERR"DSL[%02d]: ERROR - FeatureMap get failed, msg send error!"
+            DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+
+         return DSL_ERROR;
+      }
+
       DSL_DRV_VRX_FirmwareVersionCheck(pContext, DSL_MIN_FW_VERSION_VR11_R5, &nVerCheck);
 
       if (nVerCheck < DSL_VERSION_EQUAL)
@@ -5289,6 +5393,7 @@ DSL_Error_t DSL_DRV_DEV_LinkPowerDown(
 
       return DSL_ERROR;
    }
+   DSL_CTX_WRITE_SCALAR(pContext, nErrCode, bPowerDownInaccessibleFW, DSL_TRUE);
 
    DSL_DEBUG( DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: OUT - DSL_DRV_DEV_LinkPowerDown"
@@ -6809,7 +6914,7 @@ DSL_Error_t DSL_DRV_DEV_OlrStatisticsGet
       return nErrCode;
    }
 
-   memset(pData, 0x0, sizeof(DSL_OlrStatistics_t));
+   memset(&pData->data, 0x0, sizeof(DSL_OlrStatisticsData_t));
 
    pData->data.nBitswapRequested = sAckOlr.FUS.BitswapReqs;
    pData->data.nExtBitswapRequested = sAckOlr.FUS.ExtBitswapReqs;
@@ -6818,11 +6923,15 @@ DSL_Error_t DSL_DRV_DEV_OlrStatisticsGet
    pData->data.nSraRequested = sAckOlr.FUS.SRA_Reqs;
    pData->data.nSraExecuted = sAckOlr.FUS.SRAsDone;
    pData->data.nSraRejected = sAckOlr.FUS.SRA_UTCs;
+   pData->data.nSosRequested = sAckOlr.FUS.SOS_Reqs;
+   pData->data.nSosExecuted = sAckOlr.FUS.SOS_Done;
+   pData->data.nSosRejected = sAckOlr.FUS.SOS_UTCs;
 
    if (pData->nDirection == DSL_DOWNSTREAM)
    {
       pData->data.nBitswapTimeout = sAckOlr.FDS.BitswapTimeOuts;
       pData->data.nSraTimeout =  sAckOlr.FDS.SRA_TimeOuts;
+      pData->data.nSosTimeout = sAckOlr.FDS.SOS_TimeOuts;
    }
 
    DSL_DEBUG( DSL_DBG_MSG, (pContext,
--- a/src/device/drv_dsl_cpe_msg_vrx.c
+++ b/src/device/drv_dsl_cpe_msg_vrx.c
@@ -1,7 +1,9 @@
 /******************************************************************************
 
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2016 - 2019 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
 
   For licensing information, see the file 'LICENSE' in the root folder of
   this software module.
@@ -182,6 +184,8 @@ static DSL_uint16_t g_VRxMsgWhitelist[]
    CMD_ADSL_FEATUREMAPGET,          /*     +     :      +      :       +      */
    CMD_VDSL_FEATUREMAPGET,          /*     +     :      +      :       +      */
 #endif
+   CMD_SOS_STATSNE_GET,             /*     +     :      +      :       +      */
+   CMD_SOS_STATSFE_GET,             /*     +     :      +      :       +      */
       /* Delimeter only*/
    0xFFFF
 };
@@ -205,6 +209,7 @@ static DSL_VRX_PM_MsgCheck_t g_VRxPM_Msg
 
 #ifdef INCLUDE_DSL_G997_LINE_INVENTORY
 static DSL_void_t DSL_DRV_VRX_Array16_to_8(
+   DSL_Context_t *pContext,
    DSL_uint16_t *pIn,
    DSL_uint8_t inSz,
    DSL_uint8_t *pOut,
@@ -233,7 +238,7 @@ DSL_Error_t DSL_DRV_VRX_BitAllocationTab
                   nRetCode = DSL_SUCCESS;
    DSL_uint32_t   nMsgId = 0;
    DSL_uint16_t   i = 0, nTonesLeft = 0, nTonesCurrent = 0, nTonesMax = 0,
-                  nAckSize = 0, nAckIndex = 0, nAckLength = 0;
+                  nAckSize = 0, nAckIndex = 0, nAckLength = 0, nOneMoreEntry = 0;
    DSL_LineStateValue_t   nCurrentState = DSL_LINESTATE_UNKNOWN;
    /* assume US/DS ADSL/VDSL to have the same CMD Structures */
    CMD_BAT_TableEntriesGet_t  sCmd;
@@ -329,6 +334,7 @@ DSL_Error_t DSL_DRV_VRX_BitAllocationTab
          pBand = &sBandList.nBand[nBand];
          /*  several messages for max 128*2 values have to be sent */
          nTonesLeft = (pBand->nLastToneIndex - pBand->nFirstToneIndex) + 1;
+         nOneMoreEntry = pBand->nFirstToneIndex % 2;
 
          while (nTonesLeft)
          {
@@ -336,8 +342,19 @@ DSL_Error_t DSL_DRV_VRX_BitAllocationTab
 
             /* the Msg structure allows retreival in pairs only */
             sCmd.Index = (pBand->nLastToneIndex - (nTonesLeft - 1)) / 2;
-            /* round up, to avoid missing last tone */
-            sCmd.Length = (nTonesCurrent + 1) / 2;
+
+            /* to avoid missing last tone:
+               - round-up entries amount and
+               - request one additional entry in case first tone index is odd */
+            sCmd.Length = ((nTonesCurrent + 1) / 2) + nOneMoreEntry;
+            sCmd.Length = sCmd.Length > nMaxNumOfEntries ? nMaxNumOfEntries : sCmd.Length;
+
+            DSL_DEBUG(DSL_DBG_MSG,(pContext,
+               SYS_DBG_MSG"DSL[%02d]: Tones(first:%d, last:%d, left:%d). Requested entries(idx:%d, qty:%d)."
+               DSL_DRV_CRLF, DSL_DEV_NUM(pContext),
+               pBand->nFirstToneIndex, pBand->nLastToneIndex, nTonesLeft,
+               sCmd.Index, sCmd.Length));
+
             nRetCode = DSL_DRV_VRX_SendMessage(pContext, nMsgId,
                            sizeof(sCmd), (DSL_uint8_t*)&sCmd,
                            nAckSize, (DSL_uint8_t*)&sAck);
@@ -385,9 +402,9 @@ DSL_Error_t DSL_DRV_VRX_BitAllocationTab
                      }
 
                      DSL_DEBUG(DSL_DBG_MSG,(pContext,
-                        SYS_DBG_MSG"%04X, ", pData->nNSCData[(i+nAckIndex)*2]));
-                     DSL_DEBUG(DSL_DBG_MSG,(pContext,
-                        SYS_DBG_MSG"%04X, ", pData->nNSCData[(i+nAckIndex)*2 + 1]));
+                        SYS_DBG_MSG"(%d,%02X) (%d,%02X)" DSL_DRV_CRLF,
+                        (i+nAckIndex)*2, pData->nNSCData[(i+nAckIndex)*2],
+                        (i+nAckIndex)*2 + 1, pData->nNSCData[(i+nAckIndex)*2 + 1]));
                   }
 
                   if (pBitsPerSymbol != DSL_NULL)
@@ -1174,8 +1191,6 @@ DSL_Error_t DSL_DRV_VRX_SendMsgInventory
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_VRX_SendMsgInventoryFeGet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
 
-   DSL_DRV_MUTEX_LOCK(pContext->dataMutex);
-
    /* do the G994 Vendor ID */
    memset(&sCmd, 0, sizeof(sCmd));
    memset(&sAck, 0, sizeof(sAck));
@@ -1195,6 +1210,7 @@ DSL_Error_t DSL_DRV_VRX_SendMsgInventory
    {
       /* get the data */
       DSL_DRV_VRX_Array16_to_8(
+         pContext,
          sAck.G994VendorId.vendorID,
          DSL_ARRAY_LENGTH(sAck.G994VendorId.vendorID),
          pContext->lineInventoryFe.G994VendorID,
@@ -1220,6 +1236,7 @@ DSL_Error_t DSL_DRV_VRX_SendMsgInventory
    {
       /* get the data */
       DSL_DRV_VRX_Array16_to_8(
+         pContext,
          sAck.VendorId.sysVendorID,
          DSL_ARRAY_LENGTH(sAck.VendorId.sysVendorID),
          pContext->lineInventoryFe.SystemVendorID,
@@ -1247,6 +1264,7 @@ DSL_Error_t DSL_DRV_VRX_SendMsgInventory
    {
       /* get the data */
       DSL_DRV_VRX_Array16_to_8(
+         pContext,
          sAck.VendorVersion.versionNum,
          DSL_ARRAY_LENGTH(sAck.VendorVersion.versionNum),
          pContext->lineInventoryFe.VersionNumber,
@@ -1274,6 +1292,7 @@ DSL_Error_t DSL_DRV_VRX_SendMsgInventory
    {
       /* get the data */
       DSL_DRV_VRX_Array16_to_8(
+         pContext,
          sAck.VendorSerial.serialNum,
          DSL_ARRAY_LENGTH(sAck.VendorSerial.serialNum),
          pContext->lineInventoryFe.SerialNumber,
@@ -1305,8 +1324,6 @@ DSL_Error_t DSL_DRV_VRX_SendMsgInventory
       }
    }
 
-   DSL_DRV_MUTEX_UNLOCK(pContext->dataMutex);
-
    /* Update FE ADSL XTSE Capabilities*/
    if (DSL_DRV_VRX_FirmwareXdslModeCheck(pContext, DSL_VRX_FW_ADSL))
    {
@@ -1605,6 +1622,7 @@ DSL_Error_t DSL_DRV_VRX_SendMsgOrderlySh
 
 #ifdef INCLUDE_DSL_G997_LINE_INVENTORY
 static DSL_void_t DSL_DRV_VRX_Array16_to_8(
+   DSL_Context_t *pContext,
    DSL_uint16_t *pIn,
    DSL_uint8_t inSz,
    DSL_uint8_t *pOut,
@@ -1612,6 +1630,7 @@ static DSL_void_t DSL_DRV_VRX_Array16_to
 {
    DSL_uint8_t i = 0;
 
+   DSL_DRV_MUTEX_LOCK(pContext->dataMutex);
    for( i = 0; i < inSz; i++ )
    {
       if( (DSL_uint32_t)(i*2 + 1) < outSz )
@@ -1620,6 +1639,7 @@ static DSL_void_t DSL_DRV_VRX_Array16_to
          pOut[i*2]     = (DSL_uint8_t)(pIn[i]);
       }
    }
+   DSL_DRV_MUTEX_UNLOCK(pContext->dataMutex);
 }
 
 /*
@@ -1755,6 +1775,14 @@ DSL_void_t DSL_DRV_VRX_DumpMessage(
    DSL_DBG_ModuleLevel_t dbgmlData;
    DSL_boolean_t bPrint = DSL_FALSE, bDirSet = DSL_FALSE, bAutoMsg = DSL_FALSE;
    DSL_uint8_t i;
+   const IFX_uint32_t nCommonPayloadSize = 5*nSize/2;
+   const IFX_uint8_t nInfoSize = 35;
+   const IFX_uint8_t nBufSize = 10;
+   IFX_uint32_t nMsgSize = nCommonPayloadSize + nInfoSize;
+   IFX_uint32_t nCharsWrittenToBuf = 0;
+   char msg[nMsgSize];
+   char buf[nBufSize];
+
 
    dbgmlData.data.nDbgLevel  = DSL_DBG_NONE;
    dbgmlData.data.nDbgModule = DSL_DBG_MESSAGE_DUMP;
@@ -1823,11 +1851,12 @@ DSL_void_t DSL_DRV_VRX_DumpMessage(
       {
          bAutoMsg = DSL_TRUE;
       }
-
-      DSL_DRV_debug_printf(pContext, "DSL[%02d/%s]: 0x%04x 0x%04x 0x%04x",
-                           DSL_DEV_NUM(pContext),
-                           bReceive == DSL_TRUE ? (bAutoMsg == DSL_TRUE ? "ev" : "rx") : "tx",
-                           nMsgId, pData[0], pData[1]);
+      snprintf(msg, nInfoSize,
+                  "DSL[%02d/%s]: 0x%04x 0x%04x 0x%04x",
+                  DSL_DEV_NUM(pContext),
+                  bReceive == DSL_TRUE ? (bAutoMsg == DSL_TRUE ? "ev" : "rx") : "tx",
+                  nMsgId, pData[0], pData[1]);
+      nMsgSize -= nInfoSize;
 
       /* decide wether to interpret the rest as 16 or 32 bit */
       if (nMsgId & VDSL2_MBX_MSG_ID_IFX_MASK)
@@ -1835,7 +1864,9 @@ DSL_void_t DSL_DRV_VRX_DumpMessage(
          /* IFX message: 32 bit */
          for (i=0; i<((nSize-4)/4); i++)
          {
-            DSL_DRV_debug_printf(pContext, " %08X", pMsg32[i]);
+            nCharsWrittenToBuf = snprintf(buf, nBufSize, " %08X", pMsg32[i]);
+            strncat(msg, buf, nMsgSize);
+            nMsgSize -= nCharsWrittenToBuf;
          }
       }
       else
@@ -1843,11 +1874,15 @@ DSL_void_t DSL_DRV_VRX_DumpMessage(
          /* no IFX message: 16 bit */
          for (i=0; i<((nSize-4)/2); i++)
          {
-            DSL_DRV_debug_printf(pContext, " %04X", pMsg16[i]);
+            nCharsWrittenToBuf = snprintf(buf, nBufSize, " %04X", pMsg16[i]);
+            strncat(msg, buf, nMsgSize);
+            nMsgSize -= nCharsWrittenToBuf;
          }
       }
+      strncat(msg, DSL_DRV_CRLF, nMsgSize);
+
 
-      DSL_DRV_debug_printf(pContext, DSL_DRV_CRLF);
+      DSL_DRV_debug_printf(pContext, msg);
    }
 }
 #endif /* #ifndef DSL_DEBUG_DISABLE*/
@@ -1960,11 +1995,12 @@ static DSL_Error_t DSL_DRV_VRX_MsgTransm
    DSL_uint16_t i;
    DSL_uint32_t nLength, nLenAck;
    DSL_uint8_t nMsgFctOpCode = 0;
+   const DSL_uint8_t nMaxRetry = 3;
 
    nLength = pMsg->write_msg.paylSize_byte;
    nLenAck = pMsg->ack_msg.paylSize_byte;
 
-   for (i=0; i<3; i++)
+   for (i=0; i<nMaxRetry; ++i)
    {
       /* for any retry set the CMD and ACK Buffer length again,
          because the driver is changing these fields to indicate
@@ -1975,7 +2011,21 @@ static DSL_Error_t DSL_DRV_VRX_MsgTransm
       /* Send and wait for recieved data */
       if(nRet == DSL_SUCCESS)
       {
-         break;
+         /* check if received ID was the same as the sent one */
+         if ( ((DSL_uint16_t)(pMsg->write_msg.msgId & 0xFFFF)) != pMsg->ack_msg.msgId)
+         {
+            nRet = DSL_ERR_FUNCTION_WAITING;
+
+            DSL_DEBUG(DSL_DBG_WRN, (pContext, SYS_DBG_WRN
+               "DSL[%02d]: Ack mismatch in MsgID (0x%04X vs 0x%04X expected) "
+               "- on try %d!" DSL_DRV_CRLF,
+               DSL_DEV_NUM(pContext), pMsg->ack_msg.msgId, pMsg->write_msg.msgId, i));
+         }
+         else
+         {
+            /* Message send succeeded, terminate retry loop */
+            break;
+         }
       }
       else
       {
@@ -1992,7 +2042,7 @@ static DSL_Error_t DSL_DRV_VRX_MsgTransm
 
                bBlockLine = DSL_TRUE;
                nRet = DSL_ERR_MSG_EXCHANGE;
-               i = 3;
+               i = nMaxRetry;
                break;
 
             case -e_MEI_ERR_DEV_NEG_RESP:
@@ -2014,7 +2064,7 @@ static DSL_Error_t DSL_DRV_VRX_MsgTransm
                     )
                {
                   nRet = DSL_WRN_FIRMWARE_MSG_DENIED;
-                  i = 3;
+                  i = nMaxRetry;
                }
                else if(nMsgFctOpCode == D2H_CMV_CURRENTLY_UNAVAILABLE)
                {
@@ -2049,7 +2099,7 @@ static DSL_Error_t DSL_DRV_VRX_MsgTransm
                      DSL_DEV_NUM(pContext), pMsg->write_msg.msgId,
                      pMsg->ack_msg.msgClassifier, i));
                   nRet = DSL_WRN_FIRMWARE_MSG_DENIED;
-                  i = 3;
+                  i = nMaxRetry;
                   break;
                }
                else
@@ -2075,7 +2125,7 @@ static DSL_Error_t DSL_DRV_VRX_MsgTransm
                      DSL_DEV_NUM(pContext),
                      pMsg->write_msg.msgId, pMsg->ack_msg.msgClassifier, i));
                   nRet = DSL_WRN_FIRMWARE_MSG_DENIED;
-                  i = 3;
+                  i = nMaxRetry;
                   break;
                }
 #else
@@ -2091,7 +2141,7 @@ static DSL_Error_t DSL_DRV_VRX_MsgTransm
                   if (pMsg->ack_msg.msgClassifier != 0xFFFF)
                   {
                      /* an ACK has been received - stop sending, keep line */
-                     i = 3;
+                     i = nMaxRetry;
                      break;
                   }
                }
@@ -2108,6 +2158,14 @@ static DSL_Error_t DSL_DRV_VRX_MsgTransm
       }
    }
 
+   if (i >= nMaxRetry)
+   {
+      DSL_DEBUG(DSL_DBG_ERR, (pContext, SYS_DBG_ERR
+         "DSL[%02d]: Max number of retries (%d) to send msg reached, "
+         "terminate with error!"DSL_DRV_CRLF,
+         DSL_DEV_NUM(pContext), nMaxRetry));
+   }
+
    if(nRet != DSL_SUCCESS)
    {
       /* Error - Line not available */
@@ -2150,7 +2208,24 @@ DSL_Error_t DSL_DRV_VRX_SendMessage(
    IOCTL_MEI_messageSend_t sMsg;
    DSL_boolean_t bMsgSendRequired = DSL_FALSE;
    DSL_uint32_t i = 0;
-   DSL_uint8_t nMaxRetry;
+
+#if defined (DSL_VRX_DEVICE_VR11)
+   DSL_boolean_t bPowerDownInaccessibleFW = DSL_FALSE;
+   DSL_Error_t nTmpErrCode = DSL_ERROR;
+
+   DSL_CTX_READ_SCALAR(pContext, nTmpErrCode, bPowerDownInaccessibleFW, bPowerDownInaccessibleFW);
+
+   if (nTmpErrCode == DSL_SUCCESS &&
+       bPowerDownInaccessibleFW == DSL_TRUE)
+   {
+      DSL_DEBUG(DSL_DBG_WRN,
+         (pContext, SYS_DBG_WRN"DSL[%02d]: Message handling denied "
+         "in PD mode (MsgID=0x%04X)!" DSL_DRV_CRLF,
+         DSL_DEV_NUM(pContext), nMsgID));
+
+      return DSL_ERR_NOT_SUPPORTED_IN_CURRENT_AUTOBOOT_STATE;
+   }
+#endif
 
    /* Handle VRX message white list*/
    while (g_VRxMsgWhitelist[i] != 0xFFFF)
@@ -2219,48 +2294,20 @@ DSL_Error_t DSL_DRV_VRX_SendMessage(
       return DSL_ERROR;
    }
 
-   i = 0;
-   nMaxRetry = 3;
-   while (i < nMaxRetry)
-   {
-      nErrCode = DSL_SUCCESS;
-      sMsg.write_msg.msgId          = (DSL_uint16_t)(nMsgID & 0xFFFF);
-      sMsg.write_msg.pPayload       = (unsigned char *)pData;
-      sMsg.write_msg.paylSize_byte  = nLength;
-      /* to receive the answer hand over the payload buffer */
-      sMsg.ack_msg.pPayload         = (unsigned char *)pDataAck;
-
-      sMsg.ack_msg.msgId = 0;
-      sMsg.write_msg.paylSize_byte  = nLength;
-      sMsg.ack_msg.paylSize_byte    = nLenAck;
-
-      nErrCode = DSL_DRV_VRX_MsgTransmit(pContext, &sMsg);
-
-      /* check if received ID was the same as the sent one */
-      if ( ((DSL_uint16_t)(nMsgID & 0xFFFF)) !=
-           sMsg.ack_msg.msgId && nErrCode > DSL_ERROR )
-      {
-         DSL_DEBUG(DSL_DBG_WRN, (pContext, SYS_DBG_WRN
-            "DSL[%02d]: Ack mismatch in MsgID (0x%04X vs 0x%04X expected) "
-            "- on try %d!" DSL_DRV_CRLF,
-            DSL_DEV_NUM(pContext), sMsg.ack_msg.msgId, nMsgID, i));
-         i++;
-      }
-      else
-      {
-         /* Message send succeeded, terminate retry loop */
-         break;
-      }
-   }
+   sMsg.write_msg.msgId          = (DSL_uint16_t)(nMsgID & 0xFFFF);
+   sMsg.write_msg.pPayload       = (unsigned char *)pData;
+   sMsg.write_msg.paylSize_byte  = nLength;
+
+   /* to receive the answer hand over the payload buffer */
+   sMsg.ack_msg.pPayload         = (unsigned char *)pDataAck;
+   sMsg.ack_msg.msgId = 0;
+   sMsg.ack_msg.paylSize_byte    = nLenAck;
 
-   if (i >= nMaxRetry)
+   nErrCode = DSL_DRV_VRX_MsgTransmit(pContext, &sMsg);
+
+   if (nErrCode != DSL_SUCCESS)
    {
-      nErrCode = DSL_ERR_FUNCTION_WAITING;
       pContext->nErrNo = nErrCode;
-      DSL_DEBUG(DSL_DBG_ERR, (pContext, SYS_DBG_ERR
-         "DSL[%02d]: Max number of retries (%d) to send msg reached, "
-         "terminate with error!"DSL_DRV_CRLF,
-         DSL_DEV_NUM(pContext), nMaxRetry));
    }
 
    DSL_DRV_MUTEX_UNLOCK(pContext->bspMutex);
@@ -3737,15 +3784,18 @@ static DSL_Error_t DSL_DRV_VRX_SendMsgAu
    DSL_Error_t nErrCode = DSL_SUCCESS;
    CMD_AuxInventoryInfo_O_Get_t sCmd;
    ACK_AuxInventoryInfo_O_Get_t sAck;
-   DSL_uint32_t nBytes = sizeof(pData->pData);
+   DSL_uint32_t nBytes = 0;
    DSL_uint8_t i = 0;
 
    /* do the Aux Info, not part of G997.1 */
    memset(&sCmd, 0, sizeof(sCmd));
    memset(&sAck, 0, sizeof(sAck));
 
+   DSL_DRV_MUTEX_LOCK(pContext->dataMutex);
    /* there was nothing copied yet */
    pData->nLength = 0;
+   DSL_DRV_MUTEX_UNLOCK(pContext->dataMutex);
+
    sCmd.Length = DSL_VRX_16BIT_RD_MSG_LEN_GET(sAck);
 
    nErrCode = DSL_DRV_VRX_SendMessage(
@@ -3762,7 +3812,9 @@ static DSL_Error_t DSL_DRV_VRX_SendMsgAu
       return nErrCode;
    }
 
+   DSL_DRV_MUTEX_LOCK(pContext->dataMutex);
    pData->nLength = (sCmd.Length * 2);
+   nBytes = sizeof(pData->pData);
 
    /* get the data */
    for( i = 0; i < DSL_ARRAY_LENGTH(sAck.auxInfo); i++ )
@@ -3773,6 +3825,7 @@ static DSL_Error_t DSL_DRV_VRX_SendMsgAu
          pData->pData[i*2]     = (DSL_uint8_t)(sAck.auxInfo[i]);
       }
    }
+   DSL_DRV_MUTEX_UNLOCK(pContext->dataMutex);
 
    return nErrCode;
 }
@@ -3802,12 +3855,11 @@ DSL_Error_t DSL_DRV_VRX_SendMsgInventory
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_VRX_SendMsgInventoryNeSet()"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
 
-   DSL_DRV_MUTEX_LOCK(pContext->dataMutex);
-
    /* do the Vendor ID */
    memset(&sCmd, 0, sizeof(sCmd));
 
    sCmd.VendorId.Length = DSL_VRX_16BIT_RD_MSG_LEN_GET(sCmd.VendorId);
+   DSL_DRV_MUTEX_LOCK(pContext->dataMutex);
    /* fill the message */
    for (i = 0; i < DSL_ARRAY_LENGTH(sCmd.VendorId.sysVendorID); i++)
    {
@@ -3817,6 +3869,8 @@ DSL_Error_t DSL_DRV_VRX_SendMsgInventory
             ((DSL_uint16_t)(pContext->lineInventoryNe.SystemVendorID[i*2 + 1]) << 8) |
              (DSL_uint16_t)(pContext->lineInventoryNe.SystemVendorID[i*2]);
    }
+   DSL_DRV_MUTEX_UNLOCK(pContext->dataMutex);
+
    nErrCode = DSL_DRV_VRX_SendMessage(
                  pContext, CMD_SYSVENDORID_R_SET,
                  sizeof(sCmd.VendorId), (DSL_uint8_t*)&sCmd,
@@ -3833,6 +3887,7 @@ DSL_Error_t DSL_DRV_VRX_SendMsgInventory
    memset(&sCmd, 0, sizeof(sCmd));
 
    sCmd.VendorVersion.Length = DSL_VRX_16BIT_RD_MSG_LEN_GET(sCmd.VendorVersion);
+   DSL_DRV_MUTEX_LOCK(pContext->dataMutex);
    for (i = 0; i < DSL_ARRAY_LENGTH(sCmd.VendorVersion.versionNum); i++)
    {
       if( (DSL_uint32_t)(i*2 + 1) <
@@ -3841,6 +3896,8 @@ DSL_Error_t DSL_DRV_VRX_SendMsgInventory
             ((DSL_uint16_t)(pContext->lineInventoryNe.VersionNumber[i*2 + 1]) << 8) |
              (DSL_uint16_t)(pContext->lineInventoryNe.VersionNumber[i*2]);
    }
+   DSL_DRV_MUTEX_UNLOCK(pContext->dataMutex);
+
    nErrCode = DSL_DRV_VRX_SendMessage(
                  pContext, CMD_SYSVENDORVERSIONNUM_R_SET,
                  sizeof(sCmd.VendorVersion), (DSL_uint8_t*)&sCmd,
@@ -3857,6 +3914,7 @@ DSL_Error_t DSL_DRV_VRX_SendMsgInventory
    memset(&sCmd, 0, sizeof(sCmd));
 
    sCmd.VendorSerial.Length = DSL_VRX_16BIT_RD_MSG_LEN_GET(sCmd.VendorSerial);
+   DSL_DRV_MUTEX_LOCK(pContext->dataMutex);
    for (i = 0; i < DSL_ARRAY_LENGTH(sCmd.VendorSerial.serialNum); i++)
    {
       if( (DSL_uint32_t)(i*2 + 1) <
@@ -3865,6 +3923,8 @@ DSL_Error_t DSL_DRV_VRX_SendMsgInventory
             ((DSL_uint16_t)(pContext->lineInventoryNe.SerialNumber[i*2 + 1]) << 8) |
              (DSL_uint16_t)(pContext->lineInventoryNe.SerialNumber[i*2]);
    }
+   DSL_DRV_MUTEX_UNLOCK(pContext->dataMutex);
+
    nErrCode = DSL_DRV_VRX_SendMessage(
                  pContext, CMD_SYSVENDORSERIALNUM_R_SET,
                  sizeof(sCmd.VendorSerial), (DSL_uint8_t*)&sCmd,
@@ -3883,7 +3943,9 @@ DSL_Error_t DSL_DRV_VRX_SendMsgInventory
       /* do the Aux Info, not part of G997.1 */
       memset(&sCmd, 0, sizeof(sCmd));
 
+      DSL_DRV_MUTEX_LOCK(pContext->dataMutex);
       nBytesLeft = (DSL_uint16_t)(pContext->auxInventoryNe.nLength);
+      DSL_DRV_MUTEX_UNLOCK(pContext->dataMutex);
       nBytesSent = 0;
       nBytesMsg = DSL_VRX_16BIT_RD_MSG_LEN_GET(sCmd.AuxInfo) * 2;
       while( nBytesLeft )
@@ -3893,6 +3955,7 @@ DSL_Error_t DSL_DRV_VRX_SendMsgInventory
          sCmd.AuxInfo.Length  = (nBytes + 1) / 2;
          sCmd.AuxInfo.Index   = nBytesSent / 2;
 
+         DSL_DRV_MUTEX_LOCK(pContext->dataMutex);
          for( i = 0; (i < sCmd.AuxInfo.Length) && (i < DSL_ARRAY_LENGTH(sCmd.AuxInfo.auxInfo)) &&
                      (nIdx+1 < DSL_G993_LI_MAXLEN_AUX);
               i++, nIdx = i*2 + nBytesSent)
@@ -3901,6 +3964,7 @@ DSL_Error_t DSL_DRV_VRX_SendMsgInventory
                ((DSL_uint16_t)(pContext->auxInventoryNe.pData[nIdx + 1]) << 8) |
                 (DSL_uint16_t)(pContext->auxInventoryNe.pData[nIdx]);
          }
+         DSL_DRV_MUTEX_UNLOCK(pContext->dataMutex);
 
          nErrCode = DSL_DRV_VRX_SendMessage(
                        pContext, CMD_AUXINVENTORYINFO_R_SET,
@@ -3918,8 +3982,6 @@ DSL_Error_t DSL_DRV_VRX_SendMsgInventory
       }
    }
 
-   DSL_DRV_MUTEX_UNLOCK(pContext->dataMutex);
-
    if( nErrCode != DSL_SUCCESS )
       nErrCode = DSL_ERROR;
 
@@ -4044,6 +4106,25 @@ DSL_Error_t DSL_DRV_VRX_SendMsgOlrContro
       sCmd.TxBitswap = bBitswapEnableUs ? VRX_ENABLE : VRX_DISABLE;
    }
 
+   nErrCode = DSL_DRV_VRX_FirmwareVersionCheck(pContext,
+               DSL_MIN_FW_VERSION_VR11_R6, &nVerCheck);
+
+   if (nErrCode != DSL_SUCCESS)
+   {
+      DSL_DEBUG(DSL_DBG_ERR,
+                (pContext, SYS_DBG_ERR"DSL[%02d]: ERROR - FW version check failed - " \
+                 "ROC feature unavailable!"
+                 DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+
+      return nErrCode;
+   }
+
+   if (nVerCheck >= DSL_VERSION_EQUAL)
+   {
+      sCmd.RxBitswap_ROC = VRX_ENABLE;
+      sCmd.TxBitswap_ROC = VRX_ENABLE;
+   }
+
    nErrCode = DSL_DRV_VRX_SendMessage(
                  pContext, CMD_OLR_CONTROL,
                  sizeof(CMD_OLR_Control_t), (DSL_uint8_t*)&sCmd,
@@ -4068,6 +4149,8 @@ DSL_Error_t DSL_DRV_VRX_SendMsgRtxContro
                           nVerCheckUs = DSL_VERSION_ERROR;
    DSL_VRX_FwVersion_t  sFwVersion = {0};
    DSL_DEV_VersionCheck_t nVerCheck = DSL_VERSION_ERROR;
+   DSL_DslModeSelection_t nXdslMode = DSL_MODE_VDSL;
+   DSL_FeatureSupport_t bRocEnable = DSL_FEATURE_DISABLED;
 
    if (DSL_DRV_VRX_FirmwareXdslModeCheck(pContext, DSL_VRX_FW_VDSL2))
    {
@@ -4088,6 +4171,8 @@ DSL_Error_t DSL_DRV_VRX_SendMsgRtxContro
    }
    else if (DSL_DRV_VRX_FirmwareXdslModeCheck(pContext, DSL_VRX_FW_ADSL))
    {
+      nXdslMode = DSL_MODE_ADSL;
+
       /* Get FW information (US not supported for ADSL, use initial value
          (nVerCheckUs equals DSL_VERSION_ERROR) indicating missing support. */
       nErrCode = DSL_DRV_VRX_FirmwareVersionCheck(pContext,
@@ -4200,6 +4285,29 @@ DSL_Error_t DSL_DRV_VRX_SendMsgRtxContro
       }
    }
 
+   nRetCode = DSL_DRV_VRX_FirmwareVersionCheck(pContext,
+                                               DSL_MIN_FW_VERSION_VR11_R6,
+                                               &nVerCheck);
+   if (nRetCode != DSL_SUCCESS)
+   {
+      DSL_DEBUG(DSL_DBG_ERR, (pContext,
+         SYS_DBG_ERR"DSL[%02d]: ERROR - FW version check failed -" \
+         "ROC feature unavailable!"
+         DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+   }
+   else if (nVerCheck >= DSL_VERSION_EQUAL)
+   {
+      DSL_CTX_READ_SCALAR(pContext, nErrCode,
+            lineFeatureDataCfg[nXdslMode][DSL_UPSTREAM].bRocEnable,
+            bRocEnable);
+      sCmd.ROC_US = bRocEnable;
+
+      DSL_CTX_READ_SCALAR(pContext, nErrCode,
+            lineFeatureDataCfg[nXdslMode][DSL_DOWNSTREAM].bRocEnable,
+            bRocEnable);
+      sCmd.ROC_DS = bRocEnable;
+   }
+
    sCmd.Length = DSL_VRX_16BIT_RD_MSG_LEN_GET(sCmd);
 
    nErrCode = DSL_DRV_VRX_SendMessage(
@@ -4340,6 +4448,7 @@ DSL_Error_t DSL_DRV_VRX_SendMsgStandardI
          DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
    }
 
+   DSL_DRV_MUTEX_LOCK(pContext->dataMutex);
    /* get the data */
    pXTSE[8-1] &= ~(DSL_uint8_t)(XTSE_8_01_A|XTSE_8_02_B|XTSE_8_03_C);
    if (sAck.A_US0PsdSup21 ||
@@ -4378,6 +4487,7 @@ DSL_Error_t DSL_DRV_VRX_SendMsgStandardI
        sAck.C_US0PsdSup12 ||
        sAck.C_US0PsdSup13)
        pXTSE[8-1] |= (DSL_uint8_t)XTSE_8_03_C;
+   DSL_DRV_MUTEX_UNLOCK(pContext->dataMutex);
 
    DSL_DEBUG(DSL_DBG_MSG,(pContext,
       SYS_DBG_MSG"DSL[%02d]: OUT - DSL_DRV_VRX_SendMsgStandardInfoFeVdsl2Get"
@@ -5465,13 +5575,8 @@ DSL_Error_t DSL_DRV_VRX_SendMsgLineStatu
    nMsgId = nDirection == DSL_DOWNSTREAM ? CMD_LINESTATUSDS_GET :
                                            CMD_LINESTATUSUS_GET;
 
-   /*
-      Starting with VDSL-FW version w.8.x.y.z.a another16-Bit word was appended
-      (--> Length=9). The same will be done in future ADSL releases (check release
-      notes). Older VDSL FW-versions and all current ADSL FW-versions can
-      request only 8 parameters (Length=8).
-   */
-   sCmd.Length = 9;
+   /* currently 11 16-Bit word parameters (--> Length=11) */
+   sCmd.Length = 11;
 
    nErrCode = DSL_DRV_VRX_SendMessage( pContext, nMsgId,
       sizeof(CMD_LineStatusUS_Get_t), (DSL_uint8_t*)&sCmd,
@@ -5877,25 +5982,41 @@ DSL_Error_t DSL_DRV_VRX_SendMsgFwVerInfo
    CMD_VersionInfoGet_t  sCmd = {0, 3};
    ACK_VersionInfoGet_t  sAck;
    DSL_Error_t nErrCode = DSL_SUCCESS;
+   DSL_boolean_t bFWVerNumSet = DSL_TRUE;
 
    DSL_DEBUG( DSL_DBG_MSG, (pContext,
       SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_VRX_SendMsgFwVerInfoGet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
 
-   nErrCode = DSL_DRV_VRX_SendMessage(pContext,
-      (DSL_uint16_t)CMD_VERSIONINFOGET,
-      sizeof(sCmd), (DSL_uint8_t*)&sCmd,
-      sizeof(ACK_VersionInfoGet_t), (DSL_uint8_t*)&sAck);
-
-   if(nErrCode == DSL_SUCCESS)
+   DSL_CTX_READ_SCALAR(pContext, nErrCode, VersionInformation.bFWVerNumSet, bFWVerNumSet);
+   if (bFWVerNumSet == DSL_FALSE)
    {
-      *pVerNum = (DSL_uint32_t)sAck.FW_Version;
+      nErrCode = DSL_DRV_VRX_SendMessage(pContext,
+         (DSL_uint16_t)CMD_VERSIONINFOGET,
+         sizeof(sCmd), (DSL_uint8_t*)&sCmd,
+         sizeof(ACK_VersionInfoGet_t), (DSL_uint8_t*)&sAck);
+
+      if(nErrCode == DSL_SUCCESS)
+      {
+         DSL_CTX_WRITE_SCALAR(pContext, nErrCode, VersionInformation.bFWVerNumSet, DSL_TRUE);
+
+         *pVerNum = (DSL_uint32_t)sAck.FW_Version;
+         pContext->VersionInformation.nFWVerNum = *pVerNum;
+      }
+      else
+      {
+         DSL_DEBUG(DSL_DBG_ERR,(pContext,
+            SYS_DBG_ERR"DSL[%02d]: ERROR - Failed to retrieve FW Version!"
+            DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+      }
    }
    else
    {
-      DSL_DEBUG(DSL_DBG_ERR,(pContext,
-         SYS_DBG_ERR"DSL[%02d]: ERROR - Failed to retrieve FW Version!"
+      DSL_DEBUG(DSL_DBG_MSG,(pContext,
+         SYS_DBG_MSG"DSL[%02d]: DSL_DRV_VRX_SendMsgFwVerInfoGet - internal data reused."
          DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+
+      *pVerNum = pContext->VersionInformation.nFWVerNum;
    }
 
    DSL_DEBUG(DSL_DBG_MSG,(pContext,
@@ -5916,27 +6037,42 @@ DSL_Error_t DSL_DRV_VRX_SendMsgHwVerInfo
    CMD_VersionInfoGet_t  sCmd = {0, 3};
    ACK_VersionInfoGet_t  sAck;
    DSL_Error_t nErrCode = DSL_SUCCESS;
+   DSL_boolean_t bChipHWVerNumSet = DSL_TRUE;
 
    DSL_DEBUG( DSL_DBG_MSG, (pContext,
       SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_VRX_SendMsgHwVerInfoGet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
 
-   nErrCode = DSL_DRV_VRX_SendMessage(pContext,
-      (DSL_uint16_t)CMD_VERSIONINFOGET,
-      sizeof(sCmd), (DSL_uint8_t*)&sCmd,
-      sizeof(ACK_VersionInfoGet_t), (DSL_uint8_t*)&sAck);
-
-   if(nErrCode == DSL_SUCCESS)
+   DSL_CTX_READ_SCALAR(pContext, nErrCode, VersionInformation.bChipHWVerNumSet, bChipHWVerNumSet);
+   if (bChipHWVerNumSet == DSL_FALSE)
    {
-      *pVerNum = (DSL_uint32_t)sAck.HW_Version;
+      nErrCode = DSL_DRV_VRX_SendMessage(pContext,
+         (DSL_uint16_t)CMD_VERSIONINFOGET,
+         sizeof(sCmd), (DSL_uint8_t*)&sCmd,
+         sizeof(ACK_VersionInfoGet_t), (DSL_uint8_t*)&sAck);
+
+      if(nErrCode == DSL_SUCCESS)
+      {
+         DSL_CTX_WRITE_SCALAR(pContext, nErrCode, VersionInformation.bChipHWVerNumSet, DSL_TRUE);
+
+         *pVerNum = (DSL_uint32_t)sAck.HW_Version;
+         pContext->VersionInformation.nChipHWVerNum = *pVerNum;
+      }
+      else
+      {
+         DSL_DEBUG(DSL_DBG_ERR,(pContext,
+            SYS_DBG_ERR"DSL[%02d]: ERROR - Failed to retrieve HW Version!"
+            DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+      }
    }
    else
    {
-      DSL_DEBUG(DSL_DBG_ERR,(pContext,
-         SYS_DBG_ERR"DSL[%02d]: ERROR - Failed to retrieve HW Version!"
+      DSL_DEBUG(DSL_DBG_MSG,(pContext,
+         SYS_DBG_MSG"DSL[%02d]: DSL_DRV_VRX_SendMsgHwVerInfoGet - internal data reused."
          DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
-   }
 
+      *pVerNum = pContext->VersionInformation.nChipHWVerNum;
+   }
 
    DSL_DEBUG(DSL_DBG_MSG,(pContext,
       SYS_DBG_MSG"DSL[%02d]: OUT - DSL_DRV_VRX_SendMsgHwVerInfoGet"
@@ -5956,27 +6092,42 @@ DSL_Error_t DSL_DRV_VRX_SendMsgHybridTyp
    CMD_HybridGet_t  sCmd = {0,1};
    ACK_HybridGet_t  sAck = {0,0,0};
    DSL_Error_t nErrCode = DSL_SUCCESS;
+   DSL_boolean_t bHybridTypeSet = DSL_TRUE;
 
    DSL_DEBUG( DSL_DBG_MSG, (pContext,
       SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_VRX_SendMsgHybridTypeGet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
 
-   nErrCode = DSL_DRV_VRX_SendMessage(pContext,
-      (DSL_uint16_t)CMD_HYBRIDGET,
-      sizeof(sCmd), (DSL_uint8_t*)&sCmd,
-      sizeof(ACK_HybridGet_t), (DSL_uint8_t*)&sAck);
-
-   if(nErrCode == DSL_SUCCESS)
+   DSL_CTX_READ_SCALAR(pContext, nErrCode, VersionInformation.bHybridTypeSet, bHybridTypeSet);
+   if (bHybridTypeSet == DSL_FALSE)
    {
-      *pHybridType = (DSL_uint32_t)sAck.HybridType;
+      nErrCode = DSL_DRV_VRX_SendMessage(pContext,
+         (DSL_uint16_t)CMD_HYBRIDGET,
+         sizeof(sCmd), (DSL_uint8_t*)&sCmd,
+         sizeof(ACK_HybridGet_t), (DSL_uint8_t*)&sAck);
+
+      if(nErrCode == DSL_SUCCESS)
+      {
+         DSL_CTX_WRITE_SCALAR(pContext, nErrCode, VersionInformation.bHybridTypeSet, DSL_TRUE);
+
+         *pHybridType = (DSL_uint32_t)sAck.HybridType;
+         pContext->VersionInformation.nHybridType = *pHybridType;
+      }
+      else
+      {
+         DSL_DEBUG(DSL_DBG_ERR,(pContext,
+            SYS_DBG_ERR"DSL[%02d]: ERROR - Failed to retrieve HW Version!"
+            DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+      }
    }
    else
    {
-      DSL_DEBUG(DSL_DBG_ERR,(pContext,
-         SYS_DBG_ERR"DSL[%02d]: ERROR - Failed to retrieve HW Version!"
+      DSL_DEBUG(DSL_DBG_MSG,(pContext,
+         SYS_DBG_MSG"DSL[%02d]: DSL_DRV_VRX_SendMsgHybridTypeGet - internal data reused."
          DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
-   }
 
+      *pHybridType = pContext->VersionInformation.nHybridType;
+   }
 
    DSL_DEBUG(DSL_DBG_MSG,(pContext,
       SYS_DBG_MSG"DSL[%02d]: OUT - DSL_DRV_VRX_SendMsgHybridTypeGet"
@@ -6647,6 +6798,7 @@ DSL_Error_t DSL_DRV_VRX_SendMsgFeatureMa
       ACK_ADSL_FeatureMapGet_t AFM;
       ACK_VDSL_FeatureMapGet_t VFM;
    } sAck;
+   DSL_boolean_t bFeatureMapSet = DSL_TRUE;
 
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
@@ -6658,14 +6810,29 @@ DSL_Error_t DSL_DRV_VRX_SendMsgFeatureMa
    memset(&sCmd, 0, sizeof(sCmd));
    sCmd.Length = DSL_VRX_16BIT_RD_MSG_LEN_GET(sAck.AFM);
 
-   nErrCode = DSL_DRV_VRX_SendMessage(pContext,
-      DSL_DRV_VRX_FirmwareXdslModeCheck(pContext, DSL_VRX_FW_VDSL2) ? CMD_VDSL_FEATUREMAPGET : CMD_ADSL_FEATUREMAPGET,
-      sizeof(sCmd), (DSL_uint8_t*)&sCmd,
-      sizeof(ACK_ADSL_FeatureMapGet_t), (DSL_uint8_t*)&sAck);
+   DSL_CTX_READ_SCALAR(pContext, nErrCode, VersionInformation.bFeatureMapSet, bFeatureMapSet);
+   if (bFeatureMapSet == DSL_FALSE)
+   {
+      nErrCode = DSL_DRV_VRX_SendMessage(pContext,
+         DSL_DRV_VRX_FirmwareXdslModeCheck(pContext, DSL_VRX_FW_VDSL2) ? CMD_VDSL_FEATUREMAPGET : CMD_ADSL_FEATUREMAPGET,
+         sizeof(sCmd), (DSL_uint8_t*)&sCmd,
+         sizeof(ACK_ADSL_FeatureMapGet_t), (DSL_uint8_t*)&sAck);
 
-   if (nErrCode >= DSL_SUCCESS)
+      if (nErrCode >= DSL_SUCCESS)
+      {
+         DSL_CTX_WRITE_SCALAR(pContext, nErrCode, VersionInformation.bFeatureMapSet, DSL_TRUE);
+
+         memcpy(pAck, &sAck, sizeof(ACK_ADSL_FeatureMapGet_t));
+         memcpy(&(pContext->VersionInformation.sFeatureMap), &sAck, sizeof(ACK_ADSL_FeatureMapGet_t));
+      }
+   }
+   else
    {
-      memcpy(pAck, &sAck, sizeof(ACK_ADSL_FeatureMapGet_t));
+      DSL_DEBUG(DSL_DBG_MSG,(pContext,
+         SYS_DBG_MSG"DSL[%02d]: DSL_DRV_VRX_SendMsgFeatureMapGet - internal data reused."
+         DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+
+      memcpy(pAck, &(pContext->VersionInformation.sFeatureMap), sizeof(ACK_ADSL_FeatureMapGet_t));
    }
 
    DSL_DEBUG( DSL_DBG_MSG,
--- a/src/g997/drv_dsl_cpe_api_g997.c
+++ b/src/g997/drv_dsl_cpe_api_g997.c
@@ -1,7 +1,9 @@
 /******************************************************************************
 
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2016 - 2019 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
 
   For licensing information, see the file 'LICENSE' in the root folder of
   this software module.
@@ -12,6 +14,9 @@
 
 #include "drv_dsl_cpe_api.h"
 #include "drv_dsl_cpe_device_g997.h"
+#ifdef __LINUX__
+#include <linux/capability.h>
+#endif /* __LINUX__ */
 
 #ifdef __cplusplus
    extern "C" {
@@ -31,6 +36,14 @@ DSL_Error_t DSL_DRV_G997_SnmpMessageSend
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -62,6 +75,14 @@ DSL_Error_t DSL_DRV_G997_SnmpMessageRece
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -94,6 +115,14 @@ DSL_Error_t DSL_DRV_G997_LineActivateCon
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_G997_LineActivateConfigSet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
@@ -177,6 +206,14 @@ DSL_Error_t DSL_DRV_G997_LineActivateCon
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_G997_LineActivateConfigGet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
@@ -206,6 +243,14 @@ DSL_Error_t DSL_DRV_G997_XTUSystemEnabli
    DSL_uint8_t nLine;
    DSL_Context_t *pCurrCtx;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_G997_XTUSystemEnablingConfigSet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
@@ -250,6 +295,14 @@ DSL_Error_t DSL_DRV_G997_XTUSystemEnabli
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_G997_XTUSystemEnablingConfigGet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
@@ -278,6 +331,14 @@ DSL_Error_t DSL_DRV_G997_XTUSystemEnabli
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_LineStateValue_t nCurrentState = DSL_LINESTATE_UNKNOWN;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_G997_XTUSystemEnablingStatusGet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
@@ -329,6 +390,14 @@ DSL_Error_t DSL_DRV_G997_ChannelDataRate
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -359,6 +428,14 @@ DSL_Error_t DSL_DRV_G997_ChannelDataRate
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -391,6 +468,14 @@ DSL_Error_t DSL_DRV_G997_LineTransmissio
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_G997_LineTransmissionStatusGet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
@@ -420,6 +505,14 @@ DSL_Error_t DSL_DRV_G997_LineInitStatusG
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_G997_LineInitStatusGet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
@@ -448,6 +541,14 @@ DSL_Error_t DSL_DRV_G997_AttainableNdrSt
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG, (pContext,
       SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_G997_AttainableNdrStatusGet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
@@ -479,6 +580,14 @@ DSL_Error_t DSL_DRV_G997_LineStatusGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -510,6 +619,14 @@ DSL_Error_t DSL_DRV_G997_LineStatusPerBa
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_G997_LineStatusPerBandGet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
@@ -537,6 +654,14 @@ DSL_Error_t DSL_DRV_G997_UsPowerBackOffS
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_G997_UsPowerBackOffStatusGet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
@@ -563,7 +688,19 @@ DSL_Error_t DSL_DRV_G997_RateAdaptationC
    DSL_IN DSL_Context_t *pContext,
    DSL_IN_OUT DSL_G997_RateAdaptationConfig_t *pData)
 {
+   DSL_boolean_t bReTxEnable = DSL_FALSE, bRocEnable = DSL_FALSE;
    DSL_Error_t nErrCode = DSL_SUCCESS;
+#if defined (DSL_VRX_DEVICE_VR11)
+   ACK_VDSL_FeatureMapGet_t nFeatureMapGetAck = { 0 };
+#endif
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
 
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
@@ -586,12 +723,74 @@ DSL_Error_t DSL_DRV_G997_RateAdaptationC
    }
    else
    {
-#if defined(INCLUDE_DSL_CPE_API_DANUBE) || defined(INCLUDE_DSL_CPE_API_VRX)
+#if defined(INCLUDE_DSL_CPE_API_DANUBE)
       if (pData->data.RA_MODE == DSL_G997_RA_MODE_DYNAMIC_SOS)
       {
          return DSL_ERR_NOT_SUPPORTED_BY_FIRMWARE;
       }
 #endif /* INCLUDE_DSL_CPE_API_DANUBE*/
+
+      if (pData->data.RA_MODE == DSL_G997_RA_MODE_DYNAMIC_SOS)
+      {
+         if (pData->nDslMode == DSL_MODE_VDSL)
+         {
+            /* ReTx has to be enabled */
+            DSL_CTX_READ_SCALAR(pContext, nErrCode,
+               lineFeatureDataCfg[pData->nDslMode][pData->nDirection].bReTxEnable,
+               bReTxEnable);
+
+            if (bReTxEnable == DSL_TRUE)
+            {
+#if defined (DSL_VRX_DEVICE_VR11)
+               /* ROC has to be enabled */
+               DSL_CTX_READ_SCALAR(pContext, nErrCode,
+                  lineFeatureDataCfg[pData->nDslMode][pData->nDirection].bRocEnable,
+                  bRocEnable);
+
+               if (bRocEnable == DSL_TRUE)
+               {
+                  /* related FeatureMap bit WOF13 has to be enabled */
+                  nErrCode = DSL_DRV_VRX_SendMsgFeatureMapGet(pContext, (DSL_uint8_t *)&nFeatureMapGetAck);
+                  if (nErrCode == DSL_SUCCESS)
+                  {
+                     if (nFeatureMapGetAck.W0F13 == VRX_DISABLE)
+                     {
+                        DSL_DEBUG(DSL_DBG_WRN,
+                           (pContext, SYS_DBG_WRN
+                           "DSL[%02d]: Feature-Bit13 is disabled, SOS will NOT be enabled!"
+                           DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+
+                        return DSL_ERR_NOT_SUPPORTED_BY_FIRMWARE;
+                     }
+                  }
+                  else
+                  {
+                     DSL_DEBUG(DSL_DBG_ERR,
+                        (pContext, SYS_DBG_ERR"DSL[%02d]: ERROR - FeatureMap get failed!"
+                        DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+
+                     return DSL_ERR_NOT_SUPPORTED_BY_FIRMWARE;
+                  }
+               }
+               else
+               {
+                  return DSL_ERR_NOT_SUPPORTED_BY_FIRMWARE;
+               }
+#else
+               return DSL_ERR_NOT_SUPPORTED_BY_FIRMWARE;
+#endif /* defined (DSL_VRX_DEVICE_VR11) */
+            }
+            else
+            {
+               return DSL_ERR_RETRANSMISSION_DISABLED;
+            }
+         }
+         else
+         {
+            return DSL_ERR_NOT_SUPPORTED_BY_FIRMWARE;
+         }
+      }
+
       /* Update internal Rate Adaptation Mode Settings for the selected
          xDSL mode and direction */
       DSL_CTX_WRITE(pContext, nErrCode,
@@ -618,6 +817,14 @@ DSL_Error_t DSL_DRV_G997_RateAdaptationC
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_G997_RA_MODE_t nSRAmode = DSL_G997_RA_MODE_AT_INIT;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -658,6 +865,14 @@ DSL_Error_t DSL_DRV_G997_RateAdaptationS
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -689,6 +904,14 @@ DSL_Error_t DSL_DRV_G997_ChannelStatusGe
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -722,6 +945,14 @@ DSL_Error_t DSL_DRV_G997_PowerManagement
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -750,6 +981,14 @@ DSL_Error_t DSL_DRV_G997_PowerManagement
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -778,6 +1017,14 @@ DSL_Error_t DSL_DRV_G997_LastStateTransm
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -809,6 +1056,14 @@ DSL_Error_t DSL_DRV_G997_BitAllocationNS
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -839,6 +1094,14 @@ DSL_Error_t DSL_DRV_G997_GainAllocationN
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -869,6 +1132,14 @@ DSL_Error_t DSL_DRV_G997_SnrAllocationNs
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -902,6 +1173,14 @@ DSL_Error_t DSL_DRV_G997_AlarmMaskLineFa
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -965,6 +1244,14 @@ DSL_Error_t DSL_DRV_G997_AlarmMaskLineFa
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -1006,6 +1293,14 @@ DSL_Error_t DSL_DRV_G997_LineFailuresSta
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -1081,6 +1376,14 @@ DSL_Error_t DSL_DRV_G997_AlarmMaskDataPa
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -1142,6 +1445,14 @@ DSL_Error_t DSL_DRV_G997_AlarmMaskDataPa
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -1183,6 +1494,14 @@ DSL_Error_t DSL_DRV_G997_DataPathFailure
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -1241,6 +1560,14 @@ DSL_Error_t DSL_DRV_G997_FramingParamete
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -1279,6 +1606,14 @@ DSL_Error_t DSL_DRV_G997_LineInventoryGe
    DSL_LineStateValue_t nCurrentState = DSL_LINESTATE_UNKNOWN;
    DSL_boolean_t bFeLineInventoryValid = DSL_FALSE, bFeLineInventoryIncomplete = DSL_FALSE;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -1341,6 +1676,14 @@ DSL_Error_t DSL_DRV_G997_LineInventorySe
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_DEBUG(DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_G997_LineInventorySet"
       DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
@@ -1370,6 +1713,14 @@ DSL_Error_t DSL_DRV_G997_DeltHlinScaleGe
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -1402,6 +1753,14 @@ DSL_Error_t DSL_DRV_G997_DeltHlinGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -1434,6 +1793,14 @@ DSL_Error_t DSL_DRV_G997_DeltHlogGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -1466,6 +1833,14 @@ DSL_Error_t DSL_DRV_G997_DeltQLNGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -1498,6 +1873,14 @@ DSL_Error_t DSL_DRV_G997_DeltSNRGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -1529,6 +1912,15 @@ DSL_Error_t DSL_DRV_G997_DeltFreeResourc
    DSL_IN_OUT DSL_G997_DeltFreeResources_t *pData)
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -1572,6 +1964,15 @@ DSL_Error_t DSL_DRV_G997_LowPowerModeCon
 )
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
+
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
@@ -1610,6 +2011,14 @@ DSL_Error_t DSL_DRV_G997_LowPowerModeCon
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pData);
    DSL_CHECK_ERR_CODE();
 
--- a/src/include/drv_dsl_cpe_api_bnd_vrx.h
+++ b/src/include/drv_dsl_cpe_api_bnd_vrx.h
@@ -128,7 +128,7 @@ DSL_Error_t DSL_DRV_BND_VRX_ConfigWrite(
    DSL_Context_t *pContext);
 
 /**
-   XWAY(TM) VRX200 device specific Bonding HW initialization.
+   VRX200 device specific Bonding HW initialization.
 
    \param pContext - Pointer to dsl cpe library context structure, [I/O]
    \param pData    - Pointer to the Bonding HW initialization data, [I]
--- a/src/include/drv_dsl_cpe_api_config.h
+++ b/src/include/drv_dsl_cpe_api_config.h
@@ -8,7 +8,7 @@
 /* #undef DSL_CPE_STATIC_DELT_DATA */
 
 /* Debug level = local */
-#define DSL_DBG_MAX_LEVEL_PRE 0x80
+#define DSL_DBG_MAX_LEVEL_PRE 0x40
 
 /* Preselection of max. debug level = no (using default) */
 #define DSL_DBG_MAX_LEVEL_SET /**/
@@ -170,7 +170,7 @@
 #define PACKAGE_NAME "DSL CPE API driver"
 
 /* Define to the full name and version of this package. */
-#define PACKAGE_STRING "DSL CPE API driver 4.21.1"
+#define PACKAGE_STRING "DSL CPE API driver 4.21.3"
 
 /* Define to the one symbol short name of this package. */
 #define PACKAGE_TARNAME "drv_dsl_cpe_api"
@@ -179,7 +179,7 @@
 #define PACKAGE_URL ""
 
 /* Define to the version of this package. */
-#define PACKAGE_VERSION "4.21.1"
+#define PACKAGE_VERSION "4.21.3"
 
 /* Version number of package */
-#define VERSION "4.21.1"
+#define VERSION "4.21.3"
--- a/src/include/drv_dsl_cpe_api_error.h
+++ b/src/include/drv_dsl_cpe_api_error.h
@@ -252,20 +252,21 @@ typedef enum
    /** One or more parameters are ignored */
    DSL_WRN_CONFIG_PARAM_IGNORED = 4,
    /** This warning is used in case of an event was lost.
-   This could happen due to the following reasons
-   - polling cycle within polling based event handling is to slow
-   - system overload respective improper priorities within interrupt based
-     event handling
-   Also refer to "Event Handling" chapter within UMPR to get all the details. */
+       This could happen due to the following reasons
+       - polling cycle within polling based event handling is to slow
+       - system overload respective improper priorities within interrupt based
+         event handling
+       Also refer to the "Event Handling" chapter within Programmer's Reference
+       for more details. */
    DSL_WRN_EVENT_FIFO_OVERFLOW  = 5,
-   /** The ioctl function that has been used is deprecated.
-   Please do not use this function anymore. Refer to the according documentation
-   (release notes and/or User's Manual Programmer's Reference [UMPR]) of
-   the DSL CPE API to find the new function that has to be used. */
+   /** The function which has been used is deprecated.
+       Please do not use this function anymore. Refer to the according
+       documentation (Release Notes and/or Programmer's Reference [PR]) of the
+       DSL CPE API to find a new function that has to be used. */
    DSL_WRN_DEPRECATED  = 6,
-   /** This warning occurs if the firmware did not accept the last message.
-      This may occur if the message is unknown or not allowed in the current
-      state. */
+   /** This warning occurs if the firmware did not accept the last message. This
+       may occur if the message is unknown or not allowed in the current
+       state. */
    DSL_WRN_FIRMWARE_MSG_DENIED = 9,
    /** This warning occurs if no data available from the device. */
    DSL_WRN_DEVICE_NO_DATA = 10,
@@ -345,6 +346,8 @@ typedef enum
        the configuration to enable upstream RTX was discared. Please enable
        RTX for downstream first! */
    DSL_WRN_CONFIG_RTX_US_ONLY_SUPPORTED_WITH_DS_ENABLED = 402,
+   /** The configuration parameter can be only enabled together with RTX. */
+   DSL_WRN_CONFIG_ONLY_SUPPORTED_WITH_RTX_ENABLED = 403,
    /* *********************************************************************** */
    /* *** Bonding functionality related warning codes                     *** */
    /* *********************************************************************** */
--- a/src/include/drv_dsl_cpe_api_g997.h
+++ b/src/include/drv_dsl_cpe_api_g997.h
@@ -1,7 +1,9 @@
 /******************************************************************************
 
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2016 - 2019 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
 
   For licensing information, see the file 'LICENSE' in the root folder of
   this software module.
@@ -79,7 +81,7 @@ typedef struct
    from 32 to \ref DSL_MAX_NSC.
    This structure includes an array of 8 bit values.
 
-   \note For VDSL2 with 35b profiles this data uses 4.3125kHz tone spacing with 
+   \note For VDSL2 with 35b profiles this data uses 4.3125kHz tone spacing with
          35.328Mhz bandwidth what means tones 0..8192.
 */
 typedef struct
@@ -1754,8 +1756,11 @@ typedef enum
 #if defined(DSL_VRX_DEVICE_VR11)
    /**
    Clock set mode issue */
-   LINIT_SUB_S_PP_CLOCK_NEW = 12,
+   LINIT_SUB_S_AUTOMSG = 12,
    LINIT_SUB_S_PP_ERB_INIT = 13,
+   /**
+   Recovery from PPE-FW stuck required */
+   LINIT_SUB_S_REBOOT_REQ = 14,
 #endif /* defined(DSL_VRX_DEVICE_VR11) */
 } DSL_G997_LineInitSubStatus_t;
 
@@ -1940,6 +1945,30 @@ typedef struct
    \note The downstream/upstream nominal aggregate transmit power may be taken
          as a best estimate of the parameter. */
    DSL_OUT DSL_int16_t ACTATP;
+   /**
+   Downstream/Upstream actual SNR margin of ROC (see chapter
+   7.5.1.35.1/7.5.1.35.2 of G.997.1).
+   This parameter reports the actual signal-to-noise margin of the ROC in the
+   downstream/upstream direction. The format (both range as well as special
+   value) is identical to the format of the line status parameter SNR (see
+   DSL_G997_LineStatusData_t.SNR, respectively clause 7.5.1.13/7.5.1.16 within
+   G.997.1).
+   This parameter is given "per direction", not "per band".
+   \note This value is only valid in case of VDSL. In case of ADSL the special
+         value is returned.
+   \note This value is not available in DELT (special value). */
+   DSL_OUT DSL_int16_t SNR_ROC;
+   /**
+   Downstream/Upstream actual impulse noise protection of ROC (see chapter
+   7.5.1.34.1/7.5.1.34.2 of G.997.1).
+   This parameter reports the actual impulse noise protection (INP) of the ROC
+   in the downstream/upstream direction expressed in multiples of T4k in the L0
+   state. In the L1 or L2 states, the parameter contains the value in the
+   previous L0 state.
+   The value is coded in fractions of T4k with a granularity of 0.1. The range
+   is from 0 to 25.4. A special value indicates an ACTINP-ROC higher than 25.4.
+   \note T4k equals to multiples of equivalent 4k DMT symbol length. */
+   DSL_OUT DSL_int16_t ACTINP_ROC;
 } DSL_G997_LineStatusData_t;
 
 /**
@@ -2529,7 +2558,9 @@ typedef enum
    Data rate is automatically selected at initialization and may be
    continuously adapted during operation (showtime) by SOS and SRA.
    The Rate Adaptation mode 4 is optional. In this mode, enabling of SOS
-   and SRA is mandatory.
+   and SRA is mandatory. In VRX518 SOS is implemented only for RTX
+   mode (not IFEC) on a per direction basis. SOS can only be enabled for a
+   direction if RTX support is enabled for it too.
 
    At startup:
 
@@ -2542,7 +2573,7 @@ typedef enum
    the Minimum net data rate as a result of an SOS procedure.
    Additionally, SOS may be performed, when the conditions specified
    by the SOS trigger parameters are satisfied. The detailed specification
-   of SOS OLR procedure is in G.993.2.
+   of SOS OLR procedure is in G.993.2 and G.998.4 (the RTX specific SOS items).
 
    If at startup, it is detected that SOS is not supported in the downstream
    direction by either XTU's, but SRA is supported by both XTU's,
--- a/src/include/drv_dsl_cpe_api.h
+++ b/src/include/drv_dsl_cpe_api.h
@@ -764,32 +764,38 @@ typedef struct
    hw_platform.feature_set.major_ver.minor_ver.rel_indication.application
 
    Hardware platform (hw_platform):
-   - 0x01: XWAY(TM) AMAZON Family (not covered by DSL CPE API!)
-   - 0x02: XWAY(TM) DANUBE Family (not supported anymore)
-   - 0x03: XWAY(TM) AMAZON-SE Family (not supported anymore)
-   - 0x04: XWAY(TM) ARX100 Family
-   - 0x05: XWAY(TM) VRX200 Family
-   - 0x06: XWAY(TM) ARX300 Family
-   - 0x07: XWAY(TM) VRX300 Family
-   - 0x08: XWAY(TM) VRX500 Family
+
+   - 0x01: AMAZON Family (not covered by DSL CPE API!)
+   - 0x02: DANUBE Family (not supported anymore)
+   - 0x03: AMAZON-SE Family (not supported anymore)
+   - 0x04: ARX100 Family
+   - 0x05: VRX200 Family
+   - 0x06: ARX300 Family
+   - 0x07: VRX300 Family
+   - 0x08: VRX500 Family
 
    Feature set (feature_set)
+
    - Indicates the major feature set implementation for firmware (please refer
      to firmware documentation and/or contact Intel for detailed informations).
 
    Major version (major_ver)
+
    - Logical number (incremented for major updates of firmware)
 
    Minor version (minor_ver)
+
    - Logical number (incremented for minor updates of firmware)
 
    Release indication (rel_indication)
+
    - 0x00: RELEASE_STATUS_RELEASED, The firmware has been tested and released.
    - 0x01: RELEASE_STATUS_PRE_RELEASE, The firmware is undergoing the release
            process; the release has not been completed.
 
    Application type (application)
    The following application types are defined.
+
    - 0x01: ADSL Annex A
    - 0x02: ADSL Annex B
    - 0x06: VDSL
@@ -1212,12 +1218,10 @@ typedef struct
    /**
    Retransmission (ReTx) config/status value.
 
-   \note Currently the ReTx feature is only supported for downstream direction.
-         Therefore configurations are only possible for downstream and will be
-         ignored for upstream. Additionally a warning
-         \ref DSL_WRN_CONFIG_PARAM_IGNORED is returned in that case.
-   \note In case of using a VDSL capable platform the configuration is only
-         valid in case of using VDSL link activation mode. */
+   \note In case of operating a VRX family based system, retransmission (ReTx)
+         configuration for US can only be enabled together with ReTx
+         configuration for DS. This means that ReTx for DS needs to be enabled
+         first. */
    DSL_CFG DSL_boolean_t bReTxEnable;
    /**
    Virtual noise config/status value.
@@ -1225,7 +1229,7 @@ typedef struct
    \note The status value for virtual noise is directly derived from the
          configuration value (configuration value only) for ADSL only capable
          platforms.
-   \note Supported by XWAY(TM) VR200 and XWAY(TM) VR300  */
+   \note Supported by VR200 and VR300 */
    DSL_CFG DSL_boolean_t bVirtualNoiseSupport;
    /**
    20 bit constellation config/status value.
@@ -1235,6 +1239,15 @@ typedef struct
    \note The configuration and status of this feature is only available for
          ADSL only platforms and for downstream direction. */
    DSL_CFG DSL_FeatureSupport_t b20BitSupport;
+   /**
+   Robust Overhead Channel (ROC) config/status value.
+
+   \note The configuration and status of this feature is only available for
+         VDSL. In case of ADSL configuration, enabling will be ignored and an
+         according warning "DSL_WRN_CONFIG_PARAM_IGNORED" will be returned.
+   \note This feature can only be enabled for VDSL in case of Retransmission
+         (bReTxEnable) is also enabled. */
+   DSL_CFG DSL_FeatureSupport_t bRocEnable;
 } DSL_LineFeatureData_t;
 
 /**
@@ -4502,7 +4515,7 @@ typedef enum
    Restarts the firmware and the DSL CPE API for usage of updated configurations.
    \note The standard handling for this command is to perform a hard reset (full
          firmware download, including a reset and writing the firmware)
-   \note In case of using XWAY(TM) VRX200 and activated bonded (dual-port mode,
+   \note In case of using VR200 and activated bonded (dual-port mode,
          on-chip bonding) operation this command performs a soft reset instead
          (using firmware message CMD_ModemFSM_StateSet:LinkControl=0) */
    DSL_AUTOBOOT_CTRL_RESTART = 2,
@@ -4533,7 +4546,7 @@ typedef enum
    and writing the firmware).
    \attention In non-bonded operation this command is equivalent to the standard
               autoboot restart command \ref DSL_AUTOBOOT_CTRL_RESTART. In case
-              of using XWAY(TM) VRX200 and activated bonded (dual-port mode,
+              of using VR200 and activated bonded (dual-port mode,
               on-chip bonding) operation this command forces a hard reset
               whereas the standard command does a soft reset only to avoid
               tearing down both lines. */
@@ -4779,7 +4792,7 @@ typedef struct
 /**
    Defines the control functionalities of the autoboot handling
    \note Please note that this configurations are only used for ADSL only
-         platforms such like XWAY(TM) ARX100 and XWAY(TM) ARX300
+         platforms such like ARX100 and ARX300
 */
 typedef enum
 {
@@ -4834,7 +4847,7 @@ typedef enum
 /**
    Structure used for configuration of MinSnrMarging reboot criteria.
    \note Please note that this configurations are only used for ADSL only
-         platforms such like XWAY(TM) ARX100 and XWAY(TM) ARX300
+         platforms such like ARX100 and ARX300
 */
 typedef struct
 {
--- a/src/include/drv_dsl_cpe_api_ioctl.h
+++ b/src/include/drv_dsl_cpe_api_ioctl.h
@@ -18,6 +18,7 @@
 #include "drv_dsl_cpe_api.h"
 #include "drv_dsl_cpe_api_pm.h"
 #include "drv_dsl_cpe_api_bnd.h"
+#include "drv_dsl_cpe_configuration.h"
 
 #ifdef INCLUDE_DSL_ADSL_MIB
    /**
@@ -66,6 +67,7 @@ typedef union
    DSL_AccessCtl_t                   accessCtl;
 
    DSL_Init_t                        init;
+   DSL_Configuration_t               configuration;
    DSL_AutobootLoadFirmware_t        autobootLoadFirmware;
    DSL_AutobootControl_t             autobootControl;
    DSL_AutobootConfig_t              autobootConfig;
@@ -346,8 +348,9 @@ typedef union
    CLI
    - n/a
    - Note: This ioctl is called within context of starting up the control
-           application in case of using '-i' option, also refer to UMPR
-           "Command line arguments for the DSL CPE Control Application"
+           application in case of using '-i' option, also refer to the
+           description of "Command line arguments for the DSL CPE Control
+           Application" within Programmer's Reference.
 
    \param DSL_Init_t*
       The parameter points to a \ref DSL_Init_t structure
@@ -375,6 +378,32 @@ typedef union
    _IOWR(DSL_IOC_MAGIC_CPE_API, 0, DSL_Init_t)
 
 /**
+   This ioctl reloads input configuration file.
+
+   \param DSL_Configuration_t*
+      The parameter points to a \ref DSL_Configuration_t structure
+
+   \return
+      0 if successful and -1 in case of an error/warning
+      In case of an error/warning please refer to the value of 'nReturn' which
+      is included within accessCtl structure of user data.
+
+   \remarks
+   Supported by all platforms.
+
+   \code
+      DSL_Configuration_t cfg;
+      DSL_int_t ret = 0;
+
+      memset(&cfg, 0x00, sizeof(DSL_Configuration_t));
+      ret = ioctl(fd, DSL_FIO_CONFIGURATION_RELOAD, &cfg);
+   \endcode
+
+   \ingroup DRV_DSL_CPE_INIT */
+#define DSL_FIO_CONFIGURATION_RELOAD \
+   _IOWR( DSL_IOC_MAGIC_CPE_API, 99, DSL_Configuration_t )
+
+/**
    This ioctl downloads a firmware.
 
    CLI
@@ -1128,7 +1157,7 @@ typedef union
    CLI
    - Not applicable for CLI interface
    - Note: This ioctl is called within context of exception handling in case of
-           ADSL only platform build. Also refer to the UMPR,
+           ADSL only platform build. Also refer to the Programmers's Reference
            - configure option: --enable-adsl-trace
            - event type: DSL_EVENT_S_SHOWTIME_LOGGING
 
@@ -1142,7 +1171,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100 and XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100 and ARX300)
 
    \code
       DSL_ShowtimeLogging_t data;
@@ -1373,7 +1402,8 @@ typedef union
    CLI
    - Not applicable for CLI interface
    - Note: This ioctl is called within context of event handling within control
-           application. Also refer to the UMPR "Event Handling"
+           application. Also refer to the "Event Handling" description within
+           Programmer's Reference.
 
    \param DSL_EventStatus_t*
       The parameter points to a \ref DSL_EventStatus_t structure
@@ -1400,7 +1430,7 @@ typedef union
 
 /**
    This function has to be used to initialize instance specific handling.
-   Usually this function shall be called directly after using \ref DSL_FIO_INIT
+   Usually this function shall be called directly before using \ref DSL_FIO_INIT
    ioctl.
 
    CLI
@@ -1558,7 +1588,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100, ARX300)
 
    \code
       DSL_InteropFeatureConfig_t interopFeatureConfig;
@@ -1590,7 +1620,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100, ARX300)
 
    \code
       DSL_InteropFeatureConfig_t interopFeatureConfig;
@@ -1654,7 +1684,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100, ARX300)
 
    \code
       DSL_MiscLineStatus_t miscLineStatus;
@@ -1717,7 +1747,7 @@ typedef union
       is included within accessCtl structure of user data.
 
    \remarks
-   - Supported by ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - Supported by ADSL only platforms (ARX100, ARX300)
    - Please note that a change of this configuration setting(s) will be only
      effective after restarting the autoboot handling using ioctl
      \ref DSL_FIO_AUTOBOOT_CONTROL_SET with command \ref DSL_AUTOBOOT_CTRL_RESTART
@@ -1752,7 +1782,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100, ARX300)
 
    \code
       DSL_LineOptionsConfig_t lineOptionsConfig;
@@ -1820,7 +1850,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100, ARX300)
 
    \code
       DSL_DBG_DebugFeatureConfig_t dbgDebugFeatureConfig;
@@ -1858,7 +1888,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100, ARX300)
 
    \code
       DSL_DBG_DebugFeatureConfig_t dbgDebugFeatureConfig;
@@ -2436,8 +2466,9 @@ typedef union
    CLI
    - n/a
    - Note: This ioctl is called within context of starting up the control
-           application in case of using '-i' option, also refer to UMPR
-           "Command line arguments for the DSL CPE Control Application"
+           application in case of using '-i' option, also refer to the
+           description of "Command line arguments for the DSL CPE Control
+           Application" within Programmer's Reference.
 
    \param DSL_BND_HwInit_t*
       The parameter points to a \ref DSL_BND_HwInit_t structure
@@ -2449,10 +2480,10 @@ typedef union
 
    \remarks
    Supported by
-   - XWAY(TM) VRX200: xDSL-CPE
+   - VRX200: xDSL-CPE
 
-   \note This ioctl is reserved for future usage on XWAY(TM) VRX200. This means
-         there is currently no functionality included.
+   \note This ioctl is reserved for future usage on VRX200. This means there is
+         currently no functionality included.
 
    \code
       DSL_BND_HwInit_t BND_HwInit;
@@ -2718,7 +2749,7 @@ typedef union
 
    \remarks
    Supported by
-   - XWAY(TM) VRX200: xDSL-CPE
+   - VRX200: xDSL-CPE
 
    \code
       DSL_BND_PortModeSync_t BND_PortModeSync;
@@ -3215,7 +3246,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100, ARX300)
 
    \code
       DSL_G997_LastStateTransmitted_t lastStateTransmitted;
@@ -3792,10 +3823,10 @@ typedef union
    - long command: G997_DeltFreeResources
    - short command: g997dfr
    - Note: This ioctl usage only makes sense in case of using dynamically
-           allocated diagnostic data (DELT) memory. Also refer to the UMPR
-           configure option: "--enable-dsl-delt-static=no".
-           In that case and after a DELT measurement has taken place the
-           API internal memory could be freed by using this function.
+           allocated diagnostic data (DELT) memory. Also refer to the configure
+           option "--enable-dsl-delt-static=no" within Programmer's Reference.
+           In that case and after a DELT measurement has taken place the API
+           internal memory could be freed by using this function.
 
    \return
       0 if successful and -1 in case of an error/warning
@@ -3832,7 +3863,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100, ARX300)
 
    \code
       DSL_G997_Snmp_t snmpData;
@@ -3865,7 +3896,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100, ARX300)
 
    \code
       DSL_G997_Snmp_t snmpData;
@@ -3965,7 +3996,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100, ARX300)
 
    \code
       DSL_G997_RateAdaptationStatus_t raStatGet;
@@ -5532,7 +5563,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100, ARX300)
 
    \code
       DSL_PM_ChannelCountersExt_t pmChannelCountersExt;
@@ -6345,7 +6376,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100, ARX300)
 
    \code
       DSL_RTT_Init_t RTT_Init;
@@ -6377,7 +6408,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100, ARX300)
    \remarks
    - Please note that a change of this configuration setting(s) will be only
      effective after restarting the autoboot handling using ioctl
@@ -6416,7 +6447,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100, ARX300)
 
    \code
       DSL_RTT_Config_t RTT_Config;
@@ -6448,7 +6479,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100, ARX300)
 
    \code
       DSL_RTT_Status_t DSL_RTT_Status;
@@ -6481,7 +6512,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100, ARX300)
 
    \code
       DSL_RTT_Control_t RTT_Control;
@@ -6516,7 +6547,7 @@ typedef union
 
    \remarks
    Supported by
-   - ADSL only platforms (XWAY(TM) ARX100, XWAY(TM) ARX300)
+   - ADSL only platforms (ARX100, ARX300)
 
    \code
       DSL_RTT_Statistics_t RTT_Config;
--- a/src/include/drv_dsl_cpe_autoboot.h
+++ b/src/include/drv_dsl_cpe_autoboot.h
@@ -164,15 +164,15 @@ DSL_Error_t DSL_DRV_AutobootHandleDevice
 #define DSL_AUTOBOOT_TRAINING_POLL_TIME 1000
 #define DSL_AUTOBOOT_INIT_POLL_TIME 100
 #define DSL_AUTOBOOT_SHOWTIME_POLL_TIME 1000
-#define DSL_AUTOBOOT_EXCEPTION_POLL_TIME 0
+#define DSL_AUTOBOOT_EXCEPTION_POLL_TIME 10
 #define DSL_AUTOBOOT_DIAGNOSTIC_POLL_TIME 1000
-#define DSL_AUTOBOOT_FW_REQUEST_POLL_TIME 0
+#define DSL_AUTOBOOT_FW_REQUEST_POLL_TIME 10
 #define DSL_AUTOBOOT_FW_WAIT_POLL_TIME 100
 #define DSL_AUTOBOOT_LINK_ACTIVATE_WAIT_POLL_TIME 100
 #define DSL_AUTOBOOT_CONFIG_WRITE_WAIT_POLL_TIME 100
 #define DSL_AUTOBOOT_RESTART_WAIT_POLL_TIME 100
 #define DSL_AUTOBOOT_FW_READY_POLL_TIME 100
-#define DSL_AUTOBOOT_RESTART_POLL_TIME 0
+#define DSL_AUTOBOOT_RESTART_POLL_TIME 100
 #define DSL_AUTOBOOT_ORDERLY_SHUTDOWN_POLL_TIME 250
 #define DSL_AUTOBOOT_DISABLE_POLL_TIME 100
 
--- /dev/null
+++ b/src/include/drv_dsl_cpe_configuration.h
@@ -0,0 +1,277 @@
+/******************************************************************************
+
+         Copyright (c) 2018 Intel Corporation
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+*******************************************************************************/
+#ifndef _DRV_DSL_CPE_CONFIGURATION_H
+#define _DRV_DSL_CPE_CONFIGURATION_H
+
+#define CONFIG_FILE_PATH "/opt/intel/etc/dsl_cpe_control.conf"
+#define CONFIGURATION_VALUE_UNDEFINED 0x7FFFFFFF
+
+typedef struct
+{
+   /* Bitswap config for US in VDSL */
+   unsigned int Us_Vdsl;
+
+   /* Bitswap config for DS in VDSL */
+   unsigned int Ds_Vdsl;
+
+   /* Bitswap config for US in ADSL */
+   unsigned int Us_Adsl;
+
+   /* Bitswap config for DS in ADSL */
+   unsigned int Ds_Adsl;
+} DSL_CFG_Bitswap_t;
+
+typedef struct
+{
+   /* Retransmission config for US in ADSL */
+   unsigned int Us_Adsl;
+
+   /* Retransmission config for DS in ADSL */
+   unsigned int Ds_Adsl;
+
+   /* Retransmission config for US in VDSL */
+   unsigned int Us_Vdsl;
+
+   /* Retransmission config for DS in VDSL */
+   unsigned int Ds_Vdsl;
+} DSL_CFG_Retransmission_t;
+
+typedef struct
+{
+   /* SRA config for US in ADSL */
+   unsigned int Us_Adsl;
+
+   /* SRA config for DS in ADSL */
+   unsigned int Ds_Adsl;
+
+   /* SRA config for US in VDSL */
+   unsigned int Us_Vdsl;
+
+   /* SRA config for DS in VDSL */
+   unsigned int Ds_Vdsl;
+} DSL_CFG_Sra_t;
+
+typedef struct
+{
+   /* Virtual Noise config for US */
+   unsigned int Us;
+
+   /* Virtual Noise config for DS */
+   unsigned int Ds;
+} DSL_CFG_VirtualNoise_t;
+
+typedef struct
+{
+   /*
+      The value selects the activated reboot criteria's according to the
+      following bitmask definitions.
+      Please note that some values are used only within ADSL or VDSL. For
+      details please refer to the UMPR of the DSL CPE API.
+      DEFAULT value for ADSL is "4F"
+      DEFAULT value for VDSL is "F"
+         "0": CLEANED (no reboot criteria active)
+         "1": LOM              - default ON
+         "2": LOF              - default ON
+         "4": LOS              - default ON
+         "8": ESE              - default ON
+         "10": ES90             - default OFF
+         "20": SES30            - default OFF
+         "40": NEGATIVE_MARGIN  - default ON for ADSL / OFF for VDSL
+         "80": OOS_BC0          - default OFF
+         "100": OOS_BC1          - default OFF
+         "200": NCD_BC0          - default OFF
+         "400": NCD_BC1          - default OFF
+         "800": LCD_BC0          - default OFF
+         "1000": LCD_BC1          - default OFF
+   */
+   unsigned int Adsl;
+   unsigned int Vdsl;
+} DSL_CFG_RebootCriteria_t;
+
+typedef struct
+{
+   /*
+      The value selects the activated handshake tones according to the
+      following bitmask definitions.
+      The default values are related to the DSL operation mode. Please refer to
+      the UMPR of the DSL CPE API for all details.
+         "1": VDSL2 B43
+         "2": VDSL2 A43
+         "4": VDSL2 V43
+         "8": VDSL1 V43POTS
+         "10": VDSL1 V43ISDN
+         "20": ADSL1 C43
+         "40": ADSL2 J43
+         "80": ADSL2 B43C
+         "100": ADSL2 A43C
+   */
+   unsigned int Adsl;
+   unsigned int Vdsl;
+} DSL_CFG_LowLevelHsTones_t;
+
+typedef struct
+{
+   /*
+      Configuration of API shutdown handling in case of using autoboot control
+      command "acs <nLine> 7" (DSL_CFG_AUTOBOOT_CTRL_STOP_PD)
+         LdAfeShutdown
+         "0": Do not shutdown the Line Driver and the AFE
+               This option should be used for example in case of underlying
+               ISDN service is used and an impedance change of the line should
+               be avoided
+         "1": Shutdown the Line Driver and the AFE - DEFAULT
+               This option is selected by default and make use of a specific DSL FW
+               messages (if supported) to power down the LD/AFE
+   */
+   unsigned int LdAfeShutdown;
+
+   /*
+      Configuration of PLL handling in case of performing power down on DSL
+      Subsystem
+         PLL_SwitchOff
+         "0": Do not switch off the PLL on power down handling - DEFAULT
+         "1": Switch off the PLL as a last step within power down handling
+               Please note that a disabled PLL can be only re-enabled by a Hard
+               Reset of the VRX518 (GRX-GPIO pin connected to the VRX Reset input)
+   */
+   unsigned int PLL_SwitchOff;
+
+   /*
+      Configuration of test and debug specific DSL activation mode settings
+      G997 XTU octet bits.
+         G997XtuVal (only used in case of "G997XtuVal" equals "1")
+   */
+   unsigned char G997XtuVal[DSL_G997_NUM_XTSE_OCTETS];
+
+   /*
+      Configuration of SystemInterface config (syntax as for CLI command "sics")
+         SystemInterface
+         All other values will overwrite according system level configuration
+         provided by SL. Definition as within "-T" startup option as follows
+            -T<TcA>:<TcCfgUsA>:<TcCfDsA>_<TcV>:<TcCfgUsV>:<TcCfDsV>
+         For example
+            "1:0x1:0x1_2:0x1:0x1" for ADSL/ATM and VDSL/PTM (API internal default)
+   */
+   char SystemInterface[64];
+
+   /*
+      Configuration of test and debug specific vectoring setting
+         VectoringEnable
+         "0": Disable any vectoring operation
+         "1": Enables the G.993.5 full G.Vector for US and DS)
+         "2": Enables the G.993.2 Annex Y (G.Vector friendly)
+         "3": Enables automatic detection for the best fitting configuration
+   */
+   unsigned int VectoringEnable;
+
+   /*
+      VdslProfileVal
+      The value selects the activated Vdsl profile according to the
+      following bitmask definitions.
+      Please note that 12A/12B/17A/30A are not supported for the Dual port mode.
+      DEFAULT value is "0xFF" (single port mode), "0xF" (dual port mode).
+         "1": 8A
+         "2": 8B
+         "4": 8C
+         "8": 8D
+         "10": 12A
+         "20": 12B
+         "40": 17A
+         "80": 30A
+         "100": 35B
+   */
+   unsigned int VdslProfileVal;
+
+   /*
+      NextMode (DSL) to be used on API startup
+      Only of relevance if xDSL multimode is enabled by using VDSL and ADSL
+      G997 XTU octet bits.
+         NextMode
+         "0": use API-default value (if A+V modes are selected VDSL will be used)
+         "1": use ADSL mode as initial one for multimode handling
+         "2": use VDSL mode as initial one for multimode handling
+   */
+   unsigned int NextMode;
+
+   /*
+   Configuration of Non-standard activation sequence
+      ActSeq
+      "0": Automatic detection from XTSE configuration (enables Non-standard
+            activation sequence in case of T1.413 is enabled as well)
+      "1": Standard Handshake (G.HS)  - DEFAULT
+      "2": Non-standard activation sequence ("Telefonica switching mode")
+   */
+   unsigned int ActSeq;
+
+   /*
+      Configuration of initial activation mode
+         ActMode (only used if "ActMode" equals "2" or
+         "ActMode" equals "0" and T1.413 mode is included within XTSE octets)
+         "1": Start with G.HS activation mode  - DEFAULT
+         "2": Start with ANSI-T1.413 activation mode
+   */
+   unsigned int ActMode;
+
+   /*
+      Configuration of remember functionality used in case of activated xDSL multimode
+         Remember
+            "0": disable remember functionality
+            "1": enable remember functionality
+   */
+   unsigned int Remember;
+
+   /*
+      User defined configuration of entities (VRX devices) which will be operated
+         EntitiesEnabledSelect
+            The value for this parameter must be in the range of 0 to 2,
+            "0" : Do not operate any VRX device
+            "1" : Operate one VRX device
+                  Single link mode, used line will be always 0 in this case!
+            "2" : Operate both VRX devices (if available)
+                  Bonding mode
+  */
+   unsigned int EntitiesEnabledSelect;
+} DSL_CFG_Common_t;
+
+typedef struct
+{
+   /** Bitswap configuration */
+   DSL_CFG_Bitswap_t sBitswapConfig;
+
+   /** Retransmission configuration */
+   DSL_CFG_Retransmission_t sRetransmissionConfig;
+
+   /** Sra configuration */
+   DSL_CFG_Sra_t sSraConfig;
+
+   /** VirtualNoise configuration */
+   DSL_CFG_VirtualNoise_t sVirtualNoiseConfig;
+
+   /** Reboot criteria configuration */
+   DSL_CFG_RebootCriteria_t sRebootCriteriaConfig;
+
+   /** Low Level handshake tones configuration */
+   DSL_CFG_LowLevelHsTones_t sLowLevelHsTonesConfig;
+
+   /** Common configuration */
+   DSL_CFG_Common_t sCommonConfig;
+} DSL_ConfigurationData_t;
+
+
+typedef struct
+{
+   /**
+   Driver control/status structure */
+   DSL_IN_OUT DSL_AccessCtl_t accessCtl;
+
+   /**
+   Structure that contains initialization data */
+   DSL_ConfigurationData_t data;
+} DSL_Configuration_t;
+#endif /* _DRV_DSL_CPE_CONFIGURATION_H */
\ No newline at end of file
--- a/src/include/drv_dsl_cpe_device_vrx.h
+++ b/src/include/drv_dsl_cpe_device_vrx.h
@@ -70,6 +70,7 @@
 #define DSL_MIN_FW_VERSION_VR11_R5           0xC,  -1,  -1,  -1,  -1
 #define DSL_MIN_FW_VERSION_VR11_PD           0xC,   1,   4,  -1,  -1
 #define DSL_MIN_FW_VERSION_VR11_PD_ADSL      0xC,   1,   0,  -1,  -1
+#define DSL_MIN_FW_VERSION_VR11_R6           0xD,  -1,  -1,  -1,  -1
 
 /*
    Internal device dependent configuration options
--- a/src/include/drv_dsl_cpe_intern.h
+++ b/src/include/drv_dsl_cpe_intern.h
@@ -1,7 +1,9 @@
 /******************************************************************************
 
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2016 - 2019 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
 
   For licensing information, see the file 'LICENSE' in the root folder of
   this software module.
@@ -17,6 +19,7 @@
 
 #include "drv_dsl_cpe_api.h"
 #include "drv_dsl_cpe_autoboot.h"
+#include "drv_dsl_cpe_configuration.h"
 
 #include "drv_dsl_cpe_fifo.h"
 
@@ -187,6 +190,28 @@ typedef struct
 } DSL_ShowtimeMeasurement_t;
 
 /**
+   Stores version information of: FW, HW Chip, HybridType and FeatureMap
+   to avoid unnecessary messages ("FeatureMapGet", "VersionInfoGet", ...) passing.
+   Data update is per FW download.
+ */
+typedef struct
+{
+   DSL_boolean_t bFWVerNumSet;
+   DSL_boolean_t bChipHWVerNumSet;
+   DSL_boolean_t bHybridTypeSet;
+   DSL_boolean_t bFeatureMapSet;
+
+   DSL_uint32_t nFWVerNum;
+   DSL_uint32_t nChipHWVerNum;
+   DSL_HybridType_t nHybridType;
+   union
+   {
+      ACK_ADSL_FeatureMapGet_t AFM;
+      ACK_VDSL_FeatureMapGet_t VFM;
+   } sFeatureMap;
+} DSL_InternalVersionInformation_t;
+
+/**
    The driver context contains global information.
 */
 struct DSL_Context
@@ -246,6 +271,7 @@ struct DSL_Context
 #if defined(DSL_VRX_DEVICE_VR11)
    /** External trigger to power down DSL */
    DSL_boolean_t bPowerDown;
+   DSL_boolean_t bPowerDownInaccessibleFW;
 #endif
    /** Autoboot queue */
    DSL_DRV_Event_t autobootEvent;
@@ -391,6 +417,7 @@ struct DSL_Context
    DSL_uint16_t ActualImpulseNoiseProtection[DSL_ACCESSDIR_LAST][DSL_MAX_SUPPORTED_CHANNELS_PER_LINE];
    DSL_uint16_t ActualImpulseNoiseProtectionRein[DSL_ACCESSDIR_LAST][DSL_MAX_SUPPORTED_CHANNELS_PER_LINE];
    DSL_uint16_t ActualImpulseNoiseProtectionNoErasure[DSL_ACCESSDIR_LAST][DSL_MAX_SUPPORTED_CHANNELS_PER_LINE];
+   DSL_uint16_t ActualImpulseNoiseProtectionRoc[DSL_ACCESSDIR_LAST][DSL_MAX_SUPPORTED_CHANNELS_PER_LINE];
 
    /** Actual Data Rate per direction, per channel */
    DSL_uint32_t nChannelActualDataRate[DSL_ACCESSDIR_LAST][DSL_MAX_SUPPORTED_CHANNELS_PER_LINE];
@@ -546,8 +573,11 @@ struct DSL_Context
 
    DSL_boolean_t  bFwEventActivation;
    DSL_boolean_t  bFwEventRcvd;
+   DSL_boolean_t  bFeaturesEnabled;
    DSL_Error_t    nFwEventLastReadErr;
    DSL_LineStateValue_t nFwEventLineState;
+
+   DSL_InternalVersionInformation_t VersionInformation;
 };
 
 #define DSL_EVENT2MASK(evt) ((DSL_uint32_t)(0x1 << ((DSL_uint32_t)evt)))
@@ -923,6 +953,17 @@ DSL_Error_t DSL_DRV_Init(
 );
 #endif
 
+/**
+   For a detailed description please refer to the equivalent ioctl
+   \ref DSL_FIO_CONFIGURATION_RELOAD
+*/
+#ifndef SWIG
+DSL_Error_t DSL_DRV_ValidateAndApplyConfig(
+   DSL_IN DSL_Context_t *pContext,
+   DSL_IN_OUT DSL_Configuration_t *pData
+);
+#endif
+
 #ifndef SWIG
 DSL_Error_t DSL_DRV_ModulesInit(
    DSL_IN DSL_Context_t *pContext);
--- a/src/include/drv_dsl_cpe_os_linux.h
+++ b/src/include/drv_dsl_cpe_os_linux.h
@@ -1,7 +1,10 @@
 /******************************************************************************
 
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2018 Intel Corporation
+         Copyright 2016 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
 
   For licensing information, see the file 'LICENSE' in the root folder of
   this software module.
@@ -58,6 +61,7 @@
 #else
 #include <linux/smp.h>
 #endif
+#include <linux/reboot.h>     /* emergency_restart */
 
 #ifdef INCLUDE_DSL_CPE_API_IFXOS_SUPPORT
 /** IFXOS includes*/
@@ -287,6 +291,8 @@ static inline int dsl_mutex_lock(struct
    #define DSL_DRV_OS_ModUseCountDecrement() while(0) {}
 #endif
 
+#define DSL_DRV_EMERGENCY_RESTART            emergency_restart()
+
 #ifndef INCLUDE_DSL_CPE_API_IFXOS_SUPPORT
 typedef int (*DSL_DRV_KERNEL_THREAD_StartRoutine)(void *);
 
--- a/src/include/drv_dsl_cpe_os_rtems.h
+++ b/src/include/drv_dsl_cpe_os_rtems.h
@@ -1,7 +1,7 @@
 /******************************************************************************
 
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright (c) 2018 Intel Corporation
+         Copyright (c) 2007-2015 Lantiq Beteiligungs-GmbH & Co. KG
 
   For licensing information, see the file 'LICENSE' in the root folder of
   this software module.
@@ -101,6 +101,8 @@ DSL_uint32_t DSL_DRV_SysTimeGet(DSL_uint
 
 #define DSL_Le2Cpu(le) le16_to_cpu(le)
 
+#define DSL_DRV_EMERGENCY_RESTART
+
 /*weirong not needed
 #define DSL_VMalloc DSL_DRV_VMalloc
 #define DSL_VFree DSL_DRV_VFree
--- a/src/include/drv_dsl_cpe_os_vxworks.h
+++ b/src/include/drv_dsl_cpe_os_vxworks.h
@@ -1,7 +1,7 @@
 /******************************************************************************
 
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright (c) 2018 Intel Corporation
+         Copyright (c) 2007-2015 Lantiq Beteiligungs-GmbH & Co. KG
 
   For licensing information, see the file 'LICENSE' in the root folder of
   this software module.
@@ -92,6 +92,7 @@ DSL_uint32_t DSL_DRV_SysTimeGet(DSL_uint
 #define DSL_DRV_OS_ModUseCountIncrement()
 #define DSL_DRV_OS_ModUseCountDecrement()
 
+#define DSL_DRV_EMERGENCY_RESTART
 
 #ifdef __cplusplus
 }
--- a/src/include/drv_dsl_cpe_os_win32.h
+++ /dev/null
@@ -1,140 +0,0 @@
-/******************************************************************************
-
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
-
-  For licensing information, see the file 'LICENSE' in the root folder of
-  this software module.
-
-******************************************************************************/
-
-#ifndef _DRV_DSL_CPE_OS_WIN32_H
-#define _DRV_DSL_CPE_OS_WIN32_H
-
-#ifdef __cplusplus
-   extern "C" {
-#endif
-
-#include "drv_dsl_cpe_api.h"
-
-/** IFXOS includes*/
-#include "ifxos_common.h"
-#include "ifxos_copy_user_space.h"
-#include "ifxos_debug.h"
-#include "ifxos_event.h"
-#include "ifxos_thread.h"
-#include "ifxos_memory_alloc.h"
-#include "ifxos_memory_map.h"
-#include "ifxos_lock.h"
-#include "ifxos_time.h"
-#include "ifxos_select.h"
-#include "ifxos_mutex.h"
-#include "ifxos_device_io.h"
-
-#include "errno.h"
-
-#ifndef DSL_DRV_STACKSIZE
-#define DSL_DRV_STACKSIZE 2048
-#endif
-
-#ifndef DSL_DRV_PRIORITY
-#define DSL_DRV_PRIORITY  64
-#endif
-
-#define DSL_BYTE_ORDER           IFXOS_BYTE_ORDER
-#define DSL_LITTLE_ENDIAN        IFXOS_LITTLE_ENDIAN
-#define DSL_BIG_ENDIAN           IFXOS_BIG_ENDIAN
-
-typedef IFX_int_t                DSL_DRV_size_t;
-typedef IFX_uint32_t             DSL_DRV_TimeVal_t;
-typedef IFXOS_lock_t             DSL_DRV_Mutex_t;
-typedef IFXOS_event_t            DSL_DRV_Event_t;
-typedef IFXOS_drvSelectQueue_t   DSL_DRV_WaitQueue_t;
-
-#define  IOCPARM_MASK   0x7f     /* parameters must be < 128 bytes */
-#define  IOC_VOID       0x20000000  /* no parameters */
-#define  IOC_OUT         0x40000000 /* copy out parameters */
-#define  IOC_IN          0x80000000 /* copy in parameters */
-#define  IOC_INOUT      (IOC_IN|IOC_OUT)
-
-#ifndef _IO
-#define  _IO(x,y)    (IOC_VOID|((x)<<8)|y)
-#endif /* _IO*/
-#ifndef _IOR
-#define  _IOR(x,y,t)    (IOC_OUT|((sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|y)
-#endif /* _IOR*/
-#ifndef _IOW
-#define  _IOW(x,y,t)    (IOC_IN|((sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|y)
-#endif /* _IOW*/
-#ifndef _IOWR
-#define  _IOWR(x,y,t)   (IOC_INOUT|((sizeof(t)&IOCPARM_MASK)<<16)|((x)<<8)|y)
-#endif /* _IOWR*/
-
-#define _IOC_TYPE(x)                      (((x)>>8) & 0xFF)
-
-/* HAS TO BE CLARIFIED*/
-#define DSL_Le2Cpu(x)   (x)
-
-#define DSL_DRV_SIGNAL_PENDING               0
-
-/** IFXOS specific mapping for the system calls*/
-#define DSL_DRV_Malloc(nSize)                IFXOS_MemAlloc(nSize)
-#define DSL_DRV_MemFree(pPtr)                IFXOS_MemFree(pPtr)
-#define DSL_DRV_PMalloc(nSize)               IFXOS_BlockAlloc(nSize)
-#define DSL_DRV_PFree(pPtr)                  IFXOS_BlockFree(pPtr)
-#define DSL_DRV_MUTEX_INIT(id)               IFXOS_LockInit(&(id))
-#define DSL_DRV_MUTEX_LOCK(id)               IFXOS_LockGet(&(id))
-#define DSL_DRV_MUTEX_UNLOCK(id)             IFXOS_LockRelease(&(id))
-#define DSL_DRV_INIT_WAKELIST(name,queue)    IFXOS_DrvSelectQueueInit(&(queue))
-#define DSL_DRV_WAKEUP_WAKELIST(queue)       IFXOS_DrvSelectQueueWakeUp(&(queue), IFXOS_DRV_SEL_WAKEUP_TYPE_RD)
-#define DSL_DRV_ADD_TASK_WAKELIST            IFXOS_DrvSelectQueueAddTask
-
-#define DSL_DRV_INIT_EVENT(name,ev)          IFXOS_EventInit(&(ev));
-#define DSL_DRV_WAIT_EVENT_TIMEOUT(ev,t)     IFXOS_EventWait(&(ev), (t), IFX_NULL)
-#define DSL_DRV_WAIT_EVENT(ev)               IFXOS_EventWait(&(ev), 0xFFFFFFFF, IFX_NULL)
-#define DSL_DRV_WAKEUP_EVENT(ev)             IFXOS_EventWakeUp(&(ev));
-#define DSL_DRV_ElapsedTimeMSecGet(t)        IFXOS_ElapsedTimeMSecGet(t)
-#define DSL_DRV_TimeMSecGet()                IFXOS_ElapsedTimeMSecGet(0)
-#define DSL_WAIT(ms)                         IFXOS_MSecSleep(ms)
-#define DSL_DRV_MSecSleep(msec)              IFXOS_MSecSleep(msec)
-
-#define DSL_IsTimeNull(t)                    ((t) == 0)
-#define DSL_DRV_TimeSecGet(t)                (t)
-
-#define DSL_DRV_OS_ModUseCountIncrement()
-#define DSL_DRV_OS_ModUseCountDecrement()
-
-#define DSL_DRV_Phy2VirtMap                  IFXOS_Phy2VirtMap
-#define DSL_DRV_Phy2VirtUnmap                IFXOS_Phy2VirtUnmap
-
-/** IFXOS specific mapping*/
-typedef IFXOS_ThreadParams_t     DSL_DRV_ThreadParams_t;
-typedef IFXOS_ThreadFunction_t   DSL_DRV_ThreadFunc_t;
-typedef IFXOS_ThreadCtrl_t       DSL_DRV_ThreadCtrl_t;
-
-#define DSL_DRV_THREAD(a, b, c, d)        IFXOS_ThreadInit((a), (b), (c), DSL_DRV_STACKSIZE, DSL_DRV_PRIORITY, (d), 0)
-#define DSL_DRV_WAIT_COMPLETION(a)        IFXOS_ThreadShutdown((a), 3000)
-#define DSL_DRV_THREAD_DELETE(a, b)       ((void)0)
-
-#define DSL_DRV_CRLF "\n"
-
-/*
-   System Time Get
-*/
-DSL_uint32_t DSL_DRV_SysTimeGet(DSL_uint32_t nOffset);
-
-/*
-   DSL CPE API driver Device Create
-*/
-DSL_int_t DSL_DRV_SIM_DeviceCreate(DSL_void_t);
-
-/*
-   DSL CPE API driver Device Delete
-*/
-DSL_void_t DSL_DRV_SIM_DeviceDelete(DSL_void_t);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
--- a/src/include/drv_dsl_cpe_procfs_linux.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/******************************************************************************
-
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
-
-  For licensing information, see the file 'LICENSE' in the root folder of
-  this software module.
-
-******************************************************************************/
-
-#ifndef _DRV_DSL_CPE_PROCFS_LINUX_H
-#define _DRV_DSL_CPE_PROCFS_LINUX_H
-
-#ifdef DSL_INTERN
-
-#include "drv_dsl_cpe_api.h"
-
-#ifndef _lint
-#include "drv_dsl_cpe_os_linux.h"
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-#else
-#include "drv_dsl_cpe_os_lint_map.h"
-#endif /* #ifndef _lint*/
-
-#ifdef __cplusplus
-   extern "C" {
-#endif
-
-#ifdef INCLUDE_DSL_CPE_PROCFILES
-
-#define DSL_DRV_PROC_ENTRY_ADD(name, pFshow, pFget, bDevSpecific) \
-   {name, pFshow, pFget, bDevSpecific, {{0}}}
-
-typedef enum
-{
-   /* Format as hey values */
-   DSL_ARRAY_FORMAT_HEX,
-   /* Format as string */
-    DSL_ARRAY_FORMAT_STRING
-} DSL_DRV_ArrayPrintFormat_t;
-
-typedef DSL_int_t (*DSL_DRV_PROC_EntryShow_t)(struct seq_file*);
-typedef DSL_void_t * (*DSL_DRV_PROC_EntryDataGet_t)(struct seq_file*);
-
-typedef struct proc_dir_entry DSL_DRV_PROC_DirEntry_t;
-
-typedef struct
-{
-   /**
-   Iteration number*/
-   DSL_uint32_t v;
-   /**
-   Sequence end flag*/
-   DSL_boolean_t bEnd;
-   /**
-   Private entry data*/
-   DSL_void_t *pPrivateData;
-   /**
-   Printout data pointer*/
-   DSL_void_t *pPrintData;
-} DSL_DRV_PROC_SecFilePrivateData_t;
-
-typedef struct
-{
-   /**
-   device number*/
-   DSL_int_t devNum;
-   /**
-   proc entry SHOW handler*/
-   DSL_DRV_PROC_EntryShow_t    pProcShow;
-   /**
-   proc entry DATA handler*/
-   DSL_DRV_PROC_EntryDataGet_t pProcDataGet;
-   DSL_DRV_PROC_SecFilePrivateData_t SecPrivateData;
-} DSL_DRV_PROC_EntryData_t;
-
-typedef struct
-{
-   /**
-   proc entry string identifier*/
-   const DSL_char_t * const string;
-   /**
-   proc entry handler*/
-   DSL_DRV_PROC_EntryShow_t    const pProcShow;
-   DSL_DRV_PROC_EntryDataGet_t const pProcDataGet;
-   /**
-   is entry device specific*/
-   const DSL_boolean_t bDevSpecific;
-   /**
-   device proc entry data, data which is passed to the "read_proc" system call*/
-   DSL_DRV_PROC_EntryData_t entryData[DSL_DRV_MAX_ENTITIES];
-} DSL_DRV_PROC_EntryTable_t;
-
-extern DSL_DRV_PROC_EntryTable_t procEntryTable[];
-
-#ifndef SWIG
-DSL_int_t DSL_DRV_InstallProcEntry(DSL_void_t);
-#endif /* SWIG */
-
-#ifndef SWIG
-DSL_int_t DSL_DRV_RemoveProcEntry(DSL_void_t);
-#endif /* SWIG */
-
-#endif /* #ifdef INCLUDE_DSL_CPE_PROCFILES*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* DSL_INTERN*/
-
-#endif /* _DRV_DSL_CPE_PROCFS_LINUX_H*/
--- a/src/include/mcat3.1/drv_dsl_cpe_vrx_msg_config_pmd.h
+++ /dev/null
@@ -1,3856 +0,0 @@
-/******************************************************************************
-
-                            Copyright (c) 2007-2017
-                       Lantiq Beteiligungs-GmbH & Co. KG
-
-  For licensing information, see the file 'LICENSE' in the root folder of
-  this software module.
-
-******************************************************************************/
-
-
-#ifndef _DRV_DSL_CPE_VRX_MSG_CONFIG_PMD_H_
-#define _DRV_DSL_CPE_VRX_MSG_CONFIG_PMD_H_
-
-/** \file
-
-*/
-
-#ifndef __PACKED__
-   #if defined (__GNUC__) || defined (__GNUG__)
-      /* GNU C or C++ compiler */
-      #define __PACKED__ __attribute__ ((packed))
-   #else
-      /* Byte alignment adjustment */
-      #pragma pack(1)
-      #define __PACKED__      /* nothing */
-   #endif
-   #define __PACKED_DEFINED__ 1
-#endif
-
-
-/** @defgroup _CONFIG_PMD_
- *  @{
- */
-
-#ifdef __cplusplus
-   extern "C" {
-#endif
-
-/* ----- Message Specific Constants Definition section ----- */
-#define ACK_ModemFSM_StateGet_RESET_STATE 0
-#define ACK_ModemFSM_StateGet_READY_STATE 1
-#define ACK_ModemFSM_StateGet_FAIL_STATE 2
-#define ACK_ModemFSM_StateGet_DIAG_COMPLETE_STATE 3
-#define ACK_ModemFSM_StateGet_GHS_STATE 5
-#define ACK_ModemFSM_StateGet_FULLINIT_STATE 6
-#define ACK_ModemFSM_StateGet_STEADY_STATE_TC_NOSYNC 7
-#define ACK_ModemFSM_StateGet_STEADY_STATE_TC_SYNC 8
-#define ACK_ModemFSM_StateGet_DIAGMODE_STATE 9
-#define ACK_ModemFSM_StateGet_T1413_STATE 14
-#define ACK_ModemFSM_StateGet_PRE_FAIL_STATE 15
-#define ACK_ModemFSM_StateGet_GHS_BONDING_CLR_STATE 16
-#define ACK_ModemFSM_StateGet_MFD_STATE 18
-#define ACK_ModemFSM_StateGet_MFD_COMPLETE_STATE 19
-#define ACK_ModemFSM_StateGet_DSL_POWER_DOWN_STATE 20
-#define ACK_ModemFSM_StateGet_TEST_STATE 240
-#define ACK_ModemFSM_StateGet_L0 0
-#define ACK_ModemFSM_StateGet_L2 2
-#define ACK_ModemFSM_StateGet_L3 3
-#define EVT_ModemFSM_StateGet_RESET_STATE 0
-#define EVT_ModemFSM_StateGet_READY_STATE 1
-#define EVT_ModemFSM_StateGet_FAIL_STATE 2
-#define EVT_ModemFSM_StateGet_DIAG_COMPLETE_STATE 3
-#define EVT_ModemFSM_StateGet_GHS_STATE 5
-#define EVT_ModemFSM_StateGet_FULLINIT_STATE 6
-#define EVT_ModemFSM_StateGet_STEADY_STATE_TC_NOSYNC 7
-#define EVT_ModemFSM_StateGet_STEADY_STATE_TC_SYNC 8
-#define EVT_ModemFSM_StateGet_DIAGMODE_STATE 9
-#define EVT_ModemFSM_StateGet_T1413_STATE 14
-#define EVT_ModemFSM_StateGet_PRE_FAIL_STATE 15
-#define EVT_ModemFSM_StateGet_GHS_BONDING_CLR_STATE 16
-#define EVT_ModemFSM_StateGet_MFD_STATE 18
-#define EVT_ModemFSM_StateGet_MFD_COMPLETE_STATE 19
-#define EVT_ModemFSM_StateGet_DSL_POWER_DOWN_STATE 20
-#define EVT_ModemFSM_StateGet_TEST_STATE 240
-#define EVT_ModemFSM_StateGet_L0 0
-#define EVT_ModemFSM_StateGet_L2 2
-#define EVT_ModemFSM_StateGet_L3 3
-#define EVT_ModemReady_MRERR_OK 0x0
-#define EVT_ModemReady_MRWARN_OK 0x0
-#define CMD_ModemFSM_StateSet_LINKINI 2
-#define CMD_ModemFSM_StateSet_TERMINATE 4
-#define CMD_ModemFSM_StateSet_POWERDOWN 7
-#define CMD_ModemFSM_StateSet_TESTSTA 8
-#define CMD_ModemFSM_StateSet_MFD 9
-#define ALM_ModemFSM_FailReasonGet_S_OK 0x0
-#define ALM_ModemFSM_FailReasonGet_S_CODESWAP 0x1
-#define ALM_ModemFSM_FailReasonGet_S_MINRATE_DS 0x4
-#define ALM_ModemFSM_FailReasonGet_S_INIT 0x5
-#define ALM_ModemFSM_FailReasonGet_S_MODE 0x6
-#define ALM_ModemFSM_FailReasonGet_S_TIMEOUT 0x9
-#define ALM_ModemFSM_FailReasonGet_S_XDSL_MODE 0xA
-#define ALM_ModemFSM_FailReasonGet_S_PORT_MODE 0xB
-#define ALM_ModemFSM_FailReasonGet_S_T1413_MODE 0xC
-#define ALM_ModemFSM_FailReasonGet_S_GFAST_MODE 0xD
-#define ALM_ModemFSM_FailReasonGet_S_FW_RETRY 0xE
-#define ALM_ModemFSM_FailReasonGet_S_FW_HYBRID 0xF
-#define ALM_ModemFSM_FailReasonGet_S_LOS 0x10
-#define ALM_ModemFSM_FailReasonGet_S_LOF 0x11
-#define ALM_ModemFSM_FailReasonGet_S_LPR 0x12
-#define ALM_ModemFSM_FailReasonGet_S_LOM 0x13
-#define ALM_ModemFSM_FailReasonGet_S_FAST_LOS 0x14
-#define ALM_ModemFSM_FailReasonGet_S_ESE 0x15
-#define ALM_ModemFSM_FailReasonGet_S_SESX 0x16
-#define ALM_ModemFSM_FailReasonGet_S_ESX 0x17
-#define ALM_ModemFSM_FailReasonGet_S_OOS0 0x18
-#define ALM_ModemFSM_FailReasonGet_S_LCD0 0x20
-#define ALM_ModemFSM_FailReasonGet_S_NCD0 0x22
-#define ALM_ModemFSM_FailReasonGet_S_CRC_DS 0x24
-#define ALM_ModemFSM_FailReasonGet_S_PP_DRIVER 0x25
-#define ALM_ModemFSM_FailReasonGet_S_INTENDED_LOCAL_SHUTDOWN 0x26
-#define ALM_ModemFSM_FailReasonGet_S_HW 0x27
-#define ALM_ModemFSM_FailReasonGet_S_CALIBRATION 0x28
-#define ALM_ModemFSM_FailReasonGet_S_PP_CLOCK_NEW 0x29
-#define ALM_ModemFSM_FailReasonGet_S_PP_ERB_INIT 0x2A
-#define ALM_ModemFSM_FailReasonGet_E_OK 0x0
-#define ALM_ModemFSM_FailReasonGet_E_CONFIG 0x1
-#define ALM_ModemFSM_FailReasonGet_E_NOTFEASIBLE 0x2
-#define ALM_ModemFSM_FailReasonGet_E_COMM 0x3
-#define ALM_ModemFSM_FailReasonGet_E_COMMCRC 0x4
-#define ALM_ModemFSM_FailReasonGet_E_NOPEER 0x5
-#define ALM_ModemFSM_FailReasonGet_E_CHIPSET 0x6
-#define ALM_ModemFSM_FailReasonGet_E_UNKNOWN 0x7
-#define ALM_ModemFSM_FailReasonGet_E_RESERVED 0x8
-#define ALM_ModemFSM_FailReasonGet_E_SHOWTIME_NE 0x10
-#define ALM_ModemFSM_FailReasonGet_E_SHOWTIME_FE 0x11
-#define ACK_ModemFSM_FailReasonGet_S_OK 0x0
-#define ACK_ModemFSM_FailReasonGet_S_CODESWAP 0x1
-#define ACK_ModemFSM_FailReasonGet_S_MINRATE_DS 0x4
-#define ACK_ModemFSM_FailReasonGet_S_INIT 0x5
-#define ACK_ModemFSM_FailReasonGet_S_MODE 0x6
-#define ACK_ModemFSM_FailReasonGet_S_TIMEOUT 0x9
-#define ACK_ModemFSM_FailReasonGet_S_XDSL_MODE 0xA
-#define ACK_ModemFSM_FailReasonGet_S_PORT_MODE 0xB
-#define ACK_ModemFSM_FailReasonGet_S_T1413_MODE 0xC
-#define ACK_ModemFSM_FailReasonGet_S_GFAST_MODE 0xD
-#define ACK_ModemFSM_FailReasonGet_S_FW_RETRY 0xE
-#define ACK_ModemFSM_FailReasonGet_S_FW_HYBRID 0xF
-#define ACK_ModemFSM_FailReasonGet_S_LOS 0x10
-#define ACK_ModemFSM_FailReasonGet_S_LOF 0x11
-#define ACK_ModemFSM_FailReasonGet_S_LPR 0x12
-#define ACK_ModemFSM_FailReasonGet_S_LOM 0x13
-#define ACK_ModemFSM_FailReasonGet_S_FAST_LOS 0x14
-#define ACK_ModemFSM_FailReasonGet_S_ESE 0x15
-#define ACK_ModemFSM_FailReasonGet_S_SESX 0x16
-#define ACK_ModemFSM_FailReasonGet_S_ESX 0x17
-#define ACK_ModemFSM_FailReasonGet_S_OOS0 0x18
-#define ACK_ModemFSM_FailReasonGet_S_LCD0 0x20
-#define ACK_ModemFSM_FailReasonGet_S_NCD0 0x22
-#define ACK_ModemFSM_FailReasonGet_S_CRC_DS 0x24
-#define ACK_ModemFSM_FailReasonGet_S_PP_DRIVER 0x25
-#define ACK_ModemFSM_FailReasonGet_S_INTENDED_LOCAL_SHUTDOWN 0x26
-#define ACK_ModemFSM_FailReasonGet_S_HW 0x27
-#define ACK_ModemFSM_FailReasonGet_S_CALIBRATION 0x28
-#define ACK_ModemFSM_FailReasonGet_S_PP_CLOCK_NEW 0x29
-#define ACK_ModemFSM_FailReasonGet_S_PP_ERB_INIT 0x2A
-#define ACK_ModemFSM_FailReasonGet_E_OK 0x0
-#define ACK_ModemFSM_FailReasonGet_E_CONFIG 0x1
-#define ACK_ModemFSM_FailReasonGet_E_NOTFEASIBLE 0x2
-#define ACK_ModemFSM_FailReasonGet_E_COMM 0x3
-#define ACK_ModemFSM_FailReasonGet_E_COMMCRC 0x4
-#define ACK_ModemFSM_FailReasonGet_E_NOPEER 0x5
-#define ACK_ModemFSM_FailReasonGet_E_CHIPSET 0x6
-#define ACK_ModemFSM_FailReasonGet_E_UNKNOWN 0x7
-#define ACK_ModemFSM_FailReasonGet_E_RESERVED 0x8
-#define ACK_ModemFSM_FailReasonGet_E_SHOWTIME_NE 0x10
-#define ACK_ModemFSM_FailReasonGet_E_SHOWTIME_FE 0x11
-#define ACK_TxL3RequestStatusGet_L3PENDING 0
-#define ACK_TxL3RequestStatusGet_L3REJECTED 1
-#define ACK_TxL3RequestStatusGet_L3ACCEPTED 2
-#define ACK_TxL3RequestStatusGet_L3FAIL 3
-#define ACK_TxL3ReqFailReasonGet_BUSY 0x01
-#define ACK_TxL3ReqFailReasonGet_INVALID 0x02
-#define ACK_TxL3ReqFailReasonGet_STATE_NOT_DESIRED 0x03
-#define ACK_TxL3ReqFailReasonGet_NOT_L0 0x50
-#define ACK_TxL3ReqFailReasonGet_TIMEOUT 0x90
-#define CMD_ModemFSM_Freeze_FREEZE_OFF 0
-#define CMD_ModemFSM_Freeze_PERIODIC 1
-#define CMD_ModemFSM_Freeze_RP_CHDISC2 2
-#define CMD_ModemFSM_Freeze_MEDLEY 4
-#define CMD_ModemFSM_Freeze_SHOWTIME 8
-#define CMD_ModemFSM_Freeze_SHOWTIME_GI1 16
-#define ACK_FW_ImageInfoGet_STANDALONE 0x0
-#define ACK_FW_ImageInfoGet_COMBINED 0x1
-#define ACK_FW_ImageInfoGet_VDSL_FW 0x0
-#define ACK_FW_ImageInfoGet_ADSL_FW 0x1
-#define ACK_FW_ImageInfoGet_CPE_FW 0x1
-#define CMD_APS_Status_Set_1PORT 1
-#define CMD_APS_Status_Set_2PORT 2
-#define CMD_APS_Status_Set_APIDEF 0
-#define CMD_APS_Status_Set_ADSL 1
-#define CMD_APS_Status_Set_VDSL 2
-#define CMD_APS_Status_Set_FAST 3
-#define CMD_APS_Status_Set_AUTO 0
-#define CMD_APS_Status_Set_STANDARD 1
-#define CMD_APS_Status_Set_NONSTANDARD 2
-#define CMD_APS_Status_Set_GHSMODE 1
-#define CMD_APS_Status_Set_T1413MODE 2
-#define CMD_BearerCh0_DS_Set_FV 21
-#define CMD_BearerCh0_DS_Set_MAX_BER3 0
-#define CMD_BearerCh0_DS_Set_MAX_BER5 1
-#define CMD_BearerCh0_DS_Set_MAX_BER7 2
-#define ACK_BearerCh0_DS_Set_FV 21
-#define CMD_BearerCh0_US_Set_FV 21
-#define CMD_BearerCh0_US_Set_MAX_BER3 0
-#define CMD_BearerCh0_US_Set_MAX_BER5 1
-#define CMD_BearerCh0_US_Set_MAX_BER7 2
-#define ACK_BearerCh0_US_Set_FV 21
-#define CMD_InitPolicySet_MAX_NETRATE 0x0
-#define CMD_InitPolicySet_MAX_INP 0x1
-#define CMD_ErasureControlSet_MAX_NETRATE 0x0
-#define CMD_ErasureControlSet_MAX_INP 0x1
-#define CMD_Misc_ConfigSet_GHSMODE 0x0
-#define CMD_Misc_ConfigSet_T1413MODE 0x1
-#define CMD_OperatorSelect_TELCO_OFF 0
-#define CMD_OperatorSelect_TELCO_DTAG 1
-#define CMD_OperatorSelect_TELCO_BT 2
-#define CMD_OperatorSelect_TELCO_TS 3
-#define CMD_OperatorSelect_TELCO_FT 4
-#define CMD_OperatorSelect_TELCO_KPN 5
-#define CMD_OperatorSelect_TELCO_TELIA 6
-#define CMD_OperatorSelect_TELCO_FIBERHOME 7
-#define CMD_OperatorSelect_TELCO_CT 8
-#define CMD_OperatorSelect_TELCO_TW 9
-#define CMD_OperatorSelect_TELCO_VODAFONE 10
-#define CMD_OperatorSelect_TELCO_CN 11
-#define CMD_OperatorSelect_TELCO_OTE 12
-#define CMD_OperatorSelect_TELCO_TELMEX 13
-#define CMD_OperatorSelect_TELCO_ATT 14
-#define CMD_OperatorSelect_TELCO_SWISSCOM 15
-#define CMD_OperatorSelect_TELCO_NETGEAR 16
-#define CMD_OperatorSelect_TELCO_CTL 17
-#define CMD_OperatorSelect_TELCO_TI 17
-#define ACK_OperatorSelectionGet_TELCO_OFF 0
-#define ACK_OperatorSelectionGet_TELCO_DTAG 1
-#define ACK_OperatorSelectionGet_TELCO_BT 2
-#define ACK_OperatorSelectionGet_TELCO_TS 3
-#define ACK_OperatorSelectionGet_TELCO_FT 4
-#define ACK_OperatorSelectionGet_TELCO_KPN 5
-#define ACK_OperatorSelectionGet_TELCO_TELIA 6
-#define ACK_OperatorSelectionGet_TELCO_FIBERHOME 7
-#define ACK_OperatorSelectionGet_TELCO_CT 8
-#define ACK_OperatorSelectionGet_TELCO_TW 9
-#define ACK_OperatorSelectionGet_TELCO_VODAFONE 10
-#define ACK_OperatorSelectionGet_TELCO_CN 11
-#define ACK_OperatorSelectionGet_TELCO_OTE 12
-#define ACK_OperatorSelectionGet_TELCO_TELMEX 13
-#define ACK_OperatorSelectionGet_TELCO_ATT 14
-#define ACK_OperatorSelectionGet_TELCO_SWISSCOM 15
-#define ACK_OperatorSelectionGet_TELCO_NETGEAR 16
-#define ACK_OperatorSelectionGet_TELCO_CTL 17
-#define CMD_ClockSet_M1 1
-#define CMD_ClockSet_M2 2
-#define CMD_ClockSet_M3 3
-#define CMD_ClockSet_M4 4
-#define CMD_PPE_ClockConfigure_FSCALE_AUTO_OFF 0
-#define CMD_PPE_ClockConfigure_FSCALE_AUTO_A 1
-#define CMD_PPE_ClockConfigure_FSCALE_AUTO_B 2
-#define CMD_PPE_ClockConfigure_FSCALE_AUTO_C 3
-#define ACK_PPE_ClockGet_M1 1
-#define ACK_PPE_ClockGet_M2 2
-#define ACK_PPE_ClockGet_M3 3
-#define ACK_PPE_ClockGet_M4 4
-#define ACK_PPE_ClockConfigGet_FSCALE_AUTO_OFF 0
-#define ACK_PPE_ClockConfigGet_FSCALE_AUTO_A 1
-#define ACK_PPE_ClockConfigGet_FSCALE_AUTO_B 2
-#define ACK_PPE_ClockConfigGet_FSCALE_AUTO_C 3
-/* ----- Message Specific Constants Definition section (End) ----- */
-
-/** Message ID for CMD_ModemFSM_StateGet */
-#define CMD_MODEMFSM_STATEGET 0x0002
-
-/**
-   Requests information about the current state of the modem state-machine.The
-   command can be sent in all states of the modem state machine (see Figure 2).
-*/
-typedef struct CMD_ModemFSM_StateGet CMD_ModemFSM_StateGet_t;
-
-/** Message ID for ACK_ModemFSM_StateGet */
-#define ACK_MODEMFSM_STATEGET 0x0002
-
-/**
-   Returns information about the current state of the modem state-machine.
-*/
-typedef struct ACK_ModemFSM_StateGet ACK_ModemFSM_StateGet_t;
-
-/** Message ID for EVT_ModemFSM_StateGet */
-#define EVT_MODEMFSM_STATEGET 0x0002
-
-/**
-   Returns information about the current state of the modem state-machine. This
-   message is sent autonomously, if the modem enters a new state and reporting
-   is enabled for that state (see CMD_ModemFSM_EventConfigure).
-*/
-typedef struct EVT_ModemFSM_StateGet EVT_ModemFSM_StateGet_t;
-
-/** Message ID for EVT_ModemReady */
-#define EVT_MODEMREADY 0xFF02
-
-/**
-   Autonomous message indicating that the modem online code was reached and that
-   initialization was completed. The management entity may not perform any
-   query-response messaging until the EVT_ModemReady message is received. Its
-   generation cannot be disabled. If it is not received this indicates a
-   problem, possibly with the boot sequence. If the message is received, it
-   contains a result code that may also indicate that an error was detected by
-   the firmware during initialization.
-*/
-typedef struct EVT_ModemReady EVT_ModemReady_t;
-
-/** Message ID for CMD_ModemFSM_StateSet */
-#define CMD_MODEMFSM_STATESET 0x0041
-
-/**
-   Controls state transitions of the modem state-machine.
-*/
-typedef struct CMD_ModemFSM_StateSet CMD_ModemFSM_StateSet_t;
-
-/** Message ID for ACK_ModemFSM_StateSet */
-#define ACK_MODEMFSM_STATESET 0x0041
-
-/**
-   Acknowledgement for message CMD_ModemFSM_StateSet
-*/
-typedef struct ACK_ModemFSM_StateSet ACK_ModemFSM_StateSet_t;
-
-/** Message ID for ALM_ModemFSM_FailReasonGet */
-#define ALM_MODEMFSM_FAILREASONGET 0x0502
-
-/**
-   Reports failure information after entering FAIL state. This message is sent
-   autonomously without host request after entrance into FAIL was indicated by
-   EVT_ModemFSM_StateGet. Both messages are generated only if enabled with
-   CMD_ModemFSM_EventConfigure (common Bit E8 "FAIL").
-*/
-typedef struct ALM_ModemFSM_FailReasonGet ALM_ModemFSM_FailReasonGet_t;
-
-/** Message ID for CMD_ModemFSM_FailReasonGet */
-#define CMD_MODEMFSM_FAILREASONGET 0x0502
-
-/**
-   Requests failure information after entering FAIL state.
-*/
-typedef struct CMD_ModemFSM_FailReasonGet CMD_ModemFSM_FailReasonGet_t;
-
-/** Message ID for ACK_ModemFSM_FailReasonGet */
-#define ACK_MODEMFSM_FAILREASONGET 0x0502
-
-/**
-   Returns failure information after entering FAIL state.
-*/
-typedef struct ACK_ModemFSM_FailReasonGet ACK_ModemFSM_FailReasonGet_t;
-
-/** Message ID for CMD_ModemFSM_OptionsSet */
-#define CMD_MODEMFSM_OPTIONSSET 0x0449
-
-/**
-   Configuration of options for the modem state machine.
-*/
-typedef struct CMD_ModemFSM_OptionsSet CMD_ModemFSM_OptionsSet_t;
-
-/** Message ID for ACK_ModemFSM_OptionsSet */
-#define ACK_MODEMFSM_OPTIONSSET 0x0449
-
-/**
-   Acknowledgement to CMD_ModemFSM_OptionsSet.
-*/
-typedef struct ACK_ModemFSM_OptionsSet ACK_ModemFSM_OptionsSet_t;
-
-/** Message ID for CMD_ModemOptionsSet */
-#define CMD_MODEMOPTIONSSET 0x0062
-
-/**
-   Configuration of options for the modem state machine.
-*/
-typedef struct CMD_ModemOptionsSet CMD_ModemOptionsSet_t;
-
-/** Message ID for ACK_ModemOptionsSet */
-#define ACK_MODEMOPTIONSSET 0x0062
-
-/**
-   Acknowledgement to CMD_ModemOptionsSet.
-*/
-typedef struct ACK_ModemOptionsSet ACK_ModemOptionsSet_t;
-
-/** Message ID for CMD_ModemFSM_EventConfigure */
-#define CMD_MODEMFSM_EVENTCONFIGURE 0x0049
-
-/**
-   Sets options for the modem state-machine. Enables/Disables autonomous
-   messages for specific state transitions (EVT_ModemFSM_StateGet). The EVT
-   message is generated after entering the particular state listed in the
-   parameter description of the enable bits.
-*/
-typedef struct CMD_ModemFSM_EventConfigure CMD_ModemFSM_EventConfigure_t;
-
-/** Message ID for ACK_ModemFSM_EventConfigure */
-#define ACK_MODEMFSM_EVENTCONFIGURE 0x0049
-
-/**
-   Acknowledgement for CMD_ModemFSM_EventConfigure. (Enabling/Disabling EVENT
-   messages (EVTs) for specific state transitions.)
-*/
-typedef struct ACK_ModemFSM_EventConfigure ACK_ModemFSM_EventConfigure_t;
-
-/** Message ID for CMD_FailuresNE_AlarmConfigure */
-#define CMD_FAILURESNE_ALARMCONFIGURE 0x0149
-
-/**
-   Enables/Disables the generation of ALARM messages (ALM) for specific near-end
-   line failures. If the corresponding Enable bit for a line failure is set,
-   then the modem firmware will send an autonomous message ALM_LineFailureNE_Get
-   if this failure occurs.
-*/
-typedef struct CMD_FailuresNE_AlarmConfigure CMD_FailuresNE_AlarmConfigure_t;
-
-/** Message ID for ACK_FailuresNE_AlarmConfigure */
-#define ACK_FAILURESNE_ALARMCONFIGURE 0x0149
-
-/**
-   Acknowledgement to CMD_FailuresNE_AlarmConfigure.
-*/
-typedef struct ACK_FailuresNE_AlarmConfigure ACK_FailuresNE_AlarmConfigure_t;
-
-/** Message ID for CMD_FailuresFE_AlarmConfigure */
-#define CMD_FAILURESFE_ALARMCONFIGURE 0x0249
-
-/**
-   Enables/Disables the generation of ALARM messages (ALM) for specific far-end
-   line failures. If the corresponding Enable bit for a line failure is set,
-   then the modem firmware will send an autonomous message ALM_LineFailureFE_Get
-   if this failure occurs.
-*/
-typedef struct CMD_FailuresFE_AlarmConfigure CMD_FailuresFE_AlarmConfigure_t;
-
-/** Message ID for ACK_FailuresFE_AlarmConfigure */
-#define ACK_FAILURESFE_ALARMCONFIGURE 0x0249
-
-/**
-   Acknowledgement to CMD_FailuresFE_AlarmConfigure.
-*/
-typedef struct ACK_FailuresFE_AlarmConfigure ACK_FailuresFE_AlarmConfigure_t;
-
-/** Message ID for CMD_ReInitNE_Configure */
-#define CMD_REINITNE_CONFIGURE 0x0549
-
-/**
-   Configures re-initialization triggers for near-end failure conditions in
-   modem state STEADY STATE transmission (see Figure 1). This command is
-   accepted in RESET state only.
-*/
-typedef struct CMD_ReInitNE_Configure CMD_ReInitNE_Configure_t;
-
-/** Message ID for ACK_ReInitNE_Configure */
-#define ACK_REINITNE_CONFIGURE 0x0549
-
-/**
-   Acknowledgment to CMD_ReInitNE_Configure (Configuration of re-initialization
-   triggers for near-end failures).
-*/
-typedef struct ACK_ReInitNE_Configure ACK_ReInitNE_Configure_t;
-
-/** Message ID for CMD_ReinitThreshConfigure */
-#define CMD_REINITTHRESHCONFIGURE 0x1E62
-
-/**
-   Configuration of reinitialization trigger definitions.
-*/
-typedef struct CMD_ReinitThreshConfigure CMD_ReinitThreshConfigure_t;
-
-/** Message ID for ACK_ReinitThreshConfigure */
-#define ACK_REINITTHRESHCONFIGURE 0x1E62
-
-/**
-   Acknowledgement for the message ACK_ReinitThreshConfigure.
-*/
-typedef struct ACK_ReinitThreshConfigure ACK_ReinitThreshConfigure_t;
-
-/** Message ID for CMD_ShutdownRequest */
-#define CMD_SHUTDOWNREQUEST 0x0341
-
-/**
-   Triggers a shutdown request, either as "L3 orderly shutdown" towards the
-   remote side or as "locally forced shutdown" to the DSL-FW without sending a
-   request to the remote side.After an "L3 orderly shutdown" request was
-   accepted by the CO, the following shall happen: The CPE-Host forces L3 entry
-   with transition to RESET state by applying CMD_ModemFSM_StateGet.A "locally
-   forced shutdown" always results in exiting Showtime.
-*/
-typedef struct CMD_ShutdownRequest CMD_ShutdownRequest_t;
-
-/** Message ID for ACK_ShutdownRequest */
-#define ACK_SHUTDOWNREQUEST 0x0341
-
-/**
-   Acknowledgement for CMD_ShutdownRequest.
-*/
-typedef struct ACK_ShutdownRequest ACK_ShutdownRequest_t;
-
-/** Message ID for CMD_RxL3RequestStatusGet */
-#define CMD_RXL3REQUESTSTATUSGET 0x0402
-
-/**
-   Requests information about L3 orderly shutdown requests initiated from the
-   remote side.Applying CMD_RxL3RequestStatusGet allows the host to determine
-   whether a near-end LOS or LOM failure is due to an L3 shutdown or an
-   unexpected line failure.
-*/
-typedef struct CMD_RxL3RequestStatusGet CMD_RxL3RequestStatusGet_t;
-
-/** Message ID for ACK_RxL3RequestStatusGet */
-#define ACK_RXL3REQUESTSTATUSGET 0x0402
-
-/**
-   Acknowledgement for CMD_RxL3RequestStatusGet.As long as the modem is in L0
-   (Showtime), an ATU-R will automatically respond to any L3 request from the
-   ATU-C by sending an accept message.  If the ATU-R is in L2 mode when it
-   receives the request, it will send a reject message. Upon receiving an
-   acceptance, the remote side should enter L3 state and shut off its
-   transmitter.
-*/
-typedef struct ACK_RxL3RequestStatusGet ACK_RxL3RequestStatusGet_t;
-
-/** Message ID for CMD_TxL3RequestStatusGet */
-#define CMD_TXL3REQUESTSTATUSGET 0x1402
-
-/**
-   Requests the status of a near-end initiated L3 shutdown request. If the
-   remote side accepted the request, in ADSL the host will force L3 entry using
-   CMD_ModemFSM_StateSet.
-*/
-typedef struct CMD_TxL3RequestStatusGet CMD_TxL3RequestStatusGet_t;
-
-/** Message ID for ACK_TxL3RequestStatusGet */
-#define ACK_TXL3REQUESTSTATUSGET 0x1402
-
-/**
-   Acknowledgement for CMD_TxL3RequestStatusGet.
-*/
-typedef struct ACK_TxL3RequestStatusGet ACK_TxL3RequestStatusGet_t;
-
-/** Message ID for CMD_TxL3ReqFailReasonGet */
-#define CMD_TXL3REQFAILREASONGET 0x1502
-
-/**
-   Requests the fail reason of a failed near-end initiated L3 request. (see also
-   ACK_TxL3RequestStatusGet)
-*/
-typedef struct CMD_TxL3ReqFailReasonGet CMD_TxL3ReqFailReasonGet_t;
-
-/** Message ID for ACK_TxL3ReqFailReasonGet */
-#define ACK_TXL3REQFAILREASONGET 0x1502
-
-/**
-   Reports the fail reason of a near-end initiated L3 request, as response to
-   CMD_TxL3ReqFailReasonGet.
-*/
-typedef struct ACK_TxL3ReqFailReasonGet ACK_TxL3ReqFailReasonGet_t;
-
-/** Message ID for CMD_ModemFSM_Freeze */
-#define CMD_MODEMFSM_FREEZE 0x2C44
-
-/**
-   The message selects and enables one of several points during the
-   initialization process where -after a normal link start had been triggered-
-   the modem FSM "freezes". Freezing means the CO can be disconnected from the
-   line and still the CPE continues transmitting the signal of the current
-   phase. To exit from the freeze a state transition to RESET state has to be
-   triggered. In case of a Showtime Freeze the reinit-triggers do not have any
-   effect.
-*/
-typedef struct CMD_ModemFSM_Freeze CMD_ModemFSM_Freeze_t;
-
-/** Message ID for ACK_ModemFSM_Freeze */
-#define ACK_MODEMFSM_FREEZE 0x2C44
-
-/**
-   Acknowledgement for message CMD_ModemFSM_Freeze.
-*/
-typedef struct ACK_ModemFSM_Freeze ACK_ModemFSM_Freeze_t;
-
-/** Message ID for CMD_FW_ImageInfoGet */
-#define CMD_FW_IMAGEINFOGET 0xD103
-
-/**
-   Requests information about the loaded FW image. This info is used e.g. for
-   swapping between ADSL and VDSL.
-*/
-typedef struct CMD_FW_ImageInfoGet CMD_FW_ImageInfoGet_t;
-
-/** Message ID for ACK_FW_ImageInfoGet */
-#define ACK_FW_IMAGEINFOGET 0xD103
-
-/**
-   Provides the information about the FW image requested by CMD_FW_ImageInfoGet
-*/
-typedef struct ACK_FW_ImageInfoGet ACK_FW_ImageInfoGet_t;
-
-/** Message ID for CMD_APS_Status_Set */
-#define CMD_APS_STATUS_SET 0x2062
-
-/**
-   The message informs the FW about the status of SW parameters relevant for the
-   multimode state machine (APS). This can be used to trace the APS behaviour
-   with FW tools. The message does not influence the APS behaviour.
-*/
-typedef struct CMD_APS_Status_Set CMD_APS_Status_Set_t;
-
-/** Message ID for ACK_APS_Status_Set */
-#define ACK_APS_STATUS_SET 0x2062
-
-/**
-   Acknowledgement for message CMD_APS_Status_Set.
-*/
-typedef struct ACK_APS_Status_Set ACK_APS_Status_Set_t;
-
-/** Message ID for CMD_XTSE_Configure */
-#define CMD_XTSE_CONFIGURE 0x0045
-
-/**
-   Configuration of the VTU Transmission System Enabling (XTSE).Configures the
-   transmission system coding types to be supported on the line (VDSL flavour
-   and annex support).(References: Section 7.3.1.1.1 of G.997.1 and G.994.1 Amd4
-   [10] Tables "Standard information field - SPar(1) coding")
-*/
-typedef struct CMD_XTSE_Configure CMD_XTSE_Configure_t;
-
-/** Message ID for ACK_XTSE_Configure */
-#define ACK_XTSE_CONFIGURE 0x0045
-
-/**
-   Acknowledgement for message CMD_XTSE_Configure.
-*/
-typedef struct ACK_XTSE_Configure ACK_XTSE_Configure_t;
-
-/** Message ID for CMD_BandControl_US_Set */
-#define CMD_BANDCONTROL_US_SET 0x2548
-
-/**
-   Controls the upstream band usage.The message can only be used for DMTscope
-   tests without handshake and training phases.
-*/
-typedef struct CMD_BandControl_US_Set CMD_BandControl_US_Set_t;
-
-/** Message ID for ACK_BandControl_US_Set */
-#define ACK_BANDCONTROL_US_SET 0x2548
-
-/**
-   Acknowledgement for message CMD_BandControl_US_Set.
-*/
-typedef struct ACK_BandControl_US_Set ACK_BandControl_US_Set_t;
-
-/** Message ID for CMD_PSD_Set */
-#define CMD_PSD_SET 0x2348
-
-/**
-   Configuration of PSD and Power parameters. Only used for DMTscope tests
-   without handshake and training phases.
-*/
-typedef struct CMD_PSD_Set CMD_PSD_Set_t;
-
-/** Message ID for ACK_PSD_Set */
-#define ACK_PSD_SET 0x2348
-
-/**
-   Acknowledgement for the message CMD_PSD_Set.
-*/
-typedef struct ACK_PSD_Set ACK_PSD_Set_t;
-
-/** Message ID for CMD_PSD_BreakpointsTxUS_Set */
-#define CMD_PSD_BREAKPOINTSTXUS_SET 0x2848
-
-/**
-   Specifies the maximum upstream transmit PSD by means of breakpoints.To be
-   used only for DMTscope tests without handshake and training phases.
-*/
-typedef struct CMD_PSD_BreakpointsTxUS_Set CMD_PSD_BreakpointsTxUS_Set_t;
-
-/** Message ID for ACK_PSD_BreakpointsTxUS_Set */
-#define ACK_PSD_BREAKPOINTSTXUS_SET 0x2848
-
-/**
-   Acknowledgement for the message CMD_PSD_BreakpointsTxUS_Set.
-*/
-typedef struct ACK_PSD_BreakpointsTxUS_Set ACK_PSD_BreakpointsTxUS_Set_t;
-
-/** Message ID for  CMD_PSD_Calibration_DS_Set */
-#define  CMD_PSD_CALIBRATION_DS_SET 0x5748
-
-/**
-   Sends downstream calibration information for "per-tone" test parameters. It
-   is effective for Loop Diagnostic Mode (DELT) and Showtime. It is the
-   responsibility of the manufacturer to provide the data.
-*/
-typedef struct  CMD_PSD_Calibration_DS_Set CMD_PSD_Calibration_DS_Set_t;
-
-/** Message ID for ACK_PSD_Calibration_DS_Set */
-#define ACK_PSD_CALIBRATION_DS_SET 0x5748
-
-/**
-   Acknowledgement for the message CMD_PSD_Calibration_DS_Set.
-*/
-typedef struct ACK_PSD_Calibration_DS_Set ACK_PSD_Calibration_DS_Set_t;
-
-/** Message ID for  CMD_PSD_Calibration_US_Set */
-#define  CMD_PSD_CALIBRATION_US_SET 0x5848
-
-/**
-   Sends upstream calibration information for the upstream transmit PSD. It is
-   effective for loop diagnostic mode (DELT) and Showtime. It is the
-   responsibility of the manufacturer to provide the data.
-*/
-typedef struct  CMD_PSD_Calibration_US_Set CMD_PSD_Calibration_US_Set_t;
-
-/** Message ID for ACK_PSD_Calibration_US_Set */
-#define ACK_PSD_CALIBRATION_US_SET 0x5848
-
-/**
-   Acknowledgement for the message CMD_PSD_Calibration_US_Set.
-*/
-typedef struct ACK_PSD_Calibration_US_Set ACK_PSD_Calibration_US_Set_t;
-
-/** Message ID for CMD_PSD_OptionsSet */
-#define CMD_PSD_OPTIONSSET 0x0262
-
-/**
-   Configuration of PSD related options.
-*/
-typedef struct CMD_PSD_OptionsSet CMD_PSD_OptionsSet_t;
-
-/** Message ID for ACK_PSD_OptionsSet */
-#define ACK_PSD_OPTIONSSET 0x0262
-
-/**
-   Acknowledgement to CMD_PSD_OptionsSet.
-*/
-typedef struct ACK_PSD_OptionsSet ACK_PSD_OptionsSet_t;
-
-/** Message ID for CMD_UPBO_KL0Get */
-#define CMD_UPBO_KL0GET 0xD603
-
-/**
-   Requests the electrical loop length estimate kl0.
-*/
-typedef struct CMD_UPBO_KL0Get CMD_UPBO_KL0Get_t;
-
-/** Message ID for ACK_UPBO_KL0Get */
-#define ACK_UPBO_KL0GET 0xD603
-
-/**
-   Delivers the data requested by CMD_UPBO_KL0Get.(Section 7.5.1.23 of G.997.1
-   [11])
-*/
-typedef struct ACK_UPBO_KL0Get ACK_UPBO_KL0Get_t;
-
-/** Message ID for CMD_PBO_AELEM_Status_Get */
-#define CMD_PBO_AELEM_STATUS_GET 0xEA03
-
-/**
-   Requests status parameters for the Upstream  Power  Back-Off  (UPBO)
-   alternative  electrical  length  estimation  method (AELEM).
-*/
-typedef struct CMD_PBO_AELEM_Status_Get CMD_PBO_AELEM_Status_Get_t;
-
-/** Message ID for ACK_PBO_AELEM_Status_Get */
-#define ACK_PBO_AELEM_STATUS_GET 0xEA03
-
-/**
-   Upstream  Power  Back-Off  (UPBO)  status  parameters  for  the  alternative
-   electrical  length  estimation  method (AELEM) are reported.
-*/
-typedef struct ACK_PBO_AELEM_Status_Get ACK_PBO_AELEM_Status_Get_t;
-
-/** Message ID for CMD_NoiseMarginDeltaSet */
-#define CMD_NOISEMARGINDELTASET 0x1C45
-
-/**
-   Configuration of a target noise margin delta, which is added to the target
-   noise margin value configured at the CO (and in case of the CPE received from
-   there). The resulting value is then taken as target noise margin, e.g. for
-   bit loading.
-*/
-typedef struct CMD_NoiseMarginDeltaSet CMD_NoiseMarginDeltaSet_t;
-
-/** Message ID for ACK_NoiseMarginDeltaSet */
-#define ACK_NOISEMARGINDELTASET 0x1C45
-
-/**
-   Acknowledgement for the message CMD_NoiseMarginDeltaSet.
-*/
-typedef struct ACK_NoiseMarginDeltaSet ACK_NoiseMarginDeltaSet_t;
-
-/** Message ID for CMD_BearerCh0_DS_Set */
-#define CMD_BEARERCH0_DS_SET 0x0048
-
-/**
-   Sets parameters for downstream bearer channel 0 (Chapters 7.3.2.1-5 of
-   G.997.1 [11]). Bearer channel configuration at the CPE is optional and just
-   used to further limit the parameters usually configured at the CO.The mode,
-   ATM or PTM, is selected with the configuration controls "ATMControl" and
-   "PTMControl" in Parameter 2. Exactly one of them must be enabled, not both!
-*/
-typedef struct CMD_BearerCh0_DS_Set CMD_BearerCh0_DS_Set_t;
-
-/** Message ID for ACK_BearerCh0_DS_Set */
-#define ACK_BEARERCH0_DS_SET 0x0048
-
-/**
-   Acknowledgement for CMD_BearerCh0_DS_Set. (Configuration of bearer channel
-   0).
-*/
-typedef struct ACK_BearerCh0_DS_Set ACK_BearerCh0_DS_Set_t;
-
-/** Message ID for CMD_BearerCh0_US_Set */
-#define CMD_BEARERCH0_US_SET 0x0248
-
-/**
-   Sets parameters for upstream bearer channel 0 (Chapters 7.3.2.1-5 of G.997.1
-   [11]). Bearer channel configuration at the CPE is optional and just used to
-   further limit the parameters usually configured at the CO.The mode, ATM or
-   PTM, is selected with the configuration controls "ATMControl" and
-   "PTMControl" in Parameter 2. Exactly one of them must be enabled, not both!
-*/
-typedef struct CMD_BearerCh0_US_Set CMD_BearerCh0_US_Set_t;
-
-/** Message ID for ACK_BearerCh0_US_Set */
-#define ACK_BEARERCH0_US_SET 0x0248
-
-/**
-   Acknowledgement for CMD_BearerCh0_US_Set. (Configuration of bearer channel
-   0).
-*/
-typedef struct ACK_BearerCh0_US_Set ACK_BearerCh0_US_Set_t;
-
-/** Message ID for CMD_InitPolicySet */
-#define CMD_INITPOLICYSET 0x1A45
-
-/**
-   The message selects the channel initialization policy (CIPOLICY) to be
-   applied for the tranceiver configuration. (Section 7.3.2.10 of G.997.1)In
-   ADSL mode, the message is applicable only for ADSL2/2+ (Section 7.10.3 of
-   G.992.3 Amd 3). The standard defines the parameter for the CO only. Here, the
-   message is applied at the ADSL-CPE, then it overrides the policy given by the
-   CO!
-*/
-typedef struct CMD_InitPolicySet CMD_InitPolicySet_t;
-
-/** Message ID for ACK_InitPolicySet */
-#define ACK_INITPOLICYSET 0x1A45
-
-/**
-   Acknowledgment for message CMD_InitPolicySet.
-*/
-typedef struct ACK_InitPolicySet ACK_InitPolicySet_t;
-
-/** Message ID for CMD_ErasureControlSet */
-#define CMD_ERASURECONTROLSET 0x0162
-
-/**
-   Configuration of options for the modem state machine.
-*/
-typedef struct CMD_ErasureControlSet CMD_ErasureControlSet_t;
-
-/** Message ID for ACK_ErasureControlSet */
-#define ACK_ERASURECONTROLSET 0x0162
-
-/**
-   Acknowledgement to CMD_ErasureControlSet.
-*/
-typedef struct ACK_ErasureControlSet ACK_ErasureControlSet_t;
-
-/** Message ID for CMD_Misc_ConfigSet */
-#define CMD_MISC_CONFIGSET 0x3A48
-
-/**
-   Performs some miscellaneous chip set configurations.
-*/
-typedef struct CMD_Misc_ConfigSet CMD_Misc_ConfigSet_t;
-
-/** Message ID for ACK_Misc_ConfigSet */
-#define ACK_MISC_CONFIGSET 0x3A48
-
-/**
-   This is the acknowledgement for ACK_Misc_ConfigSet.
-*/
-typedef struct ACK_Misc_ConfigSet ACK_Misc_ConfigSet_t;
-
-/** Message ID for CMD_OperationOptionsSet */
-#define CMD_OPERATIONOPTIONSSET 0x0D62
-
-/**
-   Performs some miscellaneous chip set configurations.
-*/
-typedef struct CMD_OperationOptionsSet CMD_OperationOptionsSet_t;
-
-/** Message ID for ACK_OperationOptionsSet */
-#define ACK_OPERATIONOPTIONSSET 0x0D62
-
-/**
-   This is the acknowledgement for CMD_OperationOptionsSet.
-*/
-typedef struct ACK_OperationOptionsSet ACK_OperationOptionsSet_t;
-
-/** Message ID for CMD_OperatorSelect */
-#define CMD_OPERATORSELECT 0x1562
-
-/**
-   The message selects a DSL operator. The information is used to configure
-   operator specific settings inside the DSL firmware.
-*/
-typedef struct CMD_OperatorSelect CMD_OperatorSelect_t;
-
-/** Message ID for ACK_OperatorSelect */
-#define ACK_OPERATORSELECT 0x1562
-
-/**
-   This is the acknowledgement for ACK_OperatorSelect.
-*/
-typedef struct ACK_OperatorSelect ACK_OperatorSelect_t;
-
-/** Message ID for CMD_OperatorSelectionGet */
-#define CMD_OPERATORSELECTIONGET 0x1522
-
-/**
-   The message reads back the selected DSL operator, as selected by
-   ACK_OperatorSelect.
-*/
-typedef struct CMD_OperatorSelectionGet CMD_OperatorSelectionGet_t;
-
-/** Message ID for ACK_OperatorSelectionGet */
-#define ACK_OPERATORSELECTIONGET 0x1522
-
-/**
-   The message provides the selected DSL operator.
-*/
-typedef struct ACK_OperatorSelectionGet ACK_OperatorSelectionGet_t;
-
-/** Message ID for CMD_TestOptionsSet */
-#define CMD_TESTOPTIONSSET 0x1C44
-
-/**
-   The messages configures settings for test modes.
-*/
-typedef struct CMD_TestOptionsSet CMD_TestOptionsSet_t;
-
-/** Message ID for ACK_TestOptionsSet */
-#define ACK_TESTOPTIONSSET 0x1C44
-
-/**
-   This is the acknowledgement for CMD_TestOptionsSet.
-*/
-typedef struct ACK_TestOptionsSet ACK_TestOptionsSet_t;
-
-/** Message ID for CMD_ClockSet */
-#define CMD_CLOCKSET 0x0F62
-
-/**
-   Sets the PPE clock. The message is supposed to be used for debug/test
-   purposes only. If applied this PPE clock is forced and will be kept
-   throughout the link. The PPE frequency scaling automode (see
-   CMD_PPE_ClockConfigure) will then not change it but behave as being disabled.
-*/
-typedef struct CMD_ClockSet CMD_ClockSet_t;
-
-/** Message ID for ACK_ClockSet */
-#define ACK_CLOCKSET 0x0F62
-
-/**
-   This is the acknowledgement for CMD_ClockSet.
-*/
-typedef struct ACK_ClockSet ACK_ClockSet_t;
-
-/** Message ID for CMD_PPE_ClockConfigure */
-#define CMD_PPE_CLOCKCONFIGURE 0x2262
-
-/**
-   Configures PPE clock options.The message CMD_ClockSet used for debug/test
-   purposes forces a PPE clock frequency which will be kept throughout the
-   link.. The PPE frequency scaling automode (see CMD_ClockSet) will then not
-   change it but behave as being disabled.
-*/
-typedef struct CMD_PPE_ClockConfigure CMD_PPE_ClockConfigure_t;
-
-/** Message ID for ACK_PPE_ClockConfigure */
-#define ACK_PPE_CLOCKCONFIGURE 0x2262
-
-/**
-   This is the acknowledgement for CMD_PPE_ClockConfigure.
-*/
-typedef struct ACK_PPE_ClockConfigure ACK_PPE_ClockConfigure_t;
-
-/** Message ID for CMD_PPE_ClockGet */
-#define CMD_PPE_CLOCKGET 0xF403
-
-/**
-   Reads PPE clock settings.
-*/
-typedef struct CMD_PPE_ClockGet CMD_PPE_ClockGet_t;
-
-/** Message ID for ACK_PPE_ClockGet */
-#define ACK_PPE_CLOCKGET 0xF403
-
-/**
-   Provides PPE clock settings.
-*/
-typedef struct ACK_PPE_ClockGet ACK_PPE_ClockGet_t;
-
-/** Message ID for CMD_PPE_ClockConfigGet */
-#define CMD_PPE_CLOCKCONFIGGET 0x2222
-
-/**
-   Reads back PPE clock options.
-*/
-typedef struct CMD_PPE_ClockConfigGet CMD_PPE_ClockConfigGet_t;
-
-/** Message ID for ACK_PPE_ClockConfigGet */
-#define ACK_PPE_CLOCKCONFIGGET 0x2222
-
-/**
-   Provides PPE clock options.
-*/
-typedef struct ACK_PPE_ClockConfigGet ACK_PPE_ClockConfigGet_t;
-
-/** Message ID for CMD_PLL_ClockSet */
-#define CMD_PLL_CLOCKSET 0x1962
-
-/**
-   Sets an offset for the PLL frequency compared to the crystals rated nominal
-   frequency of 36 MHz. This allows e.g. to fine tune the handshake tone
-   frequencies to exactly match the standard values.
-*/
-typedef struct CMD_PLL_ClockSet CMD_PLL_ClockSet_t;
-
-/** Message ID for ACK_PLL_ClockSet */
-#define ACK_PLL_CLOCKSET 0x1962
-
-/**
-   This is the acknowledgement for CMD_PLL_ClockSet.
-*/
-typedef struct ACK_PLL_ClockSet ACK_PLL_ClockSet_t;
-
-/**
-   Requests information about the current state of the modem state-machine.The
-   command can be sent in all states of the modem state machine (see Figure 2).
-*/
-struct CMD_ModemFSM_StateGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the current state of the modem state-machine.
-*/
-struct ACK_ModemFSM_StateGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Modem Status */
-   DSL_uint16_t ModemState;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** Line Power Management State */
-   DSL_uint16_t LxState : 2;
-   /** Last HS State or SOC Message */
-   DSL_uint16_t State_HsOrSoc;
-   /** RX Signal */
-   DSL_uint16_t RxSignal;
-   /** TX Signal */
-   DSL_uint16_t TxSignal;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Modem Status */
-   DSL_uint16_t ModemState;
-   /** Line Power Management State */
-   DSL_uint16_t LxState : 2;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** Last HS State or SOC Message */
-   DSL_uint16_t State_HsOrSoc;
-   /** RX Signal */
-   DSL_uint16_t RxSignal;
-   /** TX Signal */
-   DSL_uint16_t TxSignal;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the current state of the modem state-machine. This
-   message is sent autonomously, if the modem enters a new state and reporting
-   is enabled for that state (see CMD_ModemFSM_EventConfigure).
-*/
-struct EVT_ModemFSM_StateGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Modem Status */
-   DSL_uint16_t ModemState;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** Line Power Management State */
-   DSL_uint16_t LxState : 2;
-   /** Last HS State or SOC Message */
-   DSL_uint16_t State_HsOrSoc;
-   /** RX Signal */
-   DSL_uint16_t RxSignal;
-   /** TX Signal */
-   DSL_uint16_t TxSignal;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Modem Status */
-   DSL_uint16_t ModemState;
-   /** Line Power Management State */
-   DSL_uint16_t LxState : 2;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** Last HS State or SOC Message */
-   DSL_uint16_t State_HsOrSoc;
-   /** RX Signal */
-   DSL_uint16_t RxSignal;
-   /** TX Signal */
-   DSL_uint16_t TxSignal;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Autonomous message indicating that the modem online code was reached and that
-   initialization was completed. The management entity may not perform any
-   query-response messaging until the EVT_ModemReady message is received. Its
-   generation cannot be disabled. If it is not received this indicates a
-   problem, possibly with the boot sequence. If the message is received, it
-   contains a result code that may also indicate that an error was detected by
-   the firmware during initialization.
-*/
-struct EVT_ModemReady
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Error Code */
-   DSL_uint8_t ErrorCode;
-   /** Warning Code */
-   DSL_uint8_t WarningCode;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Warning Code */
-   DSL_uint8_t WarningCode;
-   /** Error Code */
-   DSL_uint8_t ErrorCode;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Controls state transitions of the modem state-machine.
-*/
-struct CMD_ModemFSM_StateSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 12;
-   /** Link Control */
-   DSL_uint16_t LinkControl : 4;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Link Control */
-   DSL_uint16_t LinkControl : 4;
-   /** Reserved */
-   DSL_uint16_t Res0 : 12;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for message CMD_ModemFSM_StateSet
-*/
-struct ACK_ModemFSM_StateSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reports failure information after entering FAIL state. This message is sent
-   autonomously without host request after entrance into FAIL was indicated by
-   EVT_ModemFSM_StateGet. Both messages are generated only if enabled with
-   CMD_ModemFSM_EventConfigure (common Bit E8 "FAIL").
-*/
-struct ALM_ModemFSM_FailReasonGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** System Sub Error Code */
-   DSL_uint8_t SubErrorCode;
-   /** System Error Code */
-   DSL_uint8_t ErrorCode;
-   /** Failure State Information */
-   DSL_uint16_t FW_FailCode;
-   /** Reserved */
-   DSL_uint16_t Res0[8];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** System Error Code */
-   DSL_uint8_t ErrorCode;
-   /** System Sub Error Code */
-   DSL_uint8_t SubErrorCode;
-   /** Failure State Information */
-   DSL_uint16_t FW_FailCode;
-   /** Reserved */
-   DSL_uint16_t Res0[8];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests failure information after entering FAIL state.
-*/
-struct CMD_ModemFSM_FailReasonGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns failure information after entering FAIL state.
-*/
-struct ACK_ModemFSM_FailReasonGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** System Sub Error Code */
-   DSL_uint8_t SubErrorCode;
-   /** System Error Code */
-   DSL_uint8_t ErrorCode;
-   /** Failure State Information */
-   DSL_uint16_t FW_FailCode;
-   /** Reserved */
-   DSL_uint16_t Res0[8];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** System Error Code */
-   DSL_uint8_t ErrorCode;
-   /** System Sub Error Code */
-   DSL_uint8_t SubErrorCode;
-   /** Failure State Information */
-   DSL_uint16_t FW_FailCode;
-   /** Reserved */
-   DSL_uint16_t Res0[8];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Configuration of options for the modem state machine.
-*/
-struct CMD_ModemFSM_OptionsSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 5;
-   /** L2 Extensions of G.992.3 Amd4 (2011), (ADSL only), Bit 10 */
-   DSL_uint16_t E10 : 1;
-   /** L2 Automatic Exit (ADSL only), Bit 9 */
-   DSL_uint16_t E9 : 1;
-   /** L2 Low-Power Mode Enable (ADSL only), Bit 8 */
-   DSL_uint16_t E8 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 5;
-   /** Loop Diagnostic Mode Control, Bit 2 */
-   DSL_uint16_t E2 : 1;
-   /** Reserved 0 */
-   DSL_uint16_t E1 : 1;
-   /** Automatic Re-Start Control, Bit 0 */
-   DSL_uint16_t E0 : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Automatic Re-Start Control, Bit 0 */
-   DSL_uint16_t E0 : 1;
-   /** Reserved 0 */
-   DSL_uint16_t E1 : 1;
-   /** Loop Diagnostic Mode Control, Bit 2 */
-   DSL_uint16_t E2 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 5;
-   /** L2 Low-Power Mode Enable (ADSL only), Bit 8 */
-   DSL_uint16_t E8 : 1;
-   /** L2 Automatic Exit (ADSL only), Bit 9 */
-   DSL_uint16_t E9 : 1;
-   /** L2 Extensions of G.992.3 Amd4 (2011), (ADSL only), Bit 10 */
-   DSL_uint16_t E10 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 5;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_ModemFSM_OptionsSet.
-*/
-struct ACK_ModemFSM_OptionsSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Configuration of options for the modem state machine.
-*/
-struct CMD_ModemOptionsSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 10;
-   /** Steady-State Algorithm Control, Bit5 */
-   DSL_uint16_t Trellis : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 1;
-   /** AELEM Control (VDSL only), Bit 3 */
-   DSL_uint16_t enableAelem : 1;
-   /** Short Init Control (ADSL only), Bit 2 */
-   DSL_uint16_t shortInit : 1;
-   /** US Virtual Noise Support, Bit 1 */
-   DSL_uint16_t enableVN_US : 1;
-   /** DS Virtual Noise Support, Bit 0 */
-   DSL_uint16_t enableVN_DS : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** DS Virtual Noise Support, Bit 0 */
-   DSL_uint16_t enableVN_DS : 1;
-   /** US Virtual Noise Support, Bit 1 */
-   DSL_uint16_t enableVN_US : 1;
-   /** Short Init Control (ADSL only), Bit 2 */
-   DSL_uint16_t shortInit : 1;
-   /** AELEM Control (VDSL only), Bit 3 */
-   DSL_uint16_t enableAelem : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 1;
-   /** Steady-State Algorithm Control, Bit5 */
-   DSL_uint16_t Trellis : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 10;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_ModemOptionsSet.
-*/
-struct ACK_ModemOptionsSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Sets options for the modem state-machine. Enables/Disables autonomous
-   messages for specific state transitions (EVT_ModemFSM_StateGet). The EVT
-   message is generated after entering the particular state listed in the
-   parameter description of the enable bits.
-*/
-struct CMD_ModemFSM_EventConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Enable Bit 15 */
-   DSL_uint16_t E15 : 1;
-   /** Enable Bit 14 */
-   DSL_uint16_t E14 : 1;
-   /** Enable Bit 13 */
-   DSL_uint16_t E13 : 1;
-   /** Enable Bit 12 */
-   DSL_uint16_t E12 : 1;
-   /** Enable Bit 11 */
-   DSL_uint16_t E11 : 1;
-   /** Enable Bit 10 */
-   DSL_uint16_t E10 : 1;
-   /** Enable Bit 9 */
-   DSL_uint16_t E9 : 1;
-   /** Enable Bit 8 */
-   DSL_uint16_t E8 : 1;
-   /** Enable Bit 7 */
-   DSL_uint16_t E7 : 1;
-   /** Enable Bit 6 */
-   DSL_uint16_t E6 : 1;
-   /** Enable Bit 5 */
-   DSL_uint16_t E5 : 1;
-   /** Enable Bit 4 */
-   DSL_uint16_t E4 : 1;
-   /** Enable Bit 3 */
-   DSL_uint16_t E3 : 1;
-   /** Enable Bit 2 */
-   DSL_uint16_t E2 : 1;
-   /** Enable Bit 1 (ADSL only) */
-   DSL_uint16_t E1 : 1;
-   /** Enable Bit 0 */
-   DSL_uint16_t E0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 15;
-   /** Enable Bit 16 */
-   DSL_uint16_t E16 : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Enable Bit 0 */
-   DSL_uint16_t E0 : 1;
-   /** Enable Bit 1 (ADSL only) */
-   DSL_uint16_t E1 : 1;
-   /** Enable Bit 2 */
-   DSL_uint16_t E2 : 1;
-   /** Enable Bit 3 */
-   DSL_uint16_t E3 : 1;
-   /** Enable Bit 4 */
-   DSL_uint16_t E4 : 1;
-   /** Enable Bit 5 */
-   DSL_uint16_t E5 : 1;
-   /** Enable Bit 6 */
-   DSL_uint16_t E6 : 1;
-   /** Enable Bit 7 */
-   DSL_uint16_t E7 : 1;
-   /** Enable Bit 8 */
-   DSL_uint16_t E8 : 1;
-   /** Enable Bit 9 */
-   DSL_uint16_t E9 : 1;
-   /** Enable Bit 10 */
-   DSL_uint16_t E10 : 1;
-   /** Enable Bit 11 */
-   DSL_uint16_t E11 : 1;
-   /** Enable Bit 12 */
-   DSL_uint16_t E12 : 1;
-   /** Enable Bit 13 */
-   DSL_uint16_t E13 : 1;
-   /** Enable Bit 14 */
-   DSL_uint16_t E14 : 1;
-   /** Enable Bit 15 */
-   DSL_uint16_t E15 : 1;
-   /** Enable Bit 16 */
-   DSL_uint16_t E16 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 15;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for CMD_ModemFSM_EventConfigure. (Enabling/Disabling EVENT
-   messages (EVTs) for specific state transitions.)
-*/
-struct ACK_ModemFSM_EventConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Enables/Disables the generation of ALARM messages (ALM) for specific near-end
-   line failures. If the corresponding Enable bit for a line failure is set,
-   then the modem firmware will send an autonomous message ALM_LineFailureNE_Get
-   if this failure occurs.
-*/
-struct CMD_FailuresNE_AlarmConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 2;
-   /** Enable Bit 13 */
-   DSL_uint16_t E13 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 9;
-   /** Enable Bit3 */
-   DSL_uint16_t E3 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 1;
-   /** Enable Bit1 */
-   DSL_uint16_t E1 : 1;
-   /** Enable Bit0 */
-   DSL_uint16_t E0 : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Enable Bit0 */
-   DSL_uint16_t E0 : 1;
-   /** Enable Bit1 */
-   DSL_uint16_t E1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 1;
-   /** Enable Bit3 */
-   DSL_uint16_t E3 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 9;
-   /** Enable Bit 13 */
-   DSL_uint16_t E13 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 2;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_FailuresNE_AlarmConfigure.
-*/
-struct ACK_FailuresNE_AlarmConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Enables/Disables the generation of ALARM messages (ALM) for specific far-end
-   line failures. If the corresponding Enable bit for a line failure is set,
-   then the modem firmware will send an autonomous message ALM_LineFailureFE_Get
-   if this failure occurs.
-*/
-struct CMD_FailuresFE_AlarmConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 12;
-   /** Enable Bit3 */
-   DSL_uint16_t E3 : 1;
-   /** Enable Bit2 */
-   DSL_uint16_t E2 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 1;
-   /** Enable Bit0 */
-   DSL_uint16_t E0 : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Enable Bit0 */
-   DSL_uint16_t E0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 1;
-   /** Enable Bit2 */
-   DSL_uint16_t E2 : 1;
-   /** Enable Bit3 */
-   DSL_uint16_t E3 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 12;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_FailuresFE_AlarmConfigure.
-*/
-struct ACK_FailuresFE_AlarmConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Configures re-initialization triggers for near-end failure conditions in
-   modem state STEADY STATE transmission (see Figure 1). This command is
-   accepted in RESET state only.
-*/
-struct CMD_ReInitNE_Configure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 2;
-   /** ESE */
-   DSL_uint16_t E13 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 2;
-   /** OOS BC0 */
-   DSL_uint16_t E10 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 1;
-   /** NCD BC0 */
-   DSL_uint16_t E8 : 1;
-   /** Reserved */
-   DSL_uint16_t Res3 : 1;
-   /** LCD BC0 */
-   DSL_uint16_t E6 : 1;
-   /** Reserved */
-   DSL_uint16_t Res4 : 2;
-   /** LOM */
-   DSL_uint16_t E3 : 1;
-   /** Reserved */
-   DSL_uint16_t Res5 : 1;
-   /** LOF */
-   DSL_uint16_t E1 : 1;
-   /** LOS */
-   DSL_uint16_t E0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res6 : 14;
-   /** ESx */
-   DSL_uint16_t F1 : 1;
-   /** SESx */
-   DSL_uint16_t F0 : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** LOS */
-   DSL_uint16_t E0 : 1;
-   /** LOF */
-   DSL_uint16_t E1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res5 : 1;
-   /** LOM */
-   DSL_uint16_t E3 : 1;
-   /** Reserved */
-   DSL_uint16_t Res4 : 2;
-   /** LCD BC0 */
-   DSL_uint16_t E6 : 1;
-   /** Reserved */
-   DSL_uint16_t Res3 : 1;
-   /** NCD BC0 */
-   DSL_uint16_t E8 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 1;
-   /** OOS BC0 */
-   DSL_uint16_t E10 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 2;
-   /** ESE */
-   DSL_uint16_t E13 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 2;
-   /** SESx */
-   DSL_uint16_t F0 : 1;
-   /** ESx */
-   DSL_uint16_t F1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res6 : 14;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgment to CMD_ReInitNE_Configure (Configuration of re-initialization
-   triggers for near-end failures).
-*/
-struct ACK_ReInitNE_Configure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Configuration of reinitialization trigger definitions.
-*/
-struct CMD_ReinitThreshConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** SESx Reinit Period */
-   DSL_uint16_t SESxPeriod;
-   /** LOM Persistency Time for Reinit */
-   DSL_uint16_t LomRiPeriod;
-   /** ESx Reinit Period */
-   DSL_uint16_t ESxPeriod;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** SESx Reinit Period */
-   DSL_uint16_t SESxPeriod;
-   /** LOM Persistency Time for Reinit */
-   DSL_uint16_t LomRiPeriod;
-   /** ESx Reinit Period */
-   DSL_uint16_t ESxPeriod;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for the message ACK_ReinitThreshConfigure.
-*/
-struct ACK_ReinitThreshConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Triggers a shutdown request, either as "L3 orderly shutdown" towards the
-   remote side or as "locally forced shutdown" to the DSL-FW without sending a
-   request to the remote side.After an "L3 orderly shutdown" request was
-   accepted by the CO, the following shall happen: The CPE-Host forces L3 entry
-   with transition to RESET state by applying CMD_ModemFSM_StateGet.A "locally
-   forced shutdown" always results in exiting Showtime.
-*/
-struct CMD_ShutdownRequest
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** Locally Forced Shutdown */
-   DSL_uint16_t ForcedShutdown : 1;
-   /** L3 Orderly Shutdown Request */
-   DSL_uint16_t L3shutdown : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** L3 Orderly Shutdown Request */
-   DSL_uint16_t L3shutdown : 1;
-   /** Locally Forced Shutdown */
-   DSL_uint16_t ForcedShutdown : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for CMD_ShutdownRequest.
-*/
-struct ACK_ShutdownRequest
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests information about L3 orderly shutdown requests initiated from the
-   remote side.Applying CMD_RxL3RequestStatusGet allows the host to determine
-   whether a near-end LOS or LOM failure is due to an L3 shutdown or an
-   unexpected line failure.
-*/
-struct CMD_RxL3RequestStatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for CMD_RxL3RequestStatusGet.As long as the modem is in L0
-   (Showtime), an ATU-R will automatically respond to any L3 request from the
-   ATU-C by sending an accept message.  If the ATU-R is in L2 mode when it
-   receives the request, it will send a reject message. Upon receiving an
-   acceptance, the remote side should enter L3 state and shut off its
-   transmitter.
-*/
-struct ACK_RxL3RequestStatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** L3 Request Response */
-   DSL_uint16_t L3ReqResponse : 1;
-   /** L3 Request Received */
-   DSL_uint16_t L3ReqReceived : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** L3 Request Received */
-   DSL_uint16_t L3ReqReceived : 1;
-   /** L3 Request Response */
-   DSL_uint16_t L3ReqResponse : 1;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the status of a near-end initiated L3 shutdown request. If the
-   remote side accepted the request, in ADSL the host will force L3 entry using
-   CMD_ModemFSM_StateSet.
-*/
-struct CMD_TxL3RequestStatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for CMD_TxL3RequestStatusGet.
-*/
-struct ACK_TxL3RequestStatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** Status L3 Request */
-   DSL_uint16_t L3ReqStatus : 2;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Status L3 Request */
-   DSL_uint16_t L3ReqStatus : 2;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the fail reason of a failed near-end initiated L3 request. (see also
-   ACK_TxL3RequestStatusGet)
-*/
-struct CMD_TxL3ReqFailReasonGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reports the fail reason of a near-end initiated L3 request, as response to
-   CMD_TxL3ReqFailReasonGet.
-*/
-struct ACK_TxL3ReqFailReasonGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 8;
-   /** L3 Fail Reason */
-   DSL_uint8_t L3FailReason;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** L3 Fail Reason */
-   DSL_uint8_t L3FailReason;
-   /** Reserved */
-   DSL_uint16_t Res0 : 8;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message selects and enables one of several points during the
-   initialization process where -after a normal link start had been triggered-
-   the modem FSM "freezes". Freezing means the CO can be disconnected from the
-   line and still the CPE continues transmitting the signal of the current
-   phase. To exit from the freeze a state transition to RESET state has to be
-   triggered. In case of a Showtime Freeze the reinit-triggers do not have any
-   effect.
-*/
-struct CMD_ModemFSM_Freeze
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Freeze Points */
-   DSL_uint16_t FreezePoint;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Freeze Points */
-   DSL_uint16_t FreezePoint;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for message CMD_ModemFSM_Freeze.
-*/
-struct ACK_ModemFSM_Freeze
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests information about the loaded FW image. This info is used e.g. for
-   swapping between ADSL and VDSL.
-*/
-struct CMD_FW_ImageInfoGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the information about the FW image requested by CMD_FW_ImageInfoGet
-*/
-struct ACK_FW_ImageInfoGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-   /** Site */
-   DSL_uint16_t imageType : 1;
-   /** DSL mode */
-   DSL_uint16_t dslMode : 1;
-   /** Site */
-   DSL_uint16_t location : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Site */
-   DSL_uint16_t location : 1;
-   /** DSL mode */
-   DSL_uint16_t dslMode : 1;
-   /** Site */
-   DSL_uint16_t imageType : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message informs the FW about the status of SW parameters relevant for the
-   multimode state machine (APS). This can be used to trace the APS behaviour
-   with FW tools. The message does not influence the APS behaviour.
-*/
-struct CMD_APS_Status_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Port Mode */
-   DSL_uint16_t DualPortMode;
-   /** NextMode */
-   DSL_uint16_t NextMode;
-   /** Remember Function */
-   DSL_uint16_t bRemember;
-   /** Activation Sequence */
-   DSL_uint16_t ActSeq;
-   /** Activation Start Mode (ADSL only) */
-   DSL_uint16_t ActMode;
-   /** nRetry  */
-   DSL_uint16_t nRetry;
-   /** nFwRetry  */
-   DSL_uint16_t nFwRetry;
-   /** nGhsRetry  */
-   DSL_uint16_t nGhsRetry;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Port Mode */
-   DSL_uint16_t DualPortMode;
-   /** NextMode */
-   DSL_uint16_t NextMode;
-   /** Remember Function */
-   DSL_uint16_t bRemember;
-   /** Activation Sequence */
-   DSL_uint16_t ActSeq;
-   /** Activation Start Mode (ADSL only) */
-   DSL_uint16_t ActMode;
-   /** nRetry  */
-   DSL_uint16_t nRetry;
-   /** nFwRetry  */
-   DSL_uint16_t nFwRetry;
-   /** nGhsRetry  */
-   DSL_uint16_t nGhsRetry;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for message CMD_APS_Status_Set.
-*/
-struct ACK_APS_Status_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Configuration of the VTU Transmission System Enabling (XTSE).Configures the
-   transmission system coding types to be supported on the line (VDSL flavour
-   and annex support).(References: Section 7.3.1.1.1 of G.997.1 and G.994.1 Amd4
-   [10] Tables "Standard information field - SPar(1) coding")
-*/
-struct CMD_XTSE_Configure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** ADSL Mode-Bit15: G.992.5, Annex A */
-   DSL_uint16_t A15 : 1;
-   /** ADSL Mode-Bit14: G.992.5, Annex B */
-   DSL_uint16_t A14 : 1;
-   /** ADSL Mode-Bit13: G.992.3, Annex M */
-   DSL_uint16_t A13 : 1;
-   /** ADSL Mode-Bit12: G.992.3, Annex L, US Mask2 */
-   DSL_uint16_t A12 : 1;
-   /** ADSL Mode-Bit11: G.992.3, Annex L, US Mask1 */
-   DSL_uint16_t A11 : 1;
-   /** ADSL Mode-Bit10: G.992.2, Annex A */
-   DSL_uint16_t A10 : 1;
-   /** ADSL Mode-Bit9: G.992.3, Annex B */
-   DSL_uint16_t A9 : 1;
-   /** ADSL Mode-Bit8: G.992.3, Annex A */
-   DSL_uint16_t A8 : 1;
-   /** ADSL Mode-Bit7: G.992.5, Annex J */
-   DSL_uint16_t A7 : 1;
-   /** ADSL Mode-Bit6: G.992.5, Annex I */
-   DSL_uint16_t A6 : 1;
-   /** ADSL Mode-Bit5: G.992.3, Annex J */
-   DSL_uint16_t A5 : 1;
-   /** ADSL Mode-Bit4: G.992.3, Annex I */
-   DSL_uint16_t A4 : 1;
-   /** ADSL Mode-Bit3: G.992.1, Annex B */
-   DSL_uint16_t A3 : 1;
-   /** ADSL Mode-Bit2: G.992.1, Annex A */
-   DSL_uint16_t A2 : 1;
-   /** ADSL Mode-Bit1: G.992.5, Annex M */
-   DSL_uint16_t A1 : 1;
-   /** ADSL Mode-Bit0: T1.413 */
-   DSL_uint16_t A0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 7;
-   /** Bit8: G.FAST */
-   DSL_uint16_t F8 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 5;
-   /** VDSL Mode-Bit2: VDSL2 */
-   DSL_uint16_t V2 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 2;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** ADSL Mode-Bit0: T1.413 */
-   DSL_uint16_t A0 : 1;
-   /** ADSL Mode-Bit1: G.992.5, Annex M */
-   DSL_uint16_t A1 : 1;
-   /** ADSL Mode-Bit2: G.992.1, Annex A */
-   DSL_uint16_t A2 : 1;
-   /** ADSL Mode-Bit3: G.992.1, Annex B */
-   DSL_uint16_t A3 : 1;
-   /** ADSL Mode-Bit4: G.992.3, Annex I */
-   DSL_uint16_t A4 : 1;
-   /** ADSL Mode-Bit5: G.992.3, Annex J */
-   DSL_uint16_t A5 : 1;
-   /** ADSL Mode-Bit6: G.992.5, Annex I */
-   DSL_uint16_t A6 : 1;
-   /** ADSL Mode-Bit7: G.992.5, Annex J */
-   DSL_uint16_t A7 : 1;
-   /** ADSL Mode-Bit8: G.992.3, Annex A */
-   DSL_uint16_t A8 : 1;
-   /** ADSL Mode-Bit9: G.992.3, Annex B */
-   DSL_uint16_t A9 : 1;
-   /** ADSL Mode-Bit10: G.992.2, Annex A */
-   DSL_uint16_t A10 : 1;
-   /** ADSL Mode-Bit11: G.992.3, Annex L, US Mask1 */
-   DSL_uint16_t A11 : 1;
-   /** ADSL Mode-Bit12: G.992.3, Annex L, US Mask2 */
-   DSL_uint16_t A12 : 1;
-   /** ADSL Mode-Bit13: G.992.3, Annex M */
-   DSL_uint16_t A13 : 1;
-   /** ADSL Mode-Bit14: G.992.5, Annex B */
-   DSL_uint16_t A14 : 1;
-   /** ADSL Mode-Bit15: G.992.5, Annex A */
-   DSL_uint16_t A15 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 2;
-   /** VDSL Mode-Bit2: VDSL2 */
-   DSL_uint16_t V2 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 5;
-   /** Bit8: G.FAST */
-   DSL_uint16_t F8 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 7;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for message CMD_XTSE_Configure.
-*/
-struct ACK_XTSE_Configure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Controls the upstream band usage.The message can only be used for DMTscope
-   tests without handshake and training phases.
-*/
-struct CMD_BandControl_US_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint8_t Res0;
-   /** Number of Upstream Bands */
-   DSL_uint8_t NumBandsUS;
-   /** Band Descriptor US */
-   VRX_ToneIndex_t band[8];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Number of Upstream Bands */
-   DSL_uint8_t NumBandsUS;
-   /** Reserved */
-   DSL_uint8_t Res0;
-   /** Band Descriptor US */
-   VRX_ToneIndex_t band[8];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for message CMD_BandControl_US_Set.
-*/
-struct ACK_BandControl_US_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Configuration of PSD and Power parameters. Only used for DMTscope tests
-   without handshake and training phases.
-*/
-struct CMD_PSD_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** MAXNOMPSDus */
-   DSL_uint16_t MAXNOMPSDus;
-   /** Reserved */
-   DSL_uint16_t Res1;
-   /** MAXNOMATPus */
-   DSL_uint16_t MAXNOMATPus;
-   /** Reserved */
-   DSL_uint16_t Res2;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** MAXNOMPSDus */
-   DSL_uint16_t MAXNOMPSDus;
-   /** Reserved */
-   DSL_uint16_t Res1;
-   /** MAXNOMATPus */
-   DSL_uint16_t MAXNOMATPus;
-   /** Reserved */
-   DSL_uint16_t Res2;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for the message CMD_PSD_Set.
-*/
-struct ACK_PSD_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Specifies the maximum upstream transmit PSD by means of breakpoints.To be
-   used only for DMTscope tests without handshake and training phases.
-*/
-struct CMD_PSD_BreakpointsTxUS_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint8_t Res0;
-   /** Number of Breakpoints */
-   DSL_uint8_t NumBreakPts;
-   /** Breakpoint Descriptor TxPSDus */
-   VRX_PSDbreak_t breakpoint[32];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Number of Breakpoints */
-   DSL_uint8_t NumBreakPts;
-   /** Reserved */
-   DSL_uint8_t Res0;
-   /** Breakpoint Descriptor TxPSDus */
-   VRX_PSDbreak_t breakpoint[32];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for the message CMD_PSD_BreakpointsTxUS_Set.
-*/
-struct ACK_PSD_BreakpointsTxUS_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Sends downstream calibration information for "per-tone" test parameters. It
-   is effective for Loop Diagnostic Mode (DELT) and Showtime. It is the
-   responsibility of the manufacturer to provide the data.
-*/
-struct  CMD_PSD_Calibration_DS_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Number of Breakpoints */
-   DSL_uint16_t NumBreakPts;
-   /** Breakpoint Descriptor RxPSD Compensation */
-   VRX_PSD_CompBreak_t breakpoint[16];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Number of Breakpoints */
-   DSL_uint16_t NumBreakPts;
-   /** Breakpoint Descriptor RxPSD Compensation */
-   VRX_PSD_CompBreak_t breakpoint[16];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for the message CMD_PSD_Calibration_DS_Set.
-*/
-struct ACK_PSD_Calibration_DS_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Sends upstream calibration information for the upstream transmit PSD. It is
-   effective for loop diagnostic mode (DELT) and Showtime. It is the
-   responsibility of the manufacturer to provide the data.
-*/
-struct  CMD_PSD_Calibration_US_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Number of Breakpoints */
-   DSL_uint16_t NumBreakPts;
-   /** Breakpoint Descriptor TxPSD Compensation */
-   VRX_PSD_CompBreak_t breakpoint[32];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Number of Breakpoints */
-   DSL_uint16_t NumBreakPts;
-   /** Breakpoint Descriptor TxPSD Compensation */
-   VRX_PSD_CompBreak_t breakpoint[32];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for the message CMD_PSD_Calibration_US_Set.
-*/
-struct ACK_PSD_Calibration_US_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Configuration of PSD related options.
-*/
-struct CMD_PSD_OptionsSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 15;
-   /** US TSSI Control, Bit 0 */
-   DSL_uint16_t useTssiUS : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** US TSSI Control, Bit 0 */
-   DSL_uint16_t useTssiUS : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 15;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_PSD_OptionsSet.
-*/
-struct ACK_PSD_OptionsSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the electrical loop length estimate kl0.
-*/
-struct CMD_UPBO_KL0Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the data requested by CMD_UPBO_KL0Get.(Section 7.5.1.23 of G.997.1
-   [11])
-*/
-struct ACK_UPBO_KL0Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Kl0 Estimate VTU-R */
-   DSL_uint16_t kl0_EstimR;
-   /** Kl0 Estimate VTU-O */
-   DSL_uint16_t kl0_EstimO;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Kl0 Estimate VTU-R */
-   DSL_uint16_t kl0_EstimR;
-   /** Kl0 Estimate VTU-O */
-   DSL_uint16_t kl0_EstimO;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests status parameters for the Upstream  Power  Back-Off  (UPBO)
-   alternative  electrical  length  estimation  method (AELEM).
-*/
-struct CMD_PBO_AELEM_Status_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Upstream  Power  Back-Off  (UPBO)  status  parameters  for  the  alternative
-   electrical  length  estimation  method (AELEM) are reported.
-*/
-struct ACK_PBO_AELEM_Status_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** AELE-MODE Used */
-   DSL_uint16_t AeleMode;
-   /** Kl0 Estimate per Band VTU-R */
-   DSL_uint16_t Kl0EstimRPb[4];
-   /** Final Kl0 per Band VTU-O */
-   DSL_uint16_t Kl0EstimOPb[4];
-   /** UPBOELMT */
-   DSL_uint16_t UpboElmt;
-   /** RXTHRSHDS */
-   DSL_int16_t RxThreshDs;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** AELE-MODE Used */
-   DSL_uint16_t AeleMode;
-   /** Kl0 Estimate per Band VTU-R */
-   DSL_uint16_t Kl0EstimRPb[4];
-   /** Final Kl0 per Band VTU-O */
-   DSL_uint16_t Kl0EstimOPb[4];
-   /** UPBOELMT */
-   DSL_uint16_t UpboElmt;
-   /** RXTHRSHDS */
-   DSL_int16_t RxThreshDs;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Configuration of a target noise margin delta, which is added to the target
-   noise margin value configured at the CO (and in case of the CPE received from
-   there). The resulting value is then taken as target noise margin, e.g. for
-   bit loading.
-*/
-struct CMD_NoiseMarginDeltaSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Target Noise Margin Delta DS */
-   DSL_int16_t deltaTARSNRMds;
-   /** Reserved (VDSL only) */
-   DSL_uint16_t Res0 : 14;
-   /** Reserved (VDSL only) */
-   DSL_uint16_t Res1 : 1;
-   /** Reserved (VDSL only) */
-   DSL_uint16_t Res2 : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Target Noise Margin Delta DS */
-   DSL_int16_t deltaTARSNRMds;
-   /** Reserved (VDSL only) */
-   DSL_uint16_t Res2 : 1;
-   /** Reserved (VDSL only) */
-   DSL_uint16_t Res1 : 1;
-   /** Reserved (VDSL only) */
-   DSL_uint16_t Res0 : 14;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for the message CMD_NoiseMarginDeltaSet.
-*/
-struct ACK_NoiseMarginDeltaSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Sets parameters for downstream bearer channel 0 (Chapters 7.3.2.1-5 of
-   G.997.1 [11]). Bearer channel configuration at the CPE is optional and just
-   used to further limit the parameters usually configured at the CO.The mode,
-   ATM or PTM, is selected with the configuration controls "ATMControl" and
-   "PTMControl" in Parameter 2. Exactly one of them must be enabled, not both!
-*/
-struct CMD_BearerCh0_DS_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-   /** Reserved (STM) */
-   DSL_uint16_t Res1 : 1;
-   /** ATM Configuration Control */
-   DSL_uint16_t ATMControl : 1;
-   /** PTM Configuration Control */
-   DSL_uint16_t PTMControl : 1;
-   /** Reserved */
-   DSL_uint16_t Res2;
-   /** Minimum Data Rate BC0 PTM DS, LSW */
-   DSL_uint16_t minRate0_PTMds_LSW;
-   /** Minimum Data Rate BC0 PTM DS, MSW */
-   DSL_uint16_t minRate0_PTMds_MSW;
-   /** Maximum Data Rate BC0 PTM DS, LSW */
-   DSL_uint16_t maxRate0_PTMds_LSW;
-   /** Maximum Data Rate BC0 PTM DS, MSW */
-   DSL_uint16_t maxRate0_PTMds_MSW;
-   /** Minimum Reserved Data Rate BC0 PTM DS, LSW */
-   DSL_uint16_t minResRate0_PTMds_LSW;
-   /** Minimum Reserved Data Rate BC0 PTM DS, MSW */
-   DSL_uint16_t minResRate0_PTMds_MSW;
-   /** Reserved */
-   DSL_uint8_t Res3;
-   /** Maximum Interleaving Delay BC0 PTM DS */
-   DSL_uint8_t maxDelay0_PTMds;
-   /** Reserved */
-   DSL_uint16_t Res4 : 4;
-   /** OPTIONAL CIPOLICY 2, BC0 PTM DS */
-   DSL_uint16_t CIPolicy2_PTMds : 1;
-   /** OPTIONAL CIPOLICY 1, BC0 PTM DS */
-   DSL_uint16_t CIPolicy1_PTMds : 1;
-   /** "SHORT PACKETS" OPTION BC0 PTM DS */
-   DSL_uint16_t ShortPacket_PTMds : 1;
-   /** "PRE-EMPTION" OPTION BC0 PTM DS */
-   DSL_uint16_t Preempt_PTMds : 1;
-   /** Reserved */
-   DSL_uint16_t Res5 : 6;
-   /** Maximum BER BC0 PTM DS */
-   DSL_uint16_t BER_PTMds : 2;
-   /** Reserved */
-   DSL_uint16_t Res6 : 4;
-   /** Minimum INP BC0 PTM DS */
-   DSL_uint16_t minINP_PTMds : 12;
-   /** Reserved */
-   DSL_uint16_t Res7;
-   /** Minimum Data Rate BC0 ATM DS, LSW */
-   DSL_uint16_t minRate0_ATMds_LSW;
-   /** Minimum Data Rate BC0 ATM DS, MSW */
-   DSL_uint16_t minRate0_ATMds_MSW;
-   /** Maximum Data Rate BC0 ATM DS, LSW */
-   DSL_uint16_t maxRate0_ATMds_LSW;
-   /** Maximum Data Rate BC0 ATM DS, MSW */
-   DSL_uint16_t maxRate0_ATMds_MSW;
-   /** Minimum Reserved Data Rate BC0 ATM DS, LSW */
-   DSL_uint16_t minResRate0_ATMds_LSW;
-   /** Minimum Reserved Data Rate BC0 ATM DS, MSW */
-   DSL_uint16_t minResRate0_ATMds_MSW;
-   /** Reserved */
-   DSL_uint8_t Res8;
-   /** Maximum Interleaving Delay BC0 ATM DS */
-   DSL_uint8_t maxDelay0_ATMds;
-   /** Reserved */
-   DSL_uint16_t Res9 : 4;
-   /** OPTIONAL CIPOLICY 2, BC0 ATM DS */
-   DSL_uint16_t CIPolicy2_ATMds : 1;
-   /** OPTIONAL CIPOLICY 1, BC0 ATM DS */
-   DSL_uint16_t CIPolicy1_ATMds : 1;
-   /** Reserved */
-   DSL_uint16_t Res10 : 8;
-   /** Maximum BER BC0 ATM DS */
-   DSL_uint16_t BER_ATMds : 2;
-   /** Reserved */
-   DSL_uint16_t Res11 : 4;
-   /** Minimum INP BC0 ATM DS */
-   DSL_uint16_t minINP_ATMds : 12;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PTM Configuration Control */
-   DSL_uint16_t PTMControl : 1;
-   /** ATM Configuration Control */
-   DSL_uint16_t ATMControl : 1;
-   /** Reserved (STM) */
-   DSL_uint16_t Res1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-   /** Reserved */
-   DSL_uint16_t Res2;
-   /** Minimum Data Rate BC0 PTM DS, LSW */
-   DSL_uint16_t minRate0_PTMds_LSW;
-   /** Minimum Data Rate BC0 PTM DS, MSW */
-   DSL_uint16_t minRate0_PTMds_MSW;
-   /** Maximum Data Rate BC0 PTM DS, LSW */
-   DSL_uint16_t maxRate0_PTMds_LSW;
-   /** Maximum Data Rate BC0 PTM DS, MSW */
-   DSL_uint16_t maxRate0_PTMds_MSW;
-   /** Minimum Reserved Data Rate BC0 PTM DS, LSW */
-   DSL_uint16_t minResRate0_PTMds_LSW;
-   /** Minimum Reserved Data Rate BC0 PTM DS, MSW */
-   DSL_uint16_t minResRate0_PTMds_MSW;
-   /** Maximum Interleaving Delay BC0 PTM DS */
-   DSL_uint8_t maxDelay0_PTMds;
-   /** Reserved */
-   DSL_uint8_t Res3;
-   /** Maximum BER BC0 PTM DS */
-   DSL_uint16_t BER_PTMds : 2;
-   /** Reserved */
-   DSL_uint16_t Res5 : 6;
-   /** "PRE-EMPTION" OPTION BC0 PTM DS */
-   DSL_uint16_t Preempt_PTMds : 1;
-   /** "SHORT PACKETS" OPTION BC0 PTM DS */
-   DSL_uint16_t ShortPacket_PTMds : 1;
-   /** OPTIONAL CIPOLICY 1, BC0 PTM DS */
-   DSL_uint16_t CIPolicy1_PTMds : 1;
-   /** OPTIONAL CIPOLICY 2, BC0 PTM DS */
-   DSL_uint16_t CIPolicy2_PTMds : 1;
-   /** Reserved */
-   DSL_uint16_t Res4 : 4;
-   /** Minimum INP BC0 PTM DS */
-   DSL_uint16_t minINP_PTMds : 12;
-   /** Reserved */
-   DSL_uint16_t Res6 : 4;
-   /** Reserved */
-   DSL_uint16_t Res7;
-   /** Minimum Data Rate BC0 ATM DS, LSW */
-   DSL_uint16_t minRate0_ATMds_LSW;
-   /** Minimum Data Rate BC0 ATM DS, MSW */
-   DSL_uint16_t minRate0_ATMds_MSW;
-   /** Maximum Data Rate BC0 ATM DS, LSW */
-   DSL_uint16_t maxRate0_ATMds_LSW;
-   /** Maximum Data Rate BC0 ATM DS, MSW */
-   DSL_uint16_t maxRate0_ATMds_MSW;
-   /** Minimum Reserved Data Rate BC0 ATM DS, LSW */
-   DSL_uint16_t minResRate0_ATMds_LSW;
-   /** Minimum Reserved Data Rate BC0 ATM DS, MSW */
-   DSL_uint16_t minResRate0_ATMds_MSW;
-   /** Maximum Interleaving Delay BC0 ATM DS */
-   DSL_uint8_t maxDelay0_ATMds;
-   /** Reserved */
-   DSL_uint8_t Res8;
-   /** Maximum BER BC0 ATM DS */
-   DSL_uint16_t BER_ATMds : 2;
-   /** Reserved */
-   DSL_uint16_t Res10 : 8;
-   /** OPTIONAL CIPOLICY 1, BC0 ATM DS */
-   DSL_uint16_t CIPolicy1_ATMds : 1;
-   /** OPTIONAL CIPOLICY 2, BC0 ATM DS */
-   DSL_uint16_t CIPolicy2_ATMds : 1;
-   /** Reserved */
-   DSL_uint16_t Res9 : 4;
-   /** Minimum INP BC0 ATM DS */
-   DSL_uint16_t minINP_ATMds : 12;
-   /** Reserved */
-   DSL_uint16_t Res11 : 4;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for CMD_BearerCh0_DS_Set. (Configuration of bearer channel
-   0).
-*/
-struct ACK_BearerCh0_DS_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Sets parameters for upstream bearer channel 0 (Chapters 7.3.2.1-5 of G.997.1
-   [11]). Bearer channel configuration at the CPE is optional and just used to
-   further limit the parameters usually configured at the CO.The mode, ATM or
-   PTM, is selected with the configuration controls "ATMControl" and
-   "PTMControl" in Parameter 2. Exactly one of them must be enabled, not both!
-*/
-struct CMD_BearerCh0_US_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-   /** Reserved (STM) */
-   DSL_uint16_t Res1 : 1;
-   /** ATM Configuration Control */
-   DSL_uint16_t ATMControl : 1;
-   /** PTM Configuration Control */
-   DSL_uint16_t PTMControl : 1;
-   /** Reserved */
-   DSL_uint16_t Res2;
-   /** Minimum Data Rate BC0 PTM US, LSW */
-   DSL_uint16_t minRate0_PTMus_LSW;
-   /** Minimum Data Rate BC0 PTM US, MSW */
-   DSL_uint16_t minRate0_PTMus_MSW;
-   /** Maximum Data Rate BC0 PTM US, LSW */
-   DSL_uint16_t maxRate0_PTMus_LSW;
-   /** Maximum Data Rate BC0 PTM US, MSW */
-   DSL_uint16_t maxRate0_PTMus_MSW;
-   /** Minimum Reserved Data Rate BC0 PTM US, LSW */
-   DSL_uint16_t minResRate0_PTMus_LSW;
-   /** Minimum Reserved Data Rate BC0 PTM US, MSW */
-   DSL_uint16_t minResRate0_PTMus_MSW;
-   /** Reserved */
-   DSL_uint8_t Res3;
-   /** Maximum Interleaving Delay BC0 PTM US */
-   DSL_uint8_t maxDelay0_PTMus;
-   /** Reserved */
-   DSL_uint16_t Res4 : 4;
-   /** OPTIONAL CIPOLICY 2, BC0 PTM US */
-   DSL_uint16_t CIPolicy2_PTMus : 1;
-   /** OPTIONAL CIPOLICY 1, BC0 PTM US */
-   DSL_uint16_t CIPolicy1_PTMus : 1;
-   /** "SHORT PACKETS" OPTION BC0 PTM US */
-   DSL_uint16_t ShortPacket_PTMus : 1;
-   /** "PRE-EMPTION" OPTION BC0 PTM US */
-   DSL_uint16_t Preempt_PTMus : 1;
-   /** Reserved */
-   DSL_uint16_t Res5 : 6;
-   /** Maximum BER BC0 PTM US */
-   DSL_uint16_t BER_PTMus : 2;
-   /** Reserved */
-   DSL_uint16_t Res6 : 4;
-   /** Minimum INP BC0 PTM US */
-   DSL_uint16_t minINP_PTMus : 12;
-   /** Reserved */
-   DSL_uint16_t Res7;
-   /** Minimum Data Rate BC0 ATM US, LSW */
-   DSL_uint16_t minRate0_ATMus_LSW;
-   /** Minimum Data Rate BC0 ATM US, MSW */
-   DSL_uint16_t minRate0_ATMus_MSW;
-   /** Maximum Data Rate BC0 ATM US, LSW */
-   DSL_uint16_t maxRate0_ATMus_LSW;
-   /** Maximum Data Rate BC0 ATM US, MSW */
-   DSL_uint16_t maxRate0_ATMus_MSW;
-   /** Minimum Reserved Data Rate BC0 ATM US, LSW */
-   DSL_uint16_t minResRate0_ATMus_LSW;
-   /** Minimum Reserved Data Rate BC0 ATM US, MSW */
-   DSL_uint16_t minResRate0_ATMus_MSW;
-   /** Reserved */
-   DSL_uint8_t Res8;
-   /** Maximum Interleaving Delay BC0 ATM US */
-   DSL_uint8_t maxDelay0_ATMus;
-   /** Reserved */
-   DSL_uint16_t Res9 : 4;
-   /** OPTIONAL CIPOLICY 1, BC0 ATM US */
-   DSL_uint16_t CIPolicy2_ATMus : 1;
-   /** OPTIONAL CIPOLICY 2, BC0 ATM US */
-   DSL_uint16_t CIPolicy1_ATMus : 1;
-   /** Reserved */
-   DSL_uint16_t Res10 : 8;
-   /** Maximum BER BC0 ATM US */
-   DSL_uint16_t BER_ATMus : 2;
-   /** Reserved */
-   DSL_uint16_t Res11 : 4;
-   /** Minimum INP BC0 ATM US */
-   DSL_uint16_t minINP_ATMus : 12;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PTM Configuration Control */
-   DSL_uint16_t PTMControl : 1;
-   /** ATM Configuration Control */
-   DSL_uint16_t ATMControl : 1;
-   /** Reserved (STM) */
-   DSL_uint16_t Res1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-   /** Reserved */
-   DSL_uint16_t Res2;
-   /** Minimum Data Rate BC0 PTM US, LSW */
-   DSL_uint16_t minRate0_PTMus_LSW;
-   /** Minimum Data Rate BC0 PTM US, MSW */
-   DSL_uint16_t minRate0_PTMus_MSW;
-   /** Maximum Data Rate BC0 PTM US, LSW */
-   DSL_uint16_t maxRate0_PTMus_LSW;
-   /** Maximum Data Rate BC0 PTM US, MSW */
-   DSL_uint16_t maxRate0_PTMus_MSW;
-   /** Minimum Reserved Data Rate BC0 PTM US, LSW */
-   DSL_uint16_t minResRate0_PTMus_LSW;
-   /** Minimum Reserved Data Rate BC0 PTM US, MSW */
-   DSL_uint16_t minResRate0_PTMus_MSW;
-   /** Maximum Interleaving Delay BC0 PTM US */
-   DSL_uint8_t maxDelay0_PTMus;
-   /** Reserved */
-   DSL_uint8_t Res3;
-   /** Maximum BER BC0 PTM US */
-   DSL_uint16_t BER_PTMus : 2;
-   /** Reserved */
-   DSL_uint16_t Res5 : 6;
-   /** "PRE-EMPTION" OPTION BC0 PTM US */
-   DSL_uint16_t Preempt_PTMus : 1;
-   /** "SHORT PACKETS" OPTION BC0 PTM US */
-   DSL_uint16_t ShortPacket_PTMus : 1;
-   /** OPTIONAL CIPOLICY 1, BC0 PTM US */
-   DSL_uint16_t CIPolicy1_PTMus : 1;
-   /** OPTIONAL CIPOLICY 2, BC0 PTM US */
-   DSL_uint16_t CIPolicy2_PTMus : 1;
-   /** Reserved */
-   DSL_uint16_t Res4 : 4;
-   /** Minimum INP BC0 PTM US */
-   DSL_uint16_t minINP_PTMus : 12;
-   /** Reserved */
-   DSL_uint16_t Res6 : 4;
-   /** Reserved */
-   DSL_uint16_t Res7;
-   /** Minimum Data Rate BC0 ATM US, LSW */
-   DSL_uint16_t minRate0_ATMus_LSW;
-   /** Minimum Data Rate BC0 ATM US, MSW */
-   DSL_uint16_t minRate0_ATMus_MSW;
-   /** Maximum Data Rate BC0 ATM US, LSW */
-   DSL_uint16_t maxRate0_ATMus_LSW;
-   /** Maximum Data Rate BC0 ATM US, MSW */
-   DSL_uint16_t maxRate0_ATMus_MSW;
-   /** Minimum Reserved Data Rate BC0 ATM US, LSW */
-   DSL_uint16_t minResRate0_ATMus_LSW;
-   /** Minimum Reserved Data Rate BC0 ATM US, MSW */
-   DSL_uint16_t minResRate0_ATMus_MSW;
-   /** Maximum Interleaving Delay BC0 ATM US */
-   DSL_uint8_t maxDelay0_ATMus;
-   /** Reserved */
-   DSL_uint8_t Res8;
-   /** Maximum BER BC0 ATM US */
-   DSL_uint16_t BER_ATMus : 2;
-   /** Reserved */
-   DSL_uint16_t Res10 : 8;
-   /** OPTIONAL CIPOLICY 2, BC0 ATM US */
-   DSL_uint16_t CIPolicy1_ATMus : 1;
-   /** OPTIONAL CIPOLICY 1, BC0 ATM US */
-   DSL_uint16_t CIPolicy2_ATMus : 1;
-   /** Reserved */
-   DSL_uint16_t Res9 : 4;
-   /** Minimum INP BC0 ATM US */
-   DSL_uint16_t minINP_ATMus : 12;
-   /** Reserved */
-   DSL_uint16_t Res11 : 4;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for CMD_BearerCh0_US_Set. (Configuration of bearer channel
-   0).
-*/
-struct ACK_BearerCh0_US_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message selects the channel initialization policy (CIPOLICY) to be
-   applied for the tranceiver configuration. (Section 7.3.2.10 of G.997.1)In
-   ADSL mode, the message is applicable only for ADSL2/2+ (Section 7.10.3 of
-   G.992.3 Amd 3). The standard defines the parameter for the CO only. Here, the
-   message is applied at the ADSL-CPE, then it overrides the policy given by the
-   CO!
-*/
-struct CMD_InitPolicySet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** Reserved for Init Policy BC1 */
-   DSL_uint16_t Res1 : 1;
-   /** Init Policy BC0 */
-   DSL_uint16_t policy0 : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Init Policy BC0 */
-   DSL_uint16_t policy0 : 1;
-   /** Reserved for Init Policy BC1 */
-   DSL_uint16_t Res1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgment for message CMD_InitPolicySet.
-*/
-struct ACK_InitPolicySet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Configuration of options for the modem state machine.
-*/
-struct CMD_ErasureControlSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-   /** "Trust-Me"-Bit, Bit 2 (ADSL only) */
-   DSL_uint16_t trustMe : 1;
-   /** Erasure Policy, Bit 1 */
-   DSL_uint16_t erasurePolicy : 1;
-   /** Reserved, Bit0 */
-   DSL_uint16_t Res1 : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved, Bit0 */
-   DSL_uint16_t Res1 : 1;
-   /** Erasure Policy, Bit 1 */
-   DSL_uint16_t erasurePolicy : 1;
-   /** "Trust-Me"-Bit, Bit 2 (ADSL only) */
-   DSL_uint16_t trustMe : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_ErasureControlSet.
-*/
-struct ACK_ErasureControlSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Performs some miscellaneous chip set configurations.
-*/
-struct CMD_Misc_ConfigSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 7;
-   /** TPS-TC Type Event Enable */
-   DSL_uint16_t TcTypeEvt : 1;
-   /** Hlog Invalidation */
-   DSL_uint16_t HlogValidation : 1;
-   /** Short CLR for ADSL2+ */
-   DSL_uint16_t ShortClrA2p : 1;
-   /** Short CLR for ADSL2 */
-   DSL_uint16_t ShortClrA2 : 1;
-   /** Short CLR for ADSL1 */
-   DSL_uint16_t ShortClrA1 : 1;
-   /** INP Protection Improvement (VDSL only) */
-   DSL_uint16_t FrameParams : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 1;
-   /** Activation Start Mode (ADSL only) */
-   DSL_uint16_t StartMode : 1;
-   /** Non-standard GHS-ANSI Activation (ADSL only) */
-   DSL_uint16_t GhsAnsiSeq : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Non-standard GHS-ANSI Activation (ADSL only) */
-   DSL_uint16_t GhsAnsiSeq : 1;
-   /** Activation Start Mode (ADSL only) */
-   DSL_uint16_t StartMode : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 1;
-   /** INP Protection Improvement (VDSL only) */
-   DSL_uint16_t FrameParams : 1;
-   /** Short CLR for ADSL1 */
-   DSL_uint16_t ShortClrA1 : 1;
-   /** Short CLR for ADSL2 */
-   DSL_uint16_t ShortClrA2 : 1;
-   /** Short CLR for ADSL2+ */
-   DSL_uint16_t ShortClrA2p : 1;
-   /** Hlog Invalidation */
-   DSL_uint16_t HlogValidation : 1;
-   /** TPS-TC Type Event Enable */
-   DSL_uint16_t TcTypeEvt : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 7;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This is the acknowledgement for ACK_Misc_ConfigSet.
-*/
-struct ACK_Misc_ConfigSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Performs some miscellaneous chip set configurations.
-*/
-struct CMD_OperationOptionsSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-   /** VRX_ENABLE, Fixed value */
-   DSL_uint16_t Mfd : 1;
-   /** Enhanced Upstream Framing (ADSL-Only) */
-   DSL_uint16_t UsFramingExt : 1;
-   /** NTR (currently VDSL-Only) */
-   DSL_uint16_t Ntr : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** NTR (currently VDSL-Only) */
-   DSL_uint16_t Ntr : 1;
-   /** Enhanced Upstream Framing (ADSL-Only) */
-   DSL_uint16_t UsFramingExt : 1;
-   /** VRX_ENABLE, Fixed value */
-   DSL_uint16_t Mfd : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This is the acknowledgement for CMD_OperationOptionsSet.
-*/
-struct ACK_OperationOptionsSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message selects a DSL operator. The information is used to configure
-   operator specific settings inside the DSL firmware.
-*/
-struct CMD_OperatorSelect
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** DSL Operator Selection */
-   DSL_uint16_t DslOperator;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** DSL Operator Selection */
-   DSL_uint16_t DslOperator;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This is the acknowledgement for ACK_OperatorSelect.
-*/
-struct ACK_OperatorSelect
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message reads back the selected DSL operator, as selected by
-   ACK_OperatorSelect.
-*/
-struct CMD_OperatorSelectionGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message provides the selected DSL operator.
-*/
-struct ACK_OperatorSelectionGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Selected DSL Operator */
-   DSL_uint16_t DslOperator;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Selected DSL Operator */
-   DSL_uint16_t DslOperator;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The messages configures settings for test modes.
-*/
-struct CMD_TestOptionsSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 11;
-   /** ATTNDR Improved Method Support (VDSL only) */
-   DSL_uint16_t AttndrImproved : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 2;
-   /** US Finegain Control */
-   DSL_uint16_t FgainControlUs : 1;
-   /** DS Finegain Control */
-   DSL_uint16_t FgainControlDs : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** DS Finegain Control */
-   DSL_uint16_t FgainControlDs : 1;
-   /** US Finegain Control */
-   DSL_uint16_t FgainControlUs : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 2;
-   /** ATTNDR Improved Method Support (VDSL only) */
-   DSL_uint16_t AttndrImproved : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 11;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This is the acknowledgement for CMD_TestOptionsSet.
-*/
-struct ACK_TestOptionsSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Sets the PPE clock. The message is supposed to be used for debug/test
-   purposes only. If applied this PPE clock is forced and will be kept
-   throughout the link. The PPE frequency scaling automode (see
-   CMD_PPE_ClockConfigure) will then not change it but behave as being disabled.
-*/
-struct CMD_ClockSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 11;
-   /** Clock Change Trigger */
-   DSL_uint16_t ppeClkSet : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 1;
-   /** PPE Clock */
-   DSL_uint16_t ppeClock : 3;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PPE Clock */
-   DSL_uint16_t ppeClock : 3;
-   /** Reserved */
-   DSL_uint16_t Res1 : 1;
-   /** Clock Change Trigger */
-   DSL_uint16_t ppeClkSet : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 11;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This is the acknowledgement for CMD_ClockSet.
-*/
-struct ACK_ClockSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Configures PPE clock options.The message CMD_ClockSet used for debug/test
-   purposes forces a PPE clock frequency which will be kept throughout the
-   link.. The PPE frequency scaling automode (see CMD_ClockSet) will then not
-   change it but behave as being disabled.
-*/
-struct CMD_PPE_ClockConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PPE Frequency Scaling Mode */
-   DSL_uint16_t FreqScaleMode;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PPE Frequency Scaling Mode */
-   DSL_uint16_t FreqScaleMode;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This is the acknowledgement for CMD_PPE_ClockConfigure.
-*/
-struct ACK_PPE_ClockConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reads PPE clock settings.
-*/
-struct CMD_PPE_ClockGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides PPE clock settings.
-*/
-struct ACK_PPE_ClockGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-   /** PPE Clock */
-   DSL_uint16_t ppeClock : 3;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PPE Clock */
-   DSL_uint16_t ppeClock : 3;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reads back PPE clock options.
-*/
-struct CMD_PPE_ClockConfigGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides PPE clock options.
-*/
-struct ACK_PPE_ClockConfigGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PPE Frequency Scaling Mode */
-   DSL_uint16_t FreqScaleMode;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PPE Frequency Scaling Mode */
-   DSL_uint16_t FreqScaleMode;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Sets an offset for the PLL frequency compared to the crystals rated nominal
-   frequency of 36 MHz. This allows e.g. to fine tune the handshake tone
-   frequencies to exactly match the standard values.
-*/
-struct CMD_PLL_ClockSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PLL Clock Offset in ppm */
-   DSL_int16_t pllClockOffset;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PLL Clock Offset in ppm */
-   DSL_int16_t pllClockOffset;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This is the acknowledgement for CMD_PLL_ClockSet.
-*/
-struct ACK_PLL_ClockSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#ifdef __PACKED_DEFINED__
-   #if !(defined (__GNUC__) || defined (__GNUG__))
-      #pragma pack()
-   #endif
-   #undef __PACKED_DEFINED__
-#endif /* __PACKED_DEFINED__ */
-
-/** @} */
-
-#endif /** _DRV_DSL_CPE_VRX_MSG_CONFIG_PMD_H_*/
--- a/src/include/mcat3.1/drv_dsl_cpe_vrx_msg_const.h
+++ /dev/null
@@ -1,611 +0,0 @@
-/******************************************************************************
-
-                            Copyright (c) 2007-2017
-                       Lantiq Beteiligungs-GmbH & Co. KG
-
-  For licensing information, see the file 'LICENSE' in the root folder of
-  this software module.
-
-******************************************************************************/
-
-
-#ifndef _DRV_DSL_CPE_VRX_MSG_CONST_H_
-#define _DRV_DSL_CPE_VRX_MSG_CONST_H_
-
-/** \file
-
-*/
-
-#ifndef __PACKED__
-   #if defined (__GNUC__) || defined (__GNUG__)
-      /* GNU C or C++ compiler */
-      #define __PACKED__ __attribute__ ((packed))
-   #else
-      /* Byte alignment adjustment */
-      #pragma pack(1)
-      #define __PACKED__      /* nothing */
-   #endif
-   #define __PACKED_DEFINED__ 1
-#endif
-
-
-/** @defgroup _CONST_
- *  @{
- */
-
-#ifdef __cplusplus
-   extern "C" {
-#endif
-
-/* ----- Common Constants Definition section ----- */
-/** Disable a functionality or state */
-#define VRX_DISABLE 0
-/** Enable a functionality or state */
-#define VRX_ENABLE 1
-/** Disable a functionality or state */
-#define VRX_DISABLE_N 1
-/** Enable a functionality or state */
-#define VRX_ENABLE_N 0
-/** Logical value TRUE */
-#define VRX_TRUE 1
-/** Logical value FALSE */
-#define VRX_FALSE 0
-/** Functionality is supported */
-#define SUPPORTED 1
-/** Functionality is not supported */
-#define NOT_SUPPORTED 0
-/** Counter value is below threshold */
-#define CNTR_OK 0
-/** Counter threshold met or exceeded */
-#define CNTR_THRESH_HIT 1
-/** Fixed Value of 0; Used for numbering parameters (like Array Index number or Length number) */
-#define FV0 0
-/** Fixed Value of 1; Used for numbering parameters (like Array Index number or Length number) */
-#define FV1 1
-/** Fixed Value of 2; Used for numbering parameters (like Array Index number or Length number) */
-#define FV2 2
-/** Fixed Value of 3; Used for numbering parameters (like Array Index number or Length number) */
-#define FV3 3
-/** Fixed Value of 4; Used for numbering parameters (like Array Index number or Length number) */
-#define FV4 4
-/** Fixed Value of 5; Used for numbering parameters (like Array Index number or Length number) */
-#define FV5 5
-/** Fixed Value of 6; Used for numbering parameters (like Array Index number or Length number) */
-#define FV6 6
-/** Fixed Value of 7; Used for numbering parameters (like Array Index number or Length number) */
-#define FV7 7
-/** Fixed Value of 8; Used for numbering parameters (like Array Index number or Length number) */
-#define FV8 8
-/** Fixed Value of 9; Used for numbering parameters (like Array Index number or Length number) */
-#define FV9 9
-/** Fixed Value of 10; Used for numbering parameters (like Array Index number or Length number) */
-#define FV10 10
-/** Fixed Value of 11; Used for numbering parameters (like Array Index number or Length number) */
-#define FV11 11
-/** Fixed Value of 12; Used for numbering parameters (like Array Index number or Length number) */
-#define FV12 12
-/** Fixed Value of 13; Used for numbering parameters (like Array Index number or Length number) */
-#define FV13 13
-/** Fixed Value of 15; Used for numbering parameters (like Array Index number or Length number) */
-#define FV15 15
-/** Fixed Value of 16; Used for numbering parameters (like Array Index number or Length number) */
-#define FV16 16
-/** Fixed Value of 17; Used for numbering parameters (like Array Index number or Length number) */
-#define FV17 17
-/** Fixed Value of 20; Used for numbering parameters (like Array Index number or Length number) */
-#define FV20 20
-/** Fixed Value of 32; Used for numbering parameters (like Array Index number or Length number) */
-#define FV32 32
-/** Fixed Value of 127; Used for numbering parameters (like Array Index number or Length number) */
-#define FV127 127
-/** Fixed Value of 128; Used for numbering parameters (like Array Index number or Length number) */
-#define FV128 128
-/** Fixed Value of 256; Used for numbering parameters (like Array Index number or Length number) */
-#define FV256 256
-/** Link 0 is selected */
-#define LINK0 0x0
-/** Link 1 is selected */
-#define LINK1 0x1
-/** No Failure */
-#define VRX_OK 0x0
-/** Failure */
-#define VRX_FAIL 0x1
-/** EOC Failure */
-#define VRX_EOCFAIL 0x2
-/** Request was rejected */
-#define VRX_REJECTED 0x1
-/* ----- Common Constants Definition section (End) ----- */
-/* ----- Message Specific Constants Definition section ----- */
-/* ----- Message Specific Constants Definition section (End) ----- */
-/**
-
-*/
-typedef struct VRX_BAT_TableEntry VRX_BAT_TableEntry_t;
-
-/**
-
-*/
-typedef struct VRX_ToneIndex VRX_ToneIndex_t;
-
-/**
-
-*/
-typedef struct VRX_PSDbreak VRX_PSDbreak_t;
-
-/**
-
-*/
-typedef struct VRX_PSD_TxDS VRX_PSD_TxDS_t;
-
-/**
-
-*/
-typedef struct VRX_PSDbreak2 VRX_PSDbreak2_t;
-
-/**
-
-*/
-typedef struct VRX_PSD_CompBreak VRX_PSD_CompBreak_t;
-
-/**
-
-*/
-typedef struct VRX_RxRef2PSD VRX_RxRef2PSD_t;
-
-/**
-
-*/
-typedef struct VRX_LineStatus_pb VRX_LineStatus_pb_t;
-
-/**
-
-*/
-typedef struct VRX_TSSIbreak VRX_TSSIbreak_t;
-
-/**
-
-*/
-typedef struct VRX_TSSI VRX_TSSI_t;
-
-/**
-
-*/
-typedef struct VRX_QLN_NE VRX_QLN_NE_t;
-
-/**
-
-*/
-typedef struct VRX_TestParam VRX_TestParam_t;
-
-/**
-
-*/
-typedef struct VRX_SNR VRX_SNR_t;
-
-/**
-
-*/
-typedef struct VRX_HLIN VRX_HLIN_t;
-
-/**
-
-*/
-typedef struct VRX_ClearEOC VRX_ClearEOC_t;
-
-/**
-
-*/
-typedef struct VRX_UER VRX_UER_t;
-
-/**
-
-*/
-typedef struct VRX_TIME VRX_TIME_t;
-
-/**
-
-*/
-typedef struct VRX_ATMcell VRX_ATMcell_t;
-
-/**
-
-*/
-struct VRX_BAT_TableEntry
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Bit Allocation */
-   DSL_uint8_t data_01;
-   /** Bit Allocation */
-   DSL_uint8_t data_00;
-#else
-   /** Bit Allocation */
-   DSL_uint8_t data_00;
-   /** Bit Allocation */
-   DSL_uint8_t data_01;
-#endif
-} __PACKED__ ;
-
-
-/**
-
-*/
-struct VRX_ToneIndex
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** First Tone Index */
-   DSL_uint16_t first;
-   /** Last Tone Index */
-   DSL_uint16_t last;
-#else
-   /** First Tone Index */
-   DSL_uint16_t first;
-   /** Last Tone Index */
-   DSL_uint16_t last;
-#endif
-} __PACKED__ ;
-
-
-/**
-
-*/
-struct VRX_PSDbreak
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Tone Index of Breakpoint */
-   DSL_uint16_t toneIndex;
-   /** PSD Level of Breakpoint */
-   DSL_uint16_t level;
-   /** Reserved */
-   DSL_uint16_t Res0;
-#else
-   /** Tone Index of Breakpoint */
-   DSL_uint16_t toneIndex;
-   /** PSD Level of Breakpoint */
-   DSL_uint16_t level;
-   /** Reserved */
-   DSL_uint16_t Res0;
-#endif
-} __PACKED__ ;
-
-
-/**
-
-*/
-struct VRX_PSD_TxDS
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Reserved */
-   DSL_uint8_t Res0;
-   /** Number of Breakpoints */
-   DSL_uint8_t NumBreakPts;
-   /** Breakpoint Descriptor TxPSDds */
-   VRX_PSDbreak_t breakpoint[48];
-#else
-   /** Number of Breakpoints */
-   DSL_uint8_t NumBreakPts;
-   /** Reserved */
-   DSL_uint8_t Res0;
-   /** Breakpoint Descriptor TxPSDds */
-   VRX_PSDbreak_t breakpoint[48];
-#endif
-} __PACKED__ ;
-
-
-/**
-
-*/
-struct VRX_PSDbreak2
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Tone Index of Breakpoint */
-   DSL_uint16_t toneIndex;
-   /** PSD Level of Breakpoint */
-   DSL_uint16_t level;
-#else
-   /** Tone Index of Breakpoint */
-   DSL_uint16_t toneIndex;
-   /** PSD Level of Breakpoint */
-   DSL_uint16_t level;
-#endif
-} __PACKED__ ;
-
-
-/**
-
-*/
-struct VRX_PSD_CompBreak
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Tone Index of Breakpoint */
-   DSL_uint16_t toneIndex;
-   /** Compensation Level of Breakpoint */
-   DSL_int16_t level;
-#else
-   /** Tone Index of Breakpoint */
-   DSL_uint16_t toneIndex;
-   /** Compensation Level of Breakpoint */
-   DSL_int16_t level;
-#endif
-} __PACKED__ ;
-
-
-/**
-
-*/
-struct VRX_RxRef2PSD
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** UPBO RxRefPSD Parameter "a" */
-   DSL_int16_t a;
-   /** UPBO RxRefPSD Parameter "b" */
-   DSL_int16_t b;
-#else
-   /** UPBO RxRefPSD Parameter "a" */
-   DSL_int16_t a;
-   /** UPBO RxRefPSD Parameter "b" */
-   DSL_int16_t b;
-#endif
-} __PACKED__ ;
-
-
-/**
-
-*/
-struct VRX_LineStatus_pb
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** LATN per Band */
-   DSL_uint16_t LATNpb;
-   /** SATN per Band */
-   DSL_uint16_t SATNpb;
-   /** SNRM per Band */
-   DSL_uint16_t SNRMpb;
-#else
-   /** LATN per Band */
-   DSL_uint16_t LATNpb;
-   /** SATN per Band */
-   DSL_uint16_t SATNpb;
-   /** SNRM per Band */
-   DSL_uint16_t SNRMpb;
-#endif
-} __PACKED__ ;
-
-
-/**
-
-*/
-struct VRX_TSSIbreak
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Supported Set Status */
-   DSL_uint16_t supset : 1;
-   /** Tone Index of Breakpoint */
-   DSL_uint16_t toneIndex : 15;
-   /** Transmit Spectrum Shaping Value of Breakpoint */
-   DSL_uint16_t level;
-#else
-   /** Tone Index of Breakpoint */
-   DSL_uint16_t toneIndex : 15;
-   /** Supported Set Status */
-   DSL_uint16_t supset : 1;
-   /** Transmit Spectrum Shaping Value of Breakpoint */
-   DSL_uint16_t level;
-#endif
-} __PACKED__ ;
-
-
-/**
-
-*/
-struct VRX_TSSI
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Number of breakpoints */
-   DSL_uint16_t Num;
-   /** TSSI breakpoints */
-   VRX_TSSIbreak_t TSSIbrkp[64];
-#else
-   /** Number of breakpoints */
-   DSL_uint16_t Num;
-   /** TSSI breakpoints */
-   VRX_TSSIbreak_t TSSIbrkp[64];
-#endif
-} __PACKED__ ;
-
-
-/**
-
-*/
-struct VRX_QLN_NE
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** QLN per Subcarrier Group */
-   DSL_uint8_t qln_01;
-   /** QLN per Subcarrier Group */
-   DSL_uint8_t qln_00;
-#else
-   /** QLN per Subcarrier Group */
-   DSL_uint8_t qln_00;
-   /** QLN per Subcarrier Group */
-   DSL_uint8_t qln_01;
-#endif
-} __PACKED__ ;
-
-
-/**
-
-*/
-struct VRX_TestParam
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** HLOG per Subcarrier Group */
-   DSL_uint16_t hlog;
-   /** SNR per Subcarrier Group */
-   DSL_uint8_t snr;
-   /** QLN per Subcarrier Group */
-   DSL_uint8_t qln;
-#else
-   /** HLOG per Subcarrier Group */
-   DSL_uint16_t hlog;
-   /** QLN per Subcarrier Group */
-   DSL_uint8_t qln;
-   /** SNR per Subcarrier Group */
-   DSL_uint8_t snr;
-#endif
-} __PACKED__ ;
-
-
-/**
-
-*/
-struct VRX_SNR
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** SNR per Subcarrier Group */
-   DSL_uint8_t snr_01;
-   /** SNR per Subcarrier Group */
-   DSL_uint8_t snr_00;
-#else
-   /** SNR per Subcarrier Group */
-   DSL_uint8_t snr_00;
-   /** SNR per Subcarrier Group */
-   DSL_uint8_t snr_01;
-#endif
-} __PACKED__ ;
-
-
-/**
-
-*/
-struct VRX_HLIN
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** HLIN per Subcarrier Group, Real Part */
-   DSL_int16_t hlin_real;
-   /** HLIN per Subcarrier Group, Imaginary Part */
-   DSL_int16_t hlin_imag;
-#else
-   /** HLIN per Subcarrier Group, Real Part */
-   DSL_int16_t hlin_real;
-   /** HLIN per Subcarrier Group, Imaginary Part */
-   DSL_int16_t hlin_imag;
-#endif
-} __PACKED__ ;
-
-
-/**
-
-*/
-struct VRX_ClearEOC
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Reserved  */
-   DSL_uint16_t Res0 : 6;
-   /** Length of the Clear EOC Message  */
-   DSL_uint16_t Length : 10;
-   /** Protocol Identifier */
-   DSL_uint16_t ProtIdent;
-   /** Clear EOC data field */
-   DSL_uint8_t Data[508];
-#else
-   /** Length of the Clear EOC Message  */
-   DSL_uint16_t Length : 10;
-   /** Reserved  */
-   DSL_uint16_t Res0 : 6;
-   /** Protocol Identifier */
-   DSL_uint16_t ProtIdent;
-   /** Clear EOC data field */
-   DSL_uint8_t Data[508];
-#endif
-} __PACKED__ ;
-
-
-/**
-
-*/
-struct VRX_UER
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** UERps Real Part, LSW */
-   DSL_uint16_t UER_Real_LSW;
-   /** UERps Real Part, MSW */
-   DSL_uint16_t UER_Real_MSW;
-   /** UERps Imaginary Part, LSW */
-   DSL_uint16_t UER_Imag_LSW;
-   /** UERps Imaginary Part, MSW */
-   DSL_uint16_t UER_Imag_MSW;
-#else
-   /** UERps Real Part, LSW */
-   DSL_uint16_t UER_Real_LSW;
-   /** UERps Real Part, MSW */
-   DSL_uint16_t UER_Real_MSW;
-   /** UERps Imaginary Part, LSW */
-   DSL_uint16_t UER_Imag_LSW;
-   /** UERps Imaginary Part, MSW */
-   DSL_uint16_t UER_Imag_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-
-*/
-struct VRX_TIME
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Hours */
-   DSL_uint8_t hours;
-   /** Minutes */
-   DSL_uint8_t minutes;
-   /** Seconds */
-   DSL_uint8_t seconds;
-   /** Reserved */
-   DSL_uint8_t Res0;
-#else
-   /** Minutes */
-   DSL_uint8_t minutes;
-   /** Hours */
-   DSL_uint8_t hours;
-   /** Reserved */
-   DSL_uint8_t Res0;
-   /** Seconds */
-   DSL_uint8_t seconds;
-#endif
-} __PACKED__ ;
-
-
-/**
-
-*/
-struct VRX_ATMcell
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** ATM cell (53 bytes) */
-   DSL_uint8_t ATMcell[53];
-   /** Reserved */
-   DSL_uint8_t Res0[3];
-#else
-   /** ATM cell (53 bytes) */
-   DSL_uint8_t ATMcell[53];
-   /** Reserved */
-   DSL_uint8_t Res0[3];
-#endif
-} __PACKED__ ;
-
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#ifdef __PACKED_DEFINED__
-   #if !(defined (__GNUC__) || defined (__GNUG__))
-      #pragma pack()
-   #endif
-   #undef __PACKED_DEFINED__
-#endif /* __PACKED_DEFINED__ */
-
-/** @} */
-
-#endif /** _DRV_DSL_CPE_VRX_MSG_CONST_H_*/
--- a/src/include/mcat3.1/drv_dsl_cpe_vrx_msg_dmt_scope.h
+++ /dev/null
@@ -1,571 +0,0 @@
-/******************************************************************************
-
-                            Copyright (c) 2007-2017
-                       Lantiq Beteiligungs-GmbH & Co. KG
-
-  For licensing information, see the file 'LICENSE' in the root folder of
-  this software module.
-
-******************************************************************************/
-
-
-#ifndef _DRV_DSL_CPE_VRX_MSG_DMT_SCOPE_H_
-#define _DRV_DSL_CPE_VRX_MSG_DMT_SCOPE_H_
-
-/** \file
-
-*/
-
-#ifndef __PACKED__
-   #if defined (__GNUC__) || defined (__GNUG__)
-      /* GNU C or C++ compiler */
-      #define __PACKED__ __attribute__ ((packed))
-   #else
-      /* Byte alignment adjustment */
-      #pragma pack(1)
-      #define __PACKED__      /* nothing */
-   #endif
-   #define __PACKED_DEFINED__ 1
-#endif
-
-
-/** @defgroup _DMT_SCOPE_
- *  @{
- */
-
-#ifdef __cplusplus
-   extern "C" {
-#endif
-
-/* ----- Message Specific Constants Definition section ----- */
-#define CMD_TEST_AFE_LoopControl_NO_LOOP 0x0
-#define CMD_TEST_AFE_LoopControl_ALOOP 0x1
-#define CMD_TEST_TxControlSet_SEND_QUIET 0
-#define CMD_TEST_TxControlSet_SEND_REVERB 1
-#define CMD_TEST_TxControlSet_SEND_SEGUE 2
-#define CMD_TEST_TxControlSet_SEND_MEDLEY 3
-#define CMD_TEST_RxControlSet_MEASURE_PSD 14
-#define CMD_TEST_RxControlSet_FDQ_TRAINING 16
-#define CMD_TEST_RxControlSet_MEASURE_SNR 17
-#define CMD_TEST_RxControlSet_PGA_TRAINING 19
-#define CMD_TEST_RxPSD_MeasureModeSet_AVERAGE 0x0
-#define CMD_TEST_RxPSD_MeasureModeSet_PEAKHOLD 0x1
-#define CMD_TEST_RxPSD_MeasureModeSet_BOTTOMHOLD 0x2
-#define CMD_TEST_RxGainControl_DEFGAIN 0x0
-#define CMD_TEST_RxGainControl_MAXGAIN 0x1
-/* ----- Message Specific Constants Definition section (End) ----- */
-
-/** Message ID for CMD_TEST_AFE_LoopControl */
-#define CMD_TEST_AFE_LOOPCONTROL 0x0156
-
-/**
-   This message can be used to enable or disable the (analog) loop within the
-   Analog Front-End (AFE) to loop back data from the transmit to the receive
-   part.
-*/
-typedef struct CMD_TEST_AFE_LoopControl CMD_TEST_AFE_LoopControl_t;
-
-/** Message ID for ACK_TEST_AFE_LoopControl */
-#define ACK_TEST_AFE_LOOPCONTROL 0x0156
-
-/**
-   This message acknowledges the message CMD_TEST_AFE_LoopControl.For TEST state
-   only!
-*/
-typedef struct ACK_TEST_AFE_LoopControl ACK_TEST_AFE_LoopControl_t;
-
-/** Message ID for CMD_TEST_TxControlSet */
-#define CMD_TEST_TXCONTROLSET 0x0844
-
-/**
-   The message controls the transmit signal in TEST state. Each setting is valid
-   until either another value is set with this message that requires the
-   previous setting to be overwritten or until TEST state is left.
-*/
-typedef struct CMD_TEST_TxControlSet CMD_TEST_TxControlSet_t;
-
-/** Message ID for ACK_TEST_TxControlSet */
-#define ACK_TEST_TXCONTROLSET 0x0844
-
-/**
-   Acknowledgement for message CMD_TEST_TxControlSet.
-*/
-typedef struct ACK_TEST_TxControlSet ACK_TEST_TxControlSet_t;
-
-/** Message ID for CMD_TEST_CarrierMaskingTxSet */
-#define CMD_TEST_CARRIERMASKINGTXSET 0x0256
-
-/**
-   Masks out every 100th subcarrier starting from an arbitrary index number
-   1...99.The carrier-mask is applied to signals in the frequency domain ("Send
-   REVERB" and "Send MEDLEY"). The signal must be activated before!
-*/
-typedef struct CMD_TEST_CarrierMaskingTxSet CMD_TEST_CarrierMaskingTxSet_t;
-
-/** Message ID for ACK_TEST_CarrierMaskingTxSet */
-#define ACK_TEST_CARRIERMASKINGTXSET 0x0256
-
-/**
-   Acknowledgement for message CMD_TEST_CarrierMaskingTxSet.
-*/
-typedef struct ACK_TEST_CarrierMaskingTxSet ACK_TEST_CarrierMaskingTxSet_t;
-
-/** Message ID for CMD_TEST_RxControlSet */
-#define CMD_TEST_RXCONTROLSET 0x0944
-
-/**
-   The message triggers measurements of the receive signal.
-*/
-typedef struct CMD_TEST_RxControlSet CMD_TEST_RxControlSet_t;
-
-/** Message ID for ACK_TEST_RxControlSet */
-#define ACK_TEST_RXCONTROLSET 0x0944
-
-/**
-   Acknowledgement for message CMD_TEST_RxControlSet.
-*/
-typedef struct ACK_TEST_RxControlSet ACK_TEST_RxControlSet_t;
-
-/** Message ID for CMD_TEST_RxPSD_TableEntriesGet */
-#define CMD_TEST_RXPSD_TABLEENTRIESGET 0x5403
-
-/**
-   The message requests information about the receive PSD per subcarrier
-   available at the near-end side, which means for downstream direction at the
-   CPE. It is the hosts responsibility to select the tone indices accordingly.
-*/
-typedef struct CMD_TEST_RxPSD_TableEntriesGet CMD_TEST_RxPSD_TableEntriesGet_t;
-
-/** Message ID for ACK_TEST_RxPSD_TableEntriesGet */
-#define ACK_TEST_RXPSD_TABLEENTRIESGET 0x5403
-
-/**
-   Returns information about the receive PSD per subcarrier available at the
-   near-end side, which means for downstream direction at the CPE.
-*/
-typedef struct ACK_TEST_RxPSD_TableEntriesGet ACK_TEST_RxPSD_TableEntriesGet_t;
-
-/** Message ID for CMD_TEST_RxPSD_Calibrate */
-#define CMD_TEST_RXPSD_CALIBRATE 0x0356
-
-/**
-   Sets the board specific calibration factor necessary to calculate the
-   absolute PSD value per subcarrier.Attention: The command needs to be applied
-   only once after power-up for a calibration value determined according to the
-   sequence described below ("Getting the calibration value:"). Applying the
-   command a second time requires another determination of the calibration value
-   too, because the shift is always relative to the current values.
-*/
-typedef struct CMD_TEST_RxPSD_Calibrate CMD_TEST_RxPSD_Calibrate_t;
-
-/** Message ID for ACK_TEST_RxPSD_Calibrate */
-#define ACK_TEST_RXPSD_CALIBRATE 0x0356
-
-/**
-   Acknowledgement to CMD_TEST_RxPSD_Calibrate.
-*/
-typedef struct ACK_TEST_RxPSD_Calibrate ACK_TEST_RxPSD_Calibrate_t;
-
-/** Message ID for CMD_TEST_RxPSD_MeasureModeSet */
-#define CMD_TEST_RXPSD_MEASUREMODESET 0x0456
-
-/**
-   Configures options for the measurement of the PSD value per subcarrier.
-*/
-typedef struct CMD_TEST_RxPSD_MeasureModeSet CMD_TEST_RxPSD_MeasureModeSet_t;
-
-/** Message ID for ACK_TEST_RxPSD_MeasureModeSet */
-#define ACK_TEST_RXPSD_MEASUREMODESET 0x0456
-
-/**
-   Acknowledgement to CMD_TEST_RxPSD_MeasureModeSet.
-*/
-typedef struct ACK_TEST_RxPSD_MeasureModeSet ACK_TEST_RxPSD_MeasureModeSet_t;
-
-/** Message ID for CMD_TEST_RxGainControl */
-#define CMD_TEST_RXGAINCONTROL 0x0556
-
-/**
-   Sets the gains in the receive path (AGC, ACE, PREFI).
-*/
-typedef struct CMD_TEST_RxGainControl CMD_TEST_RxGainControl_t;
-
-/** Message ID for ACK_TEST_RxGainControl */
-#define ACK_TEST_RXGAINCONTROL 0x0556
-
-/**
-   Acknowledgement to CMD_TEST_RxGainControl.
-*/
-typedef struct ACK_TEST_RxGainControl ACK_TEST_RxGainControl_t;
-
-/**
-   This message can be used to enable or disable the (analog) loop within the
-   Analog Front-End (AFE) to loop back data from the transmit to the receive
-   part.
-*/
-struct CMD_TEST_AFE_LoopControl
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** AFE Loop Control */
-   DSL_uint32_t loopControl;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** AFE Loop Control */
-   DSL_uint32_t loopControl;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This message acknowledges the message CMD_TEST_AFE_LoopControl.For TEST state
-   only!
-*/
-struct ACK_TEST_AFE_LoopControl
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message controls the transmit signal in TEST state. Each setting is valid
-   until either another value is set with this message that requires the
-   previous setting to be overwritten or until TEST state is left.
-*/
-struct CMD_TEST_TxControlSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TEST State's Transmit Signal Control */
-   DSL_uint16_t TxControl;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TEST State's Transmit Signal Control */
-   DSL_uint16_t TxControl;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for message CMD_TEST_TxControlSet.
-*/
-struct ACK_TEST_TxControlSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Masks out every 100th subcarrier starting from an arbitrary index number
-   1...99.The carrier-mask is applied to signals in the frequency domain ("Send
-   REVERB" and "Send MEDLEY"). The signal must be activated before!
-*/
-struct CMD_TEST_CarrierMaskingTxSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** First Masked Tone */
-   DSL_uint32_t MaskTone0;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** First Masked Tone */
-   DSL_uint32_t MaskTone0;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for message CMD_TEST_CarrierMaskingTxSet.
-*/
-struct ACK_TEST_CarrierMaskingTxSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message triggers measurements of the receive signal.
-*/
-struct CMD_TEST_RxControlSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TEST State's Receive Control */
-   DSL_uint16_t RxControl;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TEST State's Receive Control */
-   DSL_uint16_t RxControl;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for message CMD_TEST_RxControlSet.
-*/
-struct ACK_TEST_RxControlSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message requests information about the receive PSD per subcarrier
-   available at the near-end side, which means for downstream direction at the
-   CPE. It is the hosts responsibility to select the tone indices accordingly.
-*/
-struct CMD_TEST_RxPSD_TableEntriesGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the receive PSD per subcarrier available at the
-   near-end side, which means for downstream direction at the CPE.
-*/
-struct ACK_TEST_RxPSD_TableEntriesGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Receive PSD */
-   DSL_uint16_t PSDps[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Receive PSD */
-   DSL_uint16_t PSDps[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Sets the board specific calibration factor necessary to calculate the
-   absolute PSD value per subcarrier.Attention: The command needs to be applied
-   only once after power-up for a calibration value determined according to the
-   sequence described below ("Getting the calibration value:"). Applying the
-   command a second time requires another determination of the calibration value
-   too, because the shift is always relative to the current values.
-*/
-struct CMD_TEST_RxPSD_Calibrate
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** RxPSD Calibration Value */
-   DSL_uint32_t calibration;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** RxPSD Calibration Value */
-   DSL_uint32_t calibration;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_TEST_RxPSD_Calibrate.
-*/
-struct ACK_TEST_RxPSD_Calibrate
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Configures options for the measurement of the PSD value per subcarrier.
-*/
-struct CMD_TEST_RxPSD_MeasureModeSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** RxPSD Measurement Mode */
-   DSL_uint32_t MeasureMode;
-   /** Number of Frames */
-   DSL_uint32_t numOfFrames;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** RxPSD Measurement Mode */
-   DSL_uint32_t MeasureMode;
-   /** Number of Frames */
-   DSL_uint32_t numOfFrames;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_TEST_RxPSD_MeasureModeSet.
-*/
-struct ACK_TEST_RxPSD_MeasureModeSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Sets the gains in the receive path (AGC, ACE, PREFI).
-*/
-struct CMD_TEST_RxGainControl
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Rx Gain Level */
-   DSL_uint32_t RxGainLevel;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Rx Gain Level */
-   DSL_uint32_t RxGainLevel;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_TEST_RxGainControl.
-*/
-struct ACK_TEST_RxGainControl
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#ifdef __PACKED_DEFINED__
-   #if !(defined (__GNUC__) || defined (__GNUG__))
-      #pragma pack()
-   #endif
-   #undef __PACKED_DEFINED__
-#endif /* __PACKED_DEFINED__ */
-
-/** @} */
-
-#endif /** _DRV_DSL_CPE_VRX_MSG_DMT_SCOPE_H_*/
--- a/src/include/mcat3.1/drv_dsl_cpe_vrx_msg_ghs_status.h
+++ /dev/null
@@ -1,5422 +0,0 @@
-/******************************************************************************
-
-                            Copyright (c) 2007-2017
-                       Lantiq Beteiligungs-GmbH & Co. KG
-
-  For licensing information, see the file 'LICENSE' in the root folder of
-  this software module.
-
-******************************************************************************/
-
-
-#ifndef _DRV_DSL_CPE_VRX_MSG_GHS_STATUS_H_
-#define _DRV_DSL_CPE_VRX_MSG_GHS_STATUS_H_
-
-/** \file
-
-*/
-
-#ifndef __PACKED__
-   #if defined (__GNUC__) || defined (__GNUG__)
-      /* GNU C or C++ compiler */
-      #define __PACKED__ __attribute__ ((packed))
-   #else
-      /* Byte alignment adjustment */
-      #pragma pack(1)
-      #define __PACKED__      /* nothing */
-   #endif
-   #define __PACKED_DEFINED__ 1
-#endif
-
-
-/** @defgroup _GHS_STATUS_
- *  @{
- */
-
-#ifdef __cplusplus
-   extern "C" {
-#endif
-
-/* ----- Message Specific Constants Definition section ----- */
-#define ACK_T1413_RevNo_O_Get_T1413REV1 0x0
-#define ACK_T1413_RevNo_O_Get_T1413REV2 0x1
-#define ACK_T1413_RevNo_R_Get_T1413REV1 0x0
-#define ACK_T1413_RevNo_R_Get_T1413REV2 0x1
-#define CMD_RFI_BandControlGet_FV 33
-#define ACK_RFI_BandControlGet_FV 33
-#define CMD_LineStatusPerBandDS_Get_FV 25
-#define ACK_LineStatusPerBandDS_Get_FV 25
-#define CMD_LineStatusPerBandUS_Get_FV 25
-#define ACK_LineStatusPerBandUS_Get_FV 25
-#define CMD_PSD_BreakpointsUS_Get_FV 97
-#define ACK_PSD_BreakpointsUS_Get_FV 97
-#define CMD_BearerChsDS_Get_FV 18
-#define ACK_BearerChsDS_Get_FV 18
-#define CMD_BearerChsUS_Get_FV 18
-#define ACK_BearerChsUS_Get_FV 18
-#define CMD_FrameDataExt2DS_Get_FV 42
-#define ACK_FrameDataExt2DS_Get_FV 42
-#define CMD_FrameDataExt2US_Get_FV 42
-#define ACK_FrameDataExt2US_Get_FV 42
-#define ACK_HybridGet_POTS 0x1
-#define ACK_HybridGet_ISDN_B 0x2
-#define ACK_HybridGet_ISDN_BJ 0x3
-#define ACK_HybridGet_UNIVERSAL 0x4
-#define ACK_MFD_ResultsGet_NONLNF 0x0
-#define ACK_MFD_ResultsGet_NLNFTRIGGERED 0x1
-#define ACK_MFD_ResultsGet_NLNFSTARTED 0x2
-#define ACK_MFD_ResultsGet_NLNFDONE 0x3
-#define ACK_MFD_ResultsGet_NORANGE 0x0
-#define ACK_MFD_ResultsGet_SHORTRANGE 0x1
-#define ACK_MFD_ResultsGet_MIDRANGE 0x2
-#define ACK_MFD_ResultsGet_LONGRANGE 0x3
-#define ACK_MFD_ResultsGet_READY 0x1
-#define ACK_MFD_ResultsGet_NOT_READY 0x0
-/* ----- Message Specific Constants Definition section (End) ----- */
-
-/** Message ID for CMD_HS_ToneGroupSet */
-#define CMD_HS_TONEGROUPSET 0x2D48
-
-/**
-   Selects one or more groups of tones to be used during the handshake phase.
-   (See G.994.1 Amendment 2 [8], Table 1/G.994.1).
-*/
-typedef struct CMD_HS_ToneGroupSet CMD_HS_ToneGroupSet_t;
-
-/** Message ID for ACK_HS_ToneGroupSet */
-#define ACK_HS_TONEGROUPSET 0x2D48
-
-/**
-   Acknowledgement to CMD_HS_ToneGroupSet.
-*/
-typedef struct ACK_HS_ToneGroupSet ACK_HS_ToneGroupSet_t;
-
-/** Message ID for CMD_HS_VDSL2ProfileControl */
-#define CMD_HS_VDSL2PROFILECONTROL 0x2C48
-
-/**
-   Configures the profile settings to be used for the handshake phase. (See
-   G.994.1 Amendment 4 [10], NPAR(3) coding).
-*/
-typedef struct CMD_HS_VDSL2ProfileControl CMD_HS_VDSL2ProfileControl_t;
-
-/** Message ID for ACK_HS_VDSL2ProfileControl */
-#define ACK_HS_VDSL2PROFILECONTROL 0x2C48
-
-/**
-   Acknowledgement to CMD_HS_VDSL2ProfileControl.
-*/
-typedef struct ACK_HS_VDSL2ProfileControl ACK_HS_VDSL2ProfileControl_t;
-
-/** Message ID for CMD_HS_StandardInfoFE_VDSL2Get */
-#define CMD_HS_STANDARDINFOFE_VDSL2GET 0xCC03
-
-/**
-   Requests the VDSL2 far-end Standard Info (See G.994.1 Amendment 4 [10],
-   NPAR(3) coding).
-*/
-typedef struct CMD_HS_StandardInfoFE_VDSL2Get CMD_HS_StandardInfoFE_VDSL2Get_t;
-
-/** Message ID for ACK_HS_StandardInfoFE_VDSL2Get */
-#define ACK_HS_STANDARDINFOFE_VDSL2GET 0xCC03
-
-/**
-   Delivers the VDSL2 far-end info as requested by
-   CMD_HS_StandardInfoFE_VDSL2Get (see G.994.1 Amendment 4 [10], NPAR(3)
-   coding).
-*/
-typedef struct ACK_HS_StandardInfoFE_VDSL2Get ACK_HS_StandardInfoFE_VDSL2Get_t;
-
-/** Message ID for CMD_HS_SelectedProfileVDSL2Get */
-#define CMD_HS_SELECTEDPROFILEVDSL2GET 0xCD03
-
-/**
-   Requests the actual selected VDSL2 Profile (See G.994.1 Amendment 4 [10],
-   NPAR(3) coding).
-*/
-typedef struct CMD_HS_SelectedProfileVDSL2Get CMD_HS_SelectedProfileVDSL2Get_t;
-
-/** Message ID for ACK_HS_SelectedProfileVDSL2Get */
-#define ACK_HS_SELECTEDPROFILEVDSL2GET 0xCD03
-
-/**
-   Provides the actual selected VDSL2 Profile as requested by
-   CMD_HS_SelectedProfileVDSL2Get (see G.994.1 Amendment 4 [10], NPAR(3)
-   coding).
-*/
-typedef struct ACK_HS_SelectedProfileVDSL2Get ACK_HS_SelectedProfileVDSL2Get_t;
-
-/** Message ID for CMD_HS_StandardInfoFE_SPAR1Get */
-#define CMD_HS_STANDARDINFOFE_SPAR1GET 0xCB03
-
-/**
-   Requests the handshake information about the far-end operating mode (See
-   G.994.1 [6] and Amendments 1-4 [7]-[10], standard information fields- SPAR(1)
-   coding).
-*/
-typedef struct CMD_HS_StandardInfoFE_SPAR1Get CMD_HS_StandardInfoFE_SPAR1Get_t;
-
-/** Message ID for ACK_HS_StandardInfoFE_SPAR1Get */
-#define ACK_HS_STANDARDINFOFE_SPAR1GET 0xCB03
-
-/**
-   Provides the handshake information about the far-end operating mode (See
-   G.994.1 [6] and Amendments 1-4 [7]-[10], Standard information field - SPAR(1)
-   coding). The bit numbering per octet below follows the standard (starting
-   with "1").
-*/
-typedef struct ACK_HS_StandardInfoFE_SPAR1Get ACK_HS_StandardInfoFE_SPAR1Get_t;
-
-/** Message ID for CMD_SysVendorID_R_Set */
-#define CMD_SYSVENDORID_R_SET 0x3C43
-
-/**
-   Sets the in System Vendor ID at the xTU-R. (Section 7.4.4 of G.997.1 [11])
-*/
-typedef struct CMD_SysVendorID_R_Set CMD_SysVendorID_R_Set_t;
-
-/** Message ID for ACK_SysVendorID_R_Set */
-#define ACK_SYSVENDORID_R_SET 0x3C43
-
-/**
-   Acknowledgement to CMD_SysVendorID_R_Set.
-*/
-typedef struct ACK_SysVendorID_R_Set ACK_SysVendorID_R_Set_t;
-
-/** Message ID for CMD_SysVendorVersionNum_R_Set */
-#define CMD_SYSVENDORVERSIONNUM_R_SET 0x3D43
-
-/**
-   Sets the system vendor version number at the xTU-R. (Section 7.4.6 of G.997.1
-   [11])
-*/
-typedef struct CMD_SysVendorVersionNum_R_Set CMD_SysVendorVersionNum_R_Set_t;
-
-/** Message ID for ACK_SysVendorVersionNum_R_Set */
-#define ACK_SYSVENDORVERSIONNUM_R_SET 0x3D43
-
-/**
-   Acknowledgement to CMD_SysVendorVersionNum_R_Set.
-*/
-typedef struct ACK_SysVendorVersionNum_R_Set ACK_SysVendorVersionNum_R_Set_t;
-
-/** Message ID for CMD_SysVendorSerialNum_R_Set */
-#define CMD_SYSVENDORSERIALNUM_R_SET 0x3E43
-
-/**
-   Sets the system vendor serial number at the xTU-R. (Section 7.4.8 of G.997.1
-   [11])
-*/
-typedef struct CMD_SysVendorSerialNum_R_Set CMD_SysVendorSerialNum_R_Set_t;
-
-/** Message ID for ACK_SysVendorSerialNum_R_Set */
-#define ACK_SYSVENDORSERIALNUM_R_SET 0x3E43
-
-/**
-   Acknowledgement to CMD_SysVendorSerialNum_R_Set.
-*/
-typedef struct ACK_SysVendorSerialNum_R_Set ACK_SysVendorSerialNum_R_Set_t;
-
-/** Message ID for CMD_AuxInventoryInfo_R_Set */
-#define CMD_AUXINVENTORYINFO_R_SET 0x4343
-
-/**
-   Sets auxiliary inventory information at the VTU-R (Section 11.2.3.2.4 of
-   G993.2 [5]).
-*/
-typedef struct CMD_AuxInventoryInfo_R_Set CMD_AuxInventoryInfo_R_Set_t;
-
-/** Message ID for ACK_AuxInventoryInfo_R_Set */
-#define ACK_AUXINVENTORYINFO_R_SET 0x4343
-
-/**
-   Acknowledgement to CMD_AuxInventoryInfo_R_Set.
-*/
-typedef struct ACK_AuxInventoryInfo_R_Set ACK_AuxInventoryInfo_R_Set_t;
-
-/** Message ID for CMD_VendorID_O_Get */
-#define CMD_VENDORID_O_GET 0x4003
-
-/**
-   Requests the xTU-C Vendor ID. (Section 7.4.1 of G.997.1 [11])
-*/
-typedef struct CMD_VendorID_O_Get CMD_VendorID_O_Get_t;
-
-/** Message ID for ACK_VendorID_O_Get */
-#define ACK_VENDORID_O_GET 0x4003
-
-/**
-   Provides the xTU-C Vendor ID as requested by CMD_VendorID_O_Get.
-*/
-typedef struct ACK_VendorID_O_Get ACK_VendorID_O_Get_t;
-
-/** Message ID for CMD_VendorID_R_Get */
-#define CMD_VENDORID_R_GET 0x4103
-
-/**
-   Requests the xTU-R Vendor ID. (Section 7.4.2 of G.997.1 [11])
-*/
-typedef struct CMD_VendorID_R_Get CMD_VendorID_R_Get_t;
-
-/** Message ID for ACK_VendorID_R_Get */
-#define ACK_VENDORID_R_GET 0x4103
-
-/**
-   Provides the xTU-R Vendor ID as requested by CMD_VendorID_R_Get.
-*/
-typedef struct ACK_VendorID_R_Get ACK_VendorID_R_Get_t;
-
-/** Message ID for CMD_SysVendorID_O_Get */
-#define CMD_SYSVENDORID_O_GET 0x3803
-
-/**
-   Requests the xTU-C System Vendor ID. (Section 7.4.3 of G.997.1 [11])
-*/
-typedef struct CMD_SysVendorID_O_Get CMD_SysVendorID_O_Get_t;
-
-/** Message ID for ACK_SysVendorID_O_Get */
-#define ACK_SYSVENDORID_O_GET 0x3803
-
-/**
-   Delivers the xTU-C System Vendor ID as requested by CMD_SysVendorID_O_Get.
-*/
-typedef struct ACK_SysVendorID_O_Get ACK_SysVendorID_O_Get_t;
-
-/** Message ID for CMD_SysVendorID_R_Get */
-#define CMD_SYSVENDORID_R_GET 0x3C03
-
-/**
-   Requests the xTU-R System Vendor ID. (Section 7.4.4 of G.997.1 [11])
-*/
-typedef struct CMD_SysVendorID_R_Get CMD_SysVendorID_R_Get_t;
-
-/** Message ID for ACK_SysVendorID_R_Get */
-#define ACK_SYSVENDORID_R_GET 0x3C03
-
-/**
-   Delivers the xTU-R System Vendor ID as requested by CMD_SysVendorID_R_Get.
-*/
-typedef struct ACK_SysVendorID_R_Get ACK_SysVendorID_R_Get_t;
-
-/** Message ID for CMD_SysVendorVersionNumO_Get */
-#define CMD_SYSVENDORVERSIONNUMO_GET 0x3A03
-
-/**
-   Requests the xTU-C system vendor version number. (Section 7.4.5 of G.997.1
-   [11])
-*/
-typedef struct CMD_SysVendorVersionNumO_Get CMD_SysVendorVersionNumO_Get_t;
-
-/** Message ID for ACK_SysVendorVersionNum_O_Get */
-#define ACK_SYSVENDORVERSIONNUM_O_GET 0x3A03
-
-/**
-   Delivers the xTU-C system vendor version number as requested by
-   CMD_SysVendorVersionNumO_Get.
-*/
-typedef struct ACK_SysVendorVersionNum_O_Get ACK_SysVendorVersionNum_O_Get_t;
-
-/** Message ID for CMD_SysVendorVersionNum_R_Get */
-#define CMD_SYSVENDORVERSIONNUM_R_GET 0x3D03
-
-/**
-   Requests the xTU-R system vendor version number. (Section 7.4.6 of G.997.1
-   [11])
-*/
-typedef struct CMD_SysVendorVersionNum_R_Get CMD_SysVendorVersionNum_R_Get_t;
-
-/** Message ID for ACK_SysVendorVersionNum_R_Get */
-#define ACK_SYSVENDORVERSIONNUM_R_GET 0x3D03
-
-/**
-   Delivers the xTU-R system vendor version number as requested by
-   CMD_SysVendorVersionNum_R_Get.
-*/
-typedef struct ACK_SysVendorVersionNum_R_Get ACK_SysVendorVersionNum_R_Get_t;
-
-/** Message ID for CMD_SysVendorSerialNum_O_Get */
-#define CMD_SYSVENDORSERIALNUM_O_GET 0x3903
-
-/**
-   Requests the xTU-C system vendor serial number. (Section 7.4.7 of G.997.1
-   [11])
-*/
-typedef struct CMD_SysVendorSerialNum_O_Get CMD_SysVendorSerialNum_O_Get_t;
-
-/** Message ID for ACK_SysVendorSerialNum_O_Get */
-#define ACK_SYSVENDORSERIALNUM_O_GET 0x3903
-
-/**
-   Delivers the xTU-C system vendor serial number as requested by
-   CMD_SysVendorSerialNum_O_Get.
-*/
-typedef struct ACK_SysVendorSerialNum_O_Get ACK_SysVendorSerialNum_O_Get_t;
-
-/** Message ID for CMD_SysVendorSerialNum_R_Get */
-#define CMD_SYSVENDORSERIALNUM_R_GET 0x3E03
-
-/**
-   Requests the xTU-R system vendor serial number. (Section 7.4.8 of G.997.1
-   [11])
-*/
-typedef struct CMD_SysVendorSerialNum_R_Get CMD_SysVendorSerialNum_R_Get_t;
-
-/** Message ID for ACK_SysVendorSerialNum_R_Get */
-#define ACK_SYSVENDORSERIALNUM_R_GET 0x3E03
-
-/**
-   Delivers the xTU-R system vendor version number as requested by
-   CMD_SysVendorSerialNum_R_Get.
-*/
-typedef struct ACK_SysVendorSerialNum_R_Get ACK_SysVendorSerialNum_R_Get_t;
-
-/** Message ID for CMD_AuxInventoryInfo_O_Get */
-#define CMD_AUXINVENTORYINFO_O_GET 0x4203
-
-/**
-   Requests VTU-O auxiliary inventory information (Section 11.2.3.2.4 of G993.2
-   [5]).
-*/
-typedef struct CMD_AuxInventoryInfo_O_Get CMD_AuxInventoryInfo_O_Get_t;
-
-/** Message ID for ACK_AuxInventoryInfo_O_Get */
-#define ACK_AUXINVENTORYINFO_O_GET 0x4203
-
-/**
-   Delivers the VTU-O auxiliary inventory information as requested by
-   CMD_AuxInventoryInfo_O_Get.
-*/
-typedef struct ACK_AuxInventoryInfo_O_Get ACK_AuxInventoryInfo_O_Get_t;
-
-/** Message ID for CMD_AuxInventoryInfo_R_Get */
-#define CMD_AUXINVENTORYINFO_R_GET 0x4303
-
-/**
-   Requests VTU-R auxiliary inventory information (Section 11.2.3.2.4 of G993.2
-   [5]).
-*/
-typedef struct CMD_AuxInventoryInfo_R_Get CMD_AuxInventoryInfo_R_Get_t;
-
-/** Message ID for ACK_AuxInventoryInfo_R_Get */
-#define ACK_AUXINVENTORYINFO_R_GET 0x4303
-
-/**
-   Delivers the VTU-R auxiliary inventory information as requested by
-   CMD_AuxInventoryInfo_R_Get.
-*/
-typedef struct ACK_AuxInventoryInfo_R_Get ACK_AuxInventoryInfo_R_Get_t;
-
-/** Message ID for CMD_T1413_VendorID_O_Get */
-#define CMD_T1413_VENDORID_O_GET 0x7C03
-
-/**
-   Requests the ATU-C's T1.413 Vendor identification. (Section 9.6.4.2 of ANSI
-   T1.413 [16])
-*/
-typedef struct CMD_T1413_VendorID_O_Get CMD_T1413_VendorID_O_Get_t;
-
-/** Message ID for ACK_T1413_VendorID_O_Get */
-#define ACK_T1413_VENDORID_O_GET 0x7C03
-
-/**
-   Delivers the ATU-C's T1.413 vendor identification number.
-*/
-typedef struct ACK_T1413_VendorID_O_Get ACK_T1413_VendorID_O_Get_t;
-
-/** Message ID for CMD_T1413_VendorID_R_Get */
-#define CMD_T1413_VENDORID_R_GET 0x7D03
-
-/**
-   Requests the ATU-R's T1.413 Vendor identification. (Section 9.6.4.2 of ANSI
-   T1.413 [16])
-*/
-typedef struct CMD_T1413_VendorID_R_Get CMD_T1413_VendorID_R_Get_t;
-
-/** Message ID for ACK_T1413_VendorID_R_Get */
-#define ACK_T1413_VENDORID_R_GET 0x7D03
-
-/**
-   Reports the ATU-R's T1.413 vendor identification number.
-*/
-typedef struct ACK_T1413_VendorID_R_Get ACK_T1413_VendorID_R_Get_t;
-
-/** Message ID for CMD_T1413_RevNo_O_Get */
-#define CMD_T1413_REVNO_O_GET 0x7E03
-
-/**
-   Requests the xTU-C's T1.413 revision number. (Section 9.6.4.3 of ANSI T1.413
-   [16])
-*/
-typedef struct CMD_T1413_RevNo_O_Get CMD_T1413_RevNo_O_Get_t;
-
-/** Message ID for ACK_T1413_RevNo_O_Get */
-#define ACK_T1413_REVNO_O_GET 0x7E03
-
-/**
-   Delivers the xTU-C's T1.413 revision number.
-*/
-typedef struct ACK_T1413_RevNo_O_Get ACK_T1413_RevNo_O_Get_t;
-
-/** Message ID for CMD_T1413_RevNo_R_Get */
-#define CMD_T1413_REVNO_R_GET 0x7F03
-
-/**
-   Requests the xTU-R's T1.413 revision number. (Section 9.7.6.2 of ANSI T1.413
-   [16])
-*/
-typedef struct CMD_T1413_RevNo_R_Get CMD_T1413_RevNo_R_Get_t;
-
-/** Message ID for ACK_T1413_RevNo_R_Get */
-#define ACK_T1413_REVNO_R_GET 0x7F03
-
-/**
-   Delivers the xTU-R's T1.413 revision number.
-*/
-typedef struct ACK_T1413_RevNo_R_Get ACK_T1413_RevNo_R_Get_t;
-
-/** Message ID for CMD_T1413_VendorRevNo_O_Get */
-#define CMD_T1413_VENDORREVNO_O_GET 0x8003
-
-/**
-   Requests the xTU-C's T1.413 vendor revision number. (Section 9.6.4.4 of ANSI
-   T1.413 [16])
-*/
-typedef struct CMD_T1413_VendorRevNo_O_Get CMD_T1413_VendorRevNo_O_Get_t;
-
-/** Message ID for ACK_T1413_VendorRevNo_O_Get */
-#define ACK_T1413_VENDORREVNO_O_GET 0x8003
-
-/**
-   Delivers the xTU-C's T1.413 vendor revision number.
-*/
-typedef struct ACK_T1413_VendorRevNo_O_Get ACK_T1413_VendorRevNo_O_Get_t;
-
-/** Message ID for CMD_T1413_VendorRevNo_R_Get */
-#define CMD_T1413_VENDORREVNO_R_GET 0x8103
-
-/**
-   Requests the xTU-R's T1.413 vendor revision number. (Section 9.7.6.3 of ANSI
-   T1.413 [16])
-*/
-typedef struct CMD_T1413_VendorRevNo_R_Get CMD_T1413_VendorRevNo_R_Get_t;
-
-/** Message ID for ACK_T1413_VendorRevNo_R_Get */
-#define ACK_T1413_VENDORREVNO_R_GET 0x8103
-
-/**
-   Delivers the xTU-R's T1.413 vendor revision number.
-*/
-typedef struct ACK_T1413_VendorRevNo_R_Get ACK_T1413_VendorRevNo_R_Get_t;
-
-/** Message ID for CMD_XTSE_StatusGet */
-#define CMD_XTSE_STATUSGET 0x0102
-
-/**
-   Requests the transmission system in use on the line (DSL flavour). (Section
-   7.5.1.1. of G.997.1 [11]) See note at ACK_XTSE_StatusGet about the expected
-   behaviour.
-*/
-typedef struct CMD_XTSE_StatusGet CMD_XTSE_StatusGet_t;
-
-/** Message ID for ACK_XTSE_StatusGet */
-#define ACK_XTSE_STATUSGET 0x0102
-
-/**
-   Reports the transmission system mode in use as requested by
-   CMD_XTSE_StatusGet.The information is set by the FW after mode select (MS)
-   during the handshake phase or during T1.413 state. Before mode selection the
-   value "0" is reported (=none), after selection of a common mode exactly this
-   single mode must be indicated. If there is a common mode but it requires
-   another FW to be loaded (e.g. ADSL instead of VDSL), this does not happen
-   ("0" is reported ), then the FW goes to FAIL state and indicates a specific
-   suberror code (S_XDSL_MODE). If there is no common mode, "0" is to be
-   reported (here modem enters FAIL state).
-*/
-typedef struct ACK_XTSE_StatusGet ACK_XTSE_StatusGet_t;
-
-/** Message ID for CMD_BandControl_DS_Get */
-#define CMD_BANDCONTROL_DS_GET 0xC803
-
-/**
-   Reads the used downstream band configuration.
-*/
-typedef struct CMD_BandControl_DS_Get CMD_BandControl_DS_Get_t;
-
-/** Message ID for ACK_BandControl_DS_Get */
-#define ACK_BANDCONTROL_DS_GET 0xC803
-
-/**
-   Acknowledgement for message CMD_BandControl_DS_Get.
-*/
-typedef struct ACK_BandControl_DS_Get ACK_BandControl_DS_Get_t;
-
-/** Message ID for CMD_BandControl_US_Get */
-#define CMD_BANDCONTROL_US_GET 0xC903
-
-/**
-   Reads the used upstream band configuration.
-*/
-typedef struct CMD_BandControl_US_Get CMD_BandControl_US_Get_t;
-
-/** Message ID for ACK_BandControl_US_Get */
-#define ACK_BANDCONTROL_US_GET 0xC903
-
-/**
-   Acknowledgement for message CMD_BandControl_US_Get.
-*/
-typedef struct ACK_BandControl_US_Get ACK_BandControl_US_Get_t;
-
-/** Message ID for CMD_RFI_BandControlGet */
-#define CMD_RFI_BANDCONTROLGET 0xCA03
-
-/**
-   Reads the RFI band configuration.
-*/
-typedef struct CMD_RFI_BandControlGet CMD_RFI_BandControlGet_t;
-
-/** Message ID for ACK_RFI_BandControlGet */
-#define ACK_RFI_BANDCONTROLGET 0xCA03
-
-/**
-   Acknowledgement for message CMD_RFI_BandControlGet.
-*/
-typedef struct ACK_RFI_BandControlGet ACK_RFI_BandControlGet_t;
-
-/** Message ID for CMD_LineStatusDS_Get */
-#define CMD_LINESTATUSDS_GET 0x4403
-
-/**
-   This message requests data about the line status (like noise margin) for
-   downstream direction.
-*/
-typedef struct CMD_LineStatusDS_Get CMD_LineStatusDS_Get_t;
-
-/** Message ID for ACK_LineStatusDS_Get */
-#define ACK_LINESTATUSDS_GET 0x4403
-
-/**
-   The message delivers the line status data for downstream direction requested
-   by CMD_LineStatusDS_Get.
-*/
-typedef struct ACK_LineStatusDS_Get ACK_LineStatusDS_Get_t;
-
-/** Message ID for CMD_LineStatusUS_Get */
-#define CMD_LINESTATUSUS_GET 0x4503
-
-/**
-   This message requests data about the upstream line status (like noise
-   margin).
-*/
-typedef struct CMD_LineStatusUS_Get CMD_LineStatusUS_Get_t;
-
-/** Message ID for ACK_LineStatusUS_Get */
-#define ACK_LINESTATUSUS_GET 0x4503
-
-/**
-   The message delivers the line status data for upstream direction requested by
-   CMD_LineStatusUS_Get.
-*/
-typedef struct ACK_LineStatusUS_Get ACK_LineStatusUS_Get_t;
-
-/** Message ID for CMD_LineStatusPerBandDS_Get */
-#define CMD_LINESTATUSPERBANDDS_GET 0xD203
-
-/**
-   This message requests data about the line status (noise margin, line
-   attenuation and signal attenuation) for downstream direction in a "per band"
-   granularity.
-*/
-typedef struct CMD_LineStatusPerBandDS_Get CMD_LineStatusPerBandDS_Get_t;
-
-/** Message ID for ACK_LineStatusPerBandDS_Get */
-#define ACK_LINESTATUSPERBANDDS_GET 0xD203
-
-/**
-   The message delivers the line status data (line attenuation, signal
-   attenuation and noise margin) for downstream direction in a "per band"
-   granularity as requested by CMD_LineStatusPerBandDS_Get.
-*/
-typedef struct ACK_LineStatusPerBandDS_Get ACK_LineStatusPerBandDS_Get_t;
-
-/** Message ID for CMD_LineStatusPerBandUS_Get */
-#define CMD_LINESTATUSPERBANDUS_GET 0xD303
-
-/**
-   This message requests data about the line status (noise margin, line - and
-   signal attenuation) for upstream direction in a "per band" granularity.
-*/
-typedef struct CMD_LineStatusPerBandUS_Get CMD_LineStatusPerBandUS_Get_t;
-
-/** Message ID for ACK_LineStatusPerBandUS_Get */
-#define ACK_LINESTATUSPERBANDUS_GET 0xD303
-
-/**
-   The message delivers the line status data (line attenuation, signal
-   attenuation and noise margin) for upstream direction in a "per band"
-   granularity as requested by CMD_LineStatusPerBandUS_Get.
-*/
-typedef struct ACK_LineStatusPerBandUS_Get ACK_LineStatusPerBandUS_Get_t;
-
-/** Message ID for CMD_AttndrStatusGet */
-#define CMD_ATTNDRSTATUSGET 0xF003
-
-/**
-   Requests parameters used for the calculation of the downstream attainable net
-   data rate (ATTNDRds).
-*/
-typedef struct CMD_AttndrStatusGet CMD_AttndrStatusGet_t;
-
-/** Message ID for ACK_AttndrStatusGet */
-#define ACK_ATTNDRSTATUSGET 0xF003
-
-/**
-   Delivers the data requested by CMD_AttndrStatusGet.(Section 7.5.1.41 of
-   G.997.1 [12]).
-*/
-typedef struct ACK_AttndrStatusGet ACK_AttndrStatusGet_t;
-
-/** Message ID for CMD_PSD_BreakpointsDS_Get */
-#define CMD_PSD_BREAKPOINTSDS_GET 0xD403
-
-/**
-   Requests the breakpoints of the actual PSD for the downstream direction. PSDs
-   consisting of more than 42 PSD breakpoints must be read with 2 messages due
-   to the the mailbox size. (The first parameter in the retrieved data structure
-   contains the "Number of Breakpoints" parameter.)
-*/
-typedef struct CMD_PSD_BreakpointsDS_Get CMD_PSD_BreakpointsDS_Get_t;
-
-/** Message ID for ACK_PSD_BreakpointsDS_Get */
-#define ACK_PSD_BREAKPOINTSDS_GET 0xD403
-
-/**
-   Delivers the breakpoints of the actual PSD for the downstream direction as
-   requested by CMD_PSD_BreakpointsDS_Get.
-*/
-typedef struct ACK_PSD_BreakpointsDS_Get ACK_PSD_BreakpointsDS_Get_t;
-
-/** Message ID for CMD_PSD_BreakpointsUS_Get */
-#define CMD_PSD_BREAKPOINTSUS_GET 0xD503
-
-/**
-   Requests the breakpoints of the actual PSD for the upstream direction.
-*/
-typedef struct CMD_PSD_BreakpointsUS_Get CMD_PSD_BreakpointsUS_Get_t;
-
-/** Message ID for ACK_PSD_BreakpointsUS_Get */
-#define ACK_PSD_BREAKPOINTSUS_GET 0xD503
-
-/**
-   Delivers the breakpoints of the actual PSD for the upstream direction as
-   requested by CMD_PSD_BreakpointsUS_Get.
-*/
-typedef struct ACK_PSD_BreakpointsUS_Get ACK_PSD_BreakpointsUS_Get_t;
-
-/** Message ID for CMD_TssiDS_VDSL2_Get */
-#define CMD_TSSIDS_VDSL2_GET 0x2803
-
-/**
-   The Downstream TSSI Breakpoints are specified by the transmitter (VTU-O) and
-   communicated to the receiver (VTU-R) via the O-PRM message.   The TSSI
-   Breakpoints are used to shape the O-P-TEQ signal. This message provides read
-   only access to the DS TSSI Breakpoints. The DS TSSI Breakpoints are not
-   configurable via messages.
-*/
-typedef struct CMD_TssiDS_VDSL2_Get CMD_TssiDS_VDSL2_Get_t;
-
-/** Message ID for ACK_TssiDS_VDSL2_Get */
-#define ACK_TSSIDS_VDSL2_GET 0x2803
-
-/**
-   This is the acknowledgement of CMD_TssiDS_VDSL2_Get.
-*/
-typedef struct ACK_TssiDS_VDSL2_Get ACK_TssiDS_VDSL2_Get_t;
-
-/** Message ID for CMD_TssiUS_VDSL2_Get */
-#define CMD_TSSIUS_VDSL2_GET 0x2903
-
-/**
-   The Upstream TSSI Breakpoints are specified by the transmitter (VTU-R) and
-   communicated to the receiver (VTU-O) via the R-PRM message.   The TSSI
-   Breakpoints are used to shape the R-P-TEQ signal.  The TSSI Breakpoints can
-   be read only but are not configurable via messages.
-*/
-typedef struct CMD_TssiUS_VDSL2_Get CMD_TssiUS_VDSL2_Get_t;
-
-/** Message ID for ACK_TssiUS_VDSL2_Get */
-#define ACK_TSSIUS_VDSL2_GET 0x2903
-
-/**
-   This is the acknowledgement of CMD_TssiUS_VDSL2_Get.
-*/
-typedef struct ACK_TssiUS_VDSL2_Get ACK_TssiUS_VDSL2_Get_t;
-
-/** Message ID for CMD_ADSL_PCB_Get */
-#define CMD_ADSL_PCB_GET 0x000E
-
-/**
-   Reads the actual power cutback value.
-*/
-typedef struct CMD_ADSL_PCB_Get CMD_ADSL_PCB_Get_t;
-
-/** Message ID for ACK_ADSL_PCB_Get */
-#define ACK_ADSL_PCB_GET 0x000E
-
-/**
-   Provides the actual power cutback values requested with CMD_ADSL_PCB_Get.
-*/
-typedef struct ACK_ADSL_PCB_Get ACK_ADSL_PCB_Get_t;
-
-/** Message ID for CMD_ActualPSD_Get */
-#define CMD_ACTUALPSD_GET 0xD803
-
-/**
-   Requests the PSD and power parameter values actually used by the firmware.
-*/
-typedef struct CMD_ActualPSD_Get CMD_ActualPSD_Get_t;
-
-/** Message ID for ACK_ActualPSD_Get */
-#define ACK_ACTUALPSD_GET 0xD803
-
-/**
-   Provides actually used PSD and power parameters as requested by
-   CMD_ActualPSD_Get.
-*/
-typedef struct ACK_ActualPSD_Get ACK_ActualPSD_Get_t;
-
-/** Message ID for CMD_ADSL_MJ_UsMaskGet */
-#define CMD_ADSL_MJ_USMASKGET 0x1802
-
-/**
-   Requests the actually used ADSL upstream mask for ADSL2/2+ Annexes M and J.
-   To be applied only in combination with G.992.3/5 Annex M support in
-   ACK_XTSE_StatusGet.
-*/
-typedef struct CMD_ADSL_MJ_UsMaskGet CMD_ADSL_MJ_UsMaskGet_t;
-
-/** Message ID for ACK_ADSL_MJ_UsMaskGet */
-#define ACK_ADSL_MJ_USMASKGET 0x1802
-
-/**
-   Provides the actually used ADSL upstream mask for ADSL2/2+ Annexes M and J.
-*/
-typedef struct ACK_ADSL_MJ_UsMaskGet ACK_ADSL_MJ_UsMaskGet_t;
-
-/** Message ID for CMD_PSDMASK_DS_Get */
-#define CMD_PSDMASK_DS_GET 0xF203
-
-/**
-   Reports the downstream transmit PSD mask (PSDMASKds) which is received from
-   CO with O-SIGNATURE message.
-*/
-typedef struct CMD_PSDMASK_DS_Get CMD_PSDMASK_DS_Get_t;
-
-/** Message ID for ACK_PSDMASK_DS_Get */
-#define ACK_PSDMASK_DS_GET 0xF203
-
-/**
-   Reports the downstream transmit PSD mask (PSDMASKds) for both passbands and
-   stopbands, which is received from CO with O-SIGNATURE message. (Format is now
-   as absolute value without the offset.)
-*/
-typedef struct ACK_PSDMASK_DS_Get ACK_PSDMASK_DS_Get_t;
-
-/** Message ID for CMD_RxPSD_TableEntriesGet */
-#define CMD_RXPSD_TABLEENTRIESGET 0x5403
-
-/**
-   The message requests information about the receive PSD per subcarrier
-   available at the near-end side, which means for downstream direction at the
-   CPE. It is the hosts responsibility to select the tone indices accordingly.In
-   Showtime the message reports the receive PSD measured in Channel Discovery
-   phase after the final hybrid training (no Showtime update).
-*/
-typedef struct CMD_RxPSD_TableEntriesGet CMD_RxPSD_TableEntriesGet_t;
-
-/** Message ID for ACK_RxPSD_TableEntriesGet */
-#define ACK_RXPSD_TABLEENTRIESGET 0x5403
-
-/**
-   Returns information about the receive PSD per subcarrier available at the
-   near-end side, which means for downstream direction at the CPE.In Showtime
-   the message reports the receive PSD measured in Channel Discovery phase after
-   the final hybrid training (no Showtime update).
-*/
-typedef struct ACK_RxPSD_TableEntriesGet ACK_RxPSD_TableEntriesGet_t;
-
-/** Message ID for CMD_BearerChsDS_Get */
-#define CMD_BEARERCHSDS_GET 0x0106
-
-/**
-   Requests status information for the downstream bearer channels.
-*/
-typedef struct CMD_BearerChsDS_Get CMD_BearerChsDS_Get_t;
-
-/** Message ID for ACK_BearerChsDS_Get */
-#define ACK_BEARERCHSDS_GET 0x0106
-
-/**
-   Delivers status information for the downstream bearer channels. **: The terms
-   "LP0/Interleaved Path" and "LP1/Fast Path" below refer to the terminology
-   used in ITU DSL standards [1],[2], [3], [5] which means:- LP0 or LP1 in case
-   of VDSL2, ADSL2/2+- "Interleaved Path" or "Fast Path" in case of ADSL1/ADSL1
-   Lite.Attention: In VRX Device1 the "LP1/Fast Path" parameters are populated
-   only in ADSL1 and ADSL1 Lilte mode with selected fast path.
-*/
-typedef struct ACK_BearerChsDS_Get ACK_BearerChsDS_Get_t;
-
-/** Message ID for CMD_BearerChsUS_Get */
-#define CMD_BEARERCHSUS_GET 0x0006
-
-/**
-   Requests status information for the upstream bearer channels.
-*/
-typedef struct CMD_BearerChsUS_Get CMD_BearerChsUS_Get_t;
-
-/** Message ID for ACK_BearerChsUS_Get */
-#define ACK_BEARERCHSUS_GET 0x0006
-
-/**
-   Delivers status information for the upstream bearer channels. **: The terms
-   "LP0/Interleaved Path" and "LP1/Fast Path" below refer to the terminology
-   used in ITU DSL standards [1],[2], [3], [5] which means:- LP0 or LP1 in case
-   of VDSL2, ADSL2/2+- "Interleaved Path" or "Fast Path" in case of ADSL1/ADSL1
-   Lite.Attention: In VRX Device1 the "LP1/Fast Path" parameters are populated
-   only in ADSL1 and ADSL1 Lite mode with selected fast path.
-*/
-typedef struct ACK_BearerChsUS_Get ACK_BearerChsUS_Get_t;
-
-/** Message ID for CMD_FrameDataExt2DS_Get */
-#define CMD_FRAMEDATAEXT2DS_GET 0x2203
-
-/**
-   Requests an extended set of VDSL2 framing parameters for the downstream
-   direction.
-*/
-typedef struct CMD_FrameDataExt2DS_Get CMD_FrameDataExt2DS_Get_t;
-
-/** Message ID for ACK_FrameDataExt2DS_Get */
-#define ACK_FRAMEDATAEXT2DS_GET 0x2203
-
-/**
-   Delivers an extended set of VDSL2 framing parameters for the downstream
-   direction requested by CMD_FrameDataExt2DS_Get. (Sections 7.5.2.6 of G.997.1
-   and 9.5 & 9.6 of G.993.2 [5])
-*/
-typedef struct ACK_FrameDataExt2DS_Get ACK_FrameDataExt2DS_Get_t;
-
-/** Message ID for CMD_FrameDataExt2US_Get */
-#define CMD_FRAMEDATAEXT2US_GET 0x2303
-
-/**
-   Requests an extended set of VDSL2 framing parameters for the upstream
-   direction.
-*/
-typedef struct CMD_FrameDataExt2US_Get CMD_FrameDataExt2US_Get_t;
-
-/** Message ID for ACK_FrameDataExt2US_Get */
-#define ACK_FRAMEDATAEXT2US_GET 0x2303
-
-/**
-   Delivers an extended set of VDSL2 framing parameters for the upstream
-   direction requested by CMD_FrameDataExt2US_Get. (Sections 7.5.2.6 of G.997.1
-   and 9.5 & 9.6 of G.993.2 [5])
-*/
-typedef struct ACK_FrameDataExt2US_Get ACK_FrameDataExt2US_Get_t;
-
-/** Message ID for CMD_ADSL_FrameDataDS_LP0Get */
-#define CMD_ADSL_FRAMEDATADS_LP0GET 0x010E
-
-/**
-   Requests ADSL framing parameters for the downstream direction, latency path
-   0/Interleaved Path.
-*/
-typedef struct CMD_ADSL_FrameDataDS_LP0Get CMD_ADSL_FrameDataDS_LP0Get_t;
-
-/** Message ID for ACK_ADSL_FrameDataDS_LP0Get */
-#define ACK_ADSL_FRAMEDATADS_LP0GET 0x010E
-
-/**
-   Delivers the ADSL framing parameters for the downstream direction,
-   LP0/Interleaved path, as requested by CMD_ADSL_FrameDataDS_LP0Get. (Sections
-   7.5 & 7.6 of G.992.3 [2] and 7.4 of G.992.1 [1])
-*/
-typedef struct ACK_ADSL_FrameDataDS_LP0Get ACK_ADSL_FrameDataDS_LP0Get_t;
-
-/** Message ID for CMD_ADSL_FrameDataUS_LP0Get */
-#define CMD_ADSL_FRAMEDATAUS_LP0GET 0x020E
-
-/**
-   Requests ADSL framing parameters for the upstream direction, latency path
-   0/Interleaved path.
-*/
-typedef struct CMD_ADSL_FrameDataUS_LP0Get CMD_ADSL_FrameDataUS_LP0Get_t;
-
-/** Message ID for ACK_ADSL_FrameDataUS_LP0Get */
-#define ACK_ADSL_FRAMEDATAUS_LP0GET 0x020E
-
-/**
-   Delivers the ADSL framing parameters for the upstream direction, latency path
-   0/Interleaved path, as requested by CMD_ADSL_FrameDataUS_LP0Get. (Sections
-   7.5 & 7.6 of G.992.3 [2] and 7.4 of G.992.1 [1])
-*/
-typedef struct ACK_ADSL_FrameDataUS_LP0Get ACK_ADSL_FrameDataUS_LP0Get_t;
-
-/** Message ID for CMD_ADSL_FrameDataDS_LP1Get */
-#define CMD_ADSL_FRAMEDATADS_LP1GET 0x030E
-
-/**
-   Requests ADSL framing parameters for the downstream direction, latency path 1
-   (LP1)/ Fast path.In VRX Rev. 1.x to be used for ADSL1, "fast path" only.
-*/
-typedef struct CMD_ADSL_FrameDataDS_LP1Get CMD_ADSL_FrameDataDS_LP1Get_t;
-
-/** Message ID for ACK_ADSL_FrameDataDS_LP1Get */
-#define ACK_ADSL_FRAMEDATADS_LP1GET 0x030E
-
-/**
-   Delivers the ADSL framing parameters for the downstream direction, LP1/Fast
-   path, as requested by CMD_ADSL_FrameDataDS_LP1Get. (Sections 7.5 & 7.6 of
-   G.992.3 [2] and 7.4 of G.992.1 [1])
-*/
-typedef struct ACK_ADSL_FrameDataDS_LP1Get ACK_ADSL_FrameDataDS_LP1Get_t;
-
-/** Message ID for CMD_ADSL_FrameDataUS_LP1Get */
-#define CMD_ADSL_FRAMEDATAUS_LP1GET 0x040E
-
-/**
-   Requests ADSL framing parameters for the upstream direction, latency path 1
-   (LP1)/Fast path.In VRX Rev. 1.x to be used for ADSL1, "fast path" only.
-*/
-typedef struct CMD_ADSL_FrameDataUS_LP1Get CMD_ADSL_FrameDataUS_LP1Get_t;
-
-/** Message ID for ACK_ADSL_FrameDataUS_LP1Get */
-#define ACK_ADSL_FRAMEDATAUS_LP1GET 0x040E
-
-/**
-   Delivers the ADSL framing parameters for the upstream direction, LP1/Fast
-   path, as requested by CMD_ADSL_FrameDataUS_LP1Get. (Sections 7.5 & 7.6 of
-   G.992.3 [2] and 7.4 of G.992.1 [1])
-*/
-typedef struct ACK_ADSL_FrameDataUS_LP1Get ACK_ADSL_FrameDataUS_LP1Get_t;
-
-/** Message ID for CMD_HybridGet */
-#define CMD_HYBRIDGET 0x0922
-
-/**
-   Reads the connected hybrid type.
-*/
-typedef struct CMD_HybridGet CMD_HybridGet_t;
-
-/** Message ID for ACK_HybridGet */
-#define ACK_HYBRIDGET 0x0922
-
-/**
-   Contains the connected hybrid type.
-*/
-typedef struct ACK_HybridGet ACK_HybridGet_t;
-
-/** Message ID for CMD_PilotTonesGet */
-#define CMD_PILOTTONESGET 0x0322
-
-/**
-   Requests the pilot tones used in Showtime.
-*/
-typedef struct CMD_PilotTonesGet CMD_PilotTonesGet_t;
-
-/** Message ID for ACK_PilotTonesGet */
-#define ACK_PILOTTONESGET 0x0322
-
-/**
-   Provides the Showtime pilot tones as requested by CMD_PilotTonesGet.
-*/
-typedef struct ACK_PilotTonesGet ACK_PilotTonesGet_t;
-
-/** Message ID for CMD_MFD_ResultsGet */
-#define CMD_MFD_RESULTSGET 0x1022
-
-/**
-   Requests the results of the micro filter detection (MFD) function. Valid
-   information in Showtime and FAIL will be available only if the microfilter
-   detection mechanism has been run before.
-*/
-typedef struct CMD_MFD_ResultsGet CMD_MFD_ResultsGet_t;
-
-/** Message ID for ACK_MFD_ResultsGet */
-#define ACK_MFD_RESULTSGET 0x1022
-
-/**
-   Reports the results of the micro filter detection (MFD) function.
-*/
-typedef struct ACK_MFD_ResultsGet ACK_MFD_ResultsGet_t;
-
-/** Message ID for CMD_MFD_LooplengthGet */
-#define CMD_MFD_LOOPLENGTHGET 0x1122
-
-/**
-   Requests the loop length estimates done by the microfilter detection
-   function.In Showtime the data are always available.The availability of data
-   is indicated by the flag TrainingLoopLengthReady in ACK_MFD_ResultsGet.In
-   Showtime the data are always available.
-*/
-typedef struct CMD_MFD_LooplengthGet CMD_MFD_LooplengthGet_t;
-
-/** Message ID for ACK_MFD_LooplengthGet */
-#define ACK_MFD_LOOPLENGTHGET 0x1122
-
-/**
-   Reports the loop length estimates done by the microfilter detection (MFD)
-   function.
-*/
-typedef struct ACK_MFD_LooplengthGet ACK_MFD_LooplengthGet_t;
-
-/** Message ID for CMD_MFD_HybridInfoGet */
-#define CMD_MFD_HYBRIDINFOGET 0x1222
-
-/**
-   Requests hybrid information used by the microfilter detection function.In
-   Showtime the data are always available.The availability of data is indicated
-   by the flag TrainingHybridInfoReady in ACK_MFD_ResultsGet. In Showtime the
-   data are always available.
-*/
-typedef struct CMD_MFD_HybridInfoGet CMD_MFD_HybridInfoGet_t;
-
-/** Message ID for ACK_MFD_HybridInfoGet */
-#define ACK_MFD_HYBRIDINFOGET 0x1222
-
-/**
-   Reports the hybrid information used by the microfilter detection function.
-*/
-typedef struct ACK_MFD_HybridInfoGet ACK_MFD_HybridInfoGet_t;
-
-/**
-   Selects one or more groups of tones to be used during the handshake phase.
-   (See G.994.1 Amendment 2 [8], Table 1/G.994.1).
-*/
-struct CMD_HS_ToneGroupSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 7;
-   /** Tone Group 8: CAR_SET_V43I */
-   DSL_uint16_t Group8 : 1;
-   /** Tone Group 7: CAR_SET_V43P */
-   DSL_uint16_t Group7 : 1;
-   /** Tone Group 6: CAR_SET_V43 */
-   DSL_uint16_t Group6 : 1;
-   /** Tone Group 5: CAR_SET_J43 */
-   DSL_uint16_t Group5 : 1;
-   /** Tone Group 4: CAR_SET_C43 */
-   DSL_uint16_t Group4 : 1;
-   /** Tone Group 3: CAR_SET_B43C */
-   DSL_uint16_t Group3 : 1;
-   /** Tone Group 2: CAR_SET_B43 */
-   DSL_uint16_t Group2 : 1;
-   /** Tone Group 1: CAR_SET_A43C */
-   DSL_uint16_t Group1 : 1;
-   /** Tone Group 0: CAR_SET_A43 */
-   DSL_uint16_t Group0 : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Tone Group 0: CAR_SET_A43 */
-   DSL_uint16_t Group0 : 1;
-   /** Tone Group 1: CAR_SET_A43C */
-   DSL_uint16_t Group1 : 1;
-   /** Tone Group 2: CAR_SET_B43 */
-   DSL_uint16_t Group2 : 1;
-   /** Tone Group 3: CAR_SET_B43C */
-   DSL_uint16_t Group3 : 1;
-   /** Tone Group 4: CAR_SET_C43 */
-   DSL_uint16_t Group4 : 1;
-   /** Tone Group 5: CAR_SET_J43 */
-   DSL_uint16_t Group5 : 1;
-   /** Tone Group 6: CAR_SET_V43 */
-   DSL_uint16_t Group6 : 1;
-   /** Tone Group 7: CAR_SET_V43P */
-   DSL_uint16_t Group7 : 1;
-   /** Tone Group 8: CAR_SET_V43I */
-   DSL_uint16_t Group8 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 7;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_HS_ToneGroupSet.
-*/
-struct ACK_HS_ToneGroupSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Configures the profile settings to be used for the handshake phase. (See
-   G.994.1 Amendment 4 [10], NPAR(3) coding).
-*/
-struct CMD_HS_VDSL2ProfileControl
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t  Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 7;
-   /** 35b, Profile Support Bit 8 */
-   DSL_uint16_t profileSup8 : 1;
-   /** 30a, Profile Support Bit 7 */
-   DSL_uint16_t profileSup7 : 1;
-   /** 17a, Profile Support Bit 6 */
-   DSL_uint16_t profileSup6 : 1;
-   /** 12b, Profile Support Bit 5 */
-   DSL_uint16_t profileSup5 : 1;
-   /** 12a, Profile Support Bit 4 */
-   DSL_uint16_t profileSup4 : 1;
-   /** 8d, Profile Support Bit 3 */
-   DSL_uint16_t profileSup3 : 1;
-   /** 8c, Profile Support Bit 2 */
-   DSL_uint16_t profileSup2 : 1;
-   /** 8b, Profile Support Bit 1 */
-   DSL_uint16_t profileSup1 : 1;
-   /** 8a, Profile Support Bit 0 */
-   DSL_uint16_t profileSup0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 7;
-   /** 35b, Profile Preferred Bit 8 */
-   DSL_uint16_t profilePref8 : 1;
-   /** 30a, Profile Preferred Bit 7 */
-   DSL_uint16_t profilePref7 : 1;
-   /** 17a, Profile Preferred Bit 6 */
-   DSL_uint16_t profilePref6 : 1;
-   /** 12b, Profile Preferred Bit 5 */
-   DSL_uint16_t profilePref5 : 1;
-   /** 12a, Profile Preferred Bit 4 */
-   DSL_uint16_t profilePref4 : 1;
-   /** 8d, Profile Preferred Bit 3 */
-   DSL_uint16_t profilePref3 : 1;
-   /** 8c, Profile Preferred Bit 2 */
-   DSL_uint16_t profilePref2 : 1;
-   /** 8b, Profile Preferred Bit 1 */
-   DSL_uint16_t profilePref1 : 1;
-   /** 8a, Profile Preferred Bit 0 */
-   DSL_uint16_t profilePref0 : 1;
-   /** ADLU-56, Annex A US0 PSDs Supported Bit 15 */
-   DSL_uint16_t A_US0PsdSup15 : 1;
-   /** ADLU-52, Annex A US0 PSDs Supported Bit 14 */
-   DSL_uint16_t A_US0PsdSup14 : 1;
-   /** ADLU-48, Annex A US0 PSDs Supported Bit 13 */
-   DSL_uint16_t A_US0PsdSup13 : 1;
-   /** ADLU-44, Annex A US0 PSDs Supported Bit 12 */
-   DSL_uint16_t A_US0PsdSup12 : 1;
-   /** ADLU-40, Annex A US0 PSDs Supported Bit 11 */
-   DSL_uint16_t A_US0PsdSup11 : 1;
-   /** ADLU-36, Annex A US0 PSDs Supported Bit 10 */
-   DSL_uint16_t A_US0PsdSup10 : 1;
-   /** ADLU-32, Annex A US0 PSDs Supported Bit 9 */
-   DSL_uint16_t A_US0PsdSup9 : 1;
-   /** EU-64, Annex A US0 PSDs Supported Bit 8 */
-   DSL_uint16_t A_US0PsdSup8 : 1;
-   /** EU-60, Annex A US0 PSDs Supported Bit 7 */
-   DSL_uint16_t A_US0PsdSup7 : 1;
-   /** EU-56, Annex A US0 PSDs Supported Bit 6 */
-   DSL_uint16_t A_US0PsdSup6 : 1;
-   /** EU-52, Annex A US0 PSDs Supported Bit 5 */
-   DSL_uint16_t A_US0PsdSup5 : 1;
-   /** EU-48, Annex A US0 PSDs Supported Bit 4 */
-   DSL_uint16_t A_US0PsdSup4 : 1;
-   /** EU-44, Annex A US0 PSDs Supported Bit 3 */
-   DSL_uint16_t A_US0PsdSup3 : 1;
-   /** EU-40, Annex A US0 PSDs Supported Bit 2 */
-   DSL_uint16_t A_US0PsdSup2 : 1;
-   /** EU-36, Annex A US0 PSDs Supported Bit 1 */
-   DSL_uint16_t A_US0PsdSup1 : 1;
-   /** EU-32, Annex A US0 PSDs Supported Bit 0 */
-   DSL_uint16_t A_US0PsdSup0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 10;
-   /** ADLU-128, Annex A US0 PSDs Supported Bit 21 */
-   DSL_uint16_t A_US0PsdSup21 : 1;
-   /** EU-128, Annex A US0 PSDs Supported Bit 20 */
-   DSL_uint16_t A_US0PsdSup20 : 1;
-   /** 17a Profile, Annex A US0 PSDs Supported Bit 19 */
-   DSL_uint16_t A_US0PsdSup19 : 1;
-   /** 12b Profile, Annex A US0 PSDs Supported Bit 18 */
-   DSL_uint16_t A_US0PsdSup18 : 1;
-   /** ADLU-64, Annex A US0 PSDs Supported Bit 17 */
-   DSL_uint16_t A_US0PsdSup17 : 1;
-   /** ADLU-60, Annex A US0 PSDs Supported Bit 16 */
-   DSL_uint16_t A_US0PsdSup16 : 1;
-   /** Reserved */
-   DSL_uint16_t Res3[2];
-   /** Reserved */
-   DSL_uint16_t Res4 : 11;
-   /** 17a Profile, Annex B US0 PSDs Supported Bit 4 */
-   DSL_uint16_t B_US0PsdSup4 : 1;
-   /** 12b Profile, Annex B US0 PSDs Supported Bit 3 */
-   DSL_uint16_t B_US0PsdSup3 : 1;
-   /** US0 In 120 to 276 kHz, Annex B US0 PSDs Supported Bit 2 */
-   DSL_uint16_t B_US0PsdSup2 : 1;
-   /** US0 In 25 to 276 kHz, Annex B US0 PSDs Supported Bit 1 */
-   DSL_uint16_t B_US0PsdSup1 : 1;
-   /** US0 In 25 to 138 kHz, Annex B US0 PSDs Supported Bit 0 */
-   DSL_uint16_t B_US0PsdSup0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res5;
-   /** Reserved */
-   DSL_uint16_t Res6 : 2;
-   /** 17a Profile, Annex C US0 PSDs Supported Bit 13 */
-   DSL_uint16_t C_US0PsdSup13 : 1;
-   /** 12b Profile, Annex C US0 PSDs Supported Bit 12 */
-   DSL_uint16_t C_US0PsdSup12 : 1;
-   /** Reserved */
-   DSL_uint16_t Res7 : 6;
-   /** US0 In 25 to 276 kHz, Annex C US0 PSDs Supported Bit 5 */
-   DSL_uint16_t C_US0PsdSup5 : 1;
-   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Supported Bit 4 */
-   DSL_uint16_t C_US0PsdSup4 : 1;
-   /** Reserved */
-   DSL_uint16_t Res8 : 2;
-   /** US0 In 25 to 276kHz, Annex C US0 PSDs Supported Bit 1 */
-   DSL_uint16_t C_US0PsdSup1 : 1;
-   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Supported Bit 0 */
-   DSL_uint16_t C_US0PsdSup0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res9;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t  Length;
-   /** 8a, Profile Support Bit 0 */
-   DSL_uint16_t profileSup0 : 1;
-   /** 8b, Profile Support Bit 1 */
-   DSL_uint16_t profileSup1 : 1;
-   /** 8c, Profile Support Bit 2 */
-   DSL_uint16_t profileSup2 : 1;
-   /** 8d, Profile Support Bit 3 */
-   DSL_uint16_t profileSup3 : 1;
-   /** 12a, Profile Support Bit 4 */
-   DSL_uint16_t profileSup4 : 1;
-   /** 12b, Profile Support Bit 5 */
-   DSL_uint16_t profileSup5 : 1;
-   /** 17a, Profile Support Bit 6 */
-   DSL_uint16_t profileSup6 : 1;
-   /** 30a, Profile Support Bit 7 */
-   DSL_uint16_t profileSup7 : 1;
-   /** 35b, Profile Support Bit 8 */
-   DSL_uint16_t profileSup8 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 7;
-   /** 8a, Profile Preferred Bit 0 */
-   DSL_uint16_t profilePref0 : 1;
-   /** 8b, Profile Preferred Bit 1 */
-   DSL_uint16_t profilePref1 : 1;
-   /** 8c, Profile Preferred Bit 2 */
-   DSL_uint16_t profilePref2 : 1;
-   /** 8d, Profile Preferred Bit 3 */
-   DSL_uint16_t profilePref3 : 1;
-   /** 12a, Profile Preferred Bit 4 */
-   DSL_uint16_t profilePref4 : 1;
-   /** 12b, Profile Preferred Bit 5 */
-   DSL_uint16_t profilePref5 : 1;
-   /** 17a, Profile Preferred Bit 6 */
-   DSL_uint16_t profilePref6 : 1;
-   /** 30a, Profile Preferred Bit 7 */
-   DSL_uint16_t profilePref7 : 1;
-   /** 35b, Profile Preferred Bit 8 */
-   DSL_uint16_t profilePref8 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 7;
-   /** EU-32, Annex A US0 PSDs Supported Bit 0 */
-   DSL_uint16_t A_US0PsdSup0 : 1;
-   /** EU-36, Annex A US0 PSDs Supported Bit 1 */
-   DSL_uint16_t A_US0PsdSup1 : 1;
-   /** EU-40, Annex A US0 PSDs Supported Bit 2 */
-   DSL_uint16_t A_US0PsdSup2 : 1;
-   /** EU-44, Annex A US0 PSDs Supported Bit 3 */
-   DSL_uint16_t A_US0PsdSup3 : 1;
-   /** EU-48, Annex A US0 PSDs Supported Bit 4 */
-   DSL_uint16_t A_US0PsdSup4 : 1;
-   /** EU-52, Annex A US0 PSDs Supported Bit 5 */
-   DSL_uint16_t A_US0PsdSup5 : 1;
-   /** EU-56, Annex A US0 PSDs Supported Bit 6 */
-   DSL_uint16_t A_US0PsdSup6 : 1;
-   /** EU-60, Annex A US0 PSDs Supported Bit 7 */
-   DSL_uint16_t A_US0PsdSup7 : 1;
-   /** EU-64, Annex A US0 PSDs Supported Bit 8 */
-   DSL_uint16_t A_US0PsdSup8 : 1;
-   /** ADLU-32, Annex A US0 PSDs Supported Bit 9 */
-   DSL_uint16_t A_US0PsdSup9 : 1;
-   /** ADLU-36, Annex A US0 PSDs Supported Bit 10 */
-   DSL_uint16_t A_US0PsdSup10 : 1;
-   /** ADLU-40, Annex A US0 PSDs Supported Bit 11 */
-   DSL_uint16_t A_US0PsdSup11 : 1;
-   /** ADLU-44, Annex A US0 PSDs Supported Bit 12 */
-   DSL_uint16_t A_US0PsdSup12 : 1;
-   /** ADLU-48, Annex A US0 PSDs Supported Bit 13 */
-   DSL_uint16_t A_US0PsdSup13 : 1;
-   /** ADLU-52, Annex A US0 PSDs Supported Bit 14 */
-   DSL_uint16_t A_US0PsdSup14 : 1;
-   /** ADLU-56, Annex A US0 PSDs Supported Bit 15 */
-   DSL_uint16_t A_US0PsdSup15 : 1;
-   /** ADLU-60, Annex A US0 PSDs Supported Bit 16 */
-   DSL_uint16_t A_US0PsdSup16 : 1;
-   /** ADLU-64, Annex A US0 PSDs Supported Bit 17 */
-   DSL_uint16_t A_US0PsdSup17 : 1;
-   /** 12b Profile, Annex A US0 PSDs Supported Bit 18 */
-   DSL_uint16_t A_US0PsdSup18 : 1;
-   /** 17a Profile, Annex A US0 PSDs Supported Bit 19 */
-   DSL_uint16_t A_US0PsdSup19 : 1;
-   /** EU-128, Annex A US0 PSDs Supported Bit 20 */
-   DSL_uint16_t A_US0PsdSup20 : 1;
-   /** ADLU-128, Annex A US0 PSDs Supported Bit 21 */
-   DSL_uint16_t A_US0PsdSup21 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 10;
-   /** Reserved */
-   DSL_uint16_t Res3[2];
-   /** US0 In 25 to 138 kHz, Annex B US0 PSDs Supported Bit 0 */
-   DSL_uint16_t B_US0PsdSup0 : 1;
-   /** US0 In 25 to 276 kHz, Annex B US0 PSDs Supported Bit 1 */
-   DSL_uint16_t B_US0PsdSup1 : 1;
-   /** US0 In 120 to 276 kHz, Annex B US0 PSDs Supported Bit 2 */
-   DSL_uint16_t B_US0PsdSup2 : 1;
-   /** 12b Profile, Annex B US0 PSDs Supported Bit 3 */
-   DSL_uint16_t B_US0PsdSup3 : 1;
-   /** 17a Profile, Annex B US0 PSDs Supported Bit 4 */
-   DSL_uint16_t B_US0PsdSup4 : 1;
-   /** Reserved */
-   DSL_uint16_t Res4 : 11;
-   /** Reserved */
-   DSL_uint16_t Res5;
-   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Supported Bit 0 */
-   DSL_uint16_t C_US0PsdSup0 : 1;
-   /** US0 In 25 to 276kHz, Annex C US0 PSDs Supported Bit 1 */
-   DSL_uint16_t C_US0PsdSup1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res8 : 2;
-   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Supported Bit 4 */
-   DSL_uint16_t C_US0PsdSup4 : 1;
-   /** US0 In 25 to 276 kHz, Annex C US0 PSDs Supported Bit 5 */
-   DSL_uint16_t C_US0PsdSup5 : 1;
-   /** Reserved */
-   DSL_uint16_t Res7 : 6;
-   /** 12b Profile, Annex C US0 PSDs Supported Bit 12 */
-   DSL_uint16_t C_US0PsdSup12 : 1;
-   /** 17a Profile, Annex C US0 PSDs Supported Bit 13 */
-   DSL_uint16_t C_US0PsdSup13 : 1;
-   /** Reserved */
-   DSL_uint16_t Res6 : 2;
-   /** Reserved */
-   DSL_uint16_t Res9;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_HS_VDSL2ProfileControl.
-*/
-struct ACK_HS_VDSL2ProfileControl
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the VDSL2 far-end Standard Info (See G.994.1 Amendment 4 [10],
-   NPAR(3) coding).
-*/
-struct CMD_HS_StandardInfoFE_VDSL2Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t  Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t  Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the VDSL2 far-end info as requested by
-   CMD_HS_StandardInfoFE_VDSL2Get (see G.994.1 Amendment 4 [10], NPAR(3)
-   coding).
-*/
-struct ACK_HS_StandardInfoFE_VDSL2Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t  Length;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** Reserved */
-   DSL_uint16_t Res1 : 7;
-   /** 35b, Profile Support Bit 8 */
-   DSL_uint16_t profileSup8 : 1;
-   /** 30a, Profile Support Bit 7 */
-   DSL_uint16_t profileSup7 : 1;
-   /** 17a, Profile Support Bit 6 */
-   DSL_uint16_t profileSup6 : 1;
-   /** 12b, Profile Support Bit 5 */
-   DSL_uint16_t profileSup5 : 1;
-   /** 12a, Profile Support Bit 4 */
-   DSL_uint16_t profileSup4 : 1;
-   /** 8d, Profile Support Bit 3 */
-   DSL_uint16_t profileSup3 : 1;
-   /** 8c, Profile Support Bit 2 */
-   DSL_uint16_t profileSup2 : 1;
-   /** 8b, Profile Support Bit 1 */
-   DSL_uint16_t profileSup1 : 1;
-   /** 8a, Profile Support Bit 0 */
-   DSL_uint16_t profileSup0 : 1;
-   /** ADLU-56, Annex A US0 PSDs Supported Bit 15 */
-   DSL_uint16_t A_US0PsdSup15 : 1;
-   /** ADLU-52, Annex A US0 PSDs Supported Bit 14 */
-   DSL_uint16_t A_US0PsdSup14 : 1;
-   /** ADLU-48, Annex A US0 PSDs Supported Bit 13 */
-   DSL_uint16_t A_US0PsdSup13 : 1;
-   /** ADLU-44, Annex A US0 PSDs Supported Bit 12 */
-   DSL_uint16_t A_US0PsdSup12 : 1;
-   /** ADLU-40, Annex A US0 PSDs Supported Bit 11 */
-   DSL_uint16_t A_US0PsdSup11 : 1;
-   /** ADLU-36, Annex A US0 PSDs Supported Bit 10 */
-   DSL_uint16_t A_US0PsdSup10 : 1;
-   /** ADLU-32, Annex A US0 PSDs Supported Bit 9 */
-   DSL_uint16_t A_US0PsdSup9 : 1;
-   /** EU-64, Annex A US0 PSDs Supported Bit 8 */
-   DSL_uint16_t A_US0PsdSup8 : 1;
-   /** EU-60, Annex A US0 PSDs Supported Bit 7 */
-   DSL_uint16_t A_US0PsdSup7 : 1;
-   /** EU-56, Annex A US0 PSDs Supported Bit 6 */
-   DSL_uint16_t A_US0PsdSup6 : 1;
-   /** EU-52, Annex A US0 PSDs Supported Bit 5 */
-   DSL_uint16_t A_US0PsdSup5 : 1;
-   /** EU-48, Annex A US0 PSDs Supported Bit 4 */
-   DSL_uint16_t A_US0PsdSup4 : 1;
-   /** EU-44, Annex A US0 PSDs Supported Bit 3 */
-   DSL_uint16_t A_US0PsdSup3 : 1;
-   /** EU-40, Annex A US0 PSDs Supported Bit 2 */
-   DSL_uint16_t A_US0PsdSup2 : 1;
-   /** EU-36, Annex A US0 PSDs Supported Bit 1 */
-   DSL_uint16_t A_US0PsdSup1 : 1;
-   /** EU-32, Annex A US0 PSDs Supported Bit 0 */
-   DSL_uint16_t A_US0PsdSup0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 10;
-   /** ADLU-128 Annex A US0 PSDs Supported Bit 21 */
-   DSL_uint16_t A_US0PsdSup21 : 1;
-   /** EU-128, Annex A US0 PSDs Supported Bit 20 */
-   DSL_uint16_t A_US0PsdSup20 : 1;
-   /** 17a Profile, Annex A US0 PSDs Supported Bit 19 */
-   DSL_uint16_t A_US0PsdSup19 : 1;
-   /** 12b Profile, Annex A US0 PSDs Supported Bit 18 */
-   DSL_uint16_t A_US0PsdSup18 : 1;
-   /** ADLU-64, Annex A US0 PSDs Supported Bit 17 */
-   DSL_uint16_t A_US0PsdSup17 : 1;
-   /** ADLU-60, Annex A US0 PSDs Supported Bit 16 */
-   DSL_uint16_t A_US0PsdSup16 : 1;
-   /** Reserved */
-   DSL_uint16_t Res3 : 11;
-   /** 17a Profile, Annex B US0 PSDs Supported Bit 4 */
-   DSL_uint16_t B_US0PsdSup4 : 1;
-   /** 12b Profile, Annex B US0 PSDs Supported Bit 3 */
-   DSL_uint16_t B_US0PsdSup3 : 1;
-   /** US0 In 138 to 276 kHz, Annex B US0 PSDs Supported Bit 2 */
-   DSL_uint16_t B_US0PsdSup2 : 1;
-   /** US0 In 25 to 276 kHz, Annex B US0 PSDs Supported Bit 1 */
-   DSL_uint16_t B_US0PsdSup1 : 1;
-   /** US0 In 25 to 138 kHz, Annex B US0 PSDs Supported Bit 0 */
-   DSL_uint16_t B_US0PsdSup0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res4 : 2;
-   /** 17a Profile, Annex C US0 PSDs Supported Bit 13 */
-   DSL_uint16_t C_US0PsdSup13 : 1;
-   /** 12b Profile, Annex C US0 PSDs Supported Bit 12 */
-   DSL_uint16_t C_US0PsdSup12 : 1;
-   /** Reserved */
-   DSL_uint16_t Res5 : 6;
-   /** US0 In 25 to 276 kHz, Annex C US0 PSDs Supported Bit 5 */
-   DSL_uint16_t C_US0PsdSup5 : 1;
-   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Supported Bit 4 */
-   DSL_uint16_t C_US0PsdSup4 : 1;
-   /** Reserved */
-   DSL_uint16_t Res6 : 2;
-   /** US0 In 25 to 276kHz, Annex C US0 PSDs Supported Bit 1 */
-   DSL_uint16_t C_US0PsdSup1 : 1;
-   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Supported Bit 0 */
-   DSL_uint16_t C_US0PsdSup0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res7 : 7;
-   /** G.998.4 Anx D Supported Bit 8 (VDSL only) */
-   DSL_uint16_t RtxExtMemSup8 : 1;
-   /** Reserved */
-   DSL_uint16_t Res8 : 2;
-   /** O-P-VECTOR1 Flag Tones Only, Supported Bit 5 (VDSL only) */
-   DSL_uint16_t OpVect1FlagTonesSup5 : 1;
-   /** Extended O-P-VECTOR1, Supported Bit 4 (VDSL only) */
-   DSL_uint16_t ExtOpVect1Sup4 : 1;
-   /** Upstream FDPS, Supported Bit 3 (VDSL only) */
-   DSL_uint16_t FdpsUsSup3 : 1;
-   /** Pilot Sequence Length Multiple of 4, Supported Bit 2 (VDSL only) */
-   DSL_uint16_t PilotLen4xSup2 : 1;
-   /** Upstream Vectoring Supported Bit 1 (VDSL only) */
-   DSL_uint16_t VectUsSup1 : 1;
-   /** Downstream Vectoring Supported Bit 0 (VDSL only) */
-   DSL_uint16_t VectDsSup0 : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t  Length;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** 8a, Profile Support Bit 0 */
-   DSL_uint16_t profileSup0 : 1;
-   /** 8b, Profile Support Bit 1 */
-   DSL_uint16_t profileSup1 : 1;
-   /** 8c, Profile Support Bit 2 */
-   DSL_uint16_t profileSup2 : 1;
-   /** 8d, Profile Support Bit 3 */
-   DSL_uint16_t profileSup3 : 1;
-   /** 12a, Profile Support Bit 4 */
-   DSL_uint16_t profileSup4 : 1;
-   /** 12b, Profile Support Bit 5 */
-   DSL_uint16_t profileSup5 : 1;
-   /** 17a, Profile Support Bit 6 */
-   DSL_uint16_t profileSup6 : 1;
-   /** 30a, Profile Support Bit 7 */
-   DSL_uint16_t profileSup7 : 1;
-   /** 35b, Profile Support Bit 8 */
-   DSL_uint16_t profileSup8 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 7;
-   /** EU-32, Annex A US0 PSDs Supported Bit 0 */
-   DSL_uint16_t A_US0PsdSup0 : 1;
-   /** EU-36, Annex A US0 PSDs Supported Bit 1 */
-   DSL_uint16_t A_US0PsdSup1 : 1;
-   /** EU-40, Annex A US0 PSDs Supported Bit 2 */
-   DSL_uint16_t A_US0PsdSup2 : 1;
-   /** EU-44, Annex A US0 PSDs Supported Bit 3 */
-   DSL_uint16_t A_US0PsdSup3 : 1;
-   /** EU-48, Annex A US0 PSDs Supported Bit 4 */
-   DSL_uint16_t A_US0PsdSup4 : 1;
-   /** EU-52, Annex A US0 PSDs Supported Bit 5 */
-   DSL_uint16_t A_US0PsdSup5 : 1;
-   /** EU-56, Annex A US0 PSDs Supported Bit 6 */
-   DSL_uint16_t A_US0PsdSup6 : 1;
-   /** EU-60, Annex A US0 PSDs Supported Bit 7 */
-   DSL_uint16_t A_US0PsdSup7 : 1;
-   /** EU-64, Annex A US0 PSDs Supported Bit 8 */
-   DSL_uint16_t A_US0PsdSup8 : 1;
-   /** ADLU-32, Annex A US0 PSDs Supported Bit 9 */
-   DSL_uint16_t A_US0PsdSup9 : 1;
-   /** ADLU-36, Annex A US0 PSDs Supported Bit 10 */
-   DSL_uint16_t A_US0PsdSup10 : 1;
-   /** ADLU-40, Annex A US0 PSDs Supported Bit 11 */
-   DSL_uint16_t A_US0PsdSup11 : 1;
-   /** ADLU-44, Annex A US0 PSDs Supported Bit 12 */
-   DSL_uint16_t A_US0PsdSup12 : 1;
-   /** ADLU-48, Annex A US0 PSDs Supported Bit 13 */
-   DSL_uint16_t A_US0PsdSup13 : 1;
-   /** ADLU-52, Annex A US0 PSDs Supported Bit 14 */
-   DSL_uint16_t A_US0PsdSup14 : 1;
-   /** ADLU-56, Annex A US0 PSDs Supported Bit 15 */
-   DSL_uint16_t A_US0PsdSup15 : 1;
-   /** ADLU-60, Annex A US0 PSDs Supported Bit 16 */
-   DSL_uint16_t A_US0PsdSup16 : 1;
-   /** ADLU-64, Annex A US0 PSDs Supported Bit 17 */
-   DSL_uint16_t A_US0PsdSup17 : 1;
-   /** 12b Profile, Annex A US0 PSDs Supported Bit 18 */
-   DSL_uint16_t A_US0PsdSup18 : 1;
-   /** 17a Profile, Annex A US0 PSDs Supported Bit 19 */
-   DSL_uint16_t A_US0PsdSup19 : 1;
-   /** EU-128, Annex A US0 PSDs Supported Bit 20 */
-   DSL_uint16_t A_US0PsdSup20 : 1;
-   /** ADLU-128 Annex A US0 PSDs Supported Bit 21 */
-   DSL_uint16_t A_US0PsdSup21 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 10;
-   /** US0 In 25 to 138 kHz, Annex B US0 PSDs Supported Bit 0 */
-   DSL_uint16_t B_US0PsdSup0 : 1;
-   /** US0 In 25 to 276 kHz, Annex B US0 PSDs Supported Bit 1 */
-   DSL_uint16_t B_US0PsdSup1 : 1;
-   /** US0 In 138 to 276 kHz, Annex B US0 PSDs Supported Bit 2 */
-   DSL_uint16_t B_US0PsdSup2 : 1;
-   /** 12b Profile, Annex B US0 PSDs Supported Bit 3 */
-   DSL_uint16_t B_US0PsdSup3 : 1;
-   /** 17a Profile, Annex B US0 PSDs Supported Bit 4 */
-   DSL_uint16_t B_US0PsdSup4 : 1;
-   /** Reserved */
-   DSL_uint16_t Res3 : 11;
-   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Supported Bit 0 */
-   DSL_uint16_t C_US0PsdSup0 : 1;
-   /** US0 In 25 to 276kHz, Annex C US0 PSDs Supported Bit 1 */
-   DSL_uint16_t C_US0PsdSup1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res6 : 2;
-   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Supported Bit 4 */
-   DSL_uint16_t C_US0PsdSup4 : 1;
-   /** US0 In 25 to 276 kHz, Annex C US0 PSDs Supported Bit 5 */
-   DSL_uint16_t C_US0PsdSup5 : 1;
-   /** Reserved */
-   DSL_uint16_t Res5 : 6;
-   /** 12b Profile, Annex C US0 PSDs Supported Bit 12 */
-   DSL_uint16_t C_US0PsdSup12 : 1;
-   /** 17a Profile, Annex C US0 PSDs Supported Bit 13 */
-   DSL_uint16_t C_US0PsdSup13 : 1;
-   /** Reserved */
-   DSL_uint16_t Res4 : 2;
-   /** Downstream Vectoring Supported Bit 0 (VDSL only) */
-   DSL_uint16_t VectDsSup0 : 1;
-   /** Upstream Vectoring Supported Bit 1 (VDSL only) */
-   DSL_uint16_t VectUsSup1 : 1;
-   /** Pilot Sequence Length Multiple of 4, Supported Bit 2 (VDSL only) */
-   DSL_uint16_t PilotLen4xSup2 : 1;
-   /** Upstream FDPS, Supported Bit 3 (VDSL only) */
-   DSL_uint16_t FdpsUsSup3 : 1;
-   /** Extended O-P-VECTOR1, Supported Bit 4 (VDSL only) */
-   DSL_uint16_t ExtOpVect1Sup4 : 1;
-   /** O-P-VECTOR1 Flag Tones Only, Supported Bit 5 (VDSL only) */
-   DSL_uint16_t OpVect1FlagTonesSup5 : 1;
-   /** Reserved */
-   DSL_uint16_t Res8 : 2;
-   /** G.998.4 Anx D Supported Bit 8 (VDSL only) */
-   DSL_uint16_t RtxExtMemSup8 : 1;
-   /** Reserved */
-   DSL_uint16_t Res7 : 7;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the actual selected VDSL2 Profile (See G.994.1 Amendment 4 [10],
-   NPAR(3) coding).
-*/
-struct CMD_HS_SelectedProfileVDSL2Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t  Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t  Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the actual selected VDSL2 Profile as requested by
-   CMD_HS_SelectedProfileVDSL2Get (see G.994.1 Amendment 4 [10], NPAR(3)
-   coding).
-*/
-struct ACK_HS_SelectedProfileVDSL2Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t  Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 4;
-   /** O-P-VECTOR1 Flag Tones Only, Selected Bit 11 */
-   DSL_uint16_t dsmSel11 : 1;
-   /** Extended O-P-VECTOR1,Selected Bit 10 */
-   DSL_uint16_t dsmSel10 : 1;
-   /** Upstream FDPS, Selected Bit 9 */
-   DSL_uint16_t dsmSel9 : 1;
-   /** Pilot Sequence Length Multiple of 4, Selected Bit 8 */
-   DSL_uint16_t dsmSel8 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 4;
-   /** G.993.2 Annex X, Selected Bit 3 */
-   DSL_uint16_t dsmSel3 : 1;
-   /** G.993.2 Annex Y, Selected Bit 2 */
-   DSL_uint16_t dsmSel2 : 1;
-   /** G.993.5 DS Vectoring, Selected Bit 1 */
-   DSL_uint16_t dsmSel1 : 1;
-   /** G.993.5 DS+US Vectoring, Selected Bit 0 */
-   DSL_uint16_t dsmSel0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 7;
-   /** 35b, Profile Selected Bit 8 */
-   DSL_uint16_t profileSel8 : 1;
-   /** 30a, Profile Selected Bit 7 */
-   DSL_uint16_t profileSel7 : 1;
-   /** 17a, Profile Selected Bit 6 */
-   DSL_uint16_t profileSel6 : 1;
-   /** 12b, Profile Selected Bit 5 */
-   DSL_uint16_t profileSel5 : 1;
-   /** 12a, Profile Selected Bit 4 */
-   DSL_uint16_t profileSel4 : 1;
-   /** 8d, Profile Selected Bit 3 */
-   DSL_uint16_t profileSel3 : 1;
-   /** 8c, Profile Selected Bit 2 */
-   DSL_uint16_t profileSel2 : 1;
-   /** 8b, Profile Selected Bit 1 */
-   DSL_uint16_t profileSel1 : 1;
-   /** 8a, Profile Selected Bit 0 */
-   DSL_uint16_t profileSel0 : 1;
-   /** ADLU-56, Annex A US0 PSDs Selected Bit  15 */
-   DSL_uint16_t A_US0PsdSel15 : 1;
-   /** ADLU-52, Annex A US0 PSDs Selected Bit  14 */
-   DSL_uint16_t A_US0PsdSel14 : 1;
-   /** ADLU-48, Annex A US0 PSDs Selected Bit  13 */
-   DSL_uint16_t A_US0PsdSel13 : 1;
-   /** ADLU-44, Annex A US0 PSDs Selected Bit  12 */
-   DSL_uint16_t A_US0PsdSel12 : 1;
-   /** ADLU-40, Annex A US0 PSDs Selected Bit  11 */
-   DSL_uint16_t A_US0PsdSel11 : 1;
-   /** ADLU-36, Annex A US0 PSDs Selected Bit  10 */
-   DSL_uint16_t A_US0PsdSel10 : 1;
-   /** ADLU-32, Annex A US0 PSDs Selected Bit  9 */
-   DSL_uint16_t A_US0PsdSel9 : 1;
-   /** EU-64, Annex A US0 PSDs Selected Bit  8 */
-   DSL_uint16_t A_US0PsdSel8 : 1;
-   /** EU-60, Annex A US0 PSDs Selected Bit  7 */
-   DSL_uint16_t A_US0PsdSel7 : 1;
-   /** EU-56, Annex A US0 PSDs Selected Bit  6 */
-   DSL_uint16_t A_US0PsdSel6 : 1;
-   /** EU-52, Annex A US0 PSDs Selected Bit  5 */
-   DSL_uint16_t A_US0PsdSel5 : 1;
-   /** EU-48, Annex A US0 PSDs Selected Bit  4 */
-   DSL_uint16_t A_US0PsdSel4 : 1;
-   /** EU-44, Annex A US0 PSDs Selected Bit  3 */
-   DSL_uint16_t A_US0PsdSel3 : 1;
-   /** EU-40, Annex A US0 PSDs Selected Bit  2 */
-   DSL_uint16_t A_US0PsdSel2 : 1;
-   /** EU-36, Annex A US0 PSDs Selected Bit  1 */
-   DSL_uint16_t A_US0PsdSel1 : 1;
-   /** EU-32, Annex A US0 PSDs Selected Bit  0 */
-   DSL_uint16_t A_US0PsdSel0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res3 : 10;
-   /** ADLU-128 Annex A US0 PSDs Selected Bit 21 */
-   DSL_uint16_t A_US0PsdSel21 : 1;
-   /** EU-128, Annex A US0 PSDs Selected Bit 20 */
-   DSL_uint16_t A_US0PsdSel20 : 1;
-   /** Reserved */
-   DSL_uint16_t Res4 : 2;
-   /** ADLU-64, Annex A US0 PSDs Selected Bit 17 */
-   DSL_uint16_t A_US0PsdSel17 : 1;
-   /** ADLU-60, Annex A US0 PSDs Selected Bit 16 */
-   DSL_uint16_t A_US0PsdSel16 : 1;
-   /** Reserved */
-   DSL_uint16_t Res5 : 13;
-   /** US0 In 120 to 276 kHz, Annex B US0 PSDs Selected Bit 2 */
-   DSL_uint16_t B_US0PsdSel2 : 1;
-   /** US0 In 25 to 276 kHz, Annex B US0 PSDs Selected Bit 1 */
-   DSL_uint16_t B_US0PsdSel1 : 1;
-   /** US0 In 25 to 138 kHz, Annex B US0 PSDs Selected Bit 0 */
-   DSL_uint16_t B_US0PsdSel0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res6 : 10;
-   /** US0 In 25 to 276 kHz, Annex C US0 PSDs Selected Bit 5 */
-   DSL_uint16_t C_US0PsdSel5 : 1;
-   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Selected Bit 4 */
-   DSL_uint16_t C_US0PsdSel4 : 1;
-   /** Reserved */
-   DSL_uint16_t Res7 : 2;
-   /** US0 In 25 to 276kHz, Annex C US0 PSDs Selected Bit 1 */
-   DSL_uint16_t C_US0PsdSel1 : 1;
-   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Selected Bit 0 */
-   DSL_uint16_t C_US0PsdSel0 : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t  Length;
-   /** G.993.5 DS+US Vectoring, Selected Bit 0 */
-   DSL_uint16_t dsmSel0 : 1;
-   /** G.993.5 DS Vectoring, Selected Bit 1 */
-   DSL_uint16_t dsmSel1 : 1;
-   /** G.993.2 Annex Y, Selected Bit 2 */
-   DSL_uint16_t dsmSel2 : 1;
-   /** G.993.2 Annex X, Selected Bit 3 */
-   DSL_uint16_t dsmSel3 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 4;
-   /** Pilot Sequence Length Multiple of 4, Selected Bit 8 */
-   DSL_uint16_t dsmSel8 : 1;
-   /** Upstream FDPS, Selected Bit 9 */
-   DSL_uint16_t dsmSel9 : 1;
-   /** Extended O-P-VECTOR1,Selected Bit 10 */
-   DSL_uint16_t dsmSel10 : 1;
-   /** O-P-VECTOR1 Flag Tones Only, Selected Bit 11 */
-   DSL_uint16_t dsmSel11 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 4;
-   /** 8a, Profile Selected Bit 0 */
-   DSL_uint16_t profileSel0 : 1;
-   /** 8b, Profile Selected Bit 1 */
-   DSL_uint16_t profileSel1 : 1;
-   /** 8c, Profile Selected Bit 2 */
-   DSL_uint16_t profileSel2 : 1;
-   /** 8d, Profile Selected Bit 3 */
-   DSL_uint16_t profileSel3 : 1;
-   /** 12a, Profile Selected Bit 4 */
-   DSL_uint16_t profileSel4 : 1;
-   /** 12b, Profile Selected Bit 5 */
-   DSL_uint16_t profileSel5 : 1;
-   /** 17a, Profile Selected Bit 6 */
-   DSL_uint16_t profileSel6 : 1;
-   /** 30a, Profile Selected Bit 7 */
-   DSL_uint16_t profileSel7 : 1;
-   /** 35b, Profile Selected Bit 8 */
-   DSL_uint16_t profileSel8 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 7;
-   /** EU-32, Annex A US0 PSDs Selected Bit  0 */
-   DSL_uint16_t A_US0PsdSel0 : 1;
-   /** EU-36, Annex A US0 PSDs Selected Bit  1 */
-   DSL_uint16_t A_US0PsdSel1 : 1;
-   /** EU-40, Annex A US0 PSDs Selected Bit  2 */
-   DSL_uint16_t A_US0PsdSel2 : 1;
-   /** EU-44, Annex A US0 PSDs Selected Bit  3 */
-   DSL_uint16_t A_US0PsdSel3 : 1;
-   /** EU-48, Annex A US0 PSDs Selected Bit  4 */
-   DSL_uint16_t A_US0PsdSel4 : 1;
-   /** EU-52, Annex A US0 PSDs Selected Bit  5 */
-   DSL_uint16_t A_US0PsdSel5 : 1;
-   /** EU-56, Annex A US0 PSDs Selected Bit  6 */
-   DSL_uint16_t A_US0PsdSel6 : 1;
-   /** EU-60, Annex A US0 PSDs Selected Bit  7 */
-   DSL_uint16_t A_US0PsdSel7 : 1;
-   /** EU-64, Annex A US0 PSDs Selected Bit  8 */
-   DSL_uint16_t A_US0PsdSel8 : 1;
-   /** ADLU-32, Annex A US0 PSDs Selected Bit  9 */
-   DSL_uint16_t A_US0PsdSel9 : 1;
-   /** ADLU-36, Annex A US0 PSDs Selected Bit  10 */
-   DSL_uint16_t A_US0PsdSel10 : 1;
-   /** ADLU-40, Annex A US0 PSDs Selected Bit  11 */
-   DSL_uint16_t A_US0PsdSel11 : 1;
-   /** ADLU-44, Annex A US0 PSDs Selected Bit  12 */
-   DSL_uint16_t A_US0PsdSel12 : 1;
-   /** ADLU-48, Annex A US0 PSDs Selected Bit  13 */
-   DSL_uint16_t A_US0PsdSel13 : 1;
-   /** ADLU-52, Annex A US0 PSDs Selected Bit  14 */
-   DSL_uint16_t A_US0PsdSel14 : 1;
-   /** ADLU-56, Annex A US0 PSDs Selected Bit  15 */
-   DSL_uint16_t A_US0PsdSel15 : 1;
-   /** ADLU-60, Annex A US0 PSDs Selected Bit 16 */
-   DSL_uint16_t A_US0PsdSel16 : 1;
-   /** ADLU-64, Annex A US0 PSDs Selected Bit 17 */
-   DSL_uint16_t A_US0PsdSel17 : 1;
-   /** Reserved */
-   DSL_uint16_t Res4 : 2;
-   /** EU-128, Annex A US0 PSDs Selected Bit 20 */
-   DSL_uint16_t A_US0PsdSel20 : 1;
-   /** ADLU-128 Annex A US0 PSDs Selected Bit 21 */
-   DSL_uint16_t A_US0PsdSel21 : 1;
-   /** Reserved */
-   DSL_uint16_t Res3 : 10;
-   /** US0 In 25 to 138 kHz, Annex B US0 PSDs Selected Bit 0 */
-   DSL_uint16_t B_US0PsdSel0 : 1;
-   /** US0 In 25 to 276 kHz, Annex B US0 PSDs Selected Bit 1 */
-   DSL_uint16_t B_US0PsdSel1 : 1;
-   /** US0 In 120 to 276 kHz, Annex B US0 PSDs Selected Bit 2 */
-   DSL_uint16_t B_US0PsdSel2 : 1;
-   /** Reserved */
-   DSL_uint16_t Res5 : 13;
-   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Selected Bit 0 */
-   DSL_uint16_t C_US0PsdSel0 : 1;
-   /** US0 In 25 to 276kHz, Annex C US0 PSDs Selected Bit 1 */
-   DSL_uint16_t C_US0PsdSel1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res7 : 2;
-   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Selected Bit 4 */
-   DSL_uint16_t C_US0PsdSel4 : 1;
-   /** US0 In 25 to 276 kHz, Annex C US0 PSDs Selected Bit 5 */
-   DSL_uint16_t C_US0PsdSel5 : 1;
-   /** Reserved */
-   DSL_uint16_t Res6 : 10;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the handshake information about the far-end operating mode (See
-   G.994.1 [6] and Amendments 1-4 [7]-[10], standard information fields- SPAR(1)
-   coding).
-*/
-struct CMD_HS_StandardInfoFE_SPAR1Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t  Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t  Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the handshake information about the far-end operating mode (See
-   G.994.1 [6] and Amendments 1-4 [7]-[10], Standard information field - SPAR(1)
-   coding). The bit numbering per octet below follows the standard (starting
-   with "1").
-*/
-struct ACK_HS_StandardInfoFE_SPAR1Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t  Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 1;
-   /** Octet 2, Bit 7: Committee T1 enhanced SHDSL */
-   DSL_uint16_t Oct2B7 : 1;
-   /** Octet 2, Bit 6: ETSI SCM VDSL */
-   DSL_uint16_t Oct2B6 : 1;
-   /** Octet 2, Bit 5: ETSI MCM VDSL */
-   DSL_uint16_t Oct2B5 : 1;
-   /** Octet 2, Bit 4: T1E1 Trial-use SCM VDSL */
-   DSL_uint16_t Oct2B4 : 1;
-   /** Octet 2, Bit 3: T1E1 Trial-use MCM VDSL */
-   DSL_uint16_t Oct2B3 : 1;
-   /** Octet 2, Bit 2: G991.2 Annex B/G */
-   DSL_uint16_t Oct2B2 : 1;
-   /** Octet 2, Bit 1: G991.2 Annex A/F */
-   DSL_uint16_t Oct2B1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 1;
-   /** Octet 1, Bit 7: G992.1 Annex I */
-   DSL_uint16_t Oct1B7 : 1;
-   /** Octet 1, Bit 6: G992.1 Annex H */
-   DSL_uint16_t Oct1B6 : 1;
-   /** Octet 1, Bit 5: G992.2 Annex C */
-   DSL_uint16_t Oct1B5 : 1;
-   /** Octet 1, Bit 4: G992.2 Annex A/B */
-   DSL_uint16_t Oct1B4 : 1;
-   /** Octet 1, Bit 3: G992.1 Annex C */
-   DSL_uint16_t Oct1B3 : 1;
-   /** Octet 1, Bit 2: G992.1 Annex B */
-   DSL_uint16_t Oct1B2 : 1;
-   /** Octet 1, Bit 1: G992.1 Annex A */
-   DSL_uint16_t Oct1B1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 1;
-   /** Octet 4, Bit 7: IEEE 802.3ah 2BASE-TS */
-   DSL_uint16_t Oct4B7 : 1;
-   /** Octet 4, Bit 6: IEEE 802.3ah 2BASE-TL */
-   DSL_uint16_t Oct4B6 : 1;
-   /** Octet 4, Bit 5: G992.5 Annex J */
-   DSL_uint16_t Oct4B5 : 1;
-   /** Octet 4, Bit 4: G992.3 Annex M */
-   DSL_uint16_t Oct4B4 : 1;
-   /** Octet 4, Bit 3: G992.5 Annex I */
-   DSL_uint16_t Oct4B3 : 1;
-   /** Octet 4, Bit 2: G992.5 Annex B */
-   DSL_uint16_t Oct4B2 : 1;
-   /** Octet 4, Bit 1: G992.5 Annex A */
-   DSL_uint16_t Oct4B1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res3 : 1;
-   /** Octet 3, Bit 7: G992.3 Annex C */
-   DSL_uint16_t Oct3B7 : 1;
-   /** Octet 3, Bit 6: G992.4 Annex I */
-   DSL_uint16_t Oct3B6 : 1;
-   /** Octet 3, Bit 5: G992.4 Annex A */
-   DSL_uint16_t Oct3B5 : 1;
-   /** Octet 3, Bit 4: G992.3 Annex J */
-   DSL_uint16_t Oct3B4 : 1;
-   /** Octet 3, Bit 3: G992.3 Annex I */
-   DSL_uint16_t Oct3B3 : 1;
-   /** Octet 3, Bit 2: G992.3 Annex B */
-   DSL_uint16_t Oct3B2 : 1;
-   /** Octet 3, Bit 1: G992.3 Annex A/L */
-   DSL_uint16_t Oct3B1 : 1;
-   /** Reserved */
-   DSL_uint8_t Res4;
-   /** Reserved */
-   DSL_uint16_t Res5 : 1;
-   /** Octet 5, Bit 6: G.FAST */
-   DSL_uint16_t Oct5B7 : 1;
-   /** Octet 5, Bit 5: G993.2 */
-   DSL_uint16_t Oct5B6 : 1;
-   /** Octet 5, Bit 4: G992.5 Annex C */
-   DSL_uint16_t Oct5B5 : 1;
-   /** Octet 5, Bit 3: Variable Silence Period */
-   DSL_uint16_t Oct5B4 : 1;
-   /** Octet 5, Bit 2: G992.1 Annex I / T1E1 TRQ 12 */
-   DSL_uint16_t Oct5B3 : 1;
-   /** Octet 5, Bit 1: G993.1 / ANSI T1.424 */
-   DSL_uint16_t Oct5B2 : 1;
-   /** Octet 5, Bit 0: G992.5 Annex M */
-   DSL_uint16_t Oct5B1 : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t  Length;
-   /** Octet 1, Bit 1: G992.1 Annex A */
-   DSL_uint16_t Oct1B1 : 1;
-   /** Octet 1, Bit 2: G992.1 Annex B */
-   DSL_uint16_t Oct1B2 : 1;
-   /** Octet 1, Bit 3: G992.1 Annex C */
-   DSL_uint16_t Oct1B3 : 1;
-   /** Octet 1, Bit 4: G992.2 Annex A/B */
-   DSL_uint16_t Oct1B4 : 1;
-   /** Octet 1, Bit 5: G992.2 Annex C */
-   DSL_uint16_t Oct1B5 : 1;
-   /** Octet 1, Bit 6: G992.1 Annex H */
-   DSL_uint16_t Oct1B6 : 1;
-   /** Octet 1, Bit 7: G992.1 Annex I */
-   DSL_uint16_t Oct1B7 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 1;
-   /** Octet 2, Bit 1: G991.2 Annex A/F */
-   DSL_uint16_t Oct2B1 : 1;
-   /** Octet 2, Bit 2: G991.2 Annex B/G */
-   DSL_uint16_t Oct2B2 : 1;
-   /** Octet 2, Bit 3: T1E1 Trial-use MCM VDSL */
-   DSL_uint16_t Oct2B3 : 1;
-   /** Octet 2, Bit 4: T1E1 Trial-use SCM VDSL */
-   DSL_uint16_t Oct2B4 : 1;
-   /** Octet 2, Bit 5: ETSI MCM VDSL */
-   DSL_uint16_t Oct2B5 : 1;
-   /** Octet 2, Bit 6: ETSI SCM VDSL */
-   DSL_uint16_t Oct2B6 : 1;
-   /** Octet 2, Bit 7: Committee T1 enhanced SHDSL */
-   DSL_uint16_t Oct2B7 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 1;
-   /** Octet 3, Bit 1: G992.3 Annex A/L */
-   DSL_uint16_t Oct3B1 : 1;
-   /** Octet 3, Bit 2: G992.3 Annex B */
-   DSL_uint16_t Oct3B2 : 1;
-   /** Octet 3, Bit 3: G992.3 Annex I */
-   DSL_uint16_t Oct3B3 : 1;
-   /** Octet 3, Bit 4: G992.3 Annex J */
-   DSL_uint16_t Oct3B4 : 1;
-   /** Octet 3, Bit 5: G992.4 Annex A */
-   DSL_uint16_t Oct3B5 : 1;
-   /** Octet 3, Bit 6: G992.4 Annex I */
-   DSL_uint16_t Oct3B6 : 1;
-   /** Octet 3, Bit 7: G992.3 Annex C */
-   DSL_uint16_t Oct3B7 : 1;
-   /** Reserved */
-   DSL_uint16_t Res3 : 1;
-   /** Octet 4, Bit 1: G992.5 Annex A */
-   DSL_uint16_t Oct4B1 : 1;
-   /** Octet 4, Bit 2: G992.5 Annex B */
-   DSL_uint16_t Oct4B2 : 1;
-   /** Octet 4, Bit 3: G992.5 Annex I */
-   DSL_uint16_t Oct4B3 : 1;
-   /** Octet 4, Bit 4: G992.3 Annex M */
-   DSL_uint16_t Oct4B4 : 1;
-   /** Octet 4, Bit 5: G992.5 Annex J */
-   DSL_uint16_t Oct4B5 : 1;
-   /** Octet 4, Bit 6: IEEE 802.3ah 2BASE-TL */
-   DSL_uint16_t Oct4B6 : 1;
-   /** Octet 4, Bit 7: IEEE 802.3ah 2BASE-TS */
-   DSL_uint16_t Oct4B7 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 1;
-   /** Octet 5, Bit 0: G992.5 Annex M */
-   DSL_uint16_t Oct5B1 : 1;
-   /** Octet 5, Bit 1: G993.1 / ANSI T1.424 */
-   DSL_uint16_t Oct5B2 : 1;
-   /** Octet 5, Bit 2: G992.1 Annex I / T1E1 TRQ 12 */
-   DSL_uint16_t Oct5B3 : 1;
-   /** Octet 5, Bit 3: Variable Silence Period */
-   DSL_uint16_t Oct5B4 : 1;
-   /** Octet 5, Bit 4: G992.5 Annex C */
-   DSL_uint16_t Oct5B5 : 1;
-   /** Octet 5, Bit 5: G993.2 */
-   DSL_uint16_t Oct5B6 : 1;
-   /** Octet 5, Bit 6: G.FAST */
-   DSL_uint16_t Oct5B7 : 1;
-   /** Reserved */
-   DSL_uint16_t Res5 : 1;
-   /** Reserved */
-   DSL_uint8_t Res4;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Sets the in System Vendor ID at the xTU-R. (Section 7.4.4 of G.997.1 [11])
-*/
-struct CMD_SysVendorID_R_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-R System Vendor ID */
-   DSL_uint16_t sysVendorID[4];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-R System Vendor ID */
-   DSL_uint16_t sysVendorID[4];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_SysVendorID_R_Set.
-*/
-struct ACK_SysVendorID_R_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Sets the system vendor version number at the xTU-R. (Section 7.4.6 of G.997.1
-   [11])
-*/
-struct CMD_SysVendorVersionNum_R_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-R System Vendor Version Number */
-   DSL_uint16_t versionNum[8];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-R System Vendor Version Number */
-   DSL_uint16_t versionNum[8];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_SysVendorVersionNum_R_Set.
-*/
-struct ACK_SysVendorVersionNum_R_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Sets the system vendor serial number at the xTU-R. (Section 7.4.8 of G.997.1
-   [11])
-*/
-struct CMD_SysVendorSerialNum_R_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-R System Vendor Serial Number */
-   DSL_uint16_t serialNum[16];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-R System Vendor Serial Number */
-   DSL_uint16_t serialNum[16];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_SysVendorSerialNum_R_Set.
-*/
-struct ACK_SysVendorSerialNum_R_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Sets auxiliary inventory information at the VTU-R (Section 11.2.3.2.4 of
-   G993.2 [5]).
-*/
-struct CMD_AuxInventoryInfo_R_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** VTU-R Auxiliary Inventory Information */
-   DSL_uint16_t auxInfo[32];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** VTU-R Auxiliary Inventory Information */
-   DSL_uint16_t auxInfo[32];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_AuxInventoryInfo_R_Set.
-*/
-struct ACK_AuxInventoryInfo_R_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the xTU-C Vendor ID. (Section 7.4.1 of G.997.1 [11])
-*/
-struct CMD_VendorID_O_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the xTU-C Vendor ID as requested by CMD_VendorID_O_Get.
-*/
-struct ACK_VendorID_O_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-C G.994.1 Vendor ID */
-   DSL_uint16_t vendorID[4];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-C G.994.1 Vendor ID */
-   DSL_uint16_t vendorID[4];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the xTU-R Vendor ID. (Section 7.4.2 of G.997.1 [11])
-*/
-struct CMD_VendorID_R_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the xTU-R Vendor ID as requested by CMD_VendorID_R_Get.
-*/
-struct ACK_VendorID_R_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-R G.994.1 Vendor ID */
-   DSL_uint16_t vendorID[4];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-R G.994.1 Vendor ID */
-   DSL_uint16_t vendorID[4];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the xTU-C System Vendor ID. (Section 7.4.3 of G.997.1 [11])
-*/
-struct CMD_SysVendorID_O_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the xTU-C System Vendor ID as requested by CMD_SysVendorID_O_Get.
-*/
-struct ACK_SysVendorID_O_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-C System Vendor ID */
-   DSL_uint16_t sysVendorID[4];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-C System Vendor ID */
-   DSL_uint16_t sysVendorID[4];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the xTU-R System Vendor ID. (Section 7.4.4 of G.997.1 [11])
-*/
-struct CMD_SysVendorID_R_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the xTU-R System Vendor ID as requested by CMD_SysVendorID_R_Get.
-*/
-struct ACK_SysVendorID_R_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-R System Vendor ID */
-   DSL_uint16_t sysVendorID[4];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-R System Vendor ID */
-   DSL_uint16_t sysVendorID[4];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the xTU-C system vendor version number. (Section 7.4.5 of G.997.1
-   [11])
-*/
-struct CMD_SysVendorVersionNumO_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the xTU-C system vendor version number as requested by
-   CMD_SysVendorVersionNumO_Get.
-*/
-struct ACK_SysVendorVersionNum_O_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-C System Vendor Version Number */
-   DSL_uint16_t versionNum[8];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-C System Vendor Version Number */
-   DSL_uint16_t versionNum[8];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the xTU-R system vendor version number. (Section 7.4.6 of G.997.1
-   [11])
-*/
-struct CMD_SysVendorVersionNum_R_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the xTU-R system vendor version number as requested by
-   CMD_SysVendorVersionNum_R_Get.
-*/
-struct ACK_SysVendorVersionNum_R_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-R System Vendor Version Number */
-   DSL_uint16_t versionNum[8];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-R System Vendor Version Number */
-   DSL_uint16_t versionNum[8];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the xTU-C system vendor serial number. (Section 7.4.7 of G.997.1
-   [11])
-*/
-struct CMD_SysVendorSerialNum_O_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the xTU-C system vendor serial number as requested by
-   CMD_SysVendorSerialNum_O_Get.
-*/
-struct ACK_SysVendorSerialNum_O_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-C System Vendor Serial Number */
-   DSL_uint16_t serialNum[16];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-C System Vendor Serial Number */
-   DSL_uint16_t serialNum[16];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the xTU-R system vendor serial number. (Section 7.4.8 of G.997.1
-   [11])
-*/
-struct CMD_SysVendorSerialNum_R_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the xTU-R system vendor version number as requested by
-   CMD_SysVendorSerialNum_R_Get.
-*/
-struct ACK_SysVendorSerialNum_R_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-R System Vendor Serial Number */
-   DSL_uint16_t serialNum[16];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** xTU-R System Vendor Serial Number */
-   DSL_uint16_t serialNum[16];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests VTU-O auxiliary inventory information (Section 11.2.3.2.4 of G993.2
-   [5]).
-*/
-struct CMD_AuxInventoryInfo_O_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the VTU-O auxiliary inventory information as requested by
-   CMD_AuxInventoryInfo_O_Get.
-*/
-struct ACK_AuxInventoryInfo_O_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** VTU-O Auxiliary Inventory Information */
-   DSL_uint16_t auxInfo[32];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** VTU-O Auxiliary Inventory Information */
-   DSL_uint16_t auxInfo[32];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests VTU-R auxiliary inventory information (Section 11.2.3.2.4 of G993.2
-   [5]).
-*/
-struct CMD_AuxInventoryInfo_R_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the VTU-R auxiliary inventory information as requested by
-   CMD_AuxInventoryInfo_R_Get.
-*/
-struct ACK_AuxInventoryInfo_R_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** VTU-O Auxiliary Inventory Information */
-   DSL_uint16_t auxInfo[32];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** VTU-O Auxiliary Inventory Information */
-   DSL_uint16_t auxInfo[32];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the ATU-C's T1.413 Vendor identification. (Section 9.6.4.2 of ANSI
-   T1.413 [16])
-*/
-struct CMD_T1413_VendorID_O_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the ATU-C's T1.413 vendor identification number.
-*/
-struct ACK_T1413_VendorID_O_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** T1.413 Vendor ID */
-   DSL_uint16_t T1413VendorID;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** T1.413 Vendor ID */
-   DSL_uint16_t T1413VendorID;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the ATU-R's T1.413 Vendor identification. (Section 9.6.4.2 of ANSI
-   T1.413 [16])
-*/
-struct CMD_T1413_VendorID_R_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reports the ATU-R's T1.413 vendor identification number.
-*/
-struct ACK_T1413_VendorID_R_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** T1.413 Vendor ID */
-   DSL_uint16_t T1413VendorID;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** T1.413 Vendor ID */
-   DSL_uint16_t T1413VendorID;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the xTU-C's T1.413 revision number. (Section 9.6.4.3 of ANSI T1.413
-   [16])
-*/
-struct CMD_T1413_RevNo_O_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the xTU-C's T1.413 revision number.
-*/
-struct ACK_T1413_RevNo_O_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** T1.413 Revision Number */
-   DSL_uint16_t T1413RevNo;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** T1.413 Revision Number */
-   DSL_uint16_t T1413RevNo;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the xTU-R's T1.413 revision number. (Section 9.7.6.2 of ANSI T1.413
-   [16])
-*/
-struct CMD_T1413_RevNo_R_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the xTU-R's T1.413 revision number.
-*/
-struct ACK_T1413_RevNo_R_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** T1.413 Revision Number */
-   DSL_uint16_t T1413RevNo;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** T1.413 Revision Number */
-   DSL_uint16_t T1413RevNo;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the xTU-C's T1.413 vendor revision number. (Section 9.6.4.4 of ANSI
-   T1.413 [16])
-*/
-struct CMD_T1413_VendorRevNo_O_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the xTU-C's T1.413 vendor revision number.
-*/
-struct ACK_T1413_VendorRevNo_O_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** T1.413 Vendor Revision Number */
-   DSL_uint16_t T1413VendorRevNo;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** T1.413 Vendor Revision Number */
-   DSL_uint16_t T1413VendorRevNo;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the xTU-R's T1.413 vendor revision number. (Section 9.7.6.3 of ANSI
-   T1.413 [16])
-*/
-struct CMD_T1413_VendorRevNo_R_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the xTU-R's T1.413 vendor revision number.
-*/
-struct ACK_T1413_VendorRevNo_R_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** T1.413 Vendor Revision Number */
-   DSL_uint16_t T1413VendorRevNo;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** T1.413 Vendor Revision Number */
-   DSL_uint16_t T1413VendorRevNo;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the transmission system in use on the line (DSL flavour). (Section
-   7.5.1.1. of G.997.1 [11]) See note at ACK_XTSE_StatusGet about the expected
-   behaviour.
-*/
-struct CMD_XTSE_StatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reports the transmission system mode in use as requested by
-   CMD_XTSE_StatusGet.The information is set by the FW after mode select (MS)
-   during the handshake phase or during T1.413 state. Before mode selection the
-   value "0" is reported (=none), after selection of a common mode exactly this
-   single mode must be indicated. If there is a common mode but it requires
-   another FW to be loaded (e.g. ADSL instead of VDSL), this does not happen
-   ("0" is reported ), then the FW goes to FAIL state and indicates a specific
-   suberror code (S_XDSL_MODE). If there is no common mode, "0" is to be
-   reported (here modem enters FAIL state).
-*/
-struct ACK_XTSE_StatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** ADSL Mode-Bit15: G.992.5, Annex A */
-   DSL_uint16_t A15 : 1;
-   /** ADSL Mode-Bit14: G.992.5, Annex B */
-   DSL_uint16_t A14 : 1;
-   /** ADSL Mode-Bit13: G.992.3, Annex M */
-   DSL_uint16_t A13 : 1;
-   /** ADSL Mode-Bit12: G.992.3, Annex L, US Mask2 */
-   DSL_uint16_t A12 : 1;
-   /** ADSL Mode-Bit11: G.992.3, Annex L, US Mask1 */
-   DSL_uint16_t A11 : 1;
-   /** ADSL Mode-Bit10: G.992.2, Annex A */
-   DSL_uint16_t A10 : 1;
-   /** ADSL Mode-Bit9: G.992.3, Annex B */
-   DSL_uint16_t A9 : 1;
-   /** ADSL Mode-Bit8: G.992.3, Annex A */
-   DSL_uint16_t A8 : 1;
-   /** ADSL Mode-Bit7: G.992.5, Annex J */
-   DSL_uint16_t A7 : 1;
-   /** ADSL Mode-Bit6: G.992.5, Annex I */
-   DSL_uint16_t A6 : 1;
-   /** ADSL Mode-Bit5: G.992.3, Annex J */
-   DSL_uint16_t A5 : 1;
-   /** ADSL Mode-Bit4: G.992.3, Annex I */
-   DSL_uint16_t A4 : 1;
-   /** ADSL Mode-Bit3: G.992.1, Annex B */
-   DSL_uint16_t A3 : 1;
-   /** ADSL Mode-Bit2: G.992.1, Annex A */
-   DSL_uint16_t A2 : 1;
-   /** ADSL Mode-Bit1: G.992.5, Annex M */
-   DSL_uint16_t A1 : 1;
-   /** ADSL Mode-Bit0: T1.413 */
-   DSL_uint16_t A0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-   /** VDSL Mode-Bit2: VDSL2 */
-   DSL_uint16_t V2 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 2;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** ADSL Mode-Bit0: T1.413 */
-   DSL_uint16_t A0 : 1;
-   /** ADSL Mode-Bit1: G.992.5, Annex M */
-   DSL_uint16_t A1 : 1;
-   /** ADSL Mode-Bit2: G.992.1, Annex A */
-   DSL_uint16_t A2 : 1;
-   /** ADSL Mode-Bit3: G.992.1, Annex B */
-   DSL_uint16_t A3 : 1;
-   /** ADSL Mode-Bit4: G.992.3, Annex I */
-   DSL_uint16_t A4 : 1;
-   /** ADSL Mode-Bit5: G.992.3, Annex J */
-   DSL_uint16_t A5 : 1;
-   /** ADSL Mode-Bit6: G.992.5, Annex I */
-   DSL_uint16_t A6 : 1;
-   /** ADSL Mode-Bit7: G.992.5, Annex J */
-   DSL_uint16_t A7 : 1;
-   /** ADSL Mode-Bit8: G.992.3, Annex A */
-   DSL_uint16_t A8 : 1;
-   /** ADSL Mode-Bit9: G.992.3, Annex B */
-   DSL_uint16_t A9 : 1;
-   /** ADSL Mode-Bit10: G.992.2, Annex A */
-   DSL_uint16_t A10 : 1;
-   /** ADSL Mode-Bit11: G.992.3, Annex L, US Mask1 */
-   DSL_uint16_t A11 : 1;
-   /** ADSL Mode-Bit12: G.992.3, Annex L, US Mask2 */
-   DSL_uint16_t A12 : 1;
-   /** ADSL Mode-Bit13: G.992.3, Annex M */
-   DSL_uint16_t A13 : 1;
-   /** ADSL Mode-Bit14: G.992.5, Annex B */
-   DSL_uint16_t A14 : 1;
-   /** ADSL Mode-Bit15: G.992.5, Annex A */
-   DSL_uint16_t A15 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 2;
-   /** VDSL Mode-Bit2: VDSL2 */
-   DSL_uint16_t V2 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reads the used downstream band configuration.
-*/
-struct CMD_BandControl_DS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for message CMD_BandControl_DS_Get.
-*/
-struct ACK_BandControl_DS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint8_t Res0;
-   /** Number of Downstream Bands */
-   DSL_uint8_t NumBandsDS;
-   /** Band Descriptor DS */
-   VRX_ToneIndex_t band[8];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Number of Downstream Bands */
-   DSL_uint8_t NumBandsDS;
-   /** Reserved */
-   DSL_uint8_t Res0;
-   /** Band Descriptor DS */
-   VRX_ToneIndex_t band[8];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reads the used upstream band configuration.
-*/
-struct CMD_BandControl_US_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for message CMD_BandControl_US_Get.
-*/
-struct ACK_BandControl_US_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint8_t Res0;
-   /** Number of Upstream Bands */
-   DSL_uint8_t NumBandsUS;
-   /** Band Descriptor US */
-   VRX_ToneIndex_t band[8];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Number of Upstream Bands */
-   DSL_uint8_t NumBandsUS;
-   /** Reserved */
-   DSL_uint8_t Res0;
-   /** Band Descriptor US */
-   VRX_ToneIndex_t band[8];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reads the RFI band configuration.
-*/
-struct CMD_RFI_BandControlGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for message CMD_RFI_BandControlGet.
-*/
-struct ACK_RFI_BandControlGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint8_t Res0;
-   /** Number of RFI Bands */
-   DSL_uint8_t NumRfiBands;
-   /** RFI Band Descriptor */
-   VRX_ToneIndex_t RfiBand[16];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Number of RFI Bands */
-   DSL_uint8_t NumRfiBands;
-   /** Reserved */
-   DSL_uint8_t Res0;
-   /** RFI Band Descriptor */
-   VRX_ToneIndex_t RfiBand[16];
-#endif
-} __PACKED__ ;
-
-
-/**
-   This message requests data about the line status (like noise margin) for
-   downstream direction.
-*/
-struct CMD_LineStatusDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message delivers the line status data for downstream direction requested
-   by CMD_LineStatusDS_Get.
-*/
-struct ACK_LineStatusDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** Downstream LATN */
-   DSL_uint16_t LATNds;
-   /** Downstream SATN */
-   DSL_uint16_t SATNds;
-   /** Downstream SNRM */
-   DSL_uint16_t SNRMds;
-   /** Downstream ATTNDR, LSW */
-   DSL_uint16_t ATTNDRds_LSW;
-   /** Downstream ATTNDR, MSW */
-   DSL_uint16_t ATTNDRds_MSW;
-   /** Downstream ACTATP */
-   DSL_int16_t ACTATPds;
-   /** Downstream ACTPSD (ADSL only) */
-   DSL_uint16_t ACTPSDds;
-   /** Reserved */
-   DSL_uint16_t Res1 : 7;
-   /** Virtual Noise Status DS */
-   DSL_uint16_t VNstatus_ds : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 6;
-   /** NTR Status DS */
-   DSL_uint16_t NTRstatus_ds : 1;
-   /** TCM Status DS */
-   DSL_uint16_t TCMstatus_ds : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** Downstream LATN */
-   DSL_uint16_t LATNds;
-   /** Downstream SATN */
-   DSL_uint16_t SATNds;
-   /** Downstream SNRM */
-   DSL_uint16_t SNRMds;
-   /** Downstream ATTNDR, LSW */
-   DSL_uint16_t ATTNDRds_LSW;
-   /** Downstream ATTNDR, MSW */
-   DSL_uint16_t ATTNDRds_MSW;
-   /** Downstream ACTATP */
-   DSL_int16_t ACTATPds;
-   /** Downstream ACTPSD (ADSL only) */
-   DSL_uint16_t ACTPSDds;
-   /** TCM Status DS */
-   DSL_uint16_t TCMstatus_ds : 1;
-   /** NTR Status DS */
-   DSL_uint16_t NTRstatus_ds : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 6;
-   /** Virtual Noise Status DS */
-   DSL_uint16_t VNstatus_ds : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 7;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This message requests data about the upstream line status (like noise
-   margin).
-*/
-struct CMD_LineStatusUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message delivers the line status data for upstream direction requested by
-   CMD_LineStatusUS_Get.
-*/
-struct ACK_LineStatusUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** Upstream LATN */
-   DSL_uint16_t LATNus;
-   /** Upstream SATN */
-   DSL_uint16_t SATNus;
-   /** Upstream SNRM */
-   DSL_uint16_t SNRMus;
-   /** Upstream ATTNDR, LSW */
-   DSL_uint16_t ATTNDRus_LSW;
-   /** Upstream ATTNDR, MSW */
-   DSL_uint16_t ATTNDRus_MSW;
-   /** Upstream ACTATP */
-   DSL_int16_t ACTATPus;
-   /** Upstream ACTPSD (ADSL only) */
-   DSL_uint16_t ACTPSDus;
-   /** Reserved */
-   DSL_uint16_t Res1 : 7;
-   /** Virtual Noise Status US */
-   DSL_uint16_t VNstatus_us : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 7;
-   /** TCM Status US */
-   DSL_uint16_t TCMstatus_us : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** Upstream LATN */
-   DSL_uint16_t LATNus;
-   /** Upstream SATN */
-   DSL_uint16_t SATNus;
-   /** Upstream SNRM */
-   DSL_uint16_t SNRMus;
-   /** Upstream ATTNDR, LSW */
-   DSL_uint16_t ATTNDRus_LSW;
-   /** Upstream ATTNDR, MSW */
-   DSL_uint16_t ATTNDRus_MSW;
-   /** Upstream ACTATP */
-   DSL_int16_t ACTATPus;
-   /** Upstream ACTPSD (ADSL only) */
-   DSL_uint16_t ACTPSDus;
-   /** TCM Status US */
-   DSL_uint16_t TCMstatus_us : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 7;
-   /** Virtual Noise Status US */
-   DSL_uint16_t VNstatus_us : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 7;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This message requests data about the line status (noise margin, line
-   attenuation and signal attenuation) for downstream direction in a "per band"
-   granularity.
-*/
-struct CMD_LineStatusPerBandDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message delivers the line status data (line attenuation, signal
-   attenuation and noise margin) for downstream direction in a "per band"
-   granularity as requested by CMD_LineStatusPerBandDS_Get.
-*/
-struct ACK_LineStatusPerBandDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** Line Status Descriptor DS  */
-   VRX_LineStatus_pb_t LineStatus_pb_ds[8];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** Line Status Descriptor DS  */
-   VRX_LineStatus_pb_t LineStatus_pb_ds[8];
-#endif
-} __PACKED__ ;
-
-
-/**
-   This message requests data about the line status (noise margin, line - and
-   signal attenuation) for upstream direction in a "per band" granularity.
-*/
-struct CMD_LineStatusPerBandUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message delivers the line status data (line attenuation, signal
-   attenuation and noise margin) for upstream direction in a "per band"
-   granularity as requested by CMD_LineStatusPerBandUS_Get.
-*/
-struct ACK_LineStatusPerBandUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** Line Status Descriptor US  */
-   VRX_LineStatus_pb_t LineStatus_pb_us[8];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** Line Status Descriptor US  */
-   VRX_LineStatus_pb_t LineStatus_pb_us[8];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests parameters used for the calculation of the downstream attainable net
-   data rate (ATTNDRds).
-*/
-struct CMD_AttndrStatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the data requested by CMD_AttndrStatusGet.(Section 7.5.1.41 of
-   G.997.1 [12]).
-*/
-struct ACK_AttndrStatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** ATTNDR Actual Method (ATTNDR_ACTMETHOD). */
-   DSL_uint16_t AttndrActMethod;
-   /** ATTNDR Downstream Actual INP (ATTNDR_ACTINPds). */
-   DSL_uint16_t AttndrActInpDs;
-   /** ATTNDR DS Actual INP against REIN (ATTNDR_ACTINP_REINds). */
-   DSL_uint16_t AttndrActInpReinDs;
-   /** ATTNDR DS Actual Delay (ATTNDR_ACTDELAYds). */
-   DSL_uint16_t AttndrActDelayDs;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** ATTNDR Actual Method (ATTNDR_ACTMETHOD). */
-   DSL_uint16_t AttndrActMethod;
-   /** ATTNDR Downstream Actual INP (ATTNDR_ACTINPds). */
-   DSL_uint16_t AttndrActInpDs;
-   /** ATTNDR DS Actual INP against REIN (ATTNDR_ACTINP_REINds). */
-   DSL_uint16_t AttndrActInpReinDs;
-   /** ATTNDR DS Actual Delay (ATTNDR_ACTDELAYds). */
-   DSL_uint16_t AttndrActDelayDs;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the breakpoints of the actual PSD for the downstream direction. PSDs
-   consisting of more than 42 PSD breakpoints must be read with 2 messages due
-   to the the mailbox size. (The first parameter in the retrieved data structure
-   contains the "Number of Breakpoints" parameter.)
-*/
-struct CMD_PSD_BreakpointsDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the breakpoints of the actual PSD for the downstream direction as
-   requested by CMD_PSD_BreakpointsDS_Get.
-*/
-struct ACK_PSD_BreakpointsDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Data */
-   DSL_uint16_t Data[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Data */
-   DSL_uint16_t Data[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the breakpoints of the actual PSD for the upstream direction.
-*/
-struct CMD_PSD_BreakpointsUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the breakpoints of the actual PSD for the upstream direction as
-   requested by CMD_PSD_BreakpointsUS_Get.
-*/
-struct ACK_PSD_BreakpointsUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint8_t Res0;
-   /** Number of Breakpoints */
-   DSL_uint8_t NumBreakPts;
-   /** Breakpoint Descriptor US PSD */
-   VRX_PSDbreak_t breakpoint[32];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Number of Breakpoints */
-   DSL_uint8_t NumBreakPts;
-   /** Reserved */
-   DSL_uint8_t Res0;
-   /** Breakpoint Descriptor US PSD */
-   VRX_PSDbreak_t breakpoint[32];
-#endif
-} __PACKED__ ;
-
-
-/**
-   The Downstream TSSI Breakpoints are specified by the transmitter (VTU-O) and
-   communicated to the receiver (VTU-R) via the O-PRM message.   The TSSI
-   Breakpoints are used to shape the O-P-TEQ signal. This message provides read
-   only access to the DS TSSI Breakpoints. The DS TSSI Breakpoints are not
-   configurable via messages.
-*/
-struct CMD_TssiDS_VDSL2_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This is the acknowledgement of CMD_TssiDS_VDSL2_Get.
-*/
-struct ACK_TssiDS_VDSL2_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Data from the DS TSSI breakpoint buffer */
-   DSL_uint16_t Data[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Data from the DS TSSI breakpoint buffer */
-   DSL_uint16_t Data[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   The Upstream TSSI Breakpoints are specified by the transmitter (VTU-R) and
-   communicated to the receiver (VTU-O) via the R-PRM message.   The TSSI
-   Breakpoints are used to shape the R-P-TEQ signal.  The TSSI Breakpoints can
-   be read only but are not configurable via messages.
-*/
-struct CMD_TssiUS_VDSL2_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This is the acknowledgement of CMD_TssiUS_VDSL2_Get.
-*/
-struct ACK_TssiUS_VDSL2_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Data from the US TSSI breakpoint buffer */
-   DSL_uint16_t Data[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Data from the US TSSI breakpoint buffer */
-   DSL_uint16_t Data[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reads the actual power cutback value.
-*/
-struct CMD_ADSL_PCB_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the actual power cutback values requested with CMD_ADSL_PCB_Get.
-*/
-struct ACK_ADSL_PCB_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Downstream Power Cutback */
-   DSL_uint16_t dspcb;
-   /** Upstream Power Cutback */
-   DSL_uint16_t uspcb;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Downstream Power Cutback */
-   DSL_uint16_t dspcb;
-   /** Upstream Power Cutback */
-   DSL_uint16_t uspcb;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the PSD and power parameter values actually used by the firmware.
-*/
-struct CMD_ActualPSD_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides actually used PSD and power parameters as requested by
-   CMD_ActualPSD_Get.
-*/
-struct ACK_ActualPSD_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Power/PSD Configuration Parameter: MAXNOMPSDds */
-   DSL_uint16_t MAXNOMPSDds;
-   /** Power/PSD Configuration Parameter: MAXNOMPSDus */
-   DSL_uint16_t MAXNOMPSDus;
-   /** Power/PSD Configuration Parameter: MAXNOMATPds */
-   DSL_uint16_t MAXNOMATPds;
-   /** Power/PSD Configuration Parameters */
-   DSL_uint16_t MAXNOMATPus;
-   /** Reserved */
-   DSL_uint16_t Res0;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Power/PSD Configuration Parameter: MAXNOMPSDds */
-   DSL_uint16_t MAXNOMPSDds;
-   /** Power/PSD Configuration Parameter: MAXNOMPSDus */
-   DSL_uint16_t MAXNOMPSDus;
-   /** Power/PSD Configuration Parameter: MAXNOMATPds */
-   DSL_uint16_t MAXNOMATPds;
-   /** Power/PSD Configuration Parameters */
-   DSL_uint16_t MAXNOMATPus;
-   /** Reserved */
-   DSL_uint16_t Res0;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the actually used ADSL upstream mask for ADSL2/2+ Annexes M and J.
-   To be applied only in combination with G.992.3/5 Annex M support in
-   ACK_XTSE_StatusGet.
-*/
-struct CMD_ADSL_MJ_UsMaskGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the actually used ADSL upstream mask for ADSL2/2+ Annexes M and J.
-*/
-struct ACK_ADSL_MJ_UsMaskGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 7;
-   /** G.992.3/5 Annex M/J Upstream Mask 9 */
-   DSL_uint16_t mask9 : 1;
-   /** G.992.3/5 Annex M/J Upstream Mask 8 */
-   DSL_uint16_t mask8 : 1;
-   /** G.992.3/5 Annex M/J Upstream Mask 7 */
-   DSL_uint16_t mask7 : 1;
-   /** G.992.3/5 Annex M/J Upstream Mask 6 */
-   DSL_uint16_t mask6 : 1;
-   /** G.992.3/5 Annex M/J Upstream Mask 5 */
-   DSL_uint16_t mask5 : 1;
-   /** G.992.3/5 Annex M/J Upstream Mask 4 */
-   DSL_uint16_t mask4 : 1;
-   /** G.992.3/5 Annex M/J Upstream Mask 3 */
-   DSL_uint16_t mask3 : 1;
-   /** G.992.3/5 Annex M/J Upstream Mask 2 */
-   DSL_uint16_t mask2 : 1;
-   /** G.992.3/5 Annex M/J Upstream Mask 1 */
-   DSL_uint16_t mask1 : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** G.992.3/5 Annex M/J Upstream Mask 1 */
-   DSL_uint16_t mask1 : 1;
-   /** G.992.3/5 Annex M/J Upstream Mask 2 */
-   DSL_uint16_t mask2 : 1;
-   /** G.992.3/5 Annex M/J Upstream Mask 3 */
-   DSL_uint16_t mask3 : 1;
-   /** G.992.3/5 Annex M/J Upstream Mask 4 */
-   DSL_uint16_t mask4 : 1;
-   /** G.992.3/5 Annex M/J Upstream Mask 5 */
-   DSL_uint16_t mask5 : 1;
-   /** G.992.3/5 Annex M/J Upstream Mask 6 */
-   DSL_uint16_t mask6 : 1;
-   /** G.992.3/5 Annex M/J Upstream Mask 7 */
-   DSL_uint16_t mask7 : 1;
-   /** G.992.3/5 Annex M/J Upstream Mask 8 */
-   DSL_uint16_t mask8 : 1;
-   /** G.992.3/5 Annex M/J Upstream Mask 9 */
-   DSL_uint16_t mask9 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 7;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reports the downstream transmit PSD mask (PSDMASKds) which is received from
-   CO with O-SIGNATURE message.
-*/
-struct CMD_PSDMASK_DS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reports the downstream transmit PSD mask (PSDMASKds) for both passbands and
-   stopbands, which is received from CO with O-SIGNATURE message. (Format is now
-   as absolute value without the offset.)
-*/
-struct ACK_PSDMASK_DS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Number of Breakpoints */
-   DSL_uint16_t NumBreakPts;
-   /** PSDMASKds Data */
-   VRX_PSDbreak2_t PSDMASK[48];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Number of Breakpoints */
-   DSL_uint16_t NumBreakPts;
-   /** PSDMASKds Data */
-   VRX_PSDbreak2_t PSDMASK[48];
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message requests information about the receive PSD per subcarrier
-   available at the near-end side, which means for downstream direction at the
-   CPE. It is the hosts responsibility to select the tone indices accordingly.In
-   Showtime the message reports the receive PSD measured in Channel Discovery
-   phase after the final hybrid training (no Showtime update).
-*/
-struct CMD_RxPSD_TableEntriesGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the receive PSD per subcarrier available at the
-   near-end side, which means for downstream direction at the CPE.In Showtime
-   the message reports the receive PSD measured in Channel Discovery phase after
-   the final hybrid training (no Showtime update).
-*/
-struct ACK_RxPSD_TableEntriesGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Receive PSD */
-   DSL_uint16_t PSDps[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Receive PSD */
-   DSL_uint16_t PSDps[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests status information for the downstream bearer channels.
-*/
-struct CMD_BearerChsDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers status information for the downstream bearer channels. **: The terms
-   "LP0/Interleaved Path" and "LP1/Fast Path" below refer to the terminology
-   used in ITU DSL standards [1],[2], [3], [5] which means:- LP0 or LP1 in case
-   of VDSL2, ADSL2/2+- "Interleaved Path" or "Fast Path" in case of ADSL1/ADSL1
-   Lite.Attention: In VRX Device1 the "LP1/Fast Path" parameters are populated
-   only in ADSL1 and ADSL1 Lilte mode with selected fast path.
-*/
-struct ACK_BearerChsDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** ACTNDR DS for LP0, LSW */
-   DSL_uint16_t DRdsLP0_LSW;
-   /** ACTNDR DS for LP0, MSW */
-   DSL_uint16_t DRdsLP0_MSW;
-   /** ACTNDR DS for LP1, LSW */
-   DSL_uint16_t DRdsLP1_LSW;
-   /** ACTNDR DS for LP1, MSW */
-   DSL_uint16_t DRdsLP1_MSW;
-   /** Reserved */
-   DSL_uint16_t Res0[4];
-   /** Actual Interleaving Delay DS, LP0 */
-   DSL_uint16_t delay_dsLP0;
-   /** Actual Interleaving Delay DS, LP1 */
-   DSL_uint16_t delay_dsLP1;
-   /** Actual Interleaver Depth DS, LP0 */
-   DSL_uint16_t intlDepth_dsLP0;
-   /** Actual Interleaver Depth DS, LP1 */
-   DSL_uint16_t intlDepth_dsLP1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 7;
-   /** TCM Status DS, LP0  */
-   DSL_uint16_t TCMstatus_dsLP0 : 1;
-   /** Parity Bytes DS, LP0 */
-   DSL_uint16_t parity_dsLP0 : 8;
-   /** Reserved */
-   DSL_uint8_t Res2;
-   /** Parity Bytes DS, LP1 */
-   DSL_uint16_t parity_dsLP1 : 8;
-   /** Actual INP NoErasure DS , LP0 */
-   DSL_uint16_t actInpNoErasure_LP0;
-   /** Actual INP NoErasure DS, LP1 */
-   DSL_uint16_t actInpNoErasure_LP1;
-   /** RX Estimated Actual INP DS, LP0 */
-   DSL_uint16_t actInpErasure_LP0;
-   /** RX Estimated Actual INP DS, LP1 */
-   DSL_uint16_t actInpErasure_LP1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** ACTNDR DS for LP0, LSW */
-   DSL_uint16_t DRdsLP0_LSW;
-   /** ACTNDR DS for LP0, MSW */
-   DSL_uint16_t DRdsLP0_MSW;
-   /** ACTNDR DS for LP1, LSW */
-   DSL_uint16_t DRdsLP1_LSW;
-   /** ACTNDR DS for LP1, MSW */
-   DSL_uint16_t DRdsLP1_MSW;
-   /** Reserved */
-   DSL_uint16_t Res0[4];
-   /** Actual Interleaving Delay DS, LP0 */
-   DSL_uint16_t delay_dsLP0;
-   /** Actual Interleaving Delay DS, LP1 */
-   DSL_uint16_t delay_dsLP1;
-   /** Actual Interleaver Depth DS, LP0 */
-   DSL_uint16_t intlDepth_dsLP0;
-   /** Actual Interleaver Depth DS, LP1 */
-   DSL_uint16_t intlDepth_dsLP1;
-   /** Parity Bytes DS, LP0 */
-   DSL_uint16_t parity_dsLP0 : 8;
-   /** TCM Status DS, LP0  */
-   DSL_uint16_t TCMstatus_dsLP0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 7;
-   /** Parity Bytes DS, LP1 */
-   DSL_uint16_t parity_dsLP1 : 8;
-   /** Reserved */
-   DSL_uint8_t Res2;
-   /** Actual INP NoErasure DS , LP0 */
-   DSL_uint16_t actInpNoErasure_LP0;
-   /** Actual INP NoErasure DS, LP1 */
-   DSL_uint16_t actInpNoErasure_LP1;
-   /** RX Estimated Actual INP DS, LP0 */
-   DSL_uint16_t actInpErasure_LP0;
-   /** RX Estimated Actual INP DS, LP1 */
-   DSL_uint16_t actInpErasure_LP1;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests status information for the upstream bearer channels.
-*/
-struct CMD_BearerChsUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers status information for the upstream bearer channels. **: The terms
-   "LP0/Interleaved Path" and "LP1/Fast Path" below refer to the terminology
-   used in ITU DSL standards [1],[2], [3], [5] which means:- LP0 or LP1 in case
-   of VDSL2, ADSL2/2+- "Interleaved Path" or "Fast Path" in case of ADSL1/ADSL1
-   Lite.Attention: In VRX Device1 the "LP1/Fast Path" parameters are populated
-   only in ADSL1 and ADSL1 Lite mode with selected fast path.
-*/
-struct ACK_BearerChsUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** ACTNDR US for LP0, LSW */
-   DSL_uint16_t DRusLP0_LSW;
-   /** ACTNDR US for LP0, MSW */
-   DSL_uint16_t DRusLP0_MSW;
-   /** ACTNDR US for LP1, LSW */
-   DSL_uint16_t DRusLP1_LSW;
-   /** ACTNDR US for LP1, MSW */
-   DSL_uint16_t DRusLP1_MSW;
-   /** Reserved */
-   DSL_uint16_t Res0[4];
-   /** Actual Interleaving Delay US, LP0 */
-   DSL_uint16_t delay_usLP0;
-   /** Actual Interleaving Delay US, LP1 */
-   DSL_uint16_t delay_usLP1;
-   /** Actual Interleaver Depth US, LP0 */
-   DSL_uint16_t intlDepth_usLP0;
-   /** Actual Interleaver Depth US, LP1 */
-   DSL_uint16_t intlDepth_usLP1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 7;
-   /** TCM Status US, LP0  */
-   DSL_uint16_t TCMstatus_usLP0 : 1;
-   /** Parity Bytes US, LP0 */
-   DSL_uint16_t parity_usLP0 : 8;
-   /** Reserved */
-   DSL_uint8_t Res2;
-   /** Parity Bytes US, LP1 */
-   DSL_uint16_t parity_usLP1 : 8;
-   /** Actual INP NoErasure US , LP0 */
-   DSL_uint16_t actInpNoErasure_LP0;
-   /** Actual INP NoErasure US, LP1 */
-   DSL_uint16_t actInpNoErasure_LP1;
-   /** RX Estimated Actual INP US , LP0 */
-   DSL_uint16_t actInpErasure_LP0;
-   /** RX Estimated Actual INP US, LP1 */
-   DSL_uint16_t actInpErasure_LP1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** ACTNDR US for LP0, LSW */
-   DSL_uint16_t DRusLP0_LSW;
-   /** ACTNDR US for LP0, MSW */
-   DSL_uint16_t DRusLP0_MSW;
-   /** ACTNDR US for LP1, LSW */
-   DSL_uint16_t DRusLP1_LSW;
-   /** ACTNDR US for LP1, MSW */
-   DSL_uint16_t DRusLP1_MSW;
-   /** Reserved */
-   DSL_uint16_t Res0[4];
-   /** Actual Interleaving Delay US, LP0 */
-   DSL_uint16_t delay_usLP0;
-   /** Actual Interleaving Delay US, LP1 */
-   DSL_uint16_t delay_usLP1;
-   /** Actual Interleaver Depth US, LP0 */
-   DSL_uint16_t intlDepth_usLP0;
-   /** Actual Interleaver Depth US, LP1 */
-   DSL_uint16_t intlDepth_usLP1;
-   /** Parity Bytes US, LP0 */
-   DSL_uint16_t parity_usLP0 : 8;
-   /** TCM Status US, LP0  */
-   DSL_uint16_t TCMstatus_usLP0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 7;
-   /** Parity Bytes US, LP1 */
-   DSL_uint16_t parity_usLP1 : 8;
-   /** Reserved */
-   DSL_uint8_t Res2;
-   /** Actual INP NoErasure US , LP0 */
-   DSL_uint16_t actInpNoErasure_LP0;
-   /** Actual INP NoErasure US, LP1 */
-   DSL_uint16_t actInpNoErasure_LP1;
-   /** RX Estimated Actual INP US , LP0 */
-   DSL_uint16_t actInpErasure_LP0;
-   /** RX Estimated Actual INP US, LP1 */
-   DSL_uint16_t actInpErasure_LP1;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests an extended set of VDSL2 framing parameters for the downstream
-   direction.
-*/
-struct CMD_FrameDataExt2DS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers an extended set of VDSL2 framing parameters for the downstream
-   direction requested by CMD_FrameDataExt2DS_Get. (Sections 7.5.2.6 of G.997.1
-   and 9.5 & 9.6 of G.993.2 [5])
-*/
-struct ACK_FrameDataExt2DS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Bytes "Bp" from BC0 per MDF LP0 DS */
-   DSL_uint16_t B0_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** Reserved */
-   DSL_uint16_t Res1;
-   /** Reserved */
-   DSL_uint16_t Res2;
-   /** MDFs per OH Sub-Frame "Tp" LP0 DS */
-   DSL_uint16_t Tp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res3;
-   /** OH Bytes per OH sub-frame "Gp" LP0 DS */
-   DSL_uint16_t Gp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res4;
-   /** OH Frames per OH Superframe "Fp" LP0 DS */
-   DSL_uint16_t Fp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res5;
-   /** MDFs per RS-Codeword "Mp" LP0 DS */
-   DSL_uint16_t Mp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res6;
-   /** Bits per Symbol "Lp" LP0 DS, LSW */
-   DSL_uint16_t Lp_LP0ds_LSW;
-   /** Bits per Symbol "Lp" LP0 DS, MSW */
-   DSL_uint16_t Lp_LP0ds_MSW;
-   /** Reserved */
-   DSL_uint16_t Res7;
-   /** Reserved */
-   DSL_uint16_t Res8;
-   /** RS Check Bytes "Rp" LP0 DS */
-   DSL_uint16_t Rp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res9;
-   /** Interleaver Block Length "Ip", LP0 DS */
-   DSL_uint16_t Ip_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res10;
-   /** Interleaving Depth "Dp" LP0 DS */
-   DSL_uint16_t Dp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res11;
-   /** OH Frame Period "PERp", LP0 DS */
-   DSL_uint16_t PERp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res12;
-   /** Line Data Rate DS for LP0, LSW */
-   DSL_uint16_t DRp_LP0ds_LSW;
-   /** Line Data Rate DS for LP0, MSW */
-   DSL_uint16_t DRp_LP0ds_MSW;
-   /** Reserved */
-   DSL_uint16_t Res13;
-   /** Reserved */
-   DSL_uint16_t Res14;
-   /** RS Codeword Size "N_fecp" LP0 DS */
-   DSL_uint16_t N_fecp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res15;
-   /** Framing Parameter "q", LP0 DS */
-   DSL_uint16_t q_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res16;
-   /** OH Bytes per OH FrameLP0 "SEQp" DS */
-   DSL_uint16_t SEQp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res17;
-   /** OH sub-frames "Up" per OH frame LP0 DS */
-   DSL_uint16_t Up_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res18;
-   /** Bytes per OH Frame LP0 DS, LSW */
-   DSL_uint16_t PERBp_LP0ds_LSW;
-   /** Bytes per OH Frame LP0 DS, MSW */
-   DSL_uint16_t PERBp_LP0ds_MSW;
-   /** Reserved */
-   DSL_uint16_t Res19;
-   /** Reserved */
-   DSL_uint16_t Res20;
-   /** Bytes in MSG OH "MSGc" LP0 DS */
-   DSL_uint16_t MSGc_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res21;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Bytes "Bp" from BC0 per MDF LP0 DS */
-   DSL_uint16_t B0_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** Reserved */
-   DSL_uint16_t Res1;
-   /** Reserved */
-   DSL_uint16_t Res2;
-   /** MDFs per OH Sub-Frame "Tp" LP0 DS */
-   DSL_uint16_t Tp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res3;
-   /** OH Bytes per OH sub-frame "Gp" LP0 DS */
-   DSL_uint16_t Gp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res4;
-   /** OH Frames per OH Superframe "Fp" LP0 DS */
-   DSL_uint16_t Fp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res5;
-   /** MDFs per RS-Codeword "Mp" LP0 DS */
-   DSL_uint16_t Mp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res6;
-   /** Bits per Symbol "Lp" LP0 DS, LSW */
-   DSL_uint16_t Lp_LP0ds_LSW;
-   /** Bits per Symbol "Lp" LP0 DS, MSW */
-   DSL_uint16_t Lp_LP0ds_MSW;
-   /** Reserved */
-   DSL_uint16_t Res7;
-   /** Reserved */
-   DSL_uint16_t Res8;
-   /** RS Check Bytes "Rp" LP0 DS */
-   DSL_uint16_t Rp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res9;
-   /** Interleaver Block Length "Ip", LP0 DS */
-   DSL_uint16_t Ip_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res10;
-   /** Interleaving Depth "Dp" LP0 DS */
-   DSL_uint16_t Dp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res11;
-   /** OH Frame Period "PERp", LP0 DS */
-   DSL_uint16_t PERp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res12;
-   /** Line Data Rate DS for LP0, LSW */
-   DSL_uint16_t DRp_LP0ds_LSW;
-   /** Line Data Rate DS for LP0, MSW */
-   DSL_uint16_t DRp_LP0ds_MSW;
-   /** Reserved */
-   DSL_uint16_t Res13;
-   /** Reserved */
-   DSL_uint16_t Res14;
-   /** RS Codeword Size "N_fecp" LP0 DS */
-   DSL_uint16_t N_fecp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res15;
-   /** Framing Parameter "q", LP0 DS */
-   DSL_uint16_t q_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res16;
-   /** OH Bytes per OH FrameLP0 "SEQp" DS */
-   DSL_uint16_t SEQp_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res17;
-   /** OH sub-frames "Up" per OH frame LP0 DS */
-   DSL_uint16_t Up_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res18;
-   /** Bytes per OH Frame LP0 DS, LSW */
-   DSL_uint16_t PERBp_LP0ds_LSW;
-   /** Bytes per OH Frame LP0 DS, MSW */
-   DSL_uint16_t PERBp_LP0ds_MSW;
-   /** Reserved */
-   DSL_uint16_t Res19;
-   /** Reserved */
-   DSL_uint16_t Res20;
-   /** Bytes in MSG OH "MSGc" LP0 DS */
-   DSL_uint16_t MSGc_LP0ds;
-   /** Reserved */
-   DSL_uint16_t Res21;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests an extended set of VDSL2 framing parameters for the upstream
-   direction.
-*/
-struct CMD_FrameDataExt2US_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers an extended set of VDSL2 framing parameters for the upstream
-   direction requested by CMD_FrameDataExt2US_Get. (Sections 7.5.2.6 of G.997.1
-   and 9.5 & 9.6 of G.993.2 [5])
-*/
-struct ACK_FrameDataExt2US_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Bytes "Bp" from BC0 per MDF LP0 US */
-   DSL_uint16_t B0_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** Reserved */
-   DSL_uint16_t Res1;
-   /** Reserved */
-   DSL_uint16_t Res2;
-   /** MDFs per OH Sub-Frame "Tp" LP0 US */
-   DSL_uint16_t Tp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res3;
-   /** OH Bytes per OH sub-frame "Gp" LP0 US */
-   DSL_uint16_t Gp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res4;
-   /** OH Frames per OH Superframe "Fp" LP0 US */
-   DSL_uint16_t Fp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res5;
-   /** MDFs per RS-Codeword "Mp" LP0 US */
-   DSL_uint16_t Mp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res6;
-   /** Bits per Symbol "Lp" LP0 US, LSW */
-   DSL_uint16_t Lp_LP0us_LSW;
-   /** Bits per Symbol "Lp" LP0 US, MSW */
-   DSL_uint16_t Lp_LP0us_MSW;
-   /** Reserved */
-   DSL_uint16_t Res7;
-   /** Reserved */
-   DSL_uint16_t Res8;
-   /** RS Check Bytes "Rp" LP0 US */
-   DSL_uint16_t Rp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res9;
-   /** Interleaver Block Length "Ip", LP0 US */
-   DSL_uint16_t Ip_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res10;
-   /** Interleaving Depth "Dp" LP0 US */
-   DSL_uint16_t Dp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res11;
-   /** OH Frame Period "PERp", LP0 US */
-   DSL_uint16_t PERp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res12;
-   /** Line Data Rate US for LP0, LSW */
-   DSL_uint16_t DRp_LP0us_LSW;
-   /** Line Data Rate US for LP0, MSW */
-   DSL_uint16_t DRp_LP0us_MSW;
-   /** Reserved */
-   DSL_uint16_t Res13;
-   /** Reserved */
-   DSL_uint16_t Res14;
-   /** RS Codeword Size "N_fecp" LP0 US */
-   DSL_uint16_t N_fecp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res15;
-   /** Framing Parameter "q", LP0 US */
-   DSL_uint16_t q_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res16;
-   /** OH Bytes per OH FrameLP0 "SEQp" US */
-   DSL_uint16_t SEQp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res17;
-   /** OH sub-frames "Up" per OH frame LP0 US */
-   DSL_uint16_t Up_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res18;
-   /** Bytes per OH Frame LP0 US, LSW */
-   DSL_uint16_t PERBp_LP0us_LSW;
-   /** Bytes per OH Frame LP0 US, MSW */
-   DSL_uint16_t PERBp_LP0us_MSW;
-   /** Reserved */
-   DSL_uint16_t Res19;
-   /** Reserved */
-   DSL_uint16_t Res20;
-   /** Bytes in MSG OH "MSGc" LP0 US */
-   DSL_uint16_t MSGc_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res21;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Bytes "Bp" from BC0 per MDF LP0 US */
-   DSL_uint16_t B0_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** Reserved */
-   DSL_uint16_t Res1;
-   /** Reserved */
-   DSL_uint16_t Res2;
-   /** MDFs per OH Sub-Frame "Tp" LP0 US */
-   DSL_uint16_t Tp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res3;
-   /** OH Bytes per OH sub-frame "Gp" LP0 US */
-   DSL_uint16_t Gp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res4;
-   /** OH Frames per OH Superframe "Fp" LP0 US */
-   DSL_uint16_t Fp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res5;
-   /** MDFs per RS-Codeword "Mp" LP0 US */
-   DSL_uint16_t Mp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res6;
-   /** Bits per Symbol "Lp" LP0 US, LSW */
-   DSL_uint16_t Lp_LP0us_LSW;
-   /** Bits per Symbol "Lp" LP0 US, MSW */
-   DSL_uint16_t Lp_LP0us_MSW;
-   /** Reserved */
-   DSL_uint16_t Res7;
-   /** Reserved */
-   DSL_uint16_t Res8;
-   /** RS Check Bytes "Rp" LP0 US */
-   DSL_uint16_t Rp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res9;
-   /** Interleaver Block Length "Ip", LP0 US */
-   DSL_uint16_t Ip_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res10;
-   /** Interleaving Depth "Dp" LP0 US */
-   DSL_uint16_t Dp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res11;
-   /** OH Frame Period "PERp", LP0 US */
-   DSL_uint16_t PERp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res12;
-   /** Line Data Rate US for LP0, LSW */
-   DSL_uint16_t DRp_LP0us_LSW;
-   /** Line Data Rate US for LP0, MSW */
-   DSL_uint16_t DRp_LP0us_MSW;
-   /** Reserved */
-   DSL_uint16_t Res13;
-   /** Reserved */
-   DSL_uint16_t Res14;
-   /** RS Codeword Size "N_fecp" LP0 US */
-   DSL_uint16_t N_fecp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res15;
-   /** Framing Parameter "q", LP0 US */
-   DSL_uint16_t q_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res16;
-   /** OH Bytes per OH FrameLP0 "SEQp" US */
-   DSL_uint16_t SEQp_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res17;
-   /** OH sub-frames "Up" per OH frame LP0 US */
-   DSL_uint16_t Up_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res18;
-   /** Bytes per OH Frame LP0 US, LSW */
-   DSL_uint16_t PERBp_LP0us_LSW;
-   /** Bytes per OH Frame LP0 US, MSW */
-   DSL_uint16_t PERBp_LP0us_MSW;
-   /** Reserved */
-   DSL_uint16_t Res19;
-   /** Reserved */
-   DSL_uint16_t Res20;
-   /** Bytes in MSG OH "MSGc" LP0 US */
-   DSL_uint16_t MSGc_LP0us;
-   /** Reserved */
-   DSL_uint16_t Res21;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests ADSL framing parameters for the downstream direction, latency path
-   0/Interleaved Path.
-*/
-struct CMD_ADSL_FrameDataDS_LP0Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the ADSL framing parameters for the downstream direction,
-   LP0/Interleaved path, as requested by CMD_ADSL_FrameDataDS_LP0Get. (Sections
-   7.5 & 7.6 of G.992.3 [2] and 7.4 of G.992.1 [1])
-*/
-struct ACK_ADSL_FrameDataDS_LP0Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** RS Check Bytes "Rp" DS LP0 */
-   DSL_uint16_t Rp;
-   /** Symbols per RS-Codeword "Sp" DS LP0 */
-   DSL_uint16_t Sp;
-   /** Interleaving Depth "Dp" DS LP0 */
-   DSL_uint16_t Dp;
-   /** Bytes per MDF "Kp" DS LP0 */
-   DSL_uint16_t Kp;
-   /** MDFs per RS-Codeword "Mp" DS LP0 */
-   DSL_uint16_t Mp;
-   /** Bits per Symbol "Lp" DS LP0 */
-   DSL_uint16_t Lp;
-   /** TCM Bits DS LP0 */
-   DSL_uint16_t TCM;
-   /** Framing Mode DS LP0 */
-   DSL_uint16_t fraMode;
-   /** "Tp" DS LP0 */
-   DSL_uint16_t Tp;
-   /** "SEQp" DS LP0 */
-   DSL_uint16_t SEQp;
-   /** Bytes in MSG-OH "MSGc" DS */
-   DSL_uint16_t MSGc;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** RS Check Bytes "Rp" DS LP0 */
-   DSL_uint16_t Rp;
-   /** Symbols per RS-Codeword "Sp" DS LP0 */
-   DSL_uint16_t Sp;
-   /** Interleaving Depth "Dp" DS LP0 */
-   DSL_uint16_t Dp;
-   /** Bytes per MDF "Kp" DS LP0 */
-   DSL_uint16_t Kp;
-   /** MDFs per RS-Codeword "Mp" DS LP0 */
-   DSL_uint16_t Mp;
-   /** Bits per Symbol "Lp" DS LP0 */
-   DSL_uint16_t Lp;
-   /** TCM Bits DS LP0 */
-   DSL_uint16_t TCM;
-   /** Framing Mode DS LP0 */
-   DSL_uint16_t fraMode;
-   /** "Tp" DS LP0 */
-   DSL_uint16_t Tp;
-   /** "SEQp" DS LP0 */
-   DSL_uint16_t SEQp;
-   /** Bytes in MSG-OH "MSGc" DS */
-   DSL_uint16_t MSGc;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests ADSL framing parameters for the upstream direction, latency path
-   0/Interleaved path.
-*/
-struct CMD_ADSL_FrameDataUS_LP0Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the ADSL framing parameters for the upstream direction, latency path
-   0/Interleaved path, as requested by CMD_ADSL_FrameDataUS_LP0Get. (Sections
-   7.5 & 7.6 of G.992.3 [2] and 7.4 of G.992.1 [1])
-*/
-struct ACK_ADSL_FrameDataUS_LP0Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** RS Check Bytes "Rp" US LP0 */
-   DSL_uint16_t Rp_LP0us;
-   /** Symbols per RS-Codeword "Sp" US LP0 */
-   DSL_uint16_t Sp;
-   /** Interleaving Depth "Dp" US LP0 */
-   DSL_uint16_t Dp;
-   /** Bytes per MDF "Kp" US LP0 */
-   DSL_uint16_t Kp;
-   /** MDFs per RS-Codeword "Mp" US LP0 */
-   DSL_uint16_t Mp;
-   /** Bits per Symbol "Lp" US LP0 */
-   DSL_uint16_t Lp;
-   /** TCM Bits US LP0 */
-   DSL_uint16_t TCM;
-   /** Framing Mode US LP0 */
-   DSL_uint16_t fraMode;
-   /** "Tp" US LP0 */
-   DSL_uint16_t Tp;
-   /** "SEQp" US LP0 */
-   DSL_uint16_t SEQp;
-   /** Bytes in MSG-OH "MSGc" US */
-   DSL_uint16_t MSGc;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** RS Check Bytes "Rp" US LP0 */
-   DSL_uint16_t Rp_LP0us;
-   /** Symbols per RS-Codeword "Sp" US LP0 */
-   DSL_uint16_t Sp;
-   /** Interleaving Depth "Dp" US LP0 */
-   DSL_uint16_t Dp;
-   /** Bytes per MDF "Kp" US LP0 */
-   DSL_uint16_t Kp;
-   /** MDFs per RS-Codeword "Mp" US LP0 */
-   DSL_uint16_t Mp;
-   /** Bits per Symbol "Lp" US LP0 */
-   DSL_uint16_t Lp;
-   /** TCM Bits US LP0 */
-   DSL_uint16_t TCM;
-   /** Framing Mode US LP0 */
-   DSL_uint16_t fraMode;
-   /** "Tp" US LP0 */
-   DSL_uint16_t Tp;
-   /** "SEQp" US LP0 */
-   DSL_uint16_t SEQp;
-   /** Bytes in MSG-OH "MSGc" US */
-   DSL_uint16_t MSGc;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests ADSL framing parameters for the downstream direction, latency path 1
-   (LP1)/ Fast path.In VRX Rev. 1.x to be used for ADSL1, "fast path" only.
-*/
-struct CMD_ADSL_FrameDataDS_LP1Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the ADSL framing parameters for the downstream direction, LP1/Fast
-   path, as requested by CMD_ADSL_FrameDataDS_LP1Get. (Sections 7.5 & 7.6 of
-   G.992.3 [2] and 7.4 of G.992.1 [1])
-*/
-struct ACK_ADSL_FrameDataDS_LP1Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** RS Check Bytes "Rp" DS LP1 */
-   DSL_uint16_t Rp;
-   /** Symbols per RS-Codeword "Sp" DS LP1 */
-   DSL_uint16_t Sp;
-   /** Interleaving Depth "Dp" DS LP1 */
-   DSL_uint16_t Dp;
-   /** Bytes per MDF "Kp" DS LP1 */
-   DSL_uint16_t Kp;
-   /** MDFs per RS-Codeword "Mp" DS LP1 */
-   DSL_uint16_t Mp;
-   /** Bits per Symbol "Lp" DS LP1 */
-   DSL_uint16_t Lp;
-   /** TCM Bits DS LP1 */
-   DSL_uint16_t TCM;
-   /** Framing Mode DS LP1 */
-   DSL_uint16_t fraMode;
-   /** "Tp" DS LP1 */
-   DSL_uint16_t Tp;
-   /** "SEQp" DS LP1 */
-   DSL_uint16_t SEQp;
-   /** Bytes in MSG-OH "MSGc" DS */
-   DSL_uint16_t MSGc;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** RS Check Bytes "Rp" DS LP1 */
-   DSL_uint16_t Rp;
-   /** Symbols per RS-Codeword "Sp" DS LP1 */
-   DSL_uint16_t Sp;
-   /** Interleaving Depth "Dp" DS LP1 */
-   DSL_uint16_t Dp;
-   /** Bytes per MDF "Kp" DS LP1 */
-   DSL_uint16_t Kp;
-   /** MDFs per RS-Codeword "Mp" DS LP1 */
-   DSL_uint16_t Mp;
-   /** Bits per Symbol "Lp" DS LP1 */
-   DSL_uint16_t Lp;
-   /** TCM Bits DS LP1 */
-   DSL_uint16_t TCM;
-   /** Framing Mode DS LP1 */
-   DSL_uint16_t fraMode;
-   /** "Tp" DS LP1 */
-   DSL_uint16_t Tp;
-   /** "SEQp" DS LP1 */
-   DSL_uint16_t SEQp;
-   /** Bytes in MSG-OH "MSGc" DS */
-   DSL_uint16_t MSGc;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests ADSL framing parameters for the upstream direction, latency path 1
-   (LP1)/Fast path.In VRX Rev. 1.x to be used for ADSL1, "fast path" only.
-*/
-struct CMD_ADSL_FrameDataUS_LP1Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the ADSL framing parameters for the upstream direction, LP1/Fast
-   path, as requested by CMD_ADSL_FrameDataUS_LP1Get. (Sections 7.5 & 7.6 of
-   G.992.3 [2] and 7.4 of G.992.1 [1])
-*/
-struct ACK_ADSL_FrameDataUS_LP1Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** RS Check Bytes "Rp" US LP1 */
-   DSL_uint16_t Rp_LP0us;
-   /** Symbols per RS-Codeword "Sp" US LP1 */
-   DSL_uint16_t Sp;
-   /** Interleaving Depth "Dp" US LP1 */
-   DSL_uint16_t Dp;
-   /** Bytes per MDF "Kp" US LP1 */
-   DSL_uint16_t Kp;
-   /** MDFs per RS-Codeword "Mp" US LP1 */
-   DSL_uint16_t Mp;
-   /** Bits per Symbol "Lp" US LP1 */
-   DSL_uint16_t Lp;
-   /** TCM Bits US LP1 */
-   DSL_uint16_t TCM;
-   /** Framing Mode US LP1 */
-   DSL_uint16_t fraMode;
-   /** "Tp" US LP1 */
-   DSL_uint16_t Tp;
-   /** "SEQp" US LP1 */
-   DSL_uint16_t SEQp;
-   /** Bytes in MSG-OH "MSGc" US */
-   DSL_uint16_t MSGc;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** RS Check Bytes "Rp" US LP1 */
-   DSL_uint16_t Rp_LP0us;
-   /** Symbols per RS-Codeword "Sp" US LP1 */
-   DSL_uint16_t Sp;
-   /** Interleaving Depth "Dp" US LP1 */
-   DSL_uint16_t Dp;
-   /** Bytes per MDF "Kp" US LP1 */
-   DSL_uint16_t Kp;
-   /** MDFs per RS-Codeword "Mp" US LP1 */
-   DSL_uint16_t Mp;
-   /** Bits per Symbol "Lp" US LP1 */
-   DSL_uint16_t Lp;
-   /** TCM Bits US LP1 */
-   DSL_uint16_t TCM;
-   /** Framing Mode US LP1 */
-   DSL_uint16_t fraMode;
-   /** "Tp" US LP1 */
-   DSL_uint16_t Tp;
-   /** "SEQp" US LP1 */
-   DSL_uint16_t SEQp;
-   /** Bytes in MSG-OH "MSGc" US */
-   DSL_uint16_t MSGc;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reads the connected hybrid type.
-*/
-struct CMD_HybridGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Contains the connected hybrid type.
-*/
-struct ACK_HybridGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Hybrid Type */
-   DSL_uint16_t HybridType;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Hybrid Type */
-   DSL_uint16_t HybridType;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the pilot tones used in Showtime.
-*/
-struct CMD_PilotTonesGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the Showtime pilot tones as requested by CMD_PilotTonesGet.
-*/
-struct ACK_PilotTonesGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Number of Pilot Tones */
-   DSL_uint16_t numPilot;
-   /** Pilot Tones */
-   DSL_uint16_t pilot[16];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Number of Pilot Tones */
-   DSL_uint16_t numPilot;
-   /** Pilot Tones */
-   DSL_uint16_t pilot[16];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the results of the micro filter detection (MFD) function. Valid
-   information in Showtime and FAIL will be available only if the microfilter
-   detection mechanism has been run before.
-*/
-struct CMD_MFD_ResultsGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reports the results of the micro filter detection (MFD) function.
-*/
-struct ACK_MFD_ResultsGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 1;
-   /** Filter Detection Process Indication, Bit 14:13 */
-   DSL_uint16_t FilterDetectStatus : 2;
-   /** Reserved */
-   DSL_uint16_t Res1 : 3;
-   /** Training Bridged Tap Range, Bit 9:8 */
-   DSL_uint16_t TrainingBTRange : 2;
-   /** Training Hybrid Info Ready Indication, Bit 7 */
-   DSL_uint16_t TrainingHybridInfoReady : 1;
-   /** Training Loop Length Ready Indication, Bit 6 */
-   DSL_uint16_t TrainingLoopLengthReady : 1;
-   /** Training Metric2 Ready Indication, Bit 5 */
-   DSL_uint16_t TrainingMetric2Ready : 1;
-   /** Reserved Bit 4:2 */
-   DSL_uint16_t Res2 : 3;
-   /** Bridge Tap Range, Bit 1:0 */
-   DSL_uint16_t BTRange : 2;
-   /** Metric1 for NLNF, Bit 15:4 */
-   DSL_uint16_t M1metric : 12;
-   /** "No Confidence" Bit, Bit 3 */
-   DSL_uint16_t M1NoConfidence : 1;
-   /** Metric1 QLN level, Bit 2:0 */
-   DSL_uint16_t M1QlnLevel : 3;
-   /** Metric2 */
-   DSL_int16_t M2Metric;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Bridge Tap Range, Bit 1:0 */
-   DSL_uint16_t BTRange : 2;
-   /** Reserved Bit 4:2 */
-   DSL_uint16_t Res2 : 3;
-   /** Training Metric2 Ready Indication, Bit 5 */
-   DSL_uint16_t TrainingMetric2Ready : 1;
-   /** Training Loop Length Ready Indication, Bit 6 */
-   DSL_uint16_t TrainingLoopLengthReady : 1;
-   /** Training Hybrid Info Ready Indication, Bit 7 */
-   DSL_uint16_t TrainingHybridInfoReady : 1;
-   /** Training Bridged Tap Range, Bit 9:8 */
-   DSL_uint16_t TrainingBTRange : 2;
-   /** Reserved */
-   DSL_uint16_t Res1 : 3;
-   /** Filter Detection Process Indication, Bit 14:13 */
-   DSL_uint16_t FilterDetectStatus : 2;
-   /** Reserved */
-   DSL_uint16_t Res0 : 1;
-   /** Metric1 QLN level, Bit 2:0 */
-   DSL_uint16_t M1QlnLevel : 3;
-   /** "No Confidence" Bit, Bit 3 */
-   DSL_uint16_t M1NoConfidence : 1;
-   /** Metric1 for NLNF, Bit 15:4 */
-   DSL_uint16_t M1metric : 12;
-   /** Metric2 */
-   DSL_int16_t M2Metric;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the loop length estimates done by the microfilter detection
-   function.In Showtime the data are always available.The availability of data
-   is indicated by the flag TrainingLoopLengthReady in ACK_MFD_ResultsGet.In
-   Showtime the data are always available.
-*/
-struct CMD_MFD_LooplengthGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reports the loop length estimates done by the microfilter detection (MFD)
-   function.
-*/
-struct ACK_MFD_LooplengthGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** AWG26 Length Estimate */
-   DSL_uint16_t Awg26Length;
-   /** AWG24 Length Estimate */
-   DSL_uint16_t Awg24Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** AWG26 Length Estimate */
-   DSL_uint16_t Awg26Length;
-   /** AWG24 Length Estimate */
-   DSL_uint16_t Awg24Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests hybrid information used by the microfilter detection function.In
-   Showtime the data are always available.The availability of data is indicated
-   by the flag TrainingHybridInfoReady in ACK_MFD_ResultsGet. In Showtime the
-   data are always available.
-*/
-struct CMD_MFD_HybridInfoGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reports the hybrid information used by the microfilter detection function.
-*/
-struct ACK_MFD_HybridInfoGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Hybrid Max Index */
-   DSL_uint16_t HybridMaxIndex;
-   /** Hybrid Max Metric */
-   DSL_uint16_t HybridMaxMetric;
-   /** Hybrid Second Best Index */
-   DSL_uint16_t Hybrid2ndBestIndex;
-   /** Hybrid Second Best Metric */
-   DSL_uint16_t Hybrid2ndBestMetric;
-   /** Hybrid Zero Metric */
-   DSL_uint16_t Hybrid0Metric;
-   /** Loaded Hybrid Index */
-   DSL_uint16_t LoadHybridIndex;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Hybrid Max Index */
-   DSL_uint16_t HybridMaxIndex;
-   /** Hybrid Max Metric */
-   DSL_uint16_t HybridMaxMetric;
-   /** Hybrid Second Best Index */
-   DSL_uint16_t Hybrid2ndBestIndex;
-   /** Hybrid Second Best Metric */
-   DSL_uint16_t Hybrid2ndBestMetric;
-   /** Hybrid Zero Metric */
-   DSL_uint16_t Hybrid0Metric;
-   /** Loaded Hybrid Index */
-   DSL_uint16_t LoadHybridIndex;
-#endif
-} __PACKED__ ;
-
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#ifdef __PACKED_DEFINED__
-   #if !(defined (__GNUC__) || defined (__GNUG__))
-      #pragma pack()
-   #endif
-   #undef __PACKED_DEFINED__
-#endif /* __PACKED_DEFINED__ */
-
-/** @} */
-
-#endif /** _DRV_DSL_CPE_VRX_MSG_GHS_STATUS_H_*/
--- a/src/include/mcat3.1/drv_dsl_cpe_vrx_msg_olr.h
+++ /dev/null
@@ -1,3875 +0,0 @@
-/******************************************************************************
-
-                            Copyright (c) 2007-2017
-                       Lantiq Beteiligungs-GmbH & Co. KG
-
-  For licensing information, see the file 'LICENSE' in the root folder of
-  this software module.
-
-******************************************************************************/
-
-
-#ifndef _DRV_DSL_CPE_VRX_MSG_OLR_H_
-#define _DRV_DSL_CPE_VRX_MSG_OLR_H_
-
-/** \file
-
-*/
-
-#ifndef __PACKED__
-   #if defined (__GNUC__) || defined (__GNUG__)
-      /* GNU C or C++ compiler */
-      #define __PACKED__ __attribute__ ((packed))
-   #else
-      /* Byte alignment adjustment */
-      #pragma pack(1)
-      #define __PACKED__      /* nothing */
-   #endif
-   #define __PACKED_DEFINED__ 1
-#endif
-
-
-/** @defgroup _OLR_
- *  @{
- */
-
-#ifdef __cplusplus
-   extern "C" {
-#endif
-
-/* ----- Message Specific Constants Definition section ----- */
-#define CMD_TestParamsFE_Request_TRIGGER 0x1
-#define CMD_TestParamsFE_Request_ABORT 0x0
-#define ACK_TestParamsFE_Poll_ONGOING 0x1
-#define CMD_ClearEOC_TxTrigger_IDLE 0
-#define CMD_ClearEOC_TxTrigger_START 1
-#define ACK_ClearEOCStatusGet_IDLE 0
-#define ACK_ClearEOCStatusGet_TXPROG 1
-#define ACK_ClearEOCStatusGet_Reserved 2
-#define ACK_ClearEOCStatusGet_TXERR 3
-#define ACK_ClearEOCStatusGet_RXPROG 1
-#define ACK_ClearEOCStatusGet_RXDONE 2
-#define ACK_ClearEOCStatusGet_RXERR 3
-#define EVT_ClearEOCStatusGet_IDLE 0
-#define EVT_ClearEOCStatusGet_TXPROG 1
-#define EVT_ClearEOCStatusGet_TXDONE 2
-#define EVT_ClearEOCStatusGet_TXERR 3
-#define EVT_ClearEOCStatusGet_RXPROG 1
-#define EVT_ClearEOCStatusGet_RXDONE 2
-#define EVT_ClearEOCStatusGet_RXERR 3
-#define CMD_ClearEOCStatusSet_IDLE 0
-#define ACK_RA_ModeDS_Get_MANUAL 1
-#define ACK_RA_ModeDS_Get_AT_INIT 2
-#define ACK_RA_ModeDS_Get_DYNAMIC 3
-#define ACK_RA_ModeDS_Get_SOS 4
-#define ACK_RA_ModeUS_Get_MANUAL 1
-#define ACK_RA_ModeUS_Get_AT_INIT 2
-#define ACK_RA_ModeUS_Get_DYNAMIC 3
-#define ACK_RA_ModeUS_Get_SOS 4
-#define CMD_RTX_Control_RTX_DS_ENABLE 1
-#define CMD_RTX_Control_RTX_DSUS_ENABLE 2
-#define CMD_DSM_Control_OFF 0
-#define CMD_DSM_Control_FULL_VECTOR 1
-#define CMD_DSM_Control_FULL_VECTOR_FRIENDLY 2
-/* ----- Message Specific Constants Definition section (End) ----- */
-
-/** Message ID for CMD_BAT_TableEntriesGet */
-#define CMD_BAT_TABLEENTRIESGET 0x1703
-
-/**
-   Requests information about the bit-allocation per subcarrier in VDSL mode.
-   The values for all subcarriers of both directions can be retrieved. (For ADSL
-   use CMD_BAT_DS_Get and CMD_BAT_US_Get).
-*/
-typedef struct CMD_BAT_TableEntriesGet CMD_BAT_TableEntriesGet_t;
-
-/** Message ID for ACK_BAT_TableEntriesGet */
-#define ACK_BAT_TABLEENTRIESGET 0x1703
-
-/**
-   Returns information about the bit-allocation per tone for the chosen range of
-   subcarriers.(Section 7.5.1.29.1-2 of G.997.1)
-*/
-typedef struct ACK_BAT_TableEntriesGet ACK_BAT_TableEntriesGet_t;
-
-/** Message ID for CMD_GainTableEntriesGet */
-#define CMD_GAINTABLEENTRIESGET 0x1903
-
-/**
-   Requests information about the Gains per subcarrier. The values for all
-   subcarriers of both directions can be retrieved.(For ADSL use
-   CMD_GainTableDS_Get and CMD_GainTableUS_Get).
-*/
-typedef struct CMD_GainTableEntriesGet CMD_GainTableEntriesGet_t;
-
-/** Message ID for ACK_GainTableEntriesGet */
-#define ACK_GAINTABLEENTRIESGET 0x1903
-
-/**
-   Returns information about the Gain-per-tone for the chosen range of
-   subcarriers.(Section 7.5.1.29.3-4 of G.997.1)
-*/
-typedef struct ACK_GainTableEntriesGet ACK_GainTableEntriesGet_t;
-
-/** Message ID for CMD_SNR_NE_TableEntriesGet */
-#define CMD_SNR_NE_TABLEENTRIESGET 0x0B03
-
-/**
-   The message requests information about the SNR per subcarrier with virtual
-   noise for the near-end side , which means for downstream direction at the
-   CPE. It is the hosts responsibility to select the tone indices
-   accordingly.See also Table 20 "How to Retrieve Test Parameter Data" on Page
-   496.
-*/
-typedef struct CMD_SNR_NE_TableEntriesGet CMD_SNR_NE_TableEntriesGet_t;
-
-/** Message ID for ACK_SNR_NE_TableEntriesGet */
-#define ACK_SNR_NE_TABLEENTRIESGET 0x0B03
-
-/**
-   Returns information about the SNR per subcarrier with virtual noise for the
-   near-end side, meaning for downstream direction.
-*/
-typedef struct ACK_SNR_NE_TableEntriesGet ACK_SNR_NE_TableEntriesGet_t;
-
-/** Message ID for CMD_BAT_DS_Get */
-#define CMD_BAT_DS_GET 0x070E
-
-/**
-   Requests information about the downstream bit-allocation per subcarrier in
-   ADSL mode.
-*/
-typedef struct CMD_BAT_DS_Get CMD_BAT_DS_Get_t;
-
-/** Message ID for ACK_BAT_DS_Get */
-#define ACK_BAT_DS_GET 0x070E
-
-/**
-   Returns information about the downstream bit-allocation per tone for the
-   chosen range of subcarriers.(Section 7.5.1.29.1 of G.997.1)
-*/
-typedef struct ACK_BAT_DS_Get ACK_BAT_DS_Get_t;
-
-/** Message ID for CMD_BAT_US_Get */
-#define CMD_BAT_US_GET 0x060E
-
-/**
-   Requests information about the upstream bit-allocation per subcarrier in ADSL
-   mode.
-*/
-typedef struct CMD_BAT_US_Get CMD_BAT_US_Get_t;
-
-/** Message ID for ACK_BAT_US_Get */
-#define ACK_BAT_US_GET 0x060E
-
-/**
-   Returns information about the upstream bit-allocation per tone for the chosen
-   range of subcarriers.(Section 7.5.1.29.2 of G.997.1)
-*/
-typedef struct ACK_BAT_US_Get ACK_BAT_US_Get_t;
-
-/** Message ID for CMD_GainTableDS_Get */
-#define CMD_GAINTABLEDS_GET 0x090E
-
-/**
-   Requests information about the Gains per subcarrier for the downstream
-   direction.
-*/
-typedef struct CMD_GainTableDS_Get CMD_GainTableDS_Get_t;
-
-/** Message ID for ACK_GainTableDS_Get */
-#define ACK_GAINTABLEDS_GET 0x090E
-
-/**
-   Returns information about the Gain-per-tone for the chosen range of
-   subcarriers for the downstream direction.(Section 7.5.1.29.3 of G.997.1) as
-   requested by CMD_GainTableDS_Get.
-*/
-typedef struct ACK_GainTableDS_Get ACK_GainTableDS_Get_t;
-
-/** Message ID for CMD_GainTableUS_Get */
-#define CMD_GAINTABLEUS_GET 0x080E
-
-/**
-   Requests information about the Gains per subcarrier for the upstream
-   direction.
-*/
-typedef struct CMD_GainTableUS_Get CMD_GainTableUS_Get_t;
-
-/** Message ID for ACK_GainTableUS_Get */
-#define ACK_GAINTABLEUS_GET 0x080E
-
-/**
-   Returns information about the Gain-per-tone for the chosen range of
-   subcarriers for the upstream direction.(Section 7.5.1.29.4 of G.997.1)
-*/
-typedef struct ACK_GainTableUS_Get ACK_GainTableUS_Get_t;
-
-/** Message ID for CMD_ADSL_ExMarginReductionGet */
-#define CMD_ADSL_EXMARGINREDUCTIONGET 0x2F03
-
-/**
-   Requests information about the Excess Margin Reduction needed for the fine
-   gain calculation at the ATU_R.(See also ACK_GainTableDS_Get).
-*/
-typedef struct CMD_ADSL_ExMarginReductionGet CMD_ADSL_ExMarginReductionGet_t;
-
-/** Message ID for ACK_ADSL_ExMarginReductionGet */
-#define ACK_ADSL_EXMARGINREDUCTIONGET 0x2F03
-
-/**
-   Returns information about the Excess Margin Reduction for the downstream
-   direction.
-*/
-typedef struct ACK_ADSL_ExMarginReductionGet ACK_ADSL_ExMarginReductionGet_t;
-
-/** Message ID for CMD_HlogDS_Get */
-#define CMD_HLOGDS_GET 0x4A03
-
-/**
-   Requests information about the downstream HLOG information per subcarrier
-   group (Section 7.5.1.26.6 of G.997.1).During STEADY_STATE, the command can be
-   used in VDSL to request near-end data only (CPE). For the far-end HLOG to be
-   provided via the EOC channel CMD_TestParamsFE_Request must be used. In ADSL,
-   the command can be applied for near-end as well as far-end parameters.During
-   loop diagnostic mode, the command shall be used to request both near-end and
-   far-end data.
-*/
-typedef struct CMD_HlogDS_Get CMD_HlogDS_Get_t;
-
-/** Message ID for ACK_HlogDS_Get */
-#define ACK_HLOGDS_GET 0x4A03
-
-/**
-   Returns information about the downstream HLOG per subcarrier group for the
-   chosen range. (Section 7.5.1.26.6 of G.997.1)
-*/
-typedef struct ACK_HlogDS_Get ACK_HlogDS_Get_t;
-
-/** Message ID for CMD_HlogUS_Get */
-#define CMD_HLOGUS_GET 0x4B03
-
-/**
-   Requests information about the upstream HLOG information per subcarrier group
-   (Section 7.5.1.26.11 of G.997.1).
-*/
-typedef struct CMD_HlogUS_Get CMD_HlogUS_Get_t;
-
-/** Message ID for ACK_HlogUS_Get */
-#define ACK_HLOGUS_GET 0x4B03
-
-/**
-   Returns information about the upstream HLOG per subcarrier group for the
-   chosen range. (Section 7.5.1.26.11 of G.997.1)
-*/
-typedef struct ACK_HlogUS_Get ACK_HlogUS_Get_t;
-
-/** Message ID for CMD_HlinDS_Get */
-#define CMD_HLINDS_GET 0x4803
-
-/**
-   Requests information about the downstream HLIN information per subcarrier
-   group. (Section 7.5.1.26.3 of G.997.1).The HLIN data are available during
-   loop diagnostic mode only.
-*/
-typedef struct CMD_HlinDS_Get CMD_HlinDS_Get_t;
-
-/** Message ID for ACK_HlinDS_Get */
-#define ACK_HLINDS_GET 0x4803
-
-/**
-   Returns information about the downstream HLIN per subcarrier group for the
-   chosen range. (Section 7.5.1.26.3 of G.997.1)
-*/
-typedef struct ACK_HlinDS_Get ACK_HlinDS_Get_t;
-
-/** Message ID for CMD_HlinUS_Get */
-#define CMD_HLINUS_GET 0x4903
-
-/**
-   Requests information about the upstream HLIN information per subcarrier
-   group. (Section 7.5.1.26.9 of G.997.1).The HLIN data are available in loop
-   diagnostic mode only.
-*/
-typedef struct CMD_HlinUS_Get CMD_HlinUS_Get_t;
-
-/** Message ID for ACK_HlinUS_Get */
-#define ACK_HLINUS_GET 0x4903
-
-/**
-   Returns information about the upstream HLIN per subcarrier group for the
-   chosen range. (Section 7.5.1.26.9 of G.997.1)
-*/
-typedef struct ACK_HlinUS_Get ACK_HlinUS_Get_t;
-
-/** Message ID for CMD_QLN_DS_Get */
-#define CMD_QLN_DS_GET 0x4C03
-
-/**
-   Requests information about the downstream QLN information (QLNpsds) per
-   subcarrier group (Section 7.5.1.27.3 of G.997.1).During STEADY_STATE, the
-   command can be used in VDSL to request near-end data only (CPE).
-*/
-typedef struct CMD_QLN_DS_Get CMD_QLN_DS_Get_t;
-
-/** Message ID for ACK_QLN_DS_Get */
-#define ACK_QLN_DS_GET 0x4C03
-
-/**
-   Returns information about the QLN per subcarrier group for the chosen range.
-   (Section 7.5.1.27.3 of G.997.1)
-*/
-typedef struct ACK_QLN_DS_Get ACK_QLN_DS_Get_t;
-
-/** Message ID for CMD_QLN_US_Get */
-#define CMD_QLN_US_GET 0x4D03
-
-/**
-   Requests information about the upstream QLN (QLNpsus) per subcarrier group.
-   (Section 7.5.1.27.6 of G.997.1).
-*/
-typedef struct CMD_QLN_US_Get CMD_QLN_US_Get_t;
-
-/** Message ID for ACK_QLN_US_Get */
-#define ACK_QLN_US_GET 0x4D03
-
-/**
-   Returns information about the QLN per subcarrier group for the chosen range.
-   (Section 7.5.1.27.6 of G.997.1)
-*/
-typedef struct ACK_QLN_US_Get ACK_QLN_US_Get_t;
-
-/** Message ID for CMD_SNR_DS_Get */
-#define CMD_SNR_DS_GET 0x5503
-
-/**
-   Requests information about the downstream SNR per subcarrier group in VDSL or
-   the SNR per subcarrier in ADSL, both without considering virtual noise
-   (Section 7.5.1.28.3 of G.997.1).
-*/
-typedef struct CMD_SNR_DS_Get CMD_SNR_DS_Get_t;
-
-/** Message ID for ACK_SNR_DS_Get */
-#define ACK_SNR_DS_GET 0x5503
-
-/**
-   Returns information about the SNR per subcarrier (ADSL) or per subcarrier
-   group (VDSL) for the chosen range without considering virtual noise. (Section
-   7.5.1.28.3 of G.997.1)
-*/
-typedef struct ACK_SNR_DS_Get ACK_SNR_DS_Get_t;
-
-/** Message ID for CMD_SNR_US_Get */
-#define CMD_SNR_US_GET 0x4E03
-
-/**
-   Requests information about the upstream SNR per subcarrier group (Section
-   7.5.1.28.6 of G.997.1).
-*/
-typedef struct CMD_SNR_US_Get CMD_SNR_US_Get_t;
-
-/** Message ID for ACK_SNR_US_Get */
-#define ACK_SNR_US_GET 0x4E03
-
-/**
-   Returns information about the upstream SNR per subcarrier group for the
-   chosen range. (Section 7.5.1.28.6 of G.997.1)
-*/
-typedef struct ACK_SNR_US_Get ACK_SNR_US_Get_t;
-
-/** Message ID for CMD_TestParamsAuxDS_Get */
-#define CMD_TESTPARAMSAUXDS_GET 0x4F03
-
-/**
-   Requests test parameter related information for the downstream direction: The
-   HLIN scaling factor (HLINSCds), the subcarrier group size "G" and the
-   measurement times for HLOGpsds, QLNpsds, SNRpsds.(Sections 7.5.1.26.1/2/4/5,
-   7.5.1.27.1/2 and 7.5.1.28.1/2 of G.997.1)
-*/
-typedef struct CMD_TestParamsAuxDS_Get CMD_TestParamsAuxDS_Get_t;
-
-/** Message ID for ACK_TestParamsAuxDS_Get */
-#define ACK_TESTPARAMSAUXDS_GET 0x4F03
-
-/**
-   Provides the test-parameter related information as requested by
-   CMD_TestParamsAuxDS_Get: The HLIN scaling factor (HLINSCds), the subcarrier
-   group size "G" and the measurement times for HLOGpsds, QLNpsds,
-   SNRpsds.(Sections 7.5.1.26.1/2/4/5, 7.5.1.27.1/2 and 7.5.1.28.1/2 of G.997.1)
-*/
-typedef struct ACK_TestParamsAuxDS_Get ACK_TestParamsAuxDS_Get_t;
-
-/** Message ID for CMD_TestParamsAuxUS_Get */
-#define CMD_TESTPARAMSAUXUS_GET 0x5003
-
-/**
-   Requests test parameter related information for the upstream direction: The
-   HLIN scaling factor (HLINSCus), the subcarrier group size "G" and the
-   measurement times for HLOGpsus, QLNpsus, SNRpsus.For older VDSL FW versions
-   from w.6.x.y.z.a to 5.8.0.x.y.z: During STEADY_STATE, the command can be used
-   only to retrieve the "group size" parameters. To get the measurement time
-   parameters (via the EOC channel) the message CMD_TestParamsFE_Request must be
-   applied instead.(Sections 7.5.1.26.7/8/10/11, 7.5.1.27.4/5 and 7.5.1.28.4/5
-   of G.997.1)For older VDSL FW versions from w.6.x.y.z.a to 5.8.0.x.y.z: During
-   STEADY_STATE, the command can be used only to retrieve the "group size"
-   parameters. To get the measurement time parameters (via the EOC channel) the
-   message CMD_TestParamsFE_Request must be applied instead.The test parameters
-   can be requested during loop diagnostic mode (VDSL, ADSL) and in ADSL also
-   during STEADY_STATE.For older VDSL FW versions from w.6.x.y.z.a to
-   5.8.0.x.y.z: During STEADY_STATE, the command can be used only to retrieve
-   the "group size" parameters. To get the measurement time parameters (via the
-   EOC channel) the message CMD_TestParamsFE_Request must be applied instead.
-*/
-typedef struct CMD_TestParamsAuxUS_Get CMD_TestParamsAuxUS_Get_t;
-
-/** Message ID for ACK_TestParamsAuxUS_Get */
-#define ACK_TESTPARAMSAUXUS_GET 0x5003
-
-/**
-   Provides the test-parameter related information as requested by
-   CMD_TestParamsAuxUS_Get: The HLIN scaling factor (HLINSCus), the subcarrier
-   group size "G" and the measurement times for HLOGpsus, QLNpsus, SNRpsus.
-*/
-typedef struct ACK_TestParamsAuxUS_Get ACK_TestParamsAuxUS_Get_t;
-
-/** Message ID for CMD_TestParamsFE_Request */
-#define CMD_TESTPARAMSFE_REQUEST 0x0849
-
-/**
-   This message is used to trigger retrieval of the far-end PMD Test Parameters
-   Hlog, SNR and QLN via the EOC channel during Showtime. If StartIndex or
-   EndIndex do not contain values in a valid range then no autonomous message
-   will be sent by the firmware. Once the retrieval process is started, it can
-   also be aborted with this message via the control parameter. The status of
-   the parameter retrieval process can be polled via the CMD_TestParamsFE_Poll
-   message. Once the parameters are retrieved, they are provided with the
-   EVT_PMD_TestParamsGet message.
-*/
-typedef struct CMD_TestParamsFE_Request CMD_TestParamsFE_Request_t;
-
-/** Message ID for ACK_TestParamsFE_Request */
-#define ACK_TESTPARAMSFE_REQUEST 0x0849
-
-/**
-   This is the acknowledgement for CMD_TestParamsFE_Request.
-*/
-typedef struct ACK_TestParamsFE_Request ACK_TestParamsFE_Request_t;
-
-/** Message ID for CMD_TestParamsFE_Poll */
-#define CMD_TESTPARAMSFE_POLL 0x0809
-
-/**
-   This message polls the status of the far end parameter retrieval process.
-*/
-typedef struct CMD_TestParamsFE_Poll CMD_TestParamsFE_Poll_t;
-
-/** Message ID for ACK_TestParamsFE_Poll */
-#define ACK_TESTPARAMSFE_POLL 0x0809
-
-/**
-   This is the acknowledgement for CMD_TestParamsFE_Poll.
-*/
-typedef struct ACK_TestParamsFE_Poll ACK_TestParamsFE_Poll_t;
-
-/** Message ID for EVT_PMD_TestParamsGet */
-#define EVT_PMD_TESTPARAMSGET 0x5803
-
-/**
-   This event message provides the far-end data after the far end data retrieval
-   process. This message is a result of the CMD_TestParamsFE_Request message.
-*/
-typedef struct EVT_PMD_TestParamsGet EVT_PMD_TestParamsGet_t;
-
-/** Message ID for CMD_ClearEOC_Configure */
-#define CMD_CLEAREOC_CONFIGURE 0x0A49
-
-/**
-   The message is used to configure the autonomous messaging related to Clear
-   EOC transmission.
-*/
-typedef struct CMD_ClearEOC_Configure CMD_ClearEOC_Configure_t;
-
-/** Message ID for ACK_ClearEOC_Configure */
-#define ACK_CLEAREOC_CONFIGURE 0x0A49
-
-/**
-   This is the acknowledgement for CMD_ClearEOC_Configure.
-*/
-typedef struct ACK_ClearEOC_Configure ACK_ClearEOC_Configure_t;
-
-/** Message ID for CMD_ClearEOC_TxTrigger */
-#define CMD_CLEAREOC_TXTRIGGER 0x0949
-
-/**
-   The message is used to trigger the transmission of  Clear EOC messages that
-   were placed into the Clear EOC transmit buffer before with
-   CMD_ClearEOC_Write.
-*/
-typedef struct CMD_ClearEOC_TxTrigger CMD_ClearEOC_TxTrigger_t;
-
-/** Message ID for ACK_ClearEOC_TxTrigger */
-#define ACK_CLEAREOC_TXTRIGGER 0x0949
-
-/**
-   This is the acknowledgement for CMD_ClearEOC_TxTrigger.
-*/
-typedef struct ACK_ClearEOC_TxTrigger ACK_ClearEOC_TxTrigger_t;
-
-/** Message ID for CMD_ClearEOC_Write */
-#define CMD_CLEAREOC_WRITE 0x5143
-
-/**
-   This message is used to write data to the ClearEOC write buffer of type
-   VRX_ClearEOC_t. When the buffer is filled, the transmission is started
-   applying CMD_ClearEOC_TxTrigger. If the message to transmit is longer than
-   the mailbox size, a sequence of writes to the ClearEOC buffer has to be done
-   before the transmission is started with CMD_ClearEOC_TxTrigger. When
-   autonomous TX status messaging is activated via CMD_ClearEOC_Configure, then
-   the finished transmission is indicated by EVT_ClearEOCStatusGet.
-*/
-typedef struct CMD_ClearEOC_Write CMD_ClearEOC_Write_t;
-
-/** Message ID for ACK_ClearEOC_Write */
-#define ACK_CLEAREOC_WRITE 0x5143
-
-/**
-   This message is the acknowledgement for CMD_ClearEOC_Write.
-*/
-typedef struct ACK_ClearEOC_Write ACK_ClearEOC_Write_t;
-
-/** Message ID for CMD_ClearEOC_Read */
-#define CMD_CLEAREOC_READ 0x5203
-
-/**
-   This message is used to read data from the ClearEOC buffer of type
-   VRX_ClearEOC_t. The length of the actual Clear EOC message can be found in
-   the buffer. Please refer to VRX_ClearEOC_t. The availability of data can
-   either be checked via CMD_ClearEOCStatusGet in polling mode or it can be
-   reported by an autonomous EVT_ClearEOCStatusGet message when data is received
-   (to be enabled using CMD_ClearEOC_Configure).
-*/
-typedef struct CMD_ClearEOC_Read CMD_ClearEOC_Read_t;
-
-/** Message ID for ACK_ClearEOC_Read */
-#define ACK_CLEAREOC_READ 0x5203
-
-/**
-   This message is the acknowledgement to CMD_ClearEOC_Read.
-*/
-typedef struct ACK_ClearEOC_Read ACK_ClearEOC_Read_t;
-
-/** Message ID for EVT_ClearEOC_Read */
-#define EVT_CLEAREOC_READ 0x5203
-
-/**
-   This message is an autonomous message that is generated when ClearEOC data
-   was received and autonomous Clear EOC data messaging has been activated via
-   CMD_ClearEOC_Configure. If the ClearEOC data does not fit in one message,
-   then a sequence of messages is generated. The ClearEOC buffer is of type
-   VRX_ClearEOC_t.
-*/
-typedef struct EVT_ClearEOC_Read EVT_ClearEOC_Read_t;
-
-/** Message ID for CMD_ClearEOCStatusGet */
-#define CMD_CLEAREOCSTATUSGET 0x0B09
-
-/**
-   This message is used to retrieve the status of the clear eoc data
-   transmission.
-*/
-typedef struct CMD_ClearEOCStatusGet CMD_ClearEOCStatusGet_t;
-
-/** Message ID for ACK_ClearEOCStatusGet */
-#define ACK_CLEAREOCSTATUSGET 0x0B09
-
-/**
-   This is the acknowledgement for CMD_ClearEOCStatusGet.
-*/
-typedef struct ACK_ClearEOCStatusGet ACK_ClearEOCStatusGet_t;
-
-/** Message ID for EVT_ClearEOCStatusGet */
-#define EVT_CLEAREOCSTATUSGET 0x0B09
-
-/**
-   This autonomous message reports the Clear EOC status. It is sent only if the
-   "Autonomous Status Message Control" was enabled for TX and/or RX direction
-   with CMD_ClearEOC_Configure. If TX direction is enabled, the message is
-   generated when a TX transmission is finished or failed. If RX direction is
-   enabled, the message is generated when the RX status transitions from "Idle"
-   to "Data Available" for retrieval by the host.
-*/
-typedef struct EVT_ClearEOCStatusGet EVT_ClearEOCStatusGet_t;
-
-/** Message ID for CMD_ClearEOCStatusSet */
-#define CMD_CLEAREOCSTATUSSET 0x0B49
-
-/**
-   The message is used to reset the transmit or receive status of the clear eoc
-   data transmission to IDLE (for defined states see also
-   CMD_ClearEOCStatusGet). See the description on the Clear EOC handling on Page
-   540 for when it has to be applied. Transmit and receive status are
-   distinguished by the Index parameter.
-*/
-typedef struct CMD_ClearEOCStatusSet CMD_ClearEOCStatusSet_t;
-
-/** Message ID for ACK_ClearEOCStatusSet */
-#define ACK_CLEAREOCSTATUSSET 0x0B49
-
-/**
-   This is the acknowledgement for CMD_ClearEOCStatusSet.
-*/
-typedef struct ACK_ClearEOCStatusSet ACK_ClearEOCStatusSet_t;
-
-/** Message ID for CMD_OH_OptionsSet */
-#define CMD_OH_OPTIONSSET 0x1945
-
-/**
-   Configuration of options for the overhead handling.
-*/
-typedef struct CMD_OH_OptionsSet CMD_OH_OptionsSet_t;
-
-/** Message ID for ACK_OH_OptionsSet */
-#define ACK_OH_OPTIONSSET 0x1945
-
-/**
-   Acknowledgement for CMD_OH_OptionsSet.
-*/
-typedef struct ACK_OH_OptionsSet ACK_OH_OptionsSet_t;
-
-/** Message ID for CMD_OH_StatsGet */
-#define CMD_OH_STATSGET 0x0F03
-
-/**
-   Requests OH polling statistic information.
-*/
-typedef struct CMD_OH_StatsGet CMD_OH_StatsGet_t;
-
-/** Message ID for ACK_OH_StatsGet */
-#define ACK_OH_STATSGET 0x0F03
-
-/**
-   Reports the OH polling statistics as requested by CMD_OH_StatsGet.
-*/
-typedef struct ACK_OH_StatsGet ACK_OH_StatsGet_t;
-
-/** Message ID for CMD_OLR_Control */
-#define CMD_OLR_CONTROL 0x0F45
-
-/**
-   Enables/Disables support for OLR events (Bitswaps, SRA, SOS, ROC).An OLR
-   transition is always initiated by the receiving PMD, so the CPE requests the
-   OLR event for downstream direction.
-*/
-typedef struct CMD_OLR_Control CMD_OLR_Control_t;
-
-/** Message ID for ACK_OLR_Control */
-#define ACK_OLR_CONTROL 0x0F45
-
-/**
-   Acknowledgement for CMD_OLR_Control.
-*/
-typedef struct ACK_OLR_Control ACK_OLR_Control_t;
-
-/** Message ID for CMD_OLR_US_StatsGet */
-#define CMD_OLR_US_STATSGET 0x5F03
-
-/**
-   Requests the OLR status information on bit swaps, DRR, SRA and SOS events for
-   the upstream direction.
-*/
-typedef struct CMD_OLR_US_StatsGet CMD_OLR_US_StatsGet_t;
-
-/** Message ID for ACK_OLR_US_StatsGet */
-#define ACK_OLR_US_STATSGET 0x5F03
-
-/**
-   Reports the OLR status information for the upstream direction as requested by
-   CMD_OLR_US_StatsGet.
-*/
-typedef struct ACK_OLR_US_StatsGet ACK_OLR_US_StatsGet_t;
-
-/** Message ID for CMD_OLR_DS_StatsGet */
-#define CMD_OLR_DS_STATSGET 0x6003
-
-/**
-   Requests the OLR status information on bit swaps, DRR, SRA and SOS events for
-   the downstream direction.
-*/
-typedef struct CMD_OLR_DS_StatsGet CMD_OLR_DS_StatsGet_t;
-
-/** Message ID for ACK_OLR_DS_StatsGet */
-#define ACK_OLR_DS_STATSGET 0x6003
-
-/**
-   Reports the OLR status information for the downstream direction as requested
-   by CMD_OLR_DS_StatsGet.
-*/
-typedef struct ACK_OLR_DS_StatsGet ACK_OLR_DS_StatsGet_t;
-
-/** Message ID for CMD_RA_ModeDS_Get */
-#define CMD_RA_MODEDS_GET 0xD903
-
-/**
-   Requests the actual active downstream RA mode (ACT-RA-MODEds, Section
-   7.5.1.33.1 of G.997.1).
-*/
-typedef struct CMD_RA_ModeDS_Get CMD_RA_ModeDS_Get_t;
-
-/** Message ID for ACK_RA_ModeDS_Get */
-#define ACK_RA_MODEDS_GET 0xD903
-
-/**
-   Reports the actual active downstream RA mode (ACT-RA-MODEds) as requested by
-   CMD_RA_ModeDS_Get.
-*/
-typedef struct ACK_RA_ModeDS_Get ACK_RA_ModeDS_Get_t;
-
-/** Message ID for CMD_RA_ModeUS_Get */
-#define CMD_RA_MODEUS_GET 0xDB03
-
-/**
-   Requests the actual active upstream RA mode (ACT-RA-MODEus, Section
-   7.5.1.33.2 of G.997.1).
-*/
-typedef struct CMD_RA_ModeUS_Get CMD_RA_ModeUS_Get_t;
-
-/** Message ID for ACK_RA_ModeUS_Get */
-#define ACK_RA_MODEUS_GET 0xDB03
-
-/**
-   Reports the actual active upstream RA mode (ACT-RA-MODEus) as requested by
-   CMD_RA_ModeUS_Get.
-*/
-typedef struct ACK_RA_ModeUS_Get ACK_RA_ModeUS_Get_t;
-
-/** Message ID for EVT_OLR_US_EventGet */
-#define EVT_OLR_US_EVENTGET 0x0307
-
-/**
-   Autonomous message indicating a successful upstream OLR event (SRA or SOS).
-*/
-typedef struct EVT_OLR_US_EventGet EVT_OLR_US_EventGet_t;
-
-/** Message ID for EVT_OLR_DS_EventGet */
-#define EVT_OLR_DS_EVENTGET 0x0407
-
-/**
-   Autonomous message indicating a successful downstream OLR event (SRA or SOS).
-*/
-typedef struct EVT_OLR_DS_EventGet EVT_OLR_DS_EventGet_t;
-
-/** Message ID for CMD_OLR_US_EventConfigure */
-#define CMD_OLR_US_EVENTCONFIGURE 0x0F49
-
-/**
-   Enables/Disables the generation of EVENT messages (EVT) for specific upstream
-   OLR events. If the corresponding Enable bit for an OLR event is set, then the
-   modem firmware will send an autonomous message EVT_OLR_US_EventGet if the OLR
-   event happened in the last 1-second interval.
-*/
-typedef struct CMD_OLR_US_EventConfigure CMD_OLR_US_EventConfigure_t;
-
-/** Message ID for ACK_OLR_US_EventConfigure */
-#define ACK_OLR_US_EVENTCONFIGURE 0x0F49
-
-/**
-   Acknoledgement for CMD_OLR_US_EventConfigure.
-*/
-typedef struct ACK_OLR_US_EventConfigure ACK_OLR_US_EventConfigure_t;
-
-/** Message ID for CMD_OLR_DS_EventConfigure */
-#define CMD_OLR_DS_EVENTCONFIGURE 0x1049
-
-/**
-   Enables/Disables the generation of EVENT messages (EVT) for specific
-   downstream OLR events. If the corresponding Enable bit for an OLR event is
-   set, then the modem firmware will send an autonomous message
-   EVT_OLR_DS_EventGet if the OLR event happened in the last 1-second interval.
-*/
-typedef struct CMD_OLR_DS_EventConfigure CMD_OLR_DS_EventConfigure_t;
-
-/** Message ID for ACK_OLR_DS_EventConfigure */
-#define ACK_OLR_DS_EVENTCONFIGURE 0x1049
-
-/**
-   Acknoledgement for CMD_OLR_DS_EventConfigure.
-*/
-typedef struct ACK_OLR_DS_EventConfigure ACK_OLR_DS_EventConfigure_t;
-
-/** Message ID for CMD_RTX_Control */
-#define CMD_RTX_CONTROL 0x5048
-
-/**
-   Configures a link for retransmission of downstream data. For using the RTX
-   function, this message has to be sent.
-*/
-typedef struct CMD_RTX_Control CMD_RTX_Control_t;
-
-/** Message ID for ACK_RTX_Control */
-#define ACK_RTX_CONTROL 0x5048
-
-/**
-   Acknowledgement for CMD_RTX_Control.
-*/
-typedef struct ACK_RTX_Control ACK_RTX_Control_t;
-
-/** Message ID for CMD_RTX_BearerChsDS_Get */
-#define CMD_RTX_BEARERCHSDS_GET 0x0206
-
-/**
-   Requests RTX specific status information for the downstream bearer channels
-   if G.INP retransmission is used.
-*/
-typedef struct CMD_RTX_BearerChsDS_Get CMD_RTX_BearerChsDS_Get_t;
-
-/** Message ID for ACK_RTX_BearerChsDS_Get */
-#define ACK_RTX_BEARERCHSDS_GET 0x0206
-
-/**
-   Delivers status information for the downstream bearer channels when G.INP
-   retransmission is actually used.
-*/
-typedef struct ACK_RTX_BearerChsDS_Get ACK_RTX_BearerChsDS_Get_t;
-
-/** Message ID for CMD_RTX_BearerChsUS_Get */
-#define CMD_RTX_BEARERCHSUS_GET 0x0306
-
-/**
-   Requests RTX specific status information for the upstream bearer channels if
-   upstream G.INP retransmission is used.
-*/
-typedef struct CMD_RTX_BearerChsUS_Get CMD_RTX_BearerChsUS_Get_t;
-
-/** Message ID for ACK_RTX_BearerChsUS_Get */
-#define ACK_RTX_BEARERCHSUS_GET 0x0306
-
-/**
-   Delivers status information for the upstream bearer channels when upstream
-   G.INP retransmission is used.
-*/
-typedef struct ACK_RTX_BearerChsUS_Get ACK_RTX_BearerChsUS_Get_t;
-
-/** Message ID for CMD_RTX_PM_DS_Get */
-#define CMD_RTX_PM_DS_GET 0x2B0A
-
-/**
-   Requests performance monitoring counters for downstream G.INP retransmission.
-*/
-typedef struct CMD_RTX_PM_DS_Get CMD_RTX_PM_DS_Get_t;
-
-/** Message ID for ACK_RTX_PM_DS_Get */
-#define ACK_RTX_PM_DS_GET 0x2B0A
-
-/**
-   Delivers performance monitoring counters for downstream G.INP retransmission.
-*/
-typedef struct ACK_RTX_PM_DS_Get ACK_RTX_PM_DS_Get_t;
-
-/** Message ID for CMD_RTX_PM_US_Get */
-#define CMD_RTX_PM_US_GET 0x3B0A
-
-/**
-   Requests performance monitoring counters for upstream G.INP retransmission.
-*/
-typedef struct CMD_RTX_PM_US_Get CMD_RTX_PM_US_Get_t;
-
-/** Message ID for ACK_RTX_PM_US_Get */
-#define ACK_RTX_PM_US_GET 0x3B0A
-
-/**
-   Delivers performance monitoring counters for upstream G.INP retransmission.
-   They are all far-end parameters received from CO.
-*/
-typedef struct ACK_RTX_PM_US_Get ACK_RTX_PM_US_Get_t;
-
-/** Message ID for CMD_RTX_DS_StatsGet */
-#define CMD_RTX_DS_STATSGET 0x2C0A
-
-/**
-   Requests DTU counters for G.INP downstream retransmission.
-*/
-typedef struct CMD_RTX_DS_StatsGet CMD_RTX_DS_StatsGet_t;
-
-/** Message ID for ACK_RTX_DS_StatsGet */
-#define ACK_RTX_DS_STATSGET 0x2C0A
-
-/**
-   Delivers DTU counters for G.INP downstream retransmission. The counters are
-   Non-TR1 wrap-around counters, which are reset at reboot only.
-*/
-typedef struct ACK_RTX_DS_StatsGet ACK_RTX_DS_StatsGet_t;
-
-/** Message ID for CMD_RTX_US_StatsGet */
-#define CMD_RTX_US_STATSGET 0x3A0A
-
-/**
-   Requests DTU counters for G.INP upstream retransmission, which is defined for
-   VDSL only.
-*/
-typedef struct CMD_RTX_US_StatsGet CMD_RTX_US_StatsGet_t;
-
-/** Message ID for ACK_RTX_US_StatsGet */
-#define ACK_RTX_US_STATSGET 0x3A0A
-
-/**
-   Delivers DTU counters for G.INP upstream retransmission. The counters are
-   Non-TR1 wrap-around counters, which are reset at reboot only.
-*/
-typedef struct ACK_RTX_US_StatsGet ACK_RTX_US_StatsGet_t;
-
-/** Message ID for CMD_RTX_StatusGet */
-#define CMD_RTX_STATUSGET 0xE503
-
-/**
-   Requests the actually used G.INP retransmission status.
-*/
-typedef struct CMD_RTX_StatusGet CMD_RTX_StatusGet_t;
-
-/** Message ID for ACK_RTX_StatusGet */
-#define ACK_RTX_STATUSGET 0xE503
-
-/**
-   Provides the actually used G.INP retransmission status.
-*/
-typedef struct ACK_RTX_StatusGet ACK_RTX_StatusGet_t;
-
-/** Message ID for CMD_RTX_US_FrameDataGet */
-#define CMD_RTX_US_FRAMEDATAGET 0xED03
-
-/**
-   Requests upstream G.INP retransmission specific framing parameters and other
-   status parameters. They are always associated with bearer channel 0.
-*/
-typedef struct CMD_RTX_US_FrameDataGet CMD_RTX_US_FrameDataGet_t;
-
-/** Message ID for ACK_RTX_US_FrameDataGet */
-#define ACK_RTX_US_FRAMEDATAGET 0xED03
-
-/**
-   Delivers upstream retransmission specific framing parameters and other status
-   parameters, as requested by CMD_RTX_US_FrameDataGet. They are always
-   associated with bearer channel 0.In addition, the usual framing parameters
-   are to be retrieved with CMD_FrameDataExt2US_Get.
-*/
-typedef struct ACK_RTX_US_FrameDataGet ACK_RTX_US_FrameDataGet_t;
-
-/** Message ID for CMD_RTX_US_Roundtrip_Get */
-#define CMD_RTX_US_ROUNDTRIP_GET 0xEF03
-
-/**
-   Requests the G.INP upstream retransmission measured roundtrip.
-*/
-typedef struct CMD_RTX_US_Roundtrip_Get CMD_RTX_US_Roundtrip_Get_t;
-
-/** Message ID for ACK_RTX_US_Roundtrip_Get */
-#define ACK_RTX_US_ROUNDTRIP_GET 0xEF03
-
-/**
-   Provides the G.INP upstream retransmission measured roundtrip delay. For
-   measuring the roundtrip, following difference is built when a correct RRC
-   codeword has been received: AbsoluteDTUCount of transmitter for next possible
-   DTU transmission minus AbsoluteDTUCount as received in RRC codeword.
-*/
-typedef struct ACK_RTX_US_Roundtrip_Get ACK_RTX_US_Roundtrip_Get_t;
-
-/** Message ID for CMD_DSM_Control */
-#define CMD_DSM_CONTROL 0x5248
-
-/**
-   Enables/Disables support for full vectoring (G.993.5) and full vector-
-   friendly operation (G.993.2 Annex Y). In case of ADSL, this only means the
-   indication of the (VDSL) vectoring capabilities during G.Handshake.
-*/
-typedef struct CMD_DSM_Control CMD_DSM_Control_t;
-
-/** Message ID for ACK_DSM_Control */
-#define ACK_DSM_CONTROL 0x5248
-
-/**
-   Acknowledgement to CMD_DSM_Control.
-*/
-typedef struct ACK_DSM_Control ACK_DSM_Control_t;
-
-/** Message ID for EVT_DSM_ErrorVectorReady */
-#define EVT_DSM_ERRORVECTORREADY 0x1109
-
-/**
-   This autononmous message indicates that new downstream DSM error vector data
-   were written by the DSL FW into the SDRAM. Generation of this EVT message is
-   enabled/disabled together with the G.993.5 vectoring functionality itself, by
-   means of CMD_DSM_Control, parameter "Vector".
-*/
-typedef struct EVT_DSM_ErrorVectorReady EVT_DSM_ErrorVectorReady_t;
-
-/** Message ID for CMD_DSM_StatsGet */
-#define CMD_DSM_STATSGET 0x370A
-
-/**
-   Requests vectoring debug counter values.
-*/
-typedef struct CMD_DSM_StatsGet CMD_DSM_StatsGet_t;
-
-/** Message ID for ACK_DSM_StatsGet */
-#define ACK_DSM_STATSGET 0x370A
-
-/**
-   Delivers vectoring debug counters.
-*/
-typedef struct ACK_DSM_StatsGet ACK_DSM_StatsGet_t;
-
-/**
-   Requests information about the bit-allocation per subcarrier in VDSL mode.
-   The values for all subcarriers of both directions can be retrieved. (For ADSL
-   use CMD_BAT_DS_Get and CMD_BAT_US_Get).
-*/
-struct CMD_BAT_TableEntriesGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the bit-allocation per tone for the chosen range of
-   subcarriers.(Section 7.5.1.29.1-2 of G.997.1)
-*/
-struct ACK_BAT_TableEntriesGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Bit Allocation */
-   VRX_BAT_TableEntry_t BAT[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Bit Allocation */
-   VRX_BAT_TableEntry_t BAT[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests information about the Gains per subcarrier. The values for all
-   subcarriers of both directions can be retrieved.(For ADSL use
-   CMD_GainTableDS_Get and CMD_GainTableUS_Get).
-*/
-struct CMD_GainTableEntriesGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the Gain-per-tone for the chosen range of
-   subcarriers.(Section 7.5.1.29.3-4 of G.997.1)
-*/
-struct ACK_GainTableEntriesGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Gains */
-   DSL_uint16_t Gains[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Gains */
-   DSL_uint16_t Gains[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message requests information about the SNR per subcarrier with virtual
-   noise for the near-end side , which means for downstream direction at the
-   CPE. It is the hosts responsibility to select the tone indices
-   accordingly.See also Table 20 "How to Retrieve Test Parameter Data" on Page
-   496.
-*/
-struct CMD_SNR_NE_TableEntriesGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the SNR per subcarrier with virtual noise for the
-   near-end side, meaning for downstream direction.
-*/
-struct ACK_SNR_NE_TableEntriesGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** SNR */
-   DSL_uint16_t SNRps[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** SNR */
-   DSL_uint16_t SNRps[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests information about the downstream bit-allocation per subcarrier in
-   ADSL mode.
-*/
-struct CMD_BAT_DS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the downstream bit-allocation per tone for the
-   chosen range of subcarriers.(Section 7.5.1.29.1 of G.997.1)
-*/
-struct ACK_BAT_DS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Bit Allocation */
-   VRX_BAT_TableEntry_t BAT[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Bit Allocation */
-   VRX_BAT_TableEntry_t BAT[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests information about the upstream bit-allocation per subcarrier in ADSL
-   mode.
-*/
-struct CMD_BAT_US_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the upstream bit-allocation per tone for the chosen
-   range of subcarriers.(Section 7.5.1.29.2 of G.997.1)
-*/
-struct ACK_BAT_US_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Bit Allocation */
-   VRX_BAT_TableEntry_t BAT[32];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Bit Allocation */
-   VRX_BAT_TableEntry_t BAT[32];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests information about the Gains per subcarrier for the downstream
-   direction.
-*/
-struct CMD_GainTableDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the Gain-per-tone for the chosen range of
-   subcarriers for the downstream direction.(Section 7.5.1.29.3 of G.997.1) as
-   requested by CMD_GainTableDS_Get.
-*/
-struct ACK_GainTableDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Gains */
-   DSL_uint16_t Gains[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Gains */
-   DSL_uint16_t Gains[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests information about the Gains per subcarrier for the upstream
-   direction.
-*/
-struct CMD_GainTableUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the Gain-per-tone for the chosen range of
-   subcarriers for the upstream direction.(Section 7.5.1.29.4 of G.997.1)
-*/
-struct ACK_GainTableUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Gains */
-   DSL_uint16_t Gains[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Gains */
-   DSL_uint16_t Gains[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests information about the Excess Margin Reduction needed for the fine
-   gain calculation at the ATU_R.(See also ACK_GainTableDS_Get).
-*/
-struct CMD_ADSL_ExMarginReductionGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the Excess Margin Reduction for the downstream
-   direction.
-*/
-struct ACK_ADSL_ExMarginReductionGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Excess Margin Reduction  */
-   DSL_uint16_t eSnrmReduction;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Excess Margin Reduction  */
-   DSL_uint16_t eSnrmReduction;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests information about the downstream HLOG information per subcarrier
-   group (Section 7.5.1.26.6 of G.997.1).During STEADY_STATE, the command can be
-   used in VDSL to request near-end data only (CPE). For the far-end HLOG to be
-   provided via the EOC channel CMD_TestParamsFE_Request must be used. In ADSL,
-   the command can be applied for near-end as well as far-end parameters.During
-   loop diagnostic mode, the command shall be used to request both near-end and
-   far-end data.
-*/
-struct CMD_HlogDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the downstream HLOG per subcarrier group for the
-   chosen range. (Section 7.5.1.26.6 of G.997.1)
-*/
-struct ACK_HlogDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** HLOG per SG: HLOGpsds */
-   DSL_uint16_t HLOGpsds[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** HLOG per SG: HLOGpsds */
-   DSL_uint16_t HLOGpsds[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests information about the upstream HLOG information per subcarrier group
-   (Section 7.5.1.26.11 of G.997.1).
-*/
-struct CMD_HlogUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the upstream HLOG per subcarrier group for the
-   chosen range. (Section 7.5.1.26.11 of G.997.1)
-*/
-struct ACK_HlogUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** HLOG per SG: HLOGpsus */
-   DSL_uint16_t HLOGpsus[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** HLOG per SG: HLOGpsus */
-   DSL_uint16_t HLOGpsus[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests information about the downstream HLIN information per subcarrier
-   group. (Section 7.5.1.26.3 of G.997.1).The HLIN data are available during
-   loop diagnostic mode only.
-*/
-struct CMD_HlinDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the downstream HLIN per subcarrier group for the
-   chosen range. (Section 7.5.1.26.3 of G.997.1)
-*/
-struct ACK_HlinDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** HLIN per SG: HLINpsds */
-   VRX_HLIN_t HLINpsds[64];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** HLIN per SG: HLINpsds */
-   VRX_HLIN_t HLINpsds[64];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests information about the upstream HLIN information per subcarrier
-   group. (Section 7.5.1.26.9 of G.997.1).The HLIN data are available in loop
-   diagnostic mode only.
-*/
-struct CMD_HlinUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the upstream HLIN per subcarrier group for the
-   chosen range. (Section 7.5.1.26.9 of G.997.1)
-*/
-struct ACK_HlinUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** HLIN per SG: HLINpsus */
-   VRX_HLIN_t HLINpsus[64];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** HLIN per SG: HLINpsus */
-   VRX_HLIN_t HLINpsus[64];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests information about the downstream QLN information (QLNpsds) per
-   subcarrier group (Section 7.5.1.27.3 of G.997.1).During STEADY_STATE, the
-   command can be used in VDSL to request near-end data only (CPE).
-*/
-struct CMD_QLN_DS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the QLN per subcarrier group for the chosen range.
-   (Section 7.5.1.27.3 of G.997.1)
-*/
-struct ACK_QLN_DS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** QLN per SG: QLNpsds */
-   VRX_QLN_NE_t QLNds[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** QLN per SG: QLNpsds */
-   VRX_QLN_NE_t QLNds[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests information about the upstream QLN (QLNpsus) per subcarrier group.
-   (Section 7.5.1.27.6 of G.997.1).
-*/
-struct CMD_QLN_US_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the QLN per subcarrier group for the chosen range.
-   (Section 7.5.1.27.6 of G.997.1)
-*/
-struct ACK_QLN_US_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** QLN per SG: QLNpsus */
-   VRX_QLN_NE_t QLNus[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** QLN per SG: QLNpsus */
-   VRX_QLN_NE_t QLNus[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests information about the downstream SNR per subcarrier group in VDSL or
-   the SNR per subcarrier in ADSL, both without considering virtual noise
-   (Section 7.5.1.28.3 of G.997.1).
-*/
-struct CMD_SNR_DS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the SNR per subcarrier (ADSL) or per subcarrier
-   group (VDSL) for the chosen range without considering virtual noise. (Section
-   7.5.1.28.3 of G.997.1)
-*/
-struct ACK_SNR_DS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** SNR per SG: SNRpsds */
-   VRX_SNR_t SNRpsds[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** SNR per SG: SNRpsds */
-   VRX_SNR_t SNRpsds[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests information about the upstream SNR per subcarrier group (Section
-   7.5.1.28.6 of G.997.1).
-*/
-struct CMD_SNR_US_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns information about the upstream SNR per subcarrier group for the
-   chosen range. (Section 7.5.1.28.6 of G.997.1)
-*/
-struct ACK_SNR_US_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** SNR per SG: SNRpsus */
-   VRX_SNR_t SNRpsus[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** SNR per SG: SNRpsus */
-   VRX_SNR_t SNRpsus[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests test parameter related information for the downstream direction: The
-   HLIN scaling factor (HLINSCds), the subcarrier group size "G" and the
-   measurement times for HLOGpsds, QLNpsds, SNRpsds.(Sections 7.5.1.26.1/2/4/5,
-   7.5.1.27.1/2 and 7.5.1.28.1/2 of G.997.1)
-*/
-struct CMD_TestParamsAuxDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the test-parameter related information as requested by
-   CMD_TestParamsAuxDS_Get: The HLIN scaling factor (HLINSCds), the subcarrier
-   group size "G" and the measurement times for HLOGpsds, QLNpsds,
-   SNRpsds.(Sections 7.5.1.26.1/2/4/5, 7.5.1.27.1/2 and 7.5.1.28.1/2 of G.997.1)
-*/
-struct ACK_TestParamsAuxDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** HLIN Scaling Factor "HLINSCds" */
-   DSL_uint16_t HLINSC;
-   /** HLIN Subcarrier Group Size DS "HLINGds" */
-   DSL_uint16_t HLING;
-   /** HLOG Measurement Time "HLOGMTds" */
-   DSL_uint16_t HLOGMT;
-   /** HLOG Subcarrier Group Size DS "HLOGGds" */
-   DSL_uint16_t HLOGG;
-   /** QLN Measurment Time "QLNMTds" */
-   DSL_uint16_t QLNMT;
-   /** QLN Subcarrier Group Size DS "QLNGds" */
-   DSL_uint16_t QLNG;
-   /** SNR Measurement Time "SNRMTds" */
-   DSL_uint16_t SNRMT;
-   /** SNR Subcarrier Group Size DS "SNRGds" */
-   DSL_uint16_t SNRG;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** HLIN Scaling Factor "HLINSCds" */
-   DSL_uint16_t HLINSC;
-   /** HLIN Subcarrier Group Size DS "HLINGds" */
-   DSL_uint16_t HLING;
-   /** HLOG Measurement Time "HLOGMTds" */
-   DSL_uint16_t HLOGMT;
-   /** HLOG Subcarrier Group Size DS "HLOGGds" */
-   DSL_uint16_t HLOGG;
-   /** QLN Measurment Time "QLNMTds" */
-   DSL_uint16_t QLNMT;
-   /** QLN Subcarrier Group Size DS "QLNGds" */
-   DSL_uint16_t QLNG;
-   /** SNR Measurement Time "SNRMTds" */
-   DSL_uint16_t SNRMT;
-   /** SNR Subcarrier Group Size DS "SNRGds" */
-   DSL_uint16_t SNRG;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests test parameter related information for the upstream direction: The
-   HLIN scaling factor (HLINSCus), the subcarrier group size "G" and the
-   measurement times for HLOGpsus, QLNpsus, SNRpsus.For older VDSL FW versions
-   from w.6.x.y.z.a to 5.8.0.x.y.z: During STEADY_STATE, the command can be used
-   only to retrieve the "group size" parameters. To get the measurement time
-   parameters (via the EOC channel) the message CMD_TestParamsFE_Request must be
-   applied instead.(Sections 7.5.1.26.7/8/10/11, 7.5.1.27.4/5 and 7.5.1.28.4/5
-   of G.997.1)For older VDSL FW versions from w.6.x.y.z.a to 5.8.0.x.y.z: During
-   STEADY_STATE, the command can be used only to retrieve the "group size"
-   parameters. To get the measurement time parameters (via the EOC channel) the
-   message CMD_TestParamsFE_Request must be applied instead.The test parameters
-   can be requested during loop diagnostic mode (VDSL, ADSL) and in ADSL also
-   during STEADY_STATE.For older VDSL FW versions from w.6.x.y.z.a to
-   5.8.0.x.y.z: During STEADY_STATE, the command can be used only to retrieve
-   the "group size" parameters. To get the measurement time parameters (via the
-   EOC channel) the message CMD_TestParamsFE_Request must be applied instead.
-*/
-struct CMD_TestParamsAuxUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the test-parameter related information as requested by
-   CMD_TestParamsAuxUS_Get: The HLIN scaling factor (HLINSCus), the subcarrier
-   group size "G" and the measurement times for HLOGpsus, QLNpsus, SNRpsus.
-*/
-struct ACK_TestParamsAuxUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** HLIN Scaling Factor "HLINSCus" */
-   DSL_uint16_t HLINSC;
-   /** HLIN Subcarrier Group Size US "HLINGus" */
-   DSL_uint16_t HLING;
-   /** HLOG Measurement Time "HLOGMTus" */
-   DSL_uint16_t HLOGMT;
-   /** HLOG Subcarrier Group Size US "HLOGGus" */
-   DSL_uint16_t HLOGG;
-   /** QLN Measurment Time "QLNMTus" */
-   DSL_uint16_t QLNMT;
-   /** QLN Subcarrier Group Size US "QLNGus" */
-   DSL_uint16_t QLNG;
-   /** SNR Measurement Time "SNRMTus" */
-   DSL_uint16_t SNRMT;
-   /** SNR Subcarrier Group Size US "SNRGus" */
-   DSL_uint16_t SNRG;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** HLIN Scaling Factor "HLINSCus" */
-   DSL_uint16_t HLINSC;
-   /** HLIN Subcarrier Group Size US "HLINGus" */
-   DSL_uint16_t HLING;
-   /** HLOG Measurement Time "HLOGMTus" */
-   DSL_uint16_t HLOGMT;
-   /** HLOG Subcarrier Group Size US "HLOGGus" */
-   DSL_uint16_t HLOGG;
-   /** QLN Measurment Time "QLNMTus" */
-   DSL_uint16_t QLNMT;
-   /** QLN Subcarrier Group Size US "QLNGus" */
-   DSL_uint16_t QLNG;
-   /** SNR Measurement Time "SNRMTus" */
-   DSL_uint16_t SNRMT;
-   /** SNR Subcarrier Group Size US "SNRGus" */
-   DSL_uint16_t SNRG;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This message is used to trigger retrieval of the far-end PMD Test Parameters
-   Hlog, SNR and QLN via the EOC channel during Showtime. If StartIndex or
-   EndIndex do not contain values in a valid range then no autonomous message
-   will be sent by the firmware. Once the retrieval process is started, it can
-   also be aborted with this message via the control parameter. The status of
-   the parameter retrieval process can be polled via the CMD_TestParamsFE_Poll
-   message. Once the parameters are retrieved, they are provided with the
-   EVT_PMD_TestParamsGet message.
-*/
-struct CMD_TestParamsFE_Request
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Far-end Retrieval Control */
-   DSL_uint16_t Control;
-   /** Subcarrier Group Start Index */
-   DSL_uint16_t StartIndex;
-   /** Subcarrier Group End Index */
-   DSL_uint16_t EndIndex;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Far-end Retrieval Control */
-   DSL_uint16_t Control;
-   /** Subcarrier Group Start Index */
-   DSL_uint16_t StartIndex;
-   /** Subcarrier Group End Index */
-   DSL_uint16_t EndIndex;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This is the acknowledgement for CMD_TestParamsFE_Request.
-*/
-struct ACK_TestParamsFE_Request
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This message polls the status of the far end parameter retrieval process.
-*/
-struct CMD_TestParamsFE_Poll
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This is the acknowledgement for CMD_TestParamsFE_Poll.
-*/
-struct ACK_TestParamsFE_Poll
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Far-end retrieval status */
-   DSL_uint16_t Status;
-   /** Reserved1 */
-   DSL_uint16_t Res1;
-   /** Reserved2 */
-   DSL_uint16_t Res2;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Far-end retrieval status */
-   DSL_uint16_t Status;
-   /** Reserved1 */
-   DSL_uint16_t Res1;
-   /** Reserved2 */
-   DSL_uint16_t Res2;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This event message provides the far-end data after the far end data retrieval
-   process. This message is a result of the CMD_TestParamsFE_Request message.
-*/
-struct EVT_PMD_TestParamsGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved1 */
-   DSL_uint16_t Res1;
-   /** Subcarrier Group Start Index */
-   DSL_uint16_t StartIndex;
-   /** Subcarrier Group End Index */
-   DSL_uint16_t EndIndex;
-   /** HLOG Measurement Time HLOGMT */
-   DSL_uint16_t hlogTime;
-   /** SNR Measurement Time SNRMT */
-   DSL_uint16_t snrTime;
-   /** QLN Measurment Time QLNMT */
-   DSL_uint16_t qlnTime;
-   /** Testparameter Result */
-   VRX_TestParam_t TestPar[60];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved1 */
-   DSL_uint16_t Res1;
-   /** Subcarrier Group Start Index */
-   DSL_uint16_t StartIndex;
-   /** Subcarrier Group End Index */
-   DSL_uint16_t EndIndex;
-   /** HLOG Measurement Time HLOGMT */
-   DSL_uint16_t hlogTime;
-   /** SNR Measurement Time SNRMT */
-   DSL_uint16_t snrTime;
-   /** QLN Measurment Time QLNMT */
-   DSL_uint16_t qlnTime;
-   /** Testparameter Result */
-   VRX_TestParam_t TestPar[60];
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message is used to configure the autonomous messaging related to Clear
-   EOC transmission.
-*/
-struct CMD_ClearEOC_Configure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-   /** RX Autonomous Clear EOC Data Message Control */
-   DSL_uint16_t RxEVTdata : 1;
-   /** RX Autonomous Status Message Control */
-   DSL_uint16_t RxEVTstatus : 1;
-   /** TX Autonomous Status Message Control */
-   DSL_uint16_t TxEVTstatus : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TX Autonomous Status Message Control */
-   DSL_uint16_t TxEVTstatus : 1;
-   /** RX Autonomous Status Message Control */
-   DSL_uint16_t RxEVTstatus : 1;
-   /** RX Autonomous Clear EOC Data Message Control */
-   DSL_uint16_t RxEVTdata : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This is the acknowledgement for CMD_ClearEOC_Configure.
-*/
-struct ACK_ClearEOC_Configure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message is used to trigger the transmission of  Clear EOC messages that
-   were placed into the Clear EOC transmit buffer before with
-   CMD_ClearEOC_Write.
-*/
-struct CMD_ClearEOC_TxTrigger
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 15;
-   /** Transmit Control Trigger */
-   DSL_uint16_t txTrigger : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Transmit Control Trigger */
-   DSL_uint16_t txTrigger : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 15;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This is the acknowledgement for CMD_ClearEOC_TxTrigger.
-*/
-struct ACK_ClearEOC_TxTrigger
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This message is used to write data to the ClearEOC write buffer of type
-   VRX_ClearEOC_t. When the buffer is filled, the transmission is started
-   applying CMD_ClearEOC_TxTrigger. If the message to transmit is longer than
-   the mailbox size, a sequence of writes to the ClearEOC buffer has to be done
-   before the transmission is started with CMD_ClearEOC_TxTrigger. When
-   autonomous TX status messaging is activated via CMD_ClearEOC_Configure, then
-   the finished transmission is indicated by EVT_ClearEOCStatusGet.
-*/
-struct CMD_ClearEOC_Write
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Data */
-   DSL_uint16_t Data[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Data */
-   DSL_uint16_t Data[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   This message is the acknowledgement for CMD_ClearEOC_Write.
-*/
-struct ACK_ClearEOC_Write
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This message is used to read data from the ClearEOC buffer of type
-   VRX_ClearEOC_t. The length of the actual Clear EOC message can be found in
-   the buffer. Please refer to VRX_ClearEOC_t. The availability of data can
-   either be checked via CMD_ClearEOCStatusGet in polling mode or it can be
-   reported by an autonomous EVT_ClearEOCStatusGet message when data is received
-   (to be enabled using CMD_ClearEOC_Configure).
-*/
-struct CMD_ClearEOC_Read
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This message is the acknowledgement to CMD_ClearEOC_Read.
-*/
-struct ACK_ClearEOC_Read
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Data */
-   DSL_uint16_t Data[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Data */
-   DSL_uint16_t Data[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   This message is an autonomous message that is generated when ClearEOC data
-   was received and autonomous Clear EOC data messaging has been activated via
-   CMD_ClearEOC_Configure. If the ClearEOC data does not fit in one message,
-   then a sequence of messages is generated. The ClearEOC buffer is of type
-   VRX_ClearEOC_t.
-*/
-struct EVT_ClearEOC_Read
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Data */
-   DSL_uint16_t Data[128];
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Data */
-   DSL_uint16_t Data[128];
-#endif
-} __PACKED__ ;
-
-
-/**
-   This message is used to retrieve the status of the clear eoc data
-   transmission.
-*/
-struct CMD_ClearEOCStatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This is the acknowledgement for CMD_ClearEOCStatusGet.
-*/
-struct ACK_ClearEOCStatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** Transmit Status */
-   DSL_uint16_t txstat : 2;
-   /** Reserved */
-   DSL_uint16_t Res1 : 14;
-   /** Receive Status */
-   DSL_uint16_t rxstat : 2;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Transmit Status */
-   DSL_uint16_t txstat : 2;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** Receive Status */
-   DSL_uint16_t rxstat : 2;
-   /** Reserved */
-   DSL_uint16_t Res1 : 14;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This autonomous message reports the Clear EOC status. It is sent only if the
-   "Autonomous Status Message Control" was enabled for TX and/or RX direction
-   with CMD_ClearEOC_Configure. If TX direction is enabled, the message is
-   generated when a TX transmission is finished or failed. If RX direction is
-   enabled, the message is generated when the RX status transitions from "Idle"
-   to "Data Available" for retrieval by the host.
-*/
-struct EVT_ClearEOCStatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** Transmit Status */
-   DSL_uint16_t txstat : 2;
-   /** Reserved */
-   DSL_uint16_t Res1 : 14;
-   /** Receive Status */
-   DSL_uint16_t rxstat : 2;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Transmit Status */
-   DSL_uint16_t txstat : 2;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** Receive Status */
-   DSL_uint16_t rxstat : 2;
-   /** Reserved */
-   DSL_uint16_t Res1 : 14;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message is used to reset the transmit or receive status of the clear eoc
-   data transmission to IDLE (for defined states see also
-   CMD_ClearEOCStatusGet). See the description on the Clear EOC handling on Page
-   540 for when it has to be applied. Transmit and receive status are
-   distinguished by the Index parameter.
-*/
-struct CMD_ClearEOCStatusSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** Status */
-   DSL_uint16_t stat : 2;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Status */
-   DSL_uint16_t stat : 2;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This is the acknowledgement for CMD_ClearEOCStatusSet.
-*/
-struct ACK_ClearEOCStatusSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Configuration of options for the overhead handling.
-*/
-struct CMD_OH_OptionsSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** EOC Polling Period Scaling Factor, Bits 15 to 8 */
-   DSL_uint8_t eocPollFactor;
-   /** Reserved */
-   DSL_uint16_t Res0 : 3;
-   /** EOC Polling Control Prio 2: PMD Test Parameters, Bit 4 */
-   DSL_uint16_t eocPoll2 : 1;
-   /** EOC Polling Control Prio 1: Inventory, Counters, Bit 3 */
-   DSL_uint16_t eocPoll1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 3;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res1 : 3;
-   /** EOC Polling Control Prio 1: Inventory, Counters, Bit 3 */
-   DSL_uint16_t eocPoll1 : 1;
-   /** EOC Polling Control Prio 2: PMD Test Parameters, Bit 4 */
-   DSL_uint16_t eocPoll2 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 3;
-   /** EOC Polling Period Scaling Factor, Bits 15 to 8 */
-   DSL_uint8_t eocPollFactor;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for CMD_OH_OptionsSet.
-*/
-struct ACK_OH_OptionsSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests OH polling statistic information.
-*/
-struct CMD_OH_StatsGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reports the OH polling statistics as requested by CMD_OH_StatsGet.
-*/
-struct ACK_OH_StatsGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** EOC CMD TX PRIO1 Sent */
-   DSL_uint16_t eocCMD1;
-   /** EOC ACK RX PRIO1 Count */
-   DSL_uint16_t eocRSP1;
-   /** EOC CMD TX PRIO2 Sent */
-   DSL_uint16_t eocCMD2;
-   /** EOC ACK RX PRIO2 Count */
-   DSL_uint16_t eocRSP2;
-   /** EOC NACK RX PRIO1 Count  */
-   DSL_uint16_t eocNACK1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** EOC CMD TX PRIO1 Sent */
-   DSL_uint16_t eocCMD1;
-   /** EOC ACK RX PRIO1 Count */
-   DSL_uint16_t eocRSP1;
-   /** EOC CMD TX PRIO2 Sent */
-   DSL_uint16_t eocCMD2;
-   /** EOC ACK RX PRIO2 Count */
-   DSL_uint16_t eocRSP2;
-   /** EOC NACK RX PRIO1 Count  */
-   DSL_uint16_t eocNACK1;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Enables/Disables support for OLR events (Bitswaps, SRA, SOS, ROC).An OLR
-   transition is always initiated by the receiving PMD, so the CPE requests the
-   OLR event for downstream direction.
-*/
-struct CMD_OLR_Control
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 4;
-   /** ROC DS */
-   DSL_uint16_t ROC_DS : 1;
-   /** ROC US */
-   DSL_uint16_t ROC_US : 1;
-   /** SOS DS */
-   DSL_uint16_t SOS_DS : 1;
-   /** SOS US */
-   DSL_uint16_t SOS_US : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 1;
-   /** SRA Strict Rate Check */
-   DSL_uint16_t SRA_StrictCheck : 1;
-   /** RX Bitswap */
-   DSL_uint16_t RxBitswap : 1;
-   /** TX Bitswap */
-   DSL_uint16_t TxBitswap : 1;
-   /** SRA Rate Check */
-   DSL_uint16_t SRA_RateCheck : 1;
-   /** Auto-SRA DS */
-   DSL_uint16_t autoSRA_DS : 1;
-   /** Auto-SRA US */
-   DSL_uint16_t autoSRA_US : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res2 : 1;
-   /** Auto-SRA US */
-   DSL_uint16_t autoSRA_US : 1;
-   /** Auto-SRA DS */
-   DSL_uint16_t autoSRA_DS : 1;
-   /** SRA Rate Check */
-   DSL_uint16_t SRA_RateCheck : 1;
-   /** TX Bitswap */
-   DSL_uint16_t TxBitswap : 1;
-   /** RX Bitswap */
-   DSL_uint16_t RxBitswap : 1;
-   /** SRA Strict Rate Check */
-   DSL_uint16_t SRA_StrictCheck : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 1;
-   /** SOS US */
-   DSL_uint16_t SOS_US : 1;
-   /** SOS DS */
-   DSL_uint16_t SOS_DS : 1;
-   /** ROC US */
-   DSL_uint16_t ROC_US : 1;
-   /** ROC DS */
-   DSL_uint16_t ROC_DS : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 4;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for CMD_OLR_Control.
-*/
-struct ACK_OLR_Control
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the OLR status information on bit swaps, DRR, SRA and SOS events for
-   the upstream direction.
-*/
-struct CMD_OLR_US_StatsGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reports the OLR status information for the upstream direction as requested by
-   CMD_OLR_US_StatsGet.
-*/
-struct ACK_OLR_US_StatsGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** US Bit Swap Requests */
-   DSL_uint16_t BitswapReqs;
-   /** US Extended Bit Swap Requests */
-   DSL_uint16_t ExtBitswapReqs;
-   /** US Bit Swap UTC Responses */
-   DSL_uint16_t BitswapUTCs;
-   /** US "Bit Swaps Performed" Count */
-   DSL_uint16_t BitswapsDone;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** Reserved for DRR */
-   DSL_uint16_t Res1[5];
-   /** US SRA Requests */
-   DSL_uint16_t SRA_Reqs;
-   /** Reserved */
-   DSL_uint16_t Res2;
-   /** US SRA UTC Responses */
-   DSL_uint16_t SRA_UTCs;
-   /** US "SRA Performed" Count */
-   DSL_uint16_t SRAsDone;
-   /** Reserved */
-   DSL_uint16_t Res3;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** US Bit Swap Requests */
-   DSL_uint16_t BitswapReqs;
-   /** US Extended Bit Swap Requests */
-   DSL_uint16_t ExtBitswapReqs;
-   /** US Bit Swap UTC Responses */
-   DSL_uint16_t BitswapUTCs;
-   /** US "Bit Swaps Performed" Count */
-   DSL_uint16_t BitswapsDone;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** Reserved for DRR */
-   DSL_uint16_t Res1[5];
-   /** US SRA Requests */
-   DSL_uint16_t SRA_Reqs;
-   /** Reserved */
-   DSL_uint16_t Res2;
-   /** US SRA UTC Responses */
-   DSL_uint16_t SRA_UTCs;
-   /** US "SRA Performed" Count */
-   DSL_uint16_t SRAsDone;
-   /** Reserved */
-   DSL_uint16_t Res3;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the OLR status information on bit swaps, DRR, SRA and SOS events for
-   the downstream direction.
-*/
-struct CMD_OLR_DS_StatsGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reports the OLR status information for the downstream direction as requested
-   by CMD_OLR_DS_StatsGet.
-*/
-struct ACK_OLR_DS_StatsGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** DS Bit Swap Requests */
-   DSL_uint16_t BitswapReqs;
-   /** DS Extended Bit Swap Requests */
-   DSL_uint16_t ExtBitswapReqs;
-   /** DS Bit Swap UTC Responses */
-   DSL_uint16_t BitswapUTCs;
-   /** DS "Bit Swaps Performed" Count */
-   DSL_uint16_t BitswapsDone;
-   /** DS Bitswap Timeouts */
-   DSL_uint16_t BitswapTimeOuts;
-   /** Reserved for DRR */
-   DSL_uint16_t Res0[5];
-   /** DS SRA Requests */
-   DSL_uint16_t SRA_Reqs;
-   /** Reserved */
-   DSL_uint16_t Res1;
-   /** DS SRA UTC Responses */
-   DSL_uint16_t SRA_UTCs;
-   /** DS "SRA Performed" Count */
-   DSL_uint16_t SRAsDone;
-   /** DS SRA Timeouts */
-   DSL_uint16_t SRA_TimeOuts;
-   /** DS SOS Requests */
-   DSL_uint16_t SOS_Reqs;
-   /** Reserved */
-   DSL_uint16_t Res2;
-   /** DS SOS UTC Responses */
-   DSL_uint16_t SOS_UTCs;
-   /** DS "SOS Performed" Count */
-   DSL_uint16_t SOS_Done;
-   /** DS SOS Timeouts */
-   DSL_uint16_t SOS_TimeOuts;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** DS Bit Swap Requests */
-   DSL_uint16_t BitswapReqs;
-   /** DS Extended Bit Swap Requests */
-   DSL_uint16_t ExtBitswapReqs;
-   /** DS Bit Swap UTC Responses */
-   DSL_uint16_t BitswapUTCs;
-   /** DS "Bit Swaps Performed" Count */
-   DSL_uint16_t BitswapsDone;
-   /** DS Bitswap Timeouts */
-   DSL_uint16_t BitswapTimeOuts;
-   /** Reserved for DRR */
-   DSL_uint16_t Res0[5];
-   /** DS SRA Requests */
-   DSL_uint16_t SRA_Reqs;
-   /** Reserved */
-   DSL_uint16_t Res1;
-   /** DS SRA UTC Responses */
-   DSL_uint16_t SRA_UTCs;
-   /** DS "SRA Performed" Count */
-   DSL_uint16_t SRAsDone;
-   /** DS SRA Timeouts */
-   DSL_uint16_t SRA_TimeOuts;
-   /** DS SOS Requests */
-   DSL_uint16_t SOS_Reqs;
-   /** Reserved */
-   DSL_uint16_t Res2;
-   /** DS SOS UTC Responses */
-   DSL_uint16_t SOS_UTCs;
-   /** DS "SOS Performed" Count */
-   DSL_uint16_t SOS_Done;
-   /** DS SOS Timeouts */
-   DSL_uint16_t SOS_TimeOuts;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the actual active downstream RA mode (ACT-RA-MODEds, Section
-   7.5.1.33.1 of G.997.1).
-*/
-struct CMD_RA_ModeDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reports the actual active downstream RA mode (ACT-RA-MODEds) as requested by
-   CMD_RA_ModeDS_Get.
-*/
-struct ACK_RA_ModeDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** RA Mode DS */
-   DSL_uint16_t actRA_mode;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** RA Mode DS */
-   DSL_uint16_t actRA_mode;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the actual active upstream RA mode (ACT-RA-MODEus, Section
-   7.5.1.33.2 of G.997.1).
-*/
-struct CMD_RA_ModeUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reports the actual active upstream RA mode (ACT-RA-MODEus) as requested by
-   CMD_RA_ModeUS_Get.
-*/
-struct ACK_RA_ModeUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** RA Mode US */
-   DSL_uint16_t actRA_mode;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** RA Mode US */
-   DSL_uint16_t actRA_mode;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Autonomous message indicating a successful upstream OLR event (SRA or SOS).
-*/
-struct EVT_OLR_US_EventGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** SRA Event */
-   DSL_uint16_t SRA_OK : 1;
-   /** SOS Event (VDSL only) */
-   DSL_uint16_t SOS_OK : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** SOS Event (VDSL only) */
-   DSL_uint16_t SOS_OK : 1;
-   /** SRA Event */
-   DSL_uint16_t SRA_OK : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Autonomous message indicating a successful downstream OLR event (SRA or SOS).
-*/
-struct EVT_OLR_DS_EventGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** SRA Event */
-   DSL_uint16_t SRA_OK : 1;
-   /** SOS Event (VDSL only) */
-   DSL_uint16_t SOS_OK : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** SOS Event (VDSL only) */
-   DSL_uint16_t SOS_OK : 1;
-   /** SRA Event */
-   DSL_uint16_t SRA_OK : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Enables/Disables the generation of EVENT messages (EVT) for specific upstream
-   OLR events. If the corresponding Enable bit for an OLR event is set, then the
-   modem firmware will send an autonomous message EVT_OLR_US_EventGet if the OLR
-   event happened in the last 1-second interval.
-*/
-struct CMD_OLR_US_EventConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** SRA Event US, Bit 1 */
-   DSL_uint16_t SRA_OK : 1;
-   /** SOS Event US , Bit 0 (VDSL only) */
-   DSL_uint16_t SOS_OK : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** SOS Event US , Bit 0 (VDSL only) */
-   DSL_uint16_t SOS_OK : 1;
-   /** SRA Event US, Bit 1 */
-   DSL_uint16_t SRA_OK : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknoledgement for CMD_OLR_US_EventConfigure.
-*/
-struct ACK_OLR_US_EventConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Enables/Disables the generation of EVENT messages (EVT) for specific
-   downstream OLR events. If the corresponding Enable bit for an OLR event is
-   set, then the modem firmware will send an autonomous message
-   EVT_OLR_DS_EventGet if the OLR event happened in the last 1-second interval.
-*/
-struct CMD_OLR_DS_EventConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** SRA Event DS, Bit 1 */
-   DSL_uint16_t SRA_OK : 1;
-   /** SOS Event DS , Bit 0 (VDSL only) */
-   DSL_uint16_t SOS_OK : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** SOS Event DS , Bit 0 (VDSL only) */
-   DSL_uint16_t SOS_OK : 1;
-   /** SRA Event DS, Bit 1 */
-   DSL_uint16_t SRA_OK : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknoledgement for CMD_OLR_DS_EventConfigure.
-*/
-struct ACK_OLR_DS_EventConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Configures a link for retransmission of downstream data. For using the RTX
-   function, this message has to be sent.
-*/
-struct CMD_RTX_Control
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 6;
-   /** Extended Memory for Enhanced Bit Rates (Anx D support, VDSL only) */
-   DSL_uint16_t ExtMem : 1;
-   /** Force Extended Memory for Enhanced Bit Rates (VDSL only) */
-   DSL_uint16_t ExtMemForced : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 3;
-   /** Intra DTU Interleaving US (VDSL only) */
-   DSL_uint16_t DtuInterleavingUs : 1;
-   /** Intra DTU Interleaving DS (VDSL only) */
-   DSL_uint16_t DtuInterleavingDs : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 1;
-   /** Retransmission Control */
-   DSL_uint16_t RtxMode : 2;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Retransmission Control */
-   DSL_uint16_t RtxMode : 2;
-   /** Reserved */
-   DSL_uint16_t Res2 : 1;
-   /** Intra DTU Interleaving DS (VDSL only) */
-   DSL_uint16_t DtuInterleavingDs : 1;
-   /** Intra DTU Interleaving US (VDSL only) */
-   DSL_uint16_t DtuInterleavingUs : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 3;
-   /** Force Extended Memory for Enhanced Bit Rates (VDSL only) */
-   DSL_uint16_t ExtMemForced : 1;
-   /** Extended Memory for Enhanced Bit Rates (Anx D support, VDSL only) */
-   DSL_uint16_t ExtMem : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 6;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for CMD_RTX_Control.
-*/
-struct ACK_RTX_Control
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests RTX specific status information for the downstream bearer channels
-   if G.INP retransmission is used.
-*/
-struct CMD_RTX_BearerChsDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers status information for the downstream bearer channels when G.INP
-   retransmission is actually used.
-*/
-struct ACK_RTX_BearerChsDS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Expected Throughput ETR of RTX Function, LSW */
-   DSL_uint16_t ETR_LSW;
-   /** Expected Throughput ETR of RTX Function, MSW */
-   DSL_uint16_t ETR_MSW;
-   /** Actual Delay of RTX Function */
-   DSL_uint16_t ActDelay;
-   /** Actual INP SHINE of RTX Function */
-   DSL_uint16_t ActInpSHINE;
-   /** Actual INP REIN of RTX Function */
-   DSL_uint16_t ActInpREIN;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Expected Throughput ETR of RTX Function, LSW */
-   DSL_uint16_t ETR_LSW;
-   /** Expected Throughput ETR of RTX Function, MSW */
-   DSL_uint16_t ETR_MSW;
-   /** Actual Delay of RTX Function */
-   DSL_uint16_t ActDelay;
-   /** Actual INP SHINE of RTX Function */
-   DSL_uint16_t ActInpSHINE;
-   /** Actual INP REIN of RTX Function */
-   DSL_uint16_t ActInpREIN;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests RTX specific status information for the upstream bearer channels if
-   upstream G.INP retransmission is used.
-*/
-struct CMD_RTX_BearerChsUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers status information for the upstream bearer channels when upstream
-   G.INP retransmission is used.
-*/
-struct ACK_RTX_BearerChsUS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Expected Throughput ETR of RTX_us Function, LSW */
-   DSL_uint16_t ETR_LSW;
-   /** Expected Throughput ETR of RTX_us Function, MSW */
-   DSL_uint16_t ETR_MSW;
-   /** Actual Delay of RTX_us Function */
-   DSL_uint16_t ActDelay;
-   /** Actual INP SHINE of RTX_us Function */
-   DSL_uint16_t ActInpSHINE;
-   /** Actual INP REIN of RTX_us Function */
-   DSL_uint16_t ActInpREIN;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Expected Throughput ETR of RTX_us Function, LSW */
-   DSL_uint16_t ETR_LSW;
-   /** Expected Throughput ETR of RTX_us Function, MSW */
-   DSL_uint16_t ETR_MSW;
-   /** Actual Delay of RTX_us Function */
-   DSL_uint16_t ActDelay;
-   /** Actual INP SHINE of RTX_us Function */
-   DSL_uint16_t ActInpSHINE;
-   /** Actual INP REIN of RTX_us Function */
-   DSL_uint16_t ActInpREIN;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests performance monitoring counters for downstream G.INP retransmission.
-*/
-struct CMD_RTX_PM_DS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers performance monitoring counters for downstream G.INP retransmission.
-*/
-struct ACK_RTX_PM_DS_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** ErrorFreeBitsCNT, LSW */
-   DSL_uint16_t ErrorFreeBits_LSW;
-   /** ErrorFreeBitsCNT, MSW */
-   DSL_uint16_t ErrorFreeBits_MSW;
-   /** Reserved */
-   DSL_uint16_t Res0[2];
-   /** EFTR_min reported to CO, LSW */
-   DSL_uint16_t EFTR_min_LSW;
-   /** EFTR_min reported to CO, MSW */
-   DSL_uint16_t EFTR_min_MSW;
-   /** Reserved */
-   DSL_uint16_t Res1[2];
-   /** "leftr" Count, LSW */
-   DSL_uint16_t leftr_LSW;
-   /** "leftr" Count, MSW */
-   DSL_uint16_t leftr_MSW;
-   /** EFTR, LSW */
-   DSL_uint16_t EFTR_LSW;
-   /** EFTR, MSW */
-   DSL_uint16_t EFTR_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** ErrorFreeBitsCNT, LSW */
-   DSL_uint16_t ErrorFreeBits_LSW;
-   /** ErrorFreeBitsCNT, MSW */
-   DSL_uint16_t ErrorFreeBits_MSW;
-   /** Reserved */
-   DSL_uint16_t Res0[2];
-   /** EFTR_min reported to CO, LSW */
-   DSL_uint16_t EFTR_min_LSW;
-   /** EFTR_min reported to CO, MSW */
-   DSL_uint16_t EFTR_min_MSW;
-   /** Reserved */
-   DSL_uint16_t Res1[2];
-   /** "leftr" Count, LSW */
-   DSL_uint16_t leftr_LSW;
-   /** "leftr" Count, MSW */
-   DSL_uint16_t leftr_MSW;
-   /** EFTR, LSW */
-   DSL_uint16_t EFTR_LSW;
-   /** EFTR, MSW */
-   DSL_uint16_t EFTR_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests performance monitoring counters for upstream G.INP retransmission.
-*/
-struct CMD_RTX_PM_US_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers performance monitoring counters for upstream G.INP retransmission.
-   They are all far-end parameters received from CO.
-*/
-struct ACK_RTX_PM_US_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** ErrorFreeBitsCNT, LSW */
-   DSL_uint16_t ErrorFreeBits_LSW;
-   /** ErrorFreeBitsCNT, MSW */
-   DSL_uint16_t ErrorFreeBits_MSW;
-   /** EFTR_min, LSW */
-   DSL_uint16_t EFTR_min_LSW;
-   /** EFTR_min, MSW */
-   DSL_uint16_t EFTR_min_MSW;
-   /** "leftr" Count, LSW */
-   DSL_uint16_t leftr_LSW;
-   /** "leftr" Count, MSW */
-   DSL_uint16_t leftr_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** ErrorFreeBitsCNT, LSW */
-   DSL_uint16_t ErrorFreeBits_LSW;
-   /** ErrorFreeBitsCNT, MSW */
-   DSL_uint16_t ErrorFreeBits_MSW;
-   /** EFTR_min, LSW */
-   DSL_uint16_t EFTR_min_LSW;
-   /** EFTR_min, MSW */
-   DSL_uint16_t EFTR_min_MSW;
-   /** "leftr" Count, LSW */
-   DSL_uint16_t leftr_LSW;
-   /** "leftr" Count, MSW */
-   DSL_uint16_t leftr_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests DTU counters for G.INP downstream retransmission.
-*/
-struct CMD_RTX_DS_StatsGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers DTU counters for G.INP downstream retransmission. The counters are
-   Non-TR1 wrap-around counters, which are reset at reboot only.
-*/
-struct ACK_RTX_DS_StatsGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TxDtuRetransmitted Count (rtx-tx), LSW */
-   DSL_uint16_t TxDtuRTX_LSW;
-   /** TxDtuRetransmitted Count (rtx-tx), MSW */
-   DSL_uint16_t TxDtuRTX_MSW;
-   /** RxDtuCorrected Count (rtx-c), LSW */
-   DSL_uint16_t RxDtuCorr_LSW;
-   /** RxDtuCorrected Count (rtx-c), MSW */
-   DSL_uint16_t RxDtuCorr_MSW;
-   /** RxDtuUncorrected Count (rtx-uc), LSW */
-   DSL_uint16_t RxDtuNoCorr_LSW;
-   /** RxDtuUncorrected Count (rtx-uc), MSW */
-   DSL_uint16_t RxDtuNoCorr_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TxDtuRetransmitted Count (rtx-tx), LSW */
-   DSL_uint16_t TxDtuRTX_LSW;
-   /** TxDtuRetransmitted Count (rtx-tx), MSW */
-   DSL_uint16_t TxDtuRTX_MSW;
-   /** RxDtuCorrected Count (rtx-c), LSW */
-   DSL_uint16_t RxDtuCorr_LSW;
-   /** RxDtuCorrected Count (rtx-c), MSW */
-   DSL_uint16_t RxDtuCorr_MSW;
-   /** RxDtuUncorrected Count (rtx-uc), LSW */
-   DSL_uint16_t RxDtuNoCorr_LSW;
-   /** RxDtuUncorrected Count (rtx-uc), MSW */
-   DSL_uint16_t RxDtuNoCorr_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests DTU counters for G.INP upstream retransmission, which is defined for
-   VDSL only.
-*/
-struct CMD_RTX_US_StatsGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers DTU counters for G.INP upstream retransmission. The counters are
-   Non-TR1 wrap-around counters, which are reset at reboot only.
-*/
-struct ACK_RTX_US_StatsGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TxDtuRetransmitted Count (rtx-tx), LSW */
-   DSL_uint16_t TxDtuRTX_LSW;
-   /** TxDtuRetransmitted Count (rtx-tx), MSW */
-   DSL_uint16_t TxDtuRTX_MSW;
-   /** RxDtuCorrected Count (rtx-c), LSW */
-   DSL_uint16_t RxDtuCorr_LSW;
-   /** RxDtuCorrected Count rtx-c), MSW */
-   DSL_uint16_t RxDtuCorr_MSW;
-   /** RxDtuUncorrected Count (rtx-uc), LSW */
-   DSL_uint16_t RxDtuNoCorr_LSW;
-   /** RxDtuUncorrected Count (rtx-uc), MSW */
-   DSL_uint16_t RxDtuNoCorr_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TxDtuRetransmitted Count (rtx-tx), LSW */
-   DSL_uint16_t TxDtuRTX_LSW;
-   /** TxDtuRetransmitted Count (rtx-tx), MSW */
-   DSL_uint16_t TxDtuRTX_MSW;
-   /** RxDtuCorrected Count (rtx-c), LSW */
-   DSL_uint16_t RxDtuCorr_LSW;
-   /** RxDtuCorrected Count rtx-c), MSW */
-   DSL_uint16_t RxDtuCorr_MSW;
-   /** RxDtuUncorrected Count (rtx-uc), LSW */
-   DSL_uint16_t RxDtuNoCorr_LSW;
-   /** RxDtuUncorrected Count (rtx-uc), MSW */
-   DSL_uint16_t RxDtuNoCorr_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the actually used G.INP retransmission status.
-*/
-struct CMD_RTX_StatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the actually used G.INP retransmission status.
-*/
-struct ACK_RTX_StatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 7;
-   /** RTX US disabled against Intel(c) VDSL Chipset  due to wrong Config.  */
-   DSL_uint16_t RtxUsOffCfgErr : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 3;
-   /** Intra DTU Interleaving US (VDSL only) */
-   DSL_uint16_t DtuInterleavingUs : 1;
-   /** Intra DTU Interleaving DS (VDSL only) */
-   DSL_uint16_t DtuInterleavingDs : 1;
-   /** Extended Memory */
-   DSL_uint16_t ExtMem : 1;
-   /** Retransmission US Used ("RTX_USED_us", VDSL only) */
-   DSL_uint16_t RtxUsedUs : 1;
-   /** Retransmission DS Used ("RTX_USED_ds") */
-   DSL_uint16_t RtxUsedDs : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Retransmission DS Used ("RTX_USED_ds") */
-   DSL_uint16_t RtxUsedDs : 1;
-   /** Retransmission US Used ("RTX_USED_us", VDSL only) */
-   DSL_uint16_t RtxUsedUs : 1;
-   /** Extended Memory */
-   DSL_uint16_t ExtMem : 1;
-   /** Intra DTU Interleaving DS (VDSL only) */
-   DSL_uint16_t DtuInterleavingDs : 1;
-   /** Intra DTU Interleaving US (VDSL only) */
-   DSL_uint16_t DtuInterleavingUs : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 3;
-   /** RTX US disabled against Intel(c) VDSL Chipset  due to wrong Config.  */
-   DSL_uint16_t RtxUsOffCfgErr : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 7;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests upstream G.INP retransmission specific framing parameters and other
-   status parameters. They are always associated with bearer channel 0.
-*/
-struct CMD_RTX_US_FrameDataGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers upstream retransmission specific framing parameters and other status
-   parameters, as requested by CMD_RTX_US_FrameDataGet. They are always
-   associated with bearer channel 0.In addition, the usual framing parameters
-   are to be retrieved with CMD_FrameDataExt2US_Get.
-*/
-struct ACK_RTX_US_FrameDataGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Framing Type of LP1 RTX_us Framing */
-   DSL_uint16_t FT;
-   /** FEC Codewords per DTU of LP1 RTX_us Framing */
-   DSL_uint16_t Q;
-   /** Padding Bytes per DTU of LP1 RTX_usFraming */
-   DSL_uint16_t V;
-   /** RTX Queue Length in DTUs of RTX_us Function */
-   DSL_uint16_t Qtx;
-   /** Look-Back Value for RRC Codeword Evaluation of RTX_us Function */
-   DSL_uint16_t lb;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Framing Type of LP1 RTX_us Framing */
-   DSL_uint16_t FT;
-   /** FEC Codewords per DTU of LP1 RTX_us Framing */
-   DSL_uint16_t Q;
-   /** Padding Bytes per DTU of LP1 RTX_usFraming */
-   DSL_uint16_t V;
-   /** RTX Queue Length in DTUs of RTX_us Function */
-   DSL_uint16_t Qtx;
-   /** Look-Back Value for RRC Codeword Evaluation of RTX_us Function */
-   DSL_uint16_t lb;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the G.INP upstream retransmission measured roundtrip.
-*/
-struct CMD_RTX_US_Roundtrip_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the G.INP upstream retransmission measured roundtrip delay. For
-   measuring the roundtrip, following difference is built when a correct RRC
-   codeword has been received: AbsoluteDTUCount of transmitter for next possible
-   DTU transmission minus AbsoluteDTUCount as received in RRC codeword.
-*/
-struct ACK_RTX_US_Roundtrip_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Minimum Measured Roundtrip in DTUs */
-   DSL_uint16_t MinRt;
-   /** Maximum Measured Roundtrip in DTUs */
-   DSL_uint16_t MaxRt;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Minimum Measured Roundtrip in DTUs */
-   DSL_uint16_t MinRt;
-   /** Maximum Measured Roundtrip in DTUs */
-   DSL_uint16_t MaxRt;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Enables/Disables support for full vectoring (G.993.5) and full vector-
-   friendly operation (G.993.2 Annex Y). In case of ADSL, this only means the
-   indication of the (VDSL) vectoring capabilities during G.Handshake.
-*/
-struct CMD_DSM_Control
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-   /** Supported Vectoring Mode */
-   DSL_uint16_t VectoringMode : 2;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Supported Vectoring Mode */
-   DSL_uint16_t VectoringMode : 2;
-   /** Reserved */
-   DSL_uint16_t Res0 : 14;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_DSM_Control.
-*/
-struct ACK_DSM_Control
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This autononmous message indicates that new downstream DSM error vector data
-   were written by the DSL FW into the SDRAM. Generation of this EVT message is
-   enabled/disabled together with the G.993.5 vectoring functionality itself, by
-   means of CMD_DSM_Control, parameter "Vector".
-*/
-struct EVT_DSM_ErrorVectorReady
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** ERB Event Result Code */
-   DSL_uint16_t ErrVecProcResult;
-   /** L2 Backchannel Error Vector Date Size */
-   DSL_uint16_t ErrVecSize;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** ERB Event Result Code */
-   DSL_uint16_t ErrVecProcResult;
-   /** L2 Backchannel Error Vector Date Size */
-   DSL_uint16_t ErrVecSize;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests vectoring debug counter values.
-*/
-struct CMD_DSM_StatsGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers vectoring debug counters.
-*/
-struct ACK_DSM_StatsGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Discarded Error Vectors, LSW */
-   DSL_uint16_t ErrVecDiscard_LSW;
-   /** Discarded Error Vectors, MSW */
-   DSL_uint16_t ErrVecDiscard_MSW;
-   /** Transmitted Error Vectors, LSW */
-   DSL_uint16_t ErrVecTransmitted_LSW;
-   /** Transmitted Error Vectors, MSW */
-   DSL_uint16_t ErrVecTransmitted_MSW;
-   /** Total Error Vectors Requested, LSW */
-   DSL_uint16_t ErrVecTotalReq_LSW;
-   /** Total Error Vectors Requested, MSW */
-   DSL_uint16_t ErrVecTotalReq_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Discarded Error Vectors, LSW */
-   DSL_uint16_t ErrVecDiscard_LSW;
-   /** Discarded Error Vectors, MSW */
-   DSL_uint16_t ErrVecDiscard_MSW;
-   /** Transmitted Error Vectors, LSW */
-   DSL_uint16_t ErrVecTransmitted_LSW;
-   /** Transmitted Error Vectors, MSW */
-   DSL_uint16_t ErrVecTransmitted_MSW;
-   /** Total Error Vectors Requested, LSW */
-   DSL_uint16_t ErrVecTotalReq_LSW;
-   /** Total Error Vectors Requested, MSW */
-   DSL_uint16_t ErrVecTotalReq_MSW;
-#endif
-} __PACKED__ ;
-
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#ifdef __PACKED_DEFINED__
-   #if !(defined (__GNUC__) || defined (__GNUG__))
-      #pragma pack()
-   #endif
-   #undef __PACKED_DEFINED__
-#endif /* __PACKED_DEFINED__ */
-
-/** @} */
-
-#endif /** _DRV_DSL_CPE_VRX_MSG_OLR_H_*/
--- a/src/include/mcat3.1/drv_dsl_cpe_vrx_msg_perf_pmd.h
+++ /dev/null
@@ -1,1674 +0,0 @@
-/******************************************************************************
-
-                            Copyright (c) 2007-2017
-                       Lantiq Beteiligungs-GmbH & Co. KG
-
-  For licensing information, see the file 'LICENSE' in the root folder of
-  this software module.
-
-******************************************************************************/
-
-
-#ifndef _DRV_DSL_CPE_VRX_MSG_PERF_PMD_H_
-#define _DRV_DSL_CPE_VRX_MSG_PERF_PMD_H_
-
-/** \file
-
-*/
-
-#ifndef __PACKED__
-   #if defined (__GNUC__) || defined (__GNUG__)
-      /* GNU C or C++ compiler */
-      #define __PACKED__ __attribute__ ((packed))
-   #else
-      /* Byte alignment adjustment */
-      #pragma pack(1)
-      #define __PACKED__      /* nothing */
-   #endif
-   #define __PACKED_DEFINED__ 1
-#endif
-
-
-/** @defgroup _PERF_PMD_
- *  @{
- */
-
-#ifdef __cplusplus
-   extern "C" {
-#endif
-
-/* ----- Message Specific Constants Definition section ----- */
-/* ----- Message Specific Constants Definition section (End) ----- */
-
-/** Message ID for CMD_CounterControlSet */
-#define CMD_COUNTERCONTROLSET 0x004A
-
-/**
-   Controls the behaviour of the performance counters.
-*/
-typedef struct CMD_CounterControlSet CMD_CounterControlSet_t;
-
-/** Message ID for ACK_CounterControlSet */
-#define ACK_COUNTERCONTROLSET 0x004A
-
-/**
-   Acknowledgement for message CMD_CounterControlSet.
-*/
-typedef struct ACK_CounterControlSet ACK_CounterControlSet_t;
-
-/** Message ID for CMD_PM_OptionsSet */
-#define CMD_PM_OPTIONSSET 0x1662
-
-/**
-   Configures options for performance monitoring functions.
-*/
-typedef struct CMD_PM_OptionsSet CMD_PM_OptionsSet_t;
-
-/** Message ID for ACK_PM_OptionsSet */
-#define ACK_PM_OPTIONSSET 0x1662
-
-/**
-   Acknowledgement for message ACK_PM_OptionsSet.
-*/
-typedef struct ACK_PM_OptionsSet ACK_PM_OptionsSet_t;
-
-/** Message ID for ALM_LineFailureNE_Get */
-#define ALM_LINEFAILURENE_GET 0x0007
-
-/**
-   This autonomous message indicates near-end line failures.
-*/
-typedef struct ALM_LineFailureNE_Get ALM_LineFailureNE_Get_t;
-
-/** Message ID for CMD_LineFailureNE_Get */
-#define CMD_LINEFAILURENE_GET 0x0007
-
-/**
-   Requests the near-end line failure status.
-*/
-typedef struct CMD_LineFailureNE_Get CMD_LineFailureNE_Get_t;
-
-/** Message ID for ACK_LineFailureNE_Get */
-#define ACK_LINEFAILURENE_GET 0x0007
-
-/**
-   Provides the near-end line failure status requested by the command
-   CMD_LineFailureNE_Get.
-*/
-typedef struct ACK_LineFailureNE_Get ACK_LineFailureNE_Get_t;
-
-/** Message ID for ALM_LineFailureFE_Get */
-#define ALM_LINEFAILUREFE_GET 0x0107
-
-/**
-   This autonomous message indicates far-end line failures.
-*/
-typedef struct ALM_LineFailureFE_Get ALM_LineFailureFE_Get_t;
-
-/** Message ID for CMD_LineFailureFE_Get */
-#define CMD_LINEFAILUREFE_GET 0x0107
-
-/**
-   Requests the far-end line failure status.
-*/
-typedef struct CMD_LineFailureFE_Get CMD_LineFailureFE_Get_t;
-
-/** Message ID for ACK_LineFailureFE_Get */
-#define ACK_LINEFAILUREFE_GET 0x0107
-
-/**
-   Provides the far-end line failure status requested by the command
-   CMD_LineFailureFE_Get.
-*/
-typedef struct ACK_LineFailureFE_Get ACK_LineFailureFE_Get_t;
-
-/** Message ID for CMD_Failure_Trigger */
-#define CMD_FAILURE_TRIGGER 0x0562
-
-/**
-   Host initiated "loss of power". Triggers indicating an lpr primitive to the
-   remote side via the indicator bits ("IB bits").The host writes the message to
-   the FW e.g. after detecting LPR by an alternative detection scheme.
-*/
-typedef struct CMD_Failure_Trigger CMD_Failure_Trigger_t;
-
-/** Message ID for ACK_Failure_Trigger */
-#define ACK_FAILURE_TRIGGER 0x0562
-
-/**
-   Acknowledgement for CMD_Failure_Trigger.
-*/
-typedef struct ACK_Failure_Trigger ACK_Failure_Trigger_t;
-
-/** Message ID for CMD_LinePerfCountNE_Get */
-#define CMD_LINEPERFCOUNTNE_GET 0x020A
-
-/**
-   Requests near-end line performance counter values (Section 7.2.1.1 of
-   G.997.1). These are wrap-around counters which are not affected by the
-   TR1-period.
-*/
-typedef struct CMD_LinePerfCountNE_Get CMD_LinePerfCountNE_Get_t;
-
-/** Message ID for ACK_LinePerfCountNE_Get */
-#define ACK_LINEPERFCOUNTNE_GET 0x020A
-
-/**
-   Provides near-end line performance counter values requested by
-   CMD_LinePerfCountNE_Get (Section 7.2.1.1 of G.997.1). These are wrap-around
-   counters which are not affected by the TR1-period.
-*/
-typedef struct ACK_LinePerfCountNE_Get ACK_LinePerfCountNE_Get_t;
-
-/** Message ID for CMD_LinePerfCountFE_Get */
-#define CMD_LINEPERFCOUNTFE_GET 0x040A
-
-/**
-   Requests far-end line performance counter values (Section 7.2.1.2 of
-   G.997.1). These are wrap-around counters which are not affected by the
-   TR1-period.
-*/
-typedef struct CMD_LinePerfCountFE_Get CMD_LinePerfCountFE_Get_t;
-
-/** Message ID for ACK_LinePerfCountFE_Get */
-#define ACK_LINEPERFCOUNTFE_GET 0x040A
-
-/**
-   Provides far-end line performance counter values requested by
-   CMD_LinePerfCountFE_Get (Section 7.2.1.2 of G.997.1). These are wrap-around
-   counters which are not affected by the TR1-period.
-*/
-typedef struct ACK_LinePerfCountFE_Get ACK_LinePerfCountFE_Get_t;
-
-/** Message ID for CMD_CRC_StatsNE_Get */
-#define CMD_CRC_STATSNE_GET 0x080A
-
-/**
-   Requests near-end CRC counter values. These are wrap-around counters which
-   are not affected by the TR1-period.
-*/
-typedef struct CMD_CRC_StatsNE_Get CMD_CRC_StatsNE_Get_t;
-
-/** Message ID for ACK_CRC_StatsNE_Get */
-#define ACK_CRC_STATSNE_GET 0x080A
-
-/**
-   Returns near-end CRC counter values. (Section 7.2.2.1.1 of G.997.1). These
-   are wrap-around counters which are not affected by the TR1-period.The
-   "LP1/Fast Path" parameters are fed only in ADSL1 and ADSL1 Lite mode with
-   selected fast path and in VDSL/ADSL with RTX mode.
-*/
-typedef struct ACK_CRC_StatsNE_Get ACK_CRC_StatsNE_Get_t;
-
-/** Message ID for CMD_CRC_StatsFE_Get */
-#define CMD_CRC_STATSFE_GET 0x0C0A
-
-/**
-   Requests far-end CRC counter values. These are wrap-around counters which are
-   not affected by the TR1-period.
-*/
-typedef struct CMD_CRC_StatsFE_Get CMD_CRC_StatsFE_Get_t;
-
-/** Message ID for ACK_CRC_StatsFE_Get */
-#define ACK_CRC_STATSFE_GET 0x0C0A
-
-/**
-   Returns far-end CRC counter values. (Section 7.2.2.2.1 of G.997.1). These are
-   wrap-around counters which are not affected by the TR1-period.The "LP1/Fast
-   Path" parameters are fed in ADSL1 and ADSL1 Lite mode with selected fast path
-   and in VDSL with RTX mode.
-*/
-typedef struct ACK_CRC_StatsFE_Get ACK_CRC_StatsFE_Get_t;
-
-/** Message ID for CMD_FEC_StatsNE_Get */
-#define CMD_FEC_STATSNE_GET 0x0A0A
-
-/**
-   Requests near-end FEC counter values. These are wrap-around counters which
-   are not affected by the TR1-period.
-*/
-typedef struct CMD_FEC_StatsNE_Get CMD_FEC_StatsNE_Get_t;
-
-/** Message ID for ACK_FEC_StatsNE_Get */
-#define ACK_FEC_STATSNE_GET 0x0A0A
-
-/**
-   Returns near-end FEC counter values (Section 7.2.2.1.2 of G.997.1). These are
-   wrap-around counters which are not affected by the TR1-period.The "LP1/Fast
-   Path" parameters are fed only in ADSL1 and ADSL1 Lite mode with selected fast
-   path and in VDSL/ADSL with RTX mode.
-*/
-typedef struct ACK_FEC_StatsNE_Get ACK_FEC_StatsNE_Get_t;
-
-/** Message ID for CMD_FEC_StatsFE_Get */
-#define CMD_FEC_STATSFE_GET 0x0E0A
-
-/**
-   Requests far-end FEC counter values. These are wrap-around counters which are
-   not affected by the TR1-period.
-*/
-typedef struct CMD_FEC_StatsFE_Get CMD_FEC_StatsFE_Get_t;
-
-/** Message ID for ACK_FEC_StatsFE_Get */
-#define ACK_FEC_STATSFE_GET 0x0E0A
-
-/**
-   Returns far-end FEC counter values (Section 7.2.2.2.2 of G.997.1). These are
-   wrap-around counters which are not affected by the TR1-period.The "LP1/Fast
-   Path" parameters are fed in ADSL1 and ADSL1 Lite mode with selected fast path
-   and in VDSL with RTX mode.
-*/
-typedef struct ACK_FEC_StatsFE_Get ACK_FEC_StatsFE_Get_t;
-
-/** Message ID for CMD_SOS_StatsNE_Get */
-#define CMD_SOS_STATSNE_GET 0x290A
-
-/**
-   Requests the near-end 15 minutes SOS counter values.
-*/
-typedef struct CMD_SOS_StatsNE_Get CMD_SOS_StatsNE_Get_t;
-
-/** Message ID for ACK_SOS_StatsNE_Get */
-#define ACK_SOS_STATSNE_GET 0x290A
-
-/**
-   Returns near-end SOS counter values. (Section 7.2.1.6.1 of G.997.1)
-*/
-typedef struct ACK_SOS_StatsNE_Get ACK_SOS_StatsNE_Get_t;
-
-/** Message ID for CMD_SOS_StatsFE_Get */
-#define CMD_SOS_STATSFE_GET 0x2A0A
-
-/**
-   Requests the far-end 15 minutes SOS counter values. These are wrap-around
-   counters which are not affected by the TR1-period.
-*/
-typedef struct CMD_SOS_StatsFE_Get CMD_SOS_StatsFE_Get_t;
-
-/** Message ID for ACK_SOS_StatsFE_Get */
-#define ACK_SOS_STATSFE_GET 0x2A0A
-
-/**
-   Returns far-end SOS counter values. (Section 7.2.1.7.1 of G.997.1)
-*/
-typedef struct ACK_SOS_StatsFE_Get ACK_SOS_StatsFE_Get_t;
-
-/** Message ID for CMD_LinePerfCountNE_Set */
-#define CMD_LINEPERFCOUNTNE_SET 0x024A
-
-/**
-   Writes near-end line performance counter values (total wrap-around)(Section
-   7.2.1.1 of G.997.1).
-*/
-typedef struct CMD_LinePerfCountNE_Set CMD_LinePerfCountNE_Set_t;
-
-/** Message ID for ACK_LinePerfCountNE_Set */
-#define ACK_LINEPERFCOUNTNE_SET 0x024A
-
-/**
-   Acknowledgement for CMD_LinePerfCountNE_Set.
-*/
-typedef struct ACK_LinePerfCountNE_Set ACK_LinePerfCountNE_Set_t;
-
-/** Message ID for CMD_CRC_StatsNE_Set */
-#define CMD_CRC_STATSNE_SET 0x084A
-
-/**
-   Writes the near-end CRC counter values (Section 7.2.2.1.1 of G.997.1)The
-   "LP1/Fast Path" parameters are used only in ADSL1 and ADSL1 Lite mode with
-   selected "Fast Path".
-*/
-typedef struct CMD_CRC_StatsNE_Set CMD_CRC_StatsNE_Set_t;
-
-/** Message ID for ACK_CRC_StatsNE_Set */
-#define ACK_CRC_STATSNE_SET 0x084A
-
-/**
-   Acknowledgement for the message CMD_CRC_StatsNE_Set.
-*/
-typedef struct ACK_CRC_StatsNE_Set ACK_CRC_StatsNE_Set_t;
-
-/** Message ID for CMD_FEC_StatsNE_Set */
-#define CMD_FEC_STATSNE_SET 0x0A4A
-
-/**
-   Writes near-end FEC counter values. (Section 7.2.2.1.2 of G.997.1)The
-   "LP1/Fast Path" parameters are used only in ADSL1 and ADSL1 Lite mode with
-   selected "Fast Path".
-*/
-typedef struct CMD_FEC_StatsNE_Set CMD_FEC_StatsNE_Set_t;
-
-/** Message ID for ACK_FEC_StatsNE_Set */
-#define ACK_FEC_STATSNE_SET 0x0A4A
-
-/**
-   Acknowledgement for the message CMD_FEC_StatsNE_Set.
-*/
-typedef struct ACK_FEC_StatsNE_Set ACK_FEC_StatsNE_Set_t;
-
-/** Message ID for  CMD_SOS_StatsNE_Set */
-#define  CMD_SOS_STATSNE_SET 0x294A
-
-/**
-   Writes near-end SOS counter values. ("SOS-SUCCESS-NE", Section 7.2.1.6.1 of
-   G.997.1).
-*/
-typedef struct  CMD_SOS_StatsNE_Set CMD_SOS_StatsNE_Set_t;
-
-/** Message ID for  ACK_SOS_StatsNE_Set */
-#define  ACK_SOS_STATSNE_SET 0x294A
-
-/**
-   Acknowledgement for CMD_SOS_StatsNE_Set.
-*/
-typedef struct  ACK_SOS_StatsNE_Set ACK_SOS_StatsNE_Set_t;
-
-/** Message ID for CMD_TimeSet */
-#define CMD_TIMESET 0x6143
-
-/**
-   Sets the running time since midnightModifying the Time does not affect the
-   TR1 supervision period and the TR1-counters.
-*/
-typedef struct CMD_TimeSet CMD_TimeSet_t;
-
-/** Message ID for ACK_TimeSet */
-#define ACK_TIMESET 0x6143
-
-/**
-   Acknowledgement for message CMD_TimeSet.
-*/
-typedef struct ACK_TimeSet ACK_TimeSet_t;
-
-/** Message ID for CMD_TimeGet */
-#define CMD_TIMEGET 0x6103
-
-/**
-   Requests the status of the "Set Time and Read Time" EOC messages.
-*/
-typedef struct CMD_TimeGet CMD_TimeGet_t;
-
-/** Message ID for ACK_TimeGet */
-#define ACK_TIMEGET 0x6103
-
-/**
-   Provides the status of the "Set Time and Read Time" EOC messages.
-*/
-typedef struct ACK_TimeGet ACK_TimeGet_t;
-
-/**
-   Controls the behaviour of the performance counters.
-*/
-struct CMD_CounterControlSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-   /** Counter Inhibiting Enable */
-   DSL_uint16_t CntInhibitEnable : 1;
-   /** Fixed value: VRX_DISABLE */
-   DSL_uint16_t Res1 : 2;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Fixed value: VRX_DISABLE */
-   DSL_uint16_t Res1 : 2;
-   /** Counter Inhibiting Enable */
-   DSL_uint16_t CntInhibitEnable : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 13;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for message CMD_CounterControlSet.
-*/
-struct ACK_CounterControlSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Configures options for performance monitoring functions.
-*/
-struct CMD_PM_OptionsSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 15;
-   /** Supress CRC/FEC Counter-Writeback (ADSL only) */
-   DSL_uint16_t CrcFecWrProtect : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Supress CRC/FEC Counter-Writeback (ADSL only) */
-   DSL_uint16_t CrcFecWrProtect : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 15;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for message ACK_PM_OptionsSet.
-*/
-struct ACK_PM_OptionsSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This autonomous message indicates near-end line failures.
-*/
-struct ALM_LineFailureNE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 2;
-   /** ESE Failure NE */
-   DSL_uint16_t ESE_NE : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 9;
-   /** LOM Failure NE */
-   DSL_uint16_t LOM_NE : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 1;
-   /** LOF Failure NE */
-   DSL_uint16_t LOF_NE : 1;
-   /** LOS Failure NE */
-   DSL_uint16_t LOS_NE : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** LOS Failure NE */
-   DSL_uint16_t LOS_NE : 1;
-   /** LOF Failure NE */
-   DSL_uint16_t LOF_NE : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 1;
-   /** LOM Failure NE */
-   DSL_uint16_t LOM_NE : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 9;
-   /** ESE Failure NE */
-   DSL_uint16_t ESE_NE : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 2;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the near-end line failure status.
-*/
-struct CMD_LineFailureNE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the near-end line failure status requested by the command
-   CMD_LineFailureNE_Get.
-*/
-struct ACK_LineFailureNE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 2;
-   /** ESE Failure NE */
-   DSL_uint16_t ESE_NE : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 9;
-   /** LOM Failure NE */
-   DSL_uint16_t LOM_NE : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 1;
-   /** LOF Failure NE */
-   DSL_uint16_t LOF_NE : 1;
-   /** LOS Failure NE */
-   DSL_uint16_t LOS_NE : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** LOS Failure NE */
-   DSL_uint16_t LOS_NE : 1;
-   /** LOF Failure NE */
-   DSL_uint16_t LOF_NE : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 1;
-   /** LOM Failure NE */
-   DSL_uint16_t LOM_NE : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 9;
-   /** ESE Failure NE */
-   DSL_uint16_t ESE_NE : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 2;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This autonomous message indicates far-end line failures.
-*/
-struct ALM_LineFailureFE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 2;
-   /** ESE Failure FE */
-   DSL_uint16_t ESE_FE : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 9;
-   /** LOM Failure FE */
-   DSL_uint16_t LOM_FE : 1;
-   /** LPR Failure FE */
-   DSL_uint16_t LPR_FE : 1;
-   /** LOF Failure FE */
-   DSL_uint16_t LOF_FE : 1;
-   /** LOS Failure FE */
-   DSL_uint16_t LOS_FE : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** LOS Failure FE */
-   DSL_uint16_t LOS_FE : 1;
-   /** LOF Failure FE */
-   DSL_uint16_t LOF_FE : 1;
-   /** LPR Failure FE */
-   DSL_uint16_t LPR_FE : 1;
-   /** LOM Failure FE */
-   DSL_uint16_t LOM_FE : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 9;
-   /** ESE Failure FE */
-   DSL_uint16_t ESE_FE : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 2;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the far-end line failure status.
-*/
-struct CMD_LineFailureFE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the far-end line failure status requested by the command
-   CMD_LineFailureFE_Get.
-*/
-struct ACK_LineFailureFE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 2;
-   /** ESE Failure FE */
-   DSL_uint16_t ESE_FE : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 9;
-   /** LOM Failure FE */
-   DSL_uint16_t LOM_FE : 1;
-   /** LPR Failure FE */
-   DSL_uint16_t LPR_FE : 1;
-   /** LOF Failure FE */
-   DSL_uint16_t LOF_FE : 1;
-   /** LOS Failure FE */
-   DSL_uint16_t LOS_FE : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** LOS Failure FE */
-   DSL_uint16_t LOS_FE : 1;
-   /** LOF Failure FE */
-   DSL_uint16_t LOF_FE : 1;
-   /** LPR Failure FE */
-   DSL_uint16_t LPR_FE : 1;
-   /** LOM Failure FE */
-   DSL_uint16_t LOM_FE : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 9;
-   /** ESE Failure FE */
-   DSL_uint16_t ESE_FE : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 2;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Host initiated "loss of power". Triggers indicating an lpr primitive to the
-   remote side via the indicator bits ("IB bits").The host writes the message to
-   the FW e.g. after detecting LPR by an alternative detection scheme.
-*/
-struct CMD_Failure_Trigger
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 15;
-   /** LPR Trigger */
-   DSL_uint16_t lpr_Trigger : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** LPR Trigger */
-   DSL_uint16_t lpr_Trigger : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 15;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for CMD_Failure_Trigger.
-*/
-struct ACK_Failure_Trigger
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests near-end line performance counter values (Section 7.2.1.1 of
-   G.997.1). These are wrap-around counters which are not affected by the
-   TR1-period.
-*/
-struct CMD_LinePerfCountNE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides near-end line performance counter values requested by
-   CMD_LinePerfCountNE_Get (Section 7.2.1.1 of G.997.1). These are wrap-around
-   counters which are not affected by the TR1-period.
-*/
-struct ACK_LinePerfCountNE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-End FECS Count, LSW */
-   DSL_uint16_t  cntFECS_LSW;
-   /** Near-End FECS Count, MSW */
-   DSL_uint16_t  cntFECS_MSW;
-   /** Near-End ES Count, LSW */
-   DSL_uint16_t  cntES_LSW;
-   /** Near-End ES Count, MSW */
-   DSL_uint16_t  cntES_MSW;
-   /** Near-End SES Count, LSW */
-   DSL_uint16_t  cntSES_LSW;
-   /** Near-End SES Count, MSW */
-   DSL_uint16_t  cntSES_MSW;
-   /** Near-End LOSS Count, LSW */
-   DSL_uint16_t  cntLOSS_LSW;
-   /** Near-End LOSS Count, MSW */
-   DSL_uint16_t  cntLOSS_MSW;
-   /** Near-End UAS Count, LSW */
-   DSL_uint16_t  cntUAS_LSW;
-   /** Near-End UAS Count, MSW */
-   DSL_uint16_t  cntUAS_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-End FECS Count, LSW */
-   DSL_uint16_t  cntFECS_LSW;
-   /** Near-End FECS Count, MSW */
-   DSL_uint16_t  cntFECS_MSW;
-   /** Near-End ES Count, LSW */
-   DSL_uint16_t  cntES_LSW;
-   /** Near-End ES Count, MSW */
-   DSL_uint16_t  cntES_MSW;
-   /** Near-End SES Count, LSW */
-   DSL_uint16_t  cntSES_LSW;
-   /** Near-End SES Count, MSW */
-   DSL_uint16_t  cntSES_MSW;
-   /** Near-End LOSS Count, LSW */
-   DSL_uint16_t  cntLOSS_LSW;
-   /** Near-End LOSS Count, MSW */
-   DSL_uint16_t  cntLOSS_MSW;
-   /** Near-End UAS Count, LSW */
-   DSL_uint16_t  cntUAS_LSW;
-   /** Near-End UAS Count, MSW */
-   DSL_uint16_t  cntUAS_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests far-end line performance counter values (Section 7.2.1.2 of
-   G.997.1). These are wrap-around counters which are not affected by the
-   TR1-period.
-*/
-struct CMD_LinePerfCountFE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides far-end line performance counter values requested by
-   CMD_LinePerfCountFE_Get (Section 7.2.1.2 of G.997.1). These are wrap-around
-   counters which are not affected by the TR1-period.
-*/
-struct ACK_LinePerfCountFE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Far-End FECS Count, LSW */
-   DSL_uint16_t  cntFECS_LSW;
-   /** Far-End FECS Count, MSW */
-   DSL_uint16_t  cntFECS_MSW;
-   /** Far-End ES Count, LSW */
-   DSL_uint16_t  cntES_LSW;
-   /** Far-End ES Count, MSW */
-   DSL_uint16_t  cntES_MSW;
-   /** Far-End SES Count, LSW */
-   DSL_uint16_t  cntSES_LSW;
-   /** Far-End SES Count, MSW */
-   DSL_uint16_t  cntSES_MSW;
-   /** Far-End LOSS Count, LSW */
-   DSL_uint16_t  cntLOSS_LSW;
-   /** Far-End LOSS Count, MSW */
-   DSL_uint16_t  cntLOSS_MSW;
-   /** Near-End UAS Count, LSW */
-   DSL_uint16_t  cntUAS_LSW;
-   /** Near-End UAS Count, MSW */
-   DSL_uint16_t  cntUAS_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Far-End FECS Count, LSW */
-   DSL_uint16_t  cntFECS_LSW;
-   /** Far-End FECS Count, MSW */
-   DSL_uint16_t  cntFECS_MSW;
-   /** Far-End ES Count, LSW */
-   DSL_uint16_t  cntES_LSW;
-   /** Far-End ES Count, MSW */
-   DSL_uint16_t  cntES_MSW;
-   /** Far-End SES Count, LSW */
-   DSL_uint16_t  cntSES_LSW;
-   /** Far-End SES Count, MSW */
-   DSL_uint16_t  cntSES_MSW;
-   /** Far-End LOSS Count, LSW */
-   DSL_uint16_t  cntLOSS_LSW;
-   /** Far-End LOSS Count, MSW */
-   DSL_uint16_t  cntLOSS_MSW;
-   /** Near-End UAS Count, LSW */
-   DSL_uint16_t  cntUAS_LSW;
-   /** Near-End UAS Count, MSW */
-   DSL_uint16_t  cntUAS_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests near-end CRC counter values. These are wrap-around counters which
-   are not affected by the TR1-period.
-*/
-struct CMD_CRC_StatsNE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns near-end CRC counter values. (Section 7.2.2.1.1 of G.997.1). These
-   are wrap-around counters which are not affected by the TR1-period.The
-   "LP1/Fast Path" parameters are fed only in ADSL1 and ADSL1 Lite mode with
-   selected fast path and in VDSL/ADSL with RTX mode.
-*/
-struct ACK_CRC_StatsNE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-End CRC Count LP0, LSW */
-   DSL_uint16_t cntCVI_LSW;
-   /** Near-End CRC Count LP0, MSW */
-   DSL_uint16_t cntCVI_MSW;
-   /** Near-End CRC Count LP1, LSW */
-   DSL_uint16_t cntCVF_LSW;
-   /** Near-End CRC Count LP1, MSW */
-   DSL_uint16_t cntCVF_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-End CRC Count LP0, LSW */
-   DSL_uint16_t cntCVI_LSW;
-   /** Near-End CRC Count LP0, MSW */
-   DSL_uint16_t cntCVI_MSW;
-   /** Near-End CRC Count LP1, LSW */
-   DSL_uint16_t cntCVF_LSW;
-   /** Near-End CRC Count LP1, MSW */
-   DSL_uint16_t cntCVF_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests far-end CRC counter values. These are wrap-around counters which are
-   not affected by the TR1-period.
-*/
-struct CMD_CRC_StatsFE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns far-end CRC counter values. (Section 7.2.2.2.1 of G.997.1). These are
-   wrap-around counters which are not affected by the TR1-period.The "LP1/Fast
-   Path" parameters are fed in ADSL1 and ADSL1 Lite mode with selected fast path
-   and in VDSL with RTX mode.
-*/
-struct ACK_CRC_StatsFE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Far-End CRC Count LP0, LSW */
-   DSL_uint16_t cntCVI_LSW;
-   /** Far-End CRC Count LP0, MSW */
-   DSL_uint16_t cntCVI_MSW;
-   /** Far-End CRC Count LP1, LSW */
-   DSL_uint16_t cntCVF_LSW;
-   /** Far-End CRC Count LP1, MSW */
-   DSL_uint16_t cntCVF_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Far-End CRC Count LP0, LSW */
-   DSL_uint16_t cntCVI_LSW;
-   /** Far-End CRC Count LP0, MSW */
-   DSL_uint16_t cntCVI_MSW;
-   /** Far-End CRC Count LP1, LSW */
-   DSL_uint16_t cntCVF_LSW;
-   /** Far-End CRC Count LP1, MSW */
-   DSL_uint16_t cntCVF_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests near-end FEC counter values. These are wrap-around counters which
-   are not affected by the TR1-period.
-*/
-struct CMD_FEC_StatsNE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns near-end FEC counter values (Section 7.2.2.1.2 of G.997.1). These are
-   wrap-around counters which are not affected by the TR1-period.The "LP1/Fast
-   Path" parameters are fed only in ADSL1 and ADSL1 Lite mode with selected fast
-   path and in VDSL/ADSL with RTX mode.
-*/
-struct ACK_FEC_StatsNE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-End FEC Count LP0, LSW */
-   DSL_uint16_t cntECI_LSW;
-   /** Near-End FEC Count LP0, MSW */
-   DSL_uint16_t cntECI_MSW;
-   /** Near-End FEC Count LP1, LSW */
-   DSL_uint16_t cntFEC_LSW;
-   /** Near-End FEC Count LP1, MSW */
-   DSL_uint16_t cntFEC_MSW;
-   /** Near-End FEC Uncorrectable Count LP0, LSW */
-   DSL_uint16_t cntECI_NoCorrLSW;
-   /** Near-End FEC Uncorrectable Count LP0, MSW */
-   DSL_uint16_t cntECI_NoCorrMSW;
-   /** Near-End FEC Uncorrectable Count LP1, LSW */
-   DSL_uint16_t cntECF_NoCorrLSW;
-   /** Near-End FEC Uncorrectable Count LP1, MSW */
-   DSL_uint16_t cntECF_NoCorrMSW;
-   /** Near-End Total RS CW Count LP0, LSW */
-   DSL_uint16_t cntECI_CW_LSW;
-   /** Near-End Total RS CW Count LP0, MSW */
-   DSL_uint16_t cntECI_CW_MSW;
-   /** Near-End Total RS CW Count LP1, LSW */
-   DSL_uint16_t cntECF_CW_LSW;
-   /** Near-End Total RS CW Count LP1, MSW */
-   DSL_uint16_t cntECF_CW_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-End FEC Count LP0, LSW */
-   DSL_uint16_t cntECI_LSW;
-   /** Near-End FEC Count LP0, MSW */
-   DSL_uint16_t cntECI_MSW;
-   /** Near-End FEC Count LP1, LSW */
-   DSL_uint16_t cntFEC_LSW;
-   /** Near-End FEC Count LP1, MSW */
-   DSL_uint16_t cntFEC_MSW;
-   /** Near-End FEC Uncorrectable Count LP0, LSW */
-   DSL_uint16_t cntECI_NoCorrLSW;
-   /** Near-End FEC Uncorrectable Count LP0, MSW */
-   DSL_uint16_t cntECI_NoCorrMSW;
-   /** Near-End FEC Uncorrectable Count LP1, LSW */
-   DSL_uint16_t cntECF_NoCorrLSW;
-   /** Near-End FEC Uncorrectable Count LP1, MSW */
-   DSL_uint16_t cntECF_NoCorrMSW;
-   /** Near-End Total RS CW Count LP0, LSW */
-   DSL_uint16_t cntECI_CW_LSW;
-   /** Near-End Total RS CW Count LP0, MSW */
-   DSL_uint16_t cntECI_CW_MSW;
-   /** Near-End Total RS CW Count LP1, LSW */
-   DSL_uint16_t cntECF_CW_LSW;
-   /** Near-End Total RS CW Count LP1, MSW */
-   DSL_uint16_t cntECF_CW_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests far-end FEC counter values. These are wrap-around counters which are
-   not affected by the TR1-period.
-*/
-struct CMD_FEC_StatsFE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns far-end FEC counter values (Section 7.2.2.2.2 of G.997.1). These are
-   wrap-around counters which are not affected by the TR1-period.The "LP1/Fast
-   Path" parameters are fed in ADSL1 and ADSL1 Lite mode with selected fast path
-   and in VDSL with RTX mode.
-*/
-struct ACK_FEC_StatsFE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Far-End FEC Count LP0, LSW */
-   DSL_uint16_t cntECI_LSW;
-   /** Far-End FEC Count LP0, MSW */
-   DSL_uint16_t cntECI_MSW;
-   /** Far-End FEC Count LP1, LSW */
-   DSL_uint16_t cntFEC_LSW;
-   /** Far-End FEC Count LP1, MSW */
-   DSL_uint16_t cntFEC_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Far-End FEC Count LP0, LSW */
-   DSL_uint16_t cntECI_LSW;
-   /** Far-End FEC Count LP0, MSW */
-   DSL_uint16_t cntECI_MSW;
-   /** Far-End FEC Count LP1, LSW */
-   DSL_uint16_t cntFEC_LSW;
-   /** Far-End FEC Count LP1, MSW */
-   DSL_uint16_t cntFEC_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the near-end 15 minutes SOS counter values.
-*/
-struct CMD_SOS_StatsNE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns near-end SOS counter values. (Section 7.2.1.6.1 of G.997.1)
-*/
-struct ACK_SOS_StatsNE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-End SOS Success Count LP0, LSW */
-   DSL_uint16_t cntSOS_SUC_LSW;
-   /** Near-End SOS Success Count LP0, MSW */
-   DSL_uint16_t cntSOS_SUC_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-End SOS Success Count LP0, LSW */
-   DSL_uint16_t cntSOS_SUC_LSW;
-   /** Near-End SOS Success Count LP0, MSW */
-   DSL_uint16_t cntSOS_SUC_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the far-end 15 minutes SOS counter values. These are wrap-around
-   counters which are not affected by the TR1-period.
-*/
-struct CMD_SOS_StatsFE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Returns far-end SOS counter values. (Section 7.2.1.7.1 of G.997.1)
-*/
-struct ACK_SOS_StatsFE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Far-End SOS Success Count LP0, LSW */
-   DSL_uint16_t cntSOS_SUC_LSW;
-   /** Far-End SOS Success Count LP0, MSW */
-   DSL_uint16_t cntSOS_SUC_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Far-End SOS Success Count LP0, LSW */
-   DSL_uint16_t cntSOS_SUC_LSW;
-   /** Far-End SOS Success Count LP0, MSW */
-   DSL_uint16_t cntSOS_SUC_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Writes near-end line performance counter values (total wrap-around)(Section
-   7.2.1.1 of G.997.1).
-*/
-struct CMD_LinePerfCountNE_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-End FECS Count, LSW */
-   DSL_uint16_t  cntFECS_LSW;
-   /** Near-End FECS Count, MSW */
-   DSL_uint16_t  cntFECS_MSW;
-   /** Near-End ES Count, LSW */
-   DSL_uint16_t  cntES_LSW;
-   /** Near-End ES Count, MSW */
-   DSL_uint16_t  cntES_MSW;
-   /** Near-End SES Count, LSW */
-   DSL_uint16_t  cntSES_LSW;
-   /** Near-End SES Count, MSW */
-   DSL_uint16_t  cntSES_MSW;
-   /** Near-End LOSS Count, LSW */
-   DSL_uint16_t  cntLOSS_LSW;
-   /** Near-End LOSS Count, MSW */
-   DSL_uint16_t  cntLOSS_MSW;
-   /** Near-End UAS Count, LSW */
-   DSL_uint16_t  cntUAS_LSW;
-   /** Near-End UAS Count, MSW */
-   DSL_uint16_t  cntUAS_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-End FECS Count, LSW */
-   DSL_uint16_t  cntFECS_LSW;
-   /** Near-End FECS Count, MSW */
-   DSL_uint16_t  cntFECS_MSW;
-   /** Near-End ES Count, LSW */
-   DSL_uint16_t  cntES_LSW;
-   /** Near-End ES Count, MSW */
-   DSL_uint16_t  cntES_MSW;
-   /** Near-End SES Count, LSW */
-   DSL_uint16_t  cntSES_LSW;
-   /** Near-End SES Count, MSW */
-   DSL_uint16_t  cntSES_MSW;
-   /** Near-End LOSS Count, LSW */
-   DSL_uint16_t  cntLOSS_LSW;
-   /** Near-End LOSS Count, MSW */
-   DSL_uint16_t  cntLOSS_MSW;
-   /** Near-End UAS Count, LSW */
-   DSL_uint16_t  cntUAS_LSW;
-   /** Near-End UAS Count, MSW */
-   DSL_uint16_t  cntUAS_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for CMD_LinePerfCountNE_Set.
-*/
-struct ACK_LinePerfCountNE_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Writes the near-end CRC counter values (Section 7.2.2.1.1 of G.997.1)The
-   "LP1/Fast Path" parameters are used only in ADSL1 and ADSL1 Lite mode with
-   selected "Fast Path".
-*/
-struct CMD_CRC_StatsNE_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-End CRC Count LP0, LSW */
-   DSL_uint16_t cntCVI_LSW;
-   /** Near-End CRC Count LP0, MSW */
-   DSL_uint16_t cntCVI_MSW;
-   /** Near-End CRC Count LP1, LSW */
-   DSL_uint16_t cntCVF_LSW;
-   /** Near-End CRC Count LP1, MSW */
-   DSL_uint16_t cntCVF_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-End CRC Count LP0, LSW */
-   DSL_uint16_t cntCVI_LSW;
-   /** Near-End CRC Count LP0, MSW */
-   DSL_uint16_t cntCVI_MSW;
-   /** Near-End CRC Count LP1, LSW */
-   DSL_uint16_t cntCVF_LSW;
-   /** Near-End CRC Count LP1, MSW */
-   DSL_uint16_t cntCVF_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for the message CMD_CRC_StatsNE_Set.
-*/
-struct ACK_CRC_StatsNE_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Writes near-end FEC counter values. (Section 7.2.2.1.2 of G.997.1)The
-   "LP1/Fast Path" parameters are used only in ADSL1 and ADSL1 Lite mode with
-   selected "Fast Path".
-*/
-struct CMD_FEC_StatsNE_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-End FEC Count LP0, LSW */
-   DSL_uint16_t cntECI_LSW;
-   /** Near-End FEC Count LP0, MSW */
-   DSL_uint16_t cntECI_MSW;
-   /** Near-End FEC Count LP1, LSW */
-   DSL_uint16_t cntFEC_LSW;
-   /** Near-End FEC Count LP1, MSW */
-   DSL_uint16_t cntFEC_MSW;
-   /** Near-End FEC Uncorrectable Count LP0, LSW */
-   DSL_uint16_t cntECI_NoCorrLSW;
-   /** Near-End FEC Uncorrectable Count LP0, MSW */
-   DSL_uint16_t cntECI_NoCorrMSW;
-   /** Near-End FEC Uncorrectable Count LP1, LSW */
-   DSL_uint16_t cntECF_NoCorrLSW;
-   /** Near-End FEC Uncorrectable Count LP1, MSW */
-   DSL_uint16_t cntECF_NoCorrMSW;
-   /** Near-End Total RS CW Count LP0, LSW */
-   DSL_uint16_t cntECI_CW_LSW;
-   /** Near-End Total RS CW Count LP0, MSW */
-   DSL_uint16_t cntECI_CW_MSW;
-   /** Near-End Total RS CW Count LP1, LSW */
-   DSL_uint16_t cntECF_CW_LSW;
-   /** Near-End Total RS CW Count LP1, MSW */
-   DSL_uint16_t cntECF_CW_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-End FEC Count LP0, LSW */
-   DSL_uint16_t cntECI_LSW;
-   /** Near-End FEC Count LP0, MSW */
-   DSL_uint16_t cntECI_MSW;
-   /** Near-End FEC Count LP1, LSW */
-   DSL_uint16_t cntFEC_LSW;
-   /** Near-End FEC Count LP1, MSW */
-   DSL_uint16_t cntFEC_MSW;
-   /** Near-End FEC Uncorrectable Count LP0, LSW */
-   DSL_uint16_t cntECI_NoCorrLSW;
-   /** Near-End FEC Uncorrectable Count LP0, MSW */
-   DSL_uint16_t cntECI_NoCorrMSW;
-   /** Near-End FEC Uncorrectable Count LP1, LSW */
-   DSL_uint16_t cntECF_NoCorrLSW;
-   /** Near-End FEC Uncorrectable Count LP1, MSW */
-   DSL_uint16_t cntECF_NoCorrMSW;
-   /** Near-End Total RS CW Count LP0, LSW */
-   DSL_uint16_t cntECI_CW_LSW;
-   /** Near-End Total RS CW Count LP0, MSW */
-   DSL_uint16_t cntECI_CW_MSW;
-   /** Near-End Total RS CW Count LP1, LSW */
-   DSL_uint16_t cntECF_CW_LSW;
-   /** Near-End Total RS CW Count LP1, MSW */
-   DSL_uint16_t cntECF_CW_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for the message CMD_FEC_StatsNE_Set.
-*/
-struct ACK_FEC_StatsNE_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Writes near-end SOS counter values. ("SOS-SUCCESS-NE", Section 7.2.1.6.1 of
-   G.997.1).
-*/
-struct  CMD_SOS_StatsNE_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-End SOS Success Count LP0, LSW */
-   DSL_uint16_t cntSOS_SUC_LSW;
-   /** Near-End SOS Success Count LP0, MSW */
-   DSL_uint16_t cntSOS_SUC_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-End SOS Success Count LP0, LSW */
-   DSL_uint16_t cntSOS_SUC_LSW;
-   /** Near-End SOS Success Count LP0, MSW */
-   DSL_uint16_t cntSOS_SUC_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for CMD_SOS_StatsNE_Set.
-*/
-struct  ACK_SOS_StatsNE_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Sets the running time since midnightModifying the Time does not affect the
-   TR1 supervision period and the TR1-counters.
-*/
-struct CMD_TimeSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0[3];
-   /** NE Time */
-   VRX_TIME_t timeNE;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0[3];
-   /** NE Time */
-   VRX_TIME_t timeNE;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for message CMD_TimeSet.
-*/
-struct ACK_TimeSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the status of the "Set Time and Read Time" EOC messages.
-*/
-struct CMD_TimeGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the status of the "Set Time and Read Time" EOC messages.
-*/
-struct ACK_TimeGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** FE Time */
-   VRX_TIME_t timeFE;
-   /** NE Time */
-   VRX_TIME_t timeNE;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0;
-   /** FE Time */
-   VRX_TIME_t timeFE;
-   /** NE Time */
-   VRX_TIME_t timeNE;
-#endif
-} __PACKED__ ;
-
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#ifdef __PACKED_DEFINED__
-   #if !(defined (__GNUC__) || defined (__GNUG__))
-      #pragma pack()
-   #endif
-   #undef __PACKED_DEFINED__
-#endif /* __PACKED_DEFINED__ */
-
-/** @} */
-
-#endif /** _DRV_DSL_CPE_VRX_MSG_PERF_PMD_H_*/
--- a/src/include/mcat3.1/drv_dsl_cpe_vrx_msg_tc_counters.h
+++ /dev/null
@@ -1,2199 +0,0 @@
-/******************************************************************************
-
-                            Copyright (c) 2007-2017
-                       Lantiq Beteiligungs-GmbH & Co. KG
-
-  For licensing information, see the file 'LICENSE' in the root folder of
-  this software module.
-
-******************************************************************************/
-
-
-#ifndef _DRV_DSL_CPE_VRX_MSG_TC_COUNTERS_H_
-#define _DRV_DSL_CPE_VRX_MSG_TC_COUNTERS_H_
-
-/** \file
-
-*/
-
-#ifndef __PACKED__
-   #if defined (__GNUC__) || defined (__GNUG__)
-      /* GNU C or C++ compiler */
-      #define __PACKED__ __attribute__ ((packed))
-   #else
-      /* Byte alignment adjustment */
-      #pragma pack(1)
-      #define __PACKED__      /* nothing */
-   #endif
-   #define __PACKED_DEFINED__ 1
-#endif
-
-
-/** @defgroup _TC_COUNTERS_
- *  @{
- */
-
-#ifdef __cplusplus
-   extern "C" {
-#endif
-
-/* ----- Message Specific Constants Definition section ----- */
-#define ACK_TC_StatusGet_UNKNOWN_TC 0x0
-#define ACK_TC_StatusGet_EFM_TC 0x1
-#define ACK_TC_StatusGet_ATM_TC 0x2
-#define EVT_TC_StatusGet_EFM_TC 0x1
-#define EVT_TC_StatusGet_ATM_TC 0x2
-#define CMD_TC_FW_InfoSet_EFM_TC 0x1
-#define CMD_TC_FW_InfoSet_ATM_TC 0x2
-#define ACK_VersionInfoGet_VRX518 0x0
-#define ACK_VersionInfoGet_VRX517 0x1
-#define ACK_VersionInfoGet_HW_VER11 0x0
-#define ACK_VersionInfoGet_HW_VER12 0x1
-#define ACK_VersionInfoGet_VRX200 0x05
-#define ACK_VersionInfoGet_VRX300 0x07
-#define ACK_VersionInfoGet_VRX500 0x08
-#define ACK_VersionInfoGet_R3 10
-#define ACK_VersionInfoGet_R4 11
-#define ACK_VersionInfoGet_R5 12
-#define ACK_VersionInfoGet_RELEASE 0
-#define ACK_VersionInfoGet_PRERELEASE 1
-#define ACK_VersionInfoGet_DEVELOP 3
-#define ACK_VersionInfoGet_ADSL_A 1
-#define ACK_VersionInfoGet_ADSL_BJ 2
-#define ACK_VersionInfoGet_VDSL2 6
-#define CMD_PAF_HS_Continue_WAIT 0x0
-#define CMD_PAF_HS_Continue_CONTINUE 0x1
-/* ----- Message Specific Constants Definition section (End) ----- */
-
-/** Message ID for CMD_TC_StatusGet */
-#define CMD_TC_STATUSGET 0x0E22
-
-/**
-   The message reads the used TC.In ADSL the TC type is selected during G.HS and
-   thus known when entering FULL_INIT. In VDSL it is selected later, during
-   FULL_INIT. Before this point the FW will report the TC as "unknown".
-*/
-typedef struct CMD_TC_StatusGet CMD_TC_StatusGet_t;
-
-/** Message ID for ACK_TC_StatusGet */
-#define ACK_TC_STATUSGET 0x0E22
-
-/**
-   Reporting of the used TC mode.
-*/
-typedef struct ACK_TC_StatusGet ACK_TC_StatusGet_t;
-
-/** Message ID for EVT_TC_StatusGet */
-#define EVT_TC_STATUSGET 0x0E22
-
-/**
-   This autonomous Event reports the to be used TC mode after being known. In R7
-   FW (w.7.x.y.z.a) only generated when enabled in CMD_Misc_ConfigSet TcTypeEvt.
-*/
-typedef struct EVT_TC_StatusGet EVT_TC_StatusGet_t;
-
-/** Message ID for CMD_TC_FW_InfoSet */
-#define CMD_TC_FW_INFOSET 0x1762
-
-/**
-   The message informs the DSL-FW about the currently loaded TC FW driver.
-*/
-typedef struct CMD_TC_FW_InfoSet CMD_TC_FW_InfoSet_t;
-
-/** Message ID for ACK_TC_FW_InfoSet */
-#define ACK_TC_FW_INFOSET 0x1762
-
-/**
-   Acknowledgement to CMD_TC_FW_InfoSet.
-*/
-typedef struct ACK_TC_FW_InfoSet ACK_TC_FW_InfoSet_t;
-
-/** Message ID for CMD_MAC_FrameConfigure */
-#define CMD_MAC_FRAMECONFIGURE 0x5348
-
-/**
-   The message configures Ethernet properties, currently the MAC address of the
-   device only.The MAC address is needed in the FW as "MAC source address"for
-   PDUs not built by the host, like e.g. for the Ethernet encapsulated
-   Backchannel Data ERB in Vectoring.
-*/
-typedef struct CMD_MAC_FrameConfigure CMD_MAC_FrameConfigure_t;
-
-/** Message ID for ACK_MAC_FrameConfigure */
-#define ACK_MAC_FRAMECONFIGURE 0x5348
-
-/**
-   Acknowledgement to CMD_MAC_FrameConfigure.
-*/
-typedef struct ACK_MAC_FrameConfigure ACK_MAC_FrameConfigure_t;
-
-/** Message ID for CMD_DataPathFailuresAlarmConfigure */
-#define CMD_DATAPATHFAILURESALARMCONFIGURE 0x1249
-
-/**
-   Enables/Disables the generation of ALARM messages (ALM) for specific data-
-   path failures. If the corresponding Enable bit for a failure is set, then the
-   modem firmware will send an autonomous message ALM_DataPathFailuresGet if
-   this failure occurs.
-*/
-typedef struct CMD_DataPathFailuresAlarmConfigure CMD_DataPathFailuresAlarmConfigure_t;
-
-/** Message ID for ACK_DataPathFailuresAlarmConfigure */
-#define ACK_DATAPATHFAILURESALARMCONFIGURE 0x1249
-
-/**
-   Acknowledgement to CMD_DataPathFailuresAlarmConfigure.
-*/
-typedef struct ACK_DataPathFailuresAlarmConfigure ACK_DataPathFailuresAlarmConfigure_t;
-
-/** Message ID for CMD_DataPathFailuresGet */
-#define CMD_DATAPATHFAILURESGET 0x0507
-
-/**
-   Requests the data-path failure status.
-*/
-typedef struct CMD_DataPathFailuresGet CMD_DataPathFailuresGet_t;
-
-/** Message ID for ACK_DataPathFailuresGet */
-#define ACK_DATAPATHFAILURESGET 0x0507
-
-/**
-   Provides the data path failure status as requested by the command
-   CMD_DataPathFailuresGet.
-*/
-typedef struct ACK_DataPathFailuresGet ACK_DataPathFailuresGet_t;
-
-/** Message ID for ALM_DataPathFailuresGet */
-#define ALM_DATAPATHFAILURESGET 0x0507
-
-/**
-   This autonomous message reports the data-path failure status. It is sent only
-   if the message generation was enabled for the corresponding failure with
-   CMD_DataPathFailuresAlarmConfigure.
-*/
-typedef struct ALM_DataPathFailuresGet ALM_DataPathFailuresGet_t;
-
-/** Message ID for CMD_PTM_BC0_StatsNE_Get */
-#define CMD_PTM_BC0_STATSNE_GET 0x2D0A
-
-/**
-   Requests the values of the near-end PTM data path performance counters for
-   bearer channel 0 (BC0) as defined in G.997.1 (Section 7.2.5.1. of [11]).The
-   counters are total counters.
-*/
-typedef struct CMD_PTM_BC0_StatsNE_Get CMD_PTM_BC0_StatsNE_Get_t;
-
-/** Message ID for ACK_PTM_BC0_StatsNE_Get */
-#define ACK_PTM_BC0_STATSNE_GET 0x2D0A
-
-/**
-   Delivers the near-end total TPS-TC counter values for bearer channel 0 (BC0)
-   as requested by CMD_PTM_BC0_StatsNE_Get. (Section 7.2.5.1. of [11])
-*/
-typedef struct ACK_PTM_BC0_StatsNE_Get ACK_PTM_BC0_StatsNE_Get_t;
-
-/** Message ID for CMD_PTM_BC0_StatsNE_Set */
-#define CMD_PTM_BC0_STATSNE_SET 0x2D4A
-
-/**
-   Writes the TPS-TC CRC error and TPS-TC coding violation counters (Section
-   7.2.5.1. of G.997.1 [11]).Why writing these counters? For "automoding",
-   meaning modems configured to support both ADSL and VDLS with automatic mode
-   selection. The first retrain is always done with an ADSL FW independent of
-   what was loaded before. Therefore, the counters must be saved by the host
-   before destroying them by the FW download and are written back before the
-   next link start of a FW that supports PTM.
-*/
-typedef struct CMD_PTM_BC0_StatsNE_Set CMD_PTM_BC0_StatsNE_Set_t;
-
-/** Message ID for ACK_PTM_BC0_StatsNE_Set */
-#define ACK_PTM_BC0_STATSNE_SET 0x2D4A
-
-/**
-   Acknowledgement for the message CMD_PTM_BC0_StatsNE_Set.
-*/
-typedef struct ACK_PTM_BC0_StatsNE_Set ACK_PTM_BC0_StatsNE_Set_t;
-
-/** Message ID for CMD_ATM_BC0_StatsNE_Get */
-#define CMD_ATM_BC0_STATSNE_GET 0x2E0A
-
-/**
-   This command is used to request the near-end data-path performance counters
-   for BC0 of an ATM-TC link as defined in Section 7.2.4. of G.997.1 [11].
-*/
-typedef struct CMD_ATM_BC0_StatsNE_Get CMD_ATM_BC0_StatsNE_Get_t;
-
-/** Message ID for ACK_ATM_BC0_StatsNE_Get */
-#define ACK_ATM_BC0_STATSNE_GET 0x2E0A
-
-/**
-   Provides the total near-end ATM-TC performance counters for bearer channel 0
-   (BC0) as requested by the command CMD_ATM_BC0_StatsNE_Get.ADSL1/ADSL1 Lite
-   Fast Path reports its ATM -TC counters in this message too.
-*/
-typedef struct ACK_ATM_BC0_StatsNE_Get ACK_ATM_BC0_StatsNE_Get_t;
-
-/** Message ID for CMD_ATM_BC0_StatsFE_Get */
-#define CMD_ATM_BC0_STATSFE_GET 0x330A
-
-/**
-   This command is used to request the far-end data-path performance counters
-   for BC0 of an ATM-TC link as defined in Section 7.2.4.2 of G.997.1 [11].
-*/
-typedef struct CMD_ATM_BC0_StatsFE_Get CMD_ATM_BC0_StatsFE_Get_t;
-
-/** Message ID for ACK_ATM_BC0_StatsFE_Get */
-#define ACK_ATM_BC0_STATSFE_GET 0x330A
-
-/**
-   Provides the total near-end ATM-TC performance counters for bearer channel 0
-   (BC0) as requested by the command CMD_ATM_BC0_StatsFE_Get.
-*/
-typedef struct ACK_ATM_BC0_StatsFE_Get ACK_ATM_BC0_StatsFE_Get_t;
-
-/** Message ID for CMD_ATM_BC0_StatsNE_Set */
-#define CMD_ATM_BC0_STATSNE_SET 0x2E4A
-
-/**
-   Writes the data-path performance counters for bearer channel 0 (BC0) of an
-   ATM-TC link (Section 7.2.4. of G.997.1 [11]).Why writing counters? The ADSL
-   FW of the VRX destroys the performance counters at the beginning of a re-
-   initialization since it starts with a FW download. Therefore the host has to
-   save the counters in FAIL state before triggering a re-init. When
-   reconfiguring the system in RESET state, the host writes the saved values as
-   start values back into the counters. To do this for the ATM-TC counters, this
-   message is used.
-*/
-typedef struct CMD_ATM_BC0_StatsNE_Set CMD_ATM_BC0_StatsNE_Set_t;
-
-/** Message ID for ACK_ATM_BC0_StatsNE_Set */
-#define ACK_ATM_BC0_STATSNE_SET 0x2E4A
-
-/**
-   Acknowledgement for the message CMD_ATM_BC0_StatsNE_Set.
-*/
-typedef struct ACK_ATM_BC0_StatsNE_Set ACK_ATM_BC0_StatsNE_Set_t;
-
-/** Message ID for CMD_ATM_BC0_TxStatsNE_Get */
-#define CMD_ATM_BC0_TXSTATSNE_GET 0x350A
-
-/**
-   Requests near-end ATM datapath performance transmit counters for bearer
-   channel 0 (BC0).
-*/
-typedef struct CMD_ATM_BC0_TxStatsNE_Get CMD_ATM_BC0_TxStatsNE_Get_t;
-
-/** Message ID for ACK_ATM_BC0_TxStatsNE_Get */
-#define ACK_ATM_BC0_TXSTATSNE_GET 0x350A
-
-/**
-   Provides the ATM-TC transmit counters for beare channel 0 (BC0) as requested
-   by the command CMD_ATM_BC0_TxStatsNE_Get.ADSL1/ADSL1 Lite Fast Path reports
-   its ATM -TC counters in this message too.
-*/
-typedef struct ACK_ATM_BC0_TxStatsNE_Get ACK_ATM_BC0_TxStatsNE_Get_t;
-
-/** Message ID for CMD_ATM_BC0_TxStatsNE_Set */
-#define CMD_ATM_BC0_TXSTATSNE_SET 0x354A
-
-/**
-   Writes the transmit data-path counters for BC0 of an ATM-TC link.For "Why
-   writing performance counters" see Page 669.
-*/
-typedef struct CMD_ATM_BC0_TxStatsNE_Set CMD_ATM_BC0_TxStatsNE_Set_t;
-
-/** Message ID for ACK_ATM_BC0_TxStatsNE_Set */
-#define ACK_ATM_BC0_TXSTATSNE_SET 0x354A
-
-/**
-   Acknowledgement for the message CMD_ATM_BC0_TxStatsNE_Set.
-*/
-typedef struct ACK_ATM_BC0_TxStatsNE_Set ACK_ATM_BC0_TxStatsNE_Set_t;
-
-/** Message ID for CMD_VersionInfoGet */
-#define CMD_VERSIONINFOGET 0x0010
-
-/**
-   Requests version information from the VDSL2-Modem.
-*/
-typedef struct CMD_VersionInfoGet CMD_VersionInfoGet_t;
-
-/** Message ID for ACK_VersionInfoGet */
-#define ACK_VERSIONINFOGET 0x0010
-
-/**
-   Provides version information about hardware and firmware. The FW version
-   numbering scheme has a long and a short form (Table 368).
-*/
-typedef struct ACK_VersionInfoGet ACK_VersionInfoGet_t;
-
-/** Message ID for CMD_PPA_FwVersionSet */
-#define CMD_PPA_FWVERSIONSET 0x2362
-
-/**
-   Writes the PPA subsystem version to the DSL FW.
-*/
-typedef struct CMD_PPA_FwVersionSet CMD_PPA_FwVersionSet_t;
-
-/** Message ID for ACK_PPA_FwVersionSet */
-#define ACK_PPA_FWVERSIONSET 0x2362
-
-/**
-   Acknowledgement for message CMD_PPA_FwVersionSet.
-*/
-typedef struct ACK_PPA_FwVersionSet ACK_PPA_FwVersionSet_t;
-
-/** Message ID for CMD_PPA_FwVersionGet */
-#define CMD_PPA_FWVERSIONGET 0x2322
-
-/**
-   Requests the PPA Subsystem Version number (Read-back).
-*/
-typedef struct CMD_PPA_FwVersionGet CMD_PPA_FwVersionGet_t;
-
-/** Message ID for ACK_PPA_FwVersionGet */
-#define ACK_PPA_FWVERSIONGET 0x2322
-
-/**
-   Provides the PPA subsystem version. Read back of the value previously written
-   by CMD_PPA_FwVersionSet.
-*/
-typedef struct ACK_PPA_FwVersionGet ACK_PPA_FwVersionGet_t;
-
-/** Message ID for CMD_PPE_FwVersionGet */
-#define CMD_PPE_FWVERSIONGET 0x2422
-
-/**
-   Requests the PPE FW Version number.
-*/
-typedef struct CMD_PPE_FwVersionGet CMD_PPE_FwVersionGet_t;
-
-/** Message ID for ACK_PPE_FwVersionGet */
-#define ACK_PPE_FWVERSIONGET 0x2422
-
-/**
-   Provides the PPE FW version number.
-*/
-typedef struct ACK_PPE_FwVersionGet ACK_PPE_FwVersionGet_t;
-
-/** Message ID for CMD_ADSL_FeatureMapGet */
-#define CMD_ADSL_FEATUREMAPGET 0x1322
-
-/**
-   Requests the feature map indicating the ADSL FW features supported by this
-   binary.
-*/
-typedef struct CMD_ADSL_FeatureMapGet CMD_ADSL_FeatureMapGet_t;
-
-/** Message ID for ACK_ADSL_FeatureMapGet */
-#define ACK_ADSL_FEATUREMAPGET 0x1322
-
-/**
-   Reports the feature map indicating the ADSL FW features supported by this
-   binary.
-*/
-typedef struct ACK_ADSL_FeatureMapGet ACK_ADSL_FeatureMapGet_t;
-
-/** Message ID for CMD_VDSL_FeatureMapGet */
-#define CMD_VDSL_FEATUREMAPGET 0x1422
-
-/**
-   Requests the feature map indicating the VDSL FW features supported by this
-   binary.
-*/
-typedef struct CMD_VDSL_FeatureMapGet CMD_VDSL_FeatureMapGet_t;
-
-/** Message ID for ACK_VDSL_FeatureMapGet */
-#define ACK_VDSL_FEATUREMAPGET 0x1422
-
-/**
-   Reports the feature map indicating the VDSL FW features supported by this
-   binary.
-*/
-typedef struct ACK_VDSL_FeatureMapGet ACK_VDSL_FeatureMapGet_t;
-
-/** Message ID for CMD_PAF_HS_Control */
-#define CMD_PAF_HS_CONTROL 0x1148
-
-/**
-   The message is used to enable bonding (PAF) and to control the GHS
-   aggregation discovery and aggregation processes. The register numbers
-   referenced refer to IEEE 802.3ah [14], Clause 45.
-*/
-typedef struct CMD_PAF_HS_Control CMD_PAF_HS_Control_t;
-
-/** Message ID for ACK_PAF_HS_Control */
-#define ACK_PAF_HS_CONTROL 0x1148
-
-/**
-   The message acknowledges CMD_PAF_HS_Control.
-*/
-typedef struct ACK_PAF_HS_Control ACK_PAF_HS_Control_t;
-
-/** Message ID for CMD_PAF_HS_ControlGet */
-#define CMD_PAF_HS_CONTROLGET 0x1108
-
-/**
-   The message reads back settings for bonding configured with
-   CMD_PAF_HS_Control.
-*/
-typedef struct CMD_PAF_HS_ControlGet CMD_PAF_HS_ControlGet_t;
-
-/** Message ID for ACK_PAF_HS_ControlGet */
-#define ACK_PAF_HS_CONTROLGET 0x1108
-
-/**
-   The message acknowledges CMD_PAF_HS_ControlGet providing PAF bonding
-   parameters used in handshake as configured with CMD_PAF_HS_Control.
-*/
-typedef struct ACK_PAF_HS_ControlGet ACK_PAF_HS_ControlGet_t;
-
-/** Message ID for CMD_PAF_HS_StatusGet */
-#define CMD_PAF_HS_STATUSGET 0xDD03
-
-/**
-   The message requests aggregation discovery and aggregation status information
-   for EFM bonding.
-*/
-typedef struct CMD_PAF_HS_StatusGet CMD_PAF_HS_StatusGet_t;
-
-/** Message ID for ACK_PAF_HS_StatusGet */
-#define ACK_PAF_HS_STATUSGET 0xDD03
-
-/**
-   The message reports discovery and aggregation status information for EFM
-   bonding after request by CMD_PAF_HS_StatusGet.At the CPE side, the Host SW
-   concludes on a GET request if none of the following 4 bits are set:
-   discoveryClearIfSame, discoverySetIfClear, aggregClear , aggregSet. It does
-   not distinguish between "discovery GET" and "aggregation GET"; in case of any
-   "GET" both the discovery and the aggregation code are sent to the CO with the
-   CLR.
-*/
-typedef struct ACK_PAF_HS_StatusGet ACK_PAF_HS_StatusGet_t;
-
-/** Message ID for CMD_PAF_HS_Continue */
-#define CMD_PAF_HS_CONTINUE 0x0C62
-
-/**
-   The message writes the aggregation discovery code and the aggregation data
-   down to the FW and is used to trigger the CPE-FW to proceed in handshake
-   (sending CLR) after it had been waiting in GHS_BONDING_CLR state for the
-   necessary host interactions to be finished. These actions depend on the
-   request type (see ACK_PAF_HS_StatusGet): the processing of the remote
-   discovery register (for an aggregation discovery "Set If Clear" or "Clear If
-   Same" command) or PME Aggregate register (for an aggregation "Set" or "Clear"
-   command) in the SW and -in any case including a "Get" command - then updating
-   the local representations of both in the FW (which are sent to the CO in a
-   CLR).
-*/
-typedef struct CMD_PAF_HS_Continue CMD_PAF_HS_Continue_t;
-
-/** Message ID for ACK_PAF_HS_Continue */
-#define ACK_PAF_HS_CONTINUE 0x0C62
-
-/**
-   The message acknowledges CMD_PAF_HS_Continue.
-*/
-typedef struct ACK_PAF_HS_Continue ACK_PAF_HS_Continue_t;
-
-/** Message ID for CMD_PAF_PME_ID_Set */
-#define CMD_PAF_PME_ID_SET 0x5948
-
-/**
-   Sets the PME identification number. This number is transferred with the CLR
-   message to the CO.
-*/
-typedef struct CMD_PAF_PME_ID_Set CMD_PAF_PME_ID_Set_t;
-
-/** Message ID for ACK_PAF_PME_ID_Set */
-#define ACK_PAF_PME_ID_SET 0x5948
-
-/**
-   The message acknowledges CMD_PAF_PME_ID_Set.
-*/
-typedef struct ACK_PAF_PME_ID_Set ACK_PAF_PME_ID_Set_t;
-
-/**
-   The message reads the used TC.In ADSL the TC type is selected during G.HS and
-   thus known when entering FULL_INIT. In VDSL it is selected later, during
-   FULL_INIT. Before this point the FW will report the TC as "unknown".
-*/
-struct CMD_TC_StatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reporting of the used TC mode.
-*/
-struct ACK_TC_StatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TC Used */
-   DSL_uint16_t TC;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TC Used */
-   DSL_uint16_t TC;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This autonomous Event reports the to be used TC mode after being known. In R7
-   FW (w.7.x.y.z.a) only generated when enabled in CMD_Misc_ConfigSet TcTypeEvt.
-*/
-struct EVT_TC_StatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TC Used */
-   DSL_uint16_t TC;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TC Used */
-   DSL_uint16_t TC;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message informs the DSL-FW about the currently loaded TC FW driver.
-*/
-struct CMD_TC_FW_InfoSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TC Loaded */
-   DSL_uint16_t loadedTC;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TC Loaded */
-   DSL_uint16_t loadedTC;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_TC_FW_InfoSet.
-*/
-struct ACK_TC_FW_InfoSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message configures Ethernet properties, currently the MAC address of the
-   device only.The MAC address is needed in the FW as "MAC source address"for
-   PDUs not built by the host, like e.g. for the Ethernet encapsulated
-   Backchannel Data ERB in Vectoring.
-*/
-struct CMD_MAC_FrameConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Source MAC Address Octets 0 to 1 */
-   DSL_uint16_t SrcMacAddrB0_1;
-   /** Source MAC Address Octets 2 to 3 */
-   DSL_uint16_t SrcMacAddrB2_3;
-   /** Source MAC Address Octets 4 to 5 */
-   DSL_uint16_t SrcMacAddrB4_5;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Source MAC Address Octets 0 to 1 */
-   DSL_uint16_t SrcMacAddrB0_1;
-   /** Source MAC Address Octets 2 to 3 */
-   DSL_uint16_t SrcMacAddrB2_3;
-   /** Source MAC Address Octets 4 to 5 */
-   DSL_uint16_t SrcMacAddrB4_5;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_MAC_FrameConfigure.
-*/
-struct ACK_MAC_FrameConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Enables/Disables the generation of ALARM messages (ALM) for specific data-
-   path failures. If the corresponding Enable bit for a failure is set, then the
-   modem firmware will send an autonomous message ALM_DataPathFailuresGet if
-   this failure occurs.
-*/
-struct CMD_DataPathFailuresAlarmConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 6;
-   /** OOS Failure FE, BC0 */
-   DSL_uint16_t OOS_FE_BC1 : 1;
-   /** OOS Failure FE, BC0 */
-   DSL_uint16_t OOS_FE_BC0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 6;
-   /** OOS Failure NE, BC1 */
-   DSL_uint16_t OOS_NE_BC1 : 1;
-   /** OOS Failure NE, BC0 */
-   DSL_uint16_t OOS_NE_BC0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 4;
-   /** LCD Failure FE, BC1 */
-   DSL_uint16_t LCD_FE_BC1 : 1;
-   /** NCD Failure FE, BC1 */
-   DSL_uint16_t NCD_FE_BC1 : 1;
-   /** LCD Failure FE, BC0 */
-   DSL_uint16_t LCD_FE_BC0 : 1;
-   /** NCD Failure FE, BC0 */
-   DSL_uint16_t NCD_FE_BC0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res3 : 4;
-   /** LCD Failure NE, BC1 */
-   DSL_uint16_t LCD_NE_BC1 : 1;
-   /** NCD Failure NE, BC1 */
-   DSL_uint16_t NCD_NE_BC1 : 1;
-   /** LCD Failure NE, BC0 */
-   DSL_uint16_t LCD_NE_BC0 : 1;
-   /** NCD Failure NE, BC0 */
-   DSL_uint16_t NCD_NE_BC0 : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** OOS Failure NE, BC0 */
-   DSL_uint16_t OOS_NE_BC0 : 1;
-   /** OOS Failure NE, BC1 */
-   DSL_uint16_t OOS_NE_BC1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 6;
-   /** OOS Failure FE, BC0 */
-   DSL_uint16_t OOS_FE_BC0 : 1;
-   /** OOS Failure FE, BC0 */
-   DSL_uint16_t OOS_FE_BC1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 6;
-   /** NCD Failure NE, BC0 */
-   DSL_uint16_t NCD_NE_BC0 : 1;
-   /** LCD Failure NE, BC0 */
-   DSL_uint16_t LCD_NE_BC0 : 1;
-   /** NCD Failure NE, BC1 */
-   DSL_uint16_t NCD_NE_BC1 : 1;
-   /** LCD Failure NE, BC1 */
-   DSL_uint16_t LCD_NE_BC1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res3 : 4;
-   /** NCD Failure FE, BC0 */
-   DSL_uint16_t NCD_FE_BC0 : 1;
-   /** LCD Failure FE, BC0 */
-   DSL_uint16_t LCD_FE_BC0 : 1;
-   /** NCD Failure FE, BC1 */
-   DSL_uint16_t NCD_FE_BC1 : 1;
-   /** LCD Failure FE, BC1 */
-   DSL_uint16_t LCD_FE_BC1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 4;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement to CMD_DataPathFailuresAlarmConfigure.
-*/
-struct ACK_DataPathFailuresAlarmConfigure
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the data-path failure status.
-*/
-struct CMD_DataPathFailuresGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the data path failure status as requested by the command
-   CMD_DataPathFailuresGet.
-*/
-struct ACK_DataPathFailuresGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 6;
-   /** OOS Failure FE, BC0 */
-   DSL_uint16_t OOS_FE_BC1 : 1;
-   /** OOS Failure FE, BC0 */
-   DSL_uint16_t OOS_FE_BC0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 6;
-   /** OOS Failure NE, BC1 */
-   DSL_uint16_t OOS_NE_BC1 : 1;
-   /** OOS Failure NE, BC0 */
-   DSL_uint16_t OOS_NE_BC0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 4;
-   /** LCD Failure FE, BC1 */
-   DSL_uint16_t LCD_FE_BC1 : 1;
-   /** NCD Failure FE, BC1 */
-   DSL_uint16_t NCD_FE_BC1 : 1;
-   /** LCD Failure FE, BC0 */
-   DSL_uint16_t LCD_FE_BC0 : 1;
-   /** NCD Failure FE, BC0 */
-   DSL_uint16_t NCD_FE_BC0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res3 : 4;
-   /** LCD Failure NE, BC1 */
-   DSL_uint16_t LCD_NE_BC1 : 1;
-   /** NCD Failure NE, BC1 */
-   DSL_uint16_t NCD_NE_BC1 : 1;
-   /** LCD Failure NE, BC0 */
-   DSL_uint16_t LCD_NE_BC0 : 1;
-   /** NCD Failure NE, BC0 */
-   DSL_uint16_t NCD_NE_BC0 : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** OOS Failure NE, BC0 */
-   DSL_uint16_t OOS_NE_BC0 : 1;
-   /** OOS Failure NE, BC1 */
-   DSL_uint16_t OOS_NE_BC1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 6;
-   /** OOS Failure FE, BC0 */
-   DSL_uint16_t OOS_FE_BC0 : 1;
-   /** OOS Failure FE, BC0 */
-   DSL_uint16_t OOS_FE_BC1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 6;
-   /** NCD Failure NE, BC0 */
-   DSL_uint16_t NCD_NE_BC0 : 1;
-   /** LCD Failure NE, BC0 */
-   DSL_uint16_t LCD_NE_BC0 : 1;
-   /** NCD Failure NE, BC1 */
-   DSL_uint16_t NCD_NE_BC1 : 1;
-   /** LCD Failure NE, BC1 */
-   DSL_uint16_t LCD_NE_BC1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res3 : 4;
-   /** NCD Failure FE, BC0 */
-   DSL_uint16_t NCD_FE_BC0 : 1;
-   /** LCD Failure FE, BC0 */
-   DSL_uint16_t LCD_FE_BC0 : 1;
-   /** NCD Failure FE, BC1 */
-   DSL_uint16_t NCD_FE_BC1 : 1;
-   /** LCD Failure FE, BC1 */
-   DSL_uint16_t LCD_FE_BC1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 4;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This autonomous message reports the data-path failure status. It is sent only
-   if the message generation was enabled for the corresponding failure with
-   CMD_DataPathFailuresAlarmConfigure.
-*/
-struct ALM_DataPathFailuresGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 6;
-   /** OOS Failure FE, BC0 */
-   DSL_uint16_t OOS_FE_BC1 : 1;
-   /** OOS Failure FE, BC0 */
-   DSL_uint16_t OOS_FE_BC0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 6;
-   /** OOS Failure NE, BC1 */
-   DSL_uint16_t OOS_NE_BC1 : 1;
-   /** OOS Failure NE, BC0 */
-   DSL_uint16_t OOS_NE_BC0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 4;
-   /** LCD Failure FE, BC1 */
-   DSL_uint16_t LCD_FE_BC1 : 1;
-   /** NCD Failure FE, BC1 */
-   DSL_uint16_t NCD_FE_BC1 : 1;
-   /** LCD Failure FE, BC0 */
-   DSL_uint16_t LCD_FE_BC0 : 1;
-   /** NCD Failure FE, BC0 */
-   DSL_uint16_t NCD_FE_BC0 : 1;
-   /** Reserved */
-   DSL_uint16_t Res3 : 4;
-   /** LCD Failure NE, BC1 */
-   DSL_uint16_t LCD_NE_BC1 : 1;
-   /** NCD Failure NE, BC1 */
-   DSL_uint16_t NCD_NE_BC1 : 1;
-   /** LCD Failure NE, BC0 */
-   DSL_uint16_t LCD_NE_BC0 : 1;
-   /** NCD Failure NE, BC0 */
-   DSL_uint16_t NCD_NE_BC0 : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** OOS Failure NE, BC0 */
-   DSL_uint16_t OOS_NE_BC0 : 1;
-   /** OOS Failure NE, BC1 */
-   DSL_uint16_t OOS_NE_BC1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 6;
-   /** OOS Failure FE, BC0 */
-   DSL_uint16_t OOS_FE_BC0 : 1;
-   /** OOS Failure FE, BC0 */
-   DSL_uint16_t OOS_FE_BC1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 6;
-   /** NCD Failure NE, BC0 */
-   DSL_uint16_t NCD_NE_BC0 : 1;
-   /** LCD Failure NE, BC0 */
-   DSL_uint16_t LCD_NE_BC0 : 1;
-   /** NCD Failure NE, BC1 */
-   DSL_uint16_t NCD_NE_BC1 : 1;
-   /** LCD Failure NE, BC1 */
-   DSL_uint16_t LCD_NE_BC1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res3 : 4;
-   /** NCD Failure FE, BC0 */
-   DSL_uint16_t NCD_FE_BC0 : 1;
-   /** LCD Failure FE, BC0 */
-   DSL_uint16_t LCD_FE_BC0 : 1;
-   /** NCD Failure FE, BC1 */
-   DSL_uint16_t NCD_FE_BC1 : 1;
-   /** LCD Failure FE, BC1 */
-   DSL_uint16_t LCD_FE_BC1 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 4;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the values of the near-end PTM data path performance counters for
-   bearer channel 0 (BC0) as defined in G.997.1 (Section 7.2.5.1. of [11]).The
-   counters are total counters.
-*/
-struct CMD_PTM_BC0_StatsNE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Delivers the near-end total TPS-TC counter values for bearer channel 0 (BC0)
-   as requested by CMD_PTM_BC0_StatsNE_Get. (Section 7.2.5.1. of [11])
-*/
-struct ACK_PTM_BC0_StatsNE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TPS-TC CRC Counter (CRC-P), NE, BC0, LSW */
-   DSL_uint16_t cntCRC_LSW;
-   /** TPS-TC CRC Counter (CRC-P), NE, BC0, MSW */
-   DSL_uint16_t cntCRC_MSW;
-   /** TPS-TC CV Counter (CV-P), NE, BC0, LSW */
-   DSL_uint16_t cntCV_LSW;
-   /** TPS-TC CV Counter (CV-P), NE, BC0, MSW */
-   DSL_uint16_t cntCV_MSW;
-   /** TPS-TC CRC Counter (CRCP-P), NE, BC0, LSW */
-   DSL_uint16_t cntCRCP_LSW;
-   /** TPS-TC CRC Counter (CRCP-P), NE, BC0, MSW */
-   DSL_uint16_t cntCRCP_MSW;
-   /** TPS-TC CV Counter (CVP-P), NE, BC0, LSW */
-   DSL_uint16_t cntCVP_LSW;
-   /** TPS-TC CV Counter (CVP-P), NE, BC0, MSW */
-   DSL_uint16_t cntCVP_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TPS-TC CRC Counter (CRC-P), NE, BC0, LSW */
-   DSL_uint16_t cntCRC_LSW;
-   /** TPS-TC CRC Counter (CRC-P), NE, BC0, MSW */
-   DSL_uint16_t cntCRC_MSW;
-   /** TPS-TC CV Counter (CV-P), NE, BC0, LSW */
-   DSL_uint16_t cntCV_LSW;
-   /** TPS-TC CV Counter (CV-P), NE, BC0, MSW */
-   DSL_uint16_t cntCV_MSW;
-   /** TPS-TC CRC Counter (CRCP-P), NE, BC0, LSW */
-   DSL_uint16_t cntCRCP_LSW;
-   /** TPS-TC CRC Counter (CRCP-P), NE, BC0, MSW */
-   DSL_uint16_t cntCRCP_MSW;
-   /** TPS-TC CV Counter (CVP-P), NE, BC0, LSW */
-   DSL_uint16_t cntCVP_LSW;
-   /** TPS-TC CV Counter (CVP-P), NE, BC0, MSW */
-   DSL_uint16_t cntCVP_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Writes the TPS-TC CRC error and TPS-TC coding violation counters (Section
-   7.2.5.1. of G.997.1 [11]).Why writing these counters? For "automoding",
-   meaning modems configured to support both ADSL and VDLS with automatic mode
-   selection. The first retrain is always done with an ADSL FW independent of
-   what was loaded before. Therefore, the counters must be saved by the host
-   before destroying them by the FW download and are written back before the
-   next link start of a FW that supports PTM.
-*/
-struct CMD_PTM_BC0_StatsNE_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TPS-TC CRC Counter (CRC-P), NE, BC0, LSW */
-   DSL_uint16_t cntCRC_LSW;
-   /** TPS-TC CRC Counter (CRC-P), NE, BC0, MSW */
-   DSL_uint16_t cntCRC_MSW;
-   /** TPS-TC CV Counter (CV-P), NE, BC0, LSW */
-   DSL_uint16_t cntCV_LSW;
-   /** TPS-TC CV Counter (CV-P), NE, BC0, MSW */
-   DSL_uint16_t cntCV_MSW;
-   /** TPS-TC CRC Counter (CRCP-P), NE, BC0, LSW */
-   DSL_uint16_t cntCRCP_LSW;
-   /** TPS-TC CRC Counter (CRCP-P), NE, BC0, MSW */
-   DSL_uint16_t cntCRCP_MSW;
-   /** TPS-TC CV Counter (CVP-P), NE, BC0, LSW */
-   DSL_uint16_t cntCVP_LSW;
-   /** TPS-TC CV Counter (CVP-P), NE, BC0, MSW */
-   DSL_uint16_t cntCVP_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** TPS-TC CRC Counter (CRC-P), NE, BC0, LSW */
-   DSL_uint16_t cntCRC_LSW;
-   /** TPS-TC CRC Counter (CRC-P), NE, BC0, MSW */
-   DSL_uint16_t cntCRC_MSW;
-   /** TPS-TC CV Counter (CV-P), NE, BC0, LSW */
-   DSL_uint16_t cntCV_LSW;
-   /** TPS-TC CV Counter (CV-P), NE, BC0, MSW */
-   DSL_uint16_t cntCV_MSW;
-   /** TPS-TC CRC Counter (CRCP-P), NE, BC0, LSW */
-   DSL_uint16_t cntCRCP_LSW;
-   /** TPS-TC CRC Counter (CRCP-P), NE, BC0, MSW */
-   DSL_uint16_t cntCRCP_MSW;
-   /** TPS-TC CV Counter (CVP-P), NE, BC0, LSW */
-   DSL_uint16_t cntCVP_LSW;
-   /** TPS-TC CV Counter (CVP-P), NE, BC0, MSW */
-   DSL_uint16_t cntCVP_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for the message CMD_PTM_BC0_StatsNE_Set.
-*/
-struct ACK_PTM_BC0_StatsNE_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This command is used to request the near-end data-path performance counters
-   for BC0 of an ATM-TC link as defined in Section 7.2.4. of G.997.1 [11].
-*/
-struct CMD_ATM_BC0_StatsNE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the total near-end ATM-TC performance counters for bearer channel 0
-   (BC0) as requested by the command CMD_ATM_BC0_StatsNE_Get.ADSL1/ADSL1 Lite
-   Fast Path reports its ATM -TC counters in this message too.
-*/
-struct ACK_ATM_BC0_StatsNE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** NE HEC Violation Count (HEC-P), LSW */
-   DSL_uint16_t hecp_LSW;
-   /** NE HEC Violation Count (HEC-P), MSW */
-   DSL_uint16_t hecp_MSW;
-   /** NE Delineated Total Cell Count (CD-P), LSW */
-   DSL_uint16_t cdp_LSW;
-   /** NE Delineated Total Cell Count (CD-P), MSW */
-   DSL_uint16_t cdp_MSW;
-   /** NE User Total Cell Count (CU-P), LSW */
-   DSL_uint16_t cup_LSW;
-   /** NE User Total Cell Count (CU-P), MSW */
-   DSL_uint16_t cup_MSW;
-   /** NE Idle Cell Bit Error Count (IBE-P), LSW */
-   DSL_uint16_t ibep_LSW;
-   /** NE Idle Cell Bit Error Count (IBE-P), MSW */
-   DSL_uint16_t ibep_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** NE HEC Violation Count (HEC-P), LSW */
-   DSL_uint16_t hecp_LSW;
-   /** NE HEC Violation Count (HEC-P), MSW */
-   DSL_uint16_t hecp_MSW;
-   /** NE Delineated Total Cell Count (CD-P), LSW */
-   DSL_uint16_t cdp_LSW;
-   /** NE Delineated Total Cell Count (CD-P), MSW */
-   DSL_uint16_t cdp_MSW;
-   /** NE User Total Cell Count (CU-P), LSW */
-   DSL_uint16_t cup_LSW;
-   /** NE User Total Cell Count (CU-P), MSW */
-   DSL_uint16_t cup_MSW;
-   /** NE Idle Cell Bit Error Count (IBE-P), LSW */
-   DSL_uint16_t ibep_LSW;
-   /** NE Idle Cell Bit Error Count (IBE-P), MSW */
-   DSL_uint16_t ibep_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   This command is used to request the far-end data-path performance counters
-   for BC0 of an ATM-TC link as defined in Section 7.2.4.2 of G.997.1 [11].
-*/
-struct CMD_ATM_BC0_StatsFE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the total near-end ATM-TC performance counters for bearer channel 0
-   (BC0) as requested by the command CMD_ATM_BC0_StatsFE_Get.
-*/
-struct ACK_ATM_BC0_StatsFE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** FE HEC Violation Count (HEC-PFE), LSW */
-   DSL_uint16_t hecpfe_LSW;
-   /** FE HEC Violation Count (HEC-PFE), MSW */
-   DSL_uint16_t hecpfe_MSW;
-   /** FE Delineated Total Cell Count (CD-PFE), LSW */
-   DSL_uint16_t cdpfe_LSW;
-   /** FE Delineated Total Cell Count (CD-PFE), MSW */
-   DSL_uint16_t cdpfe_MSW;
-   /** FE User Total Cell Count (CU-PFE), LSW */
-   DSL_uint16_t cupfe_LSW;
-   /** FE User Total Cell Count (CU-PFE), MSW */
-   DSL_uint16_t cupfe_MSW;
-   /** FE Idle Cell Bit Error Count (IBE-PFE), LSW */
-   DSL_uint16_t ibepfe_LSW;
-   /** FE Idle Cell Bit Error Count (IBE-PFE), MSW */
-   DSL_uint16_t ibepfe_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** FE HEC Violation Count (HEC-PFE), LSW */
-   DSL_uint16_t hecpfe_LSW;
-   /** FE HEC Violation Count (HEC-PFE), MSW */
-   DSL_uint16_t hecpfe_MSW;
-   /** FE Delineated Total Cell Count (CD-PFE), LSW */
-   DSL_uint16_t cdpfe_LSW;
-   /** FE Delineated Total Cell Count (CD-PFE), MSW */
-   DSL_uint16_t cdpfe_MSW;
-   /** FE User Total Cell Count (CU-PFE), LSW */
-   DSL_uint16_t cupfe_LSW;
-   /** FE User Total Cell Count (CU-PFE), MSW */
-   DSL_uint16_t cupfe_MSW;
-   /** FE Idle Cell Bit Error Count (IBE-PFE), LSW */
-   DSL_uint16_t ibepfe_LSW;
-   /** FE Idle Cell Bit Error Count (IBE-PFE), MSW */
-   DSL_uint16_t ibepfe_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Writes the data-path performance counters for bearer channel 0 (BC0) of an
-   ATM-TC link (Section 7.2.4. of G.997.1 [11]).Why writing counters? The ADSL
-   FW of the VRX destroys the performance counters at the beginning of a re-
-   initialization since it starts with a FW download. Therefore the host has to
-   save the counters in FAIL state before triggering a re-init. When
-   reconfiguring the system in RESET state, the host writes the saved values as
-   start values back into the counters. To do this for the ATM-TC counters, this
-   message is used.
-*/
-struct CMD_ATM_BC0_StatsNE_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** NE HEC Violation Count (HEC-P), LSW */
-   DSL_uint16_t hecp_LSW;
-   /** NE HEC Violation Count (HEC-P), MSW */
-   DSL_uint16_t hecp_MSW;
-   /** NE Delineated Total Cell Count (CD-P), LSW */
-   DSL_uint16_t cdp_LSW;
-   /** NE Delineated Total Cell Count (CD-P), MSW */
-   DSL_uint16_t cdp_MSW;
-   /** NE User Total Cell Count (CU-P), LSW */
-   DSL_uint16_t cup_LSW;
-   /** NE User Total Cell Count (CU-P), MSW */
-   DSL_uint16_t cup_MSW;
-   /** NE Idle Cell Bit Error Count (IBE-P), LSW */
-   DSL_uint16_t ibep_LSW;
-   /** NE Idle Cell Bit Error Count (IBE-P), MSW */
-   DSL_uint16_t ibep_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** NE HEC Violation Count (HEC-P), LSW */
-   DSL_uint16_t hecp_LSW;
-   /** NE HEC Violation Count (HEC-P), MSW */
-   DSL_uint16_t hecp_MSW;
-   /** NE Delineated Total Cell Count (CD-P), LSW */
-   DSL_uint16_t cdp_LSW;
-   /** NE Delineated Total Cell Count (CD-P), MSW */
-   DSL_uint16_t cdp_MSW;
-   /** NE User Total Cell Count (CU-P), LSW */
-   DSL_uint16_t cup_LSW;
-   /** NE User Total Cell Count (CU-P), MSW */
-   DSL_uint16_t cup_MSW;
-   /** NE Idle Cell Bit Error Count (IBE-P), LSW */
-   DSL_uint16_t ibep_LSW;
-   /** NE Idle Cell Bit Error Count (IBE-P), MSW */
-   DSL_uint16_t ibep_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for the message CMD_ATM_BC0_StatsNE_Set.
-*/
-struct ACK_ATM_BC0_StatsNE_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests near-end ATM datapath performance transmit counters for bearer
-   channel 0 (BC0).
-*/
-struct CMD_ATM_BC0_TxStatsNE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the ATM-TC transmit counters for beare channel 0 (BC0) as requested
-   by the command CMD_ATM_BC0_TxStatsNE_Get.ADSL1/ADSL1 Lite Fast Path reports
-   its ATM -TC counters in this message too.
-*/
-struct ACK_ATM_BC0_TxStatsNE_Get
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-end TX User Cell Count (TxCU), Current Period, LSW */
-   DSL_uint16_t TxCU_LSW;
-   /** Near-end TX User Cell Count (TxCU), Current Period, MSW */
-   DSL_uint16_t TxCU_MSW;
-   /** Near-end TX Idle Cell Count (TxIdle), Current Period, LSW */
-   DSL_uint16_t TxIdle_LSW;
-   /** Near-end TX Idle Cell Count (TxIdle), Current Period, MSW */
-   DSL_uint16_t TxIdle_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-end TX User Cell Count (TxCU), Current Period, LSW */
-   DSL_uint16_t TxCU_LSW;
-   /** Near-end TX User Cell Count (TxCU), Current Period, MSW */
-   DSL_uint16_t TxCU_MSW;
-   /** Near-end TX Idle Cell Count (TxIdle), Current Period, LSW */
-   DSL_uint16_t TxIdle_LSW;
-   /** Near-end TX Idle Cell Count (TxIdle), Current Period, MSW */
-   DSL_uint16_t TxIdle_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Writes the transmit data-path counters for BC0 of an ATM-TC link.For "Why
-   writing performance counters" see Page 669.
-*/
-struct CMD_ATM_BC0_TxStatsNE_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-end TX User Cell Count (TxCU), Current Period, LSW */
-   DSL_uint16_t TxCU_LSW;
-   /** Near-end TX User Cell Count (TxCU), Current Period, MSW */
-   DSL_uint16_t TxCU_MSW;
-   /** Near-end TX Idle Cell Count (TxIdle), Current Period, LSW */
-   DSL_uint16_t TxIdle_LSW;
-   /** Near-end TX Idle Cell Count (TxIdle), Current Period, MSW */
-   DSL_uint16_t TxIdle_MSW;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Near-end TX User Cell Count (TxCU), Current Period, LSW */
-   DSL_uint16_t TxCU_LSW;
-   /** Near-end TX User Cell Count (TxCU), Current Period, MSW */
-   DSL_uint16_t TxCU_MSW;
-   /** Near-end TX Idle Cell Count (TxIdle), Current Period, LSW */
-   DSL_uint16_t TxIdle_LSW;
-   /** Near-end TX Idle Cell Count (TxIdle), Current Period, MSW */
-   DSL_uint16_t TxIdle_MSW;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for the message CMD_ATM_BC0_TxStatsNE_Set.
-*/
-struct ACK_ATM_BC0_TxStatsNE_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests version information from the VDSL2-Modem.
-*/
-struct CMD_VersionInfoGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides version information about hardware and firmware. The FW version
-   numbering scheme has a long and a short form (Table 368).
-*/
-struct ACK_VersionInfoGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Hardware Version Number */
-   DSL_uint32_t HW_Version;
-   /** Reserved */
-   DSL_uint32_t Res0;
-   /** Firmware Version Number (Long) */
-   DSL_uint32_t FW_Version;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Hardware Version Number */
-   DSL_uint32_t HW_Version;
-   /** Reserved */
-   DSL_uint32_t Res0;
-   /** Firmware Version Number (Long) */
-   DSL_uint32_t FW_Version;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Writes the PPA subsystem version to the DSL FW.
-*/
-struct CMD_PPA_FwVersionSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PPA Subsystem Version Number, LSW, 3. Digit */
-   DSL_uint16_t SubSysVer3 : 8;
-   /** PPA Subsystem Version Number, LSW, 4. Digit */
-   DSL_uint16_t SubSysVer4 : 8;
-   /** PPA Subsystem Version Number, MSW, 1. Digit */
-   DSL_uint16_t SubSysVer1 : 8;
-   /** PPA Subsystem Version Number, MSW, 2. Digit */
-   DSL_uint16_t SubSysVer2 : 8;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PPA Subsystem Version Number, LSW, 4. Digit */
-   DSL_uint16_t SubSysVer4 : 8;
-   /** PPA Subsystem Version Number, LSW, 3. Digit */
-   DSL_uint16_t SubSysVer3 : 8;
-   /** PPA Subsystem Version Number, MSW, 2. Digit */
-   DSL_uint16_t SubSysVer2 : 8;
-   /** PPA Subsystem Version Number, MSW, 1. Digit */
-   DSL_uint16_t SubSysVer1 : 8;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Acknowledgement for message CMD_PPA_FwVersionSet.
-*/
-struct ACK_PPA_FwVersionSet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the PPA Subsystem Version number (Read-back).
-*/
-struct CMD_PPA_FwVersionGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the PPA subsystem version. Read back of the value previously written
-   by CMD_PPA_FwVersionSet.
-*/
-struct ACK_PPA_FwVersionGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PPA Subsystem Version Number, LSW, 3. Digit */
-   DSL_uint16_t SubSysVer3 : 8;
-   /** PPA Subsystem Version Number, LSW, 4. Digit */
-   DSL_uint16_t SubSysVer4 : 8;
-   /** PPA Subsystem Version Number, MSW, 1. Digit */
-   DSL_uint16_t SubSysVer1 : 8;
-   /** PPA Subsystem Version Number, MSW, 2. Digit */
-   DSL_uint16_t SubSysVer2 : 8;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PPA Subsystem Version Number, LSW, 4. Digit */
-   DSL_uint16_t SubSysVer4 : 8;
-   /** PPA Subsystem Version Number, LSW, 3. Digit */
-   DSL_uint16_t SubSysVer3 : 8;
-   /** PPA Subsystem Version Number, MSW, 2. Digit */
-   DSL_uint16_t SubSysVer2 : 8;
-   /** PPA Subsystem Version Number, MSW, 1. Digit */
-   DSL_uint16_t SubSysVer1 : 8;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the PPE FW Version number.
-*/
-struct CMD_PPE_FwVersionGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Provides the PPE FW version number.
-*/
-struct ACK_PPE_FwVersionGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 8;
-   /** PPE FW Version Number, 1. Digit */
-   DSL_uint16_t PpeFwVer1 : 8;
-   /** PPE FW Version Number, 2. Digit */
-   DSL_uint16_t PpeFwVer2 : 8;
-   /** PPE FW Version Number, 3. Digit */
-   DSL_uint16_t PpeFwVer3 : 8;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PPE FW Version Number, 1. Digit */
-   DSL_uint16_t PpeFwVer1 : 8;
-   /** Reserved */
-   DSL_uint16_t Res0 : 8;
-   /** PPE FW Version Number, 3. Digit */
-   DSL_uint16_t PpeFwVer3 : 8;
-   /** PPE FW Version Number, 2. Digit */
-   DSL_uint16_t PpeFwVer2 : 8;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the feature map indicating the ADSL FW features supported by this
-   binary.
-*/
-struct CMD_ADSL_FeatureMapGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reports the feature map indicating the ADSL FW features supported by this
-   binary.
-*/
-struct ACK_ADSL_FeatureMapGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Feature Map Length */
-   DSL_uint16_t FeatMapLen;
-   /** Reserved */
-   DSL_uint16_t Res0 : 3;
-   /** Feature-Bit12  */
-   DSL_uint16_t W0F12 : 1;
-   /** Feature-Bit11 of Word 0: NTR */
-   DSL_uint16_t W0F11 : 1;
-   /** Feature-Bit10 of Word 0:  CIPolicy */
-   DSL_uint16_t W0F10 : 1;
-   /** Feature-Bit9 of Word 0:  Pre-emption & Short Packets  */
-   DSL_uint16_t W0F09 : 1;
-   /** Feature-Bit8 of Word 0:  Counter Inhibiting */
-   DSL_uint16_t W0F08 : 1;
-   /** Feature-Bit7 of Word 0: Short Init */
-   DSL_uint16_t W0F07 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 1;
-   /** Feature-Bit5 of Word 0:  G.INP Retransmission DS + SRA */
-   DSL_uint16_t W0F05 : 1;
-   /** Feature-Bit4 of Word 0:  G.INP Retransmission DS + Bonding (EFM) */
-   DSL_uint16_t W0F04 : 1;
-   /** Feature-Bit3 of Word 0:PTM Off-chip Bonding BACP */
-   DSL_uint16_t W0F03 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 2;
-   /** Feature-Bit0 of Word 0: Annex I */
-   DSL_uint16_t W0F00 : 1;
-   /** Reserved */
-   DSL_uint16_t Res3 : 16;
-   /** Reserved  */
-   DSL_uint16_t Res4 : 16;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Feature Map Length */
-   DSL_uint16_t FeatMapLen;
-   /** Feature-Bit0 of Word 0: Annex I */
-   DSL_uint16_t W0F00 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 2;
-   /** Feature-Bit3 of Word 0:PTM Off-chip Bonding BACP */
-   DSL_uint16_t W0F03 : 1;
-   /** Feature-Bit4 of Word 0:  G.INP Retransmission DS + Bonding (EFM) */
-   DSL_uint16_t W0F04 : 1;
-   /** Feature-Bit5 of Word 0:  G.INP Retransmission DS + SRA */
-   DSL_uint16_t W0F05 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 1;
-   /** Feature-Bit7 of Word 0: Short Init */
-   DSL_uint16_t W0F07 : 1;
-   /** Feature-Bit8 of Word 0:  Counter Inhibiting */
-   DSL_uint16_t W0F08 : 1;
-   /** Feature-Bit9 of Word 0:  Pre-emption & Short Packets  */
-   DSL_uint16_t W0F09 : 1;
-   /** Feature-Bit10 of Word 0:  CIPolicy */
-   DSL_uint16_t W0F10 : 1;
-   /** Feature-Bit11 of Word 0: NTR */
-   DSL_uint16_t W0F11 : 1;
-   /** Feature-Bit12  */
-   DSL_uint16_t W0F12 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 3;
-   /** Reserved */
-   DSL_uint16_t Res3 : 16;
-   /** Reserved  */
-   DSL_uint16_t Res4 : 16;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Requests the feature map indicating the VDSL FW features supported by this
-   binary.
-*/
-struct CMD_VDSL_FeatureMapGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Reports the feature map indicating the VDSL FW features supported by this
-   binary.
-*/
-struct ACK_VDSL_FeatureMapGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Feature Map Length */
-   DSL_uint16_t FeatMapLen;
-   /** Reserved */
-   DSL_uint16_t Res0 : 3;
-   /** Feature-Bit12  */
-   DSL_uint16_t W0F12 : 1;
-   /** Feature-Bit11 of Word 0: NTR */
-   DSL_uint16_t W0F11 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 1;
-   /** Feature-Bit9 of Word 0: Pre-emption & Short Packets  */
-   DSL_uint16_t W0F09 : 1;
-   /** Feature-Bit8 of Word 0: Erasure Decoding /FORCEINP */
-   DSL_uint16_t W0F08 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 1;
-   /** Feature-Bit6 of Word 0: Intra DTU Interleaving US */
-   DSL_uint16_t W0F06 : 1;
-   /** Feature-Bit5 of Word 0: Intra DTU Interleaving DS */
-   DSL_uint16_t W0F05 : 1;
-   /** Feature-Bit4 of Word 0: G.INP Retransmission US + DS + PAF (VDSL only) */
-   DSL_uint16_t W0F04 : 1;
-   /** Feature-Bit3 of Word 0: PTM Off-chip Bonding BACP */
-   DSL_uint16_t W0F03 : 1;
-   /** Feature-Bit2 of Word 2: Microfilter Detection and Hybrid Data */
-   DSL_uint16_t W2F02 : 1;
-   /** Reserved */
-   DSL_uint16_t Res3 : 2;
-   /** Reserved */
-   DSL_uint16_t Res4 : 16;
-   /** Reserved  */
-   DSL_uint16_t Res5 : 16;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Feature Map Length */
-   DSL_uint16_t FeatMapLen;
-   /** Reserved */
-   DSL_uint16_t Res3 : 2;
-   /** Feature-Bit2 of Word 2: Microfilter Detection and Hybrid Data */
-   DSL_uint16_t W2F02 : 1;
-   /** Feature-Bit3 of Word 0: PTM Off-chip Bonding BACP */
-   DSL_uint16_t W0F03 : 1;
-   /** Feature-Bit4 of Word 0: G.INP Retransmission US + DS + PAF (VDSL only) */
-   DSL_uint16_t W0F04 : 1;
-   /** Feature-Bit5 of Word 0: Intra DTU Interleaving DS */
-   DSL_uint16_t W0F05 : 1;
-   /** Feature-Bit6 of Word 0: Intra DTU Interleaving US */
-   DSL_uint16_t W0F06 : 1;
-   /** Reserved */
-   DSL_uint16_t Res2 : 1;
-   /** Feature-Bit8 of Word 0: Erasure Decoding /FORCEINP */
-   DSL_uint16_t W0F08 : 1;
-   /** Feature-Bit9 of Word 0: Pre-emption & Short Packets  */
-   DSL_uint16_t W0F09 : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 1;
-   /** Feature-Bit11 of Word 0: NTR */
-   DSL_uint16_t W0F11 : 1;
-   /** Feature-Bit12  */
-   DSL_uint16_t W0F12 : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 3;
-   /** Reserved */
-   DSL_uint16_t Res4 : 16;
-   /** Reserved  */
-   DSL_uint16_t Res5 : 16;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message is used to enable bonding (PAF) and to control the GHS
-   aggregation discovery and aggregation processes. The register numbers
-   referenced refer to IEEE 802.3ah [14], Clause 45.
-*/
-struct CMD_PAF_HS_Control
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 15;
-   /** PCS Control Register (Register 3.61, Bit 0) */
-   DSL_uint16_t PAF_Enable : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PCS Control Register (Register 3.61, Bit 0) */
-   DSL_uint16_t PAF_Enable : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 15;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message acknowledges CMD_PAF_HS_Control.
-*/
-struct ACK_PAF_HS_Control
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message reads back settings for bonding configured with
-   CMD_PAF_HS_Control.
-*/
-struct CMD_PAF_HS_ControlGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message acknowledges CMD_PAF_HS_ControlGet providing PAF bonding
-   parameters used in handshake as configured with CMD_PAF_HS_Control.
-*/
-struct ACK_PAF_HS_ControlGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 15;
-   /** PCS Control Register (Register 3.61, Bit 0) */
-   DSL_uint16_t PAF_Enable : 1;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PCS Control Register (Register 3.61, Bit 0) */
-   DSL_uint16_t PAF_Enable : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 15;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message requests aggregation discovery and aggregation status information
-   for EFM bonding.
-*/
-struct CMD_PAF_HS_StatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message reports discovery and aggregation status information for EFM
-   bonding after request by CMD_PAF_HS_StatusGet.At the CPE side, the Host SW
-   concludes on a GET request if none of the following 4 bits are set:
-   discoveryClearIfSame, discoverySetIfClear, aggregClear , aggregSet. It does
-   not distinguish between "discovery GET" and "aggregation GET"; in case of any
-   "GET" both the discovery and the aggregation code are sent to the CO with the
-   CLR.
-*/
-struct ACK_PAF_HS_StatusGet
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 9;
-   /** Discovery Clear-If-Same */
-   DSL_uint16_t discoveryClearIfSame : 1;
-   /** Discovery Set-If-Clear */
-   DSL_uint16_t discoverySetIfClear : 1;
-   /** Aggregation Clear */
-   DSL_uint16_t aggregClear : 1;
-   /** Aggregation Set */
-   DSL_uint16_t aggregSet : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 2;
-   /** PCS Control Register (Register 3.60, Bit 12) */
-   DSL_uint16_t PAF_Enable : 1;
-   /** Aggregation Discovery Code (Register 6.18) */
-   DSL_uint16_t discoveryCode1;
-   /** Aggregation Discovery Code (Registers 6.19) */
-   DSL_uint16_t discoveryCode2;
-   /** Aggregation Discovery Code (Registers 6.20) */
-   DSL_uint16_t discoveryCode3;
-   /** Partner PME Aggregate Data (Registers 6.22) */
-   DSL_uint16_t aggregateData1;
-   /** Partner PME Aggregate Data (Registers 6.23) */
-   DSL_uint16_t aggregateData2;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PCS Control Register (Register 3.60, Bit 12) */
-   DSL_uint16_t PAF_Enable : 1;
-   /** Reserved */
-   DSL_uint16_t Res1 : 2;
-   /** Aggregation Set */
-   DSL_uint16_t aggregSet : 1;
-   /** Aggregation Clear */
-   DSL_uint16_t aggregClear : 1;
-   /** Discovery Set-If-Clear */
-   DSL_uint16_t discoverySetIfClear : 1;
-   /** Discovery Clear-If-Same */
-   DSL_uint16_t discoveryClearIfSame : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 9;
-   /** Aggregation Discovery Code (Register 6.18) */
-   DSL_uint16_t discoveryCode1;
-   /** Aggregation Discovery Code (Registers 6.19) */
-   DSL_uint16_t discoveryCode2;
-   /** Aggregation Discovery Code (Registers 6.20) */
-   DSL_uint16_t discoveryCode3;
-   /** Partner PME Aggregate Data (Registers 6.22) */
-   DSL_uint16_t aggregateData1;
-   /** Partner PME Aggregate Data (Registers 6.23) */
-   DSL_uint16_t aggregateData2;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message writes the aggregation discovery code and the aggregation data
-   down to the FW and is used to trigger the CPE-FW to proceed in handshake
-   (sending CLR) after it had been waiting in GHS_BONDING_CLR state for the
-   necessary host interactions to be finished. These actions depend on the
-   request type (see ACK_PAF_HS_StatusGet): the processing of the remote
-   discovery register (for an aggregation discovery "Set If Clear" or "Clear If
-   Same" command) or PME Aggregate register (for an aggregation "Set" or "Clear"
-   command) in the SW and -in any case including a "Get" command - then updating
-   the local representations of both in the FW (which are sent to the CO in a
-   CLR).
-*/
-struct CMD_PAF_HS_Continue
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Reserved */
-   DSL_uint16_t Res0 : 15;
-   /** Continue Trigger */
-   DSL_uint16_t trigger : 1;
-   /** Aggregation Discovery Code (Register 6.18) */
-   DSL_uint16_t discoveryCode1;
-   /** Aggregation Discovery Code (Registers 6.19) */
-   DSL_uint16_t discoveryCode2;
-   /** Aggregation Discovery Code (Registers 6.20) */
-   DSL_uint16_t discoveryCode3;
-   /** Partner PME Aggregate Data (Registers 6.22) */
-   DSL_uint16_t aggregateData1;
-   /** Partner PME Aggregate Data (Registers 6.23) */
-   DSL_uint16_t aggregateData2;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** Continue Trigger */
-   DSL_uint16_t trigger : 1;
-   /** Reserved */
-   DSL_uint16_t Res0 : 15;
-   /** Aggregation Discovery Code (Register 6.18) */
-   DSL_uint16_t discoveryCode1;
-   /** Aggregation Discovery Code (Registers 6.19) */
-   DSL_uint16_t discoveryCode2;
-   /** Aggregation Discovery Code (Registers 6.20) */
-   DSL_uint16_t discoveryCode3;
-   /** Partner PME Aggregate Data (Registers 6.22) */
-   DSL_uint16_t aggregateData1;
-   /** Partner PME Aggregate Data (Registers 6.23) */
-   DSL_uint16_t aggregateData2;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message acknowledges CMD_PAF_HS_Continue.
-*/
-struct ACK_PAF_HS_Continue
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-/**
-   Sets the PME identification number. This number is transferred with the CLR
-   message to the CO.
-*/
-struct CMD_PAF_PME_ID_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PME ID */
-   DSL_uint16_t PmeId;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-   /** PME ID */
-   DSL_uint16_t PmeId;
-#endif
-} __PACKED__ ;
-
-
-/**
-   The message acknowledges CMD_PAF_PME_ID_Set.
-*/
-struct ACK_PAF_PME_ID_Set
-{
-#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#else
-   /** Index */
-   DSL_uint16_t Index;
-   /** Length */
-   DSL_uint16_t Length;
-#endif
-} __PACKED__ ;
-
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#ifdef __PACKED_DEFINED__
-   #if !(defined (__GNUC__) || defined (__GNUG__))
-      #pragma pack()
-   #endif
-   #undef __PACKED_DEFINED__
-#endif /* __PACKED_DEFINED__ */
-
-/** @} */
-
-#endif /** _DRV_DSL_CPE_VRX_MSG_TC_COUNTERS_H_*/
--- /dev/null
+++ b/src/include/mcat3.2/drv_dsl_cpe_vrx_msg_config_pmd.h
@@ -0,0 +1,4051 @@
+/******************************************************************************
+
+         Copyright 2016 - 2018 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+
+#ifndef _DRV_DSL_CPE_VRX_MSG_CONFIG_PMD_H_
+#define _DRV_DSL_CPE_VRX_MSG_CONFIG_PMD_H_
+
+/** \file
+
+*/
+
+#ifndef __PACKED__
+   #if defined (__GNUC__) || defined (__GNUG__)
+      /* GNU C or C++ compiler */
+      #define __PACKED__ __attribute__ ((packed))
+   #else
+      /* Byte alignment adjustment */
+      #pragma pack(1)
+      #define __PACKED__      /* nothing */
+   #endif
+   #define __PACKED_DEFINED__ 1
+#endif
+
+
+/** @defgroup _CONFIG_PMD_
+ *  @{
+ */
+
+#ifdef __cplusplus
+   extern "C" {
+#endif
+
+/* ----- Message Specific Constants Definition section ----- */
+#define ACK_ModemFSM_StateGet_RESET_STATE 0
+#define ACK_ModemFSM_StateGet_READY_STATE 1
+#define ACK_ModemFSM_StateGet_FAIL_STATE 2
+#define ACK_ModemFSM_StateGet_DIAG_COMPLETE_STATE 3
+#define ACK_ModemFSM_StateGet_GHS_STATE 5
+#define ACK_ModemFSM_StateGet_FULLINIT_STATE 6
+#define ACK_ModemFSM_StateGet_STEADY_STATE_TC_NOSYNC 7
+#define ACK_ModemFSM_StateGet_STEADY_STATE_TC_SYNC 8
+#define ACK_ModemFSM_StateGet_DIAGMODE_STATE 9
+#define ACK_ModemFSM_StateGet_T1413_STATE 14
+#define ACK_ModemFSM_StateGet_PRE_FAIL_STATE 15
+#define ACK_ModemFSM_StateGet_GHS_BONDING_CLR_STATE 16
+#define ACK_ModemFSM_StateGet_MFD_STATE 18
+#define ACK_ModemFSM_StateGet_MFD_COMPLETE_STATE 19
+#define ACK_ModemFSM_StateGet_DSL_POWER_DOWN_STATE 20
+#define ACK_ModemFSM_StateGet_TEST_STATE 240
+#define ACK_ModemFSM_StateGet_L0 0
+#define ACK_ModemFSM_StateGet_L2 2
+#define ACK_ModemFSM_StateGet_L3 3
+#define EVT_ModemFSM_StateGet_RESET_STATE 0
+#define EVT_ModemFSM_StateGet_READY_STATE 1
+#define EVT_ModemFSM_StateGet_FAIL_STATE 2
+#define EVT_ModemFSM_StateGet_DIAG_COMPLETE_STATE 3
+#define EVT_ModemFSM_StateGet_GHS_STATE 5
+#define EVT_ModemFSM_StateGet_FULLINIT_STATE 6
+#define EVT_ModemFSM_StateGet_STEADY_STATE_TC_NOSYNC 7
+#define EVT_ModemFSM_StateGet_STEADY_STATE_TC_SYNC 8
+#define EVT_ModemFSM_StateGet_DIAGMODE_STATE 9
+#define EVT_ModemFSM_StateGet_T1413_STATE 14
+#define EVT_ModemFSM_StateGet_PRE_FAIL_STATE 15
+#define EVT_ModemFSM_StateGet_GHS_BONDING_CLR_STATE 16
+#define EVT_ModemFSM_StateGet_MFD_STATE 18
+#define EVT_ModemFSM_StateGet_MFD_COMPLETE_STATE 19
+#define EVT_ModemFSM_StateGet_DSL_POWER_DOWN_STATE 20
+#define EVT_ModemFSM_StateGet_TEST_STATE 240
+#define EVT_ModemFSM_StateGet_L0 0
+#define EVT_ModemFSM_StateGet_L2 2
+#define EVT_ModemFSM_StateGet_L3 3
+#define EVT_ModemReady_MRERR_OK 0x0
+#define EVT_ModemReady_MRWARN_OK 0x0
+#define CMD_ModemFSM_StateSet_LINKINI 2
+#define CMD_ModemFSM_StateSet_TERMINATE 4
+#define CMD_ModemFSM_StateSet_POWERDOWN 7
+#define CMD_ModemFSM_StateSet_TESTSTA 8
+#define CMD_ModemFSM_StateSet_MFD 9
+#define ALM_ModemFSM_FailReasonGet_S_OK 0x0
+#define ALM_ModemFSM_FailReasonGet_S_CODESWAP 0x1
+#define ALM_ModemFSM_FailReasonGet_S_MINRATE_DS 0x4
+#define ALM_ModemFSM_FailReasonGet_S_INIT 0x5
+#define ALM_ModemFSM_FailReasonGet_S_MODE 0x6
+#define ALM_ModemFSM_FailReasonGet_S_TIMEOUT 0x9
+#define ALM_ModemFSM_FailReasonGet_S_XDSL_MODE 0xA
+#define ALM_ModemFSM_FailReasonGet_S_PORT_MODE 0xB
+#define ALM_ModemFSM_FailReasonGet_S_T1413_MODE 0xC
+#define ALM_ModemFSM_FailReasonGet_S_GFAST_MODE 0xD
+#define ALM_ModemFSM_FailReasonGet_S_FW_RETRY 0xE
+#define ALM_ModemFSM_FailReasonGet_S_FW_HYBRID 0xF
+#define ALM_ModemFSM_FailReasonGet_S_LOS 0x10
+#define ALM_ModemFSM_FailReasonGet_S_LOF 0x11
+#define ALM_ModemFSM_FailReasonGet_S_LPR 0x12
+#define ALM_ModemFSM_FailReasonGet_S_LOM 0x13
+#define ALM_ModemFSM_FailReasonGet_S_FAST_LOS 0x14
+#define ALM_ModemFSM_FailReasonGet_S_ESE 0x15
+#define ALM_ModemFSM_FailReasonGet_S_SESX 0x16
+#define ALM_ModemFSM_FailReasonGet_S_ESX 0x17
+#define ALM_ModemFSM_FailReasonGet_S_OOS0 0x18
+#define ALM_ModemFSM_FailReasonGet_S_LCD0 0x20
+#define ALM_ModemFSM_FailReasonGet_S_NCD0 0x22
+#define ALM_ModemFSM_FailReasonGet_S_CRC_DS 0x24
+#define ALM_ModemFSM_FailReasonGet_S_PP_DRIVER 0x25
+#define ALM_ModemFSM_FailReasonGet_S_INTENDED_LOCAL_SHUTDOWN 0x26
+#define ALM_ModemFSM_FailReasonGet_S_HW 0x27
+#define ALM_ModemFSM_FailReasonGet_S_CALIBRATION 0x28
+#define ALM_ModemFSM_FailReasonGet_S_AUTOMSG 0x29
+#define ALM_ModemFSM_FailReasonGet_S_PP_ERB_INIT 0x2A
+#define ALM_ModemFSM_FailReasonGet_S_REBOOT_REQ 0x2B
+#define ALM_ModemFSM_FailReasonGet_E_OK 0x0
+#define ALM_ModemFSM_FailReasonGet_E_CONFIG 0x1
+#define ALM_ModemFSM_FailReasonGet_E_NOTFEASIBLE 0x2
+#define ALM_ModemFSM_FailReasonGet_E_COMM 0x3
+#define ALM_ModemFSM_FailReasonGet_E_COMMCRC 0x4
+#define ALM_ModemFSM_FailReasonGet_E_NOPEER 0x5
+#define ALM_ModemFSM_FailReasonGet_E_CHIPSET 0x6
+#define ALM_ModemFSM_FailReasonGet_E_UNKNOWN 0x7
+#define ALM_ModemFSM_FailReasonGet_E_RESERVED 0x8
+#define ALM_ModemFSM_FailReasonGet_E_SHOWTIME_NE 0x10
+#define ALM_ModemFSM_FailReasonGet_E_SHOWTIME_FE 0x11
+#define ACK_ModemFSM_FailReasonGet_S_OK 0x0
+#define ACK_ModemFSM_FailReasonGet_S_CODESWAP 0x1
+#define ACK_ModemFSM_FailReasonGet_S_MINRATE_DS 0x4
+#define ACK_ModemFSM_FailReasonGet_S_INIT 0x5
+#define ACK_ModemFSM_FailReasonGet_S_MODE 0x6
+#define ACK_ModemFSM_FailReasonGet_S_TIMEOUT 0x9
+#define ACK_ModemFSM_FailReasonGet_S_XDSL_MODE 0xA
+#define ACK_ModemFSM_FailReasonGet_S_PORT_MODE 0xB
+#define ACK_ModemFSM_FailReasonGet_S_T1413_MODE 0xC
+#define ACK_ModemFSM_FailReasonGet_S_GFAST_MODE 0xD
+#define ACK_ModemFSM_FailReasonGet_S_FW_RETRY 0xE
+#define ACK_ModemFSM_FailReasonGet_S_FW_HYBRID 0xF
+#define ACK_ModemFSM_FailReasonGet_S_LOS 0x10
+#define ACK_ModemFSM_FailReasonGet_S_LOF 0x11
+#define ACK_ModemFSM_FailReasonGet_S_LPR 0x12
+#define ACK_ModemFSM_FailReasonGet_S_LOM 0x13
+#define ACK_ModemFSM_FailReasonGet_S_FAST_LOS 0x14
+#define ACK_ModemFSM_FailReasonGet_S_ESE 0x15
+#define ACK_ModemFSM_FailReasonGet_S_SESX 0x16
+#define ACK_ModemFSM_FailReasonGet_S_ESX 0x17
+#define ACK_ModemFSM_FailReasonGet_S_OOS0 0x18
+#define ACK_ModemFSM_FailReasonGet_S_LCD0 0x20
+#define ACK_ModemFSM_FailReasonGet_S_NCD0 0x22
+#define ACK_ModemFSM_FailReasonGet_S_CRC_DS 0x24
+#define ACK_ModemFSM_FailReasonGet_S_PP_DRIVER 0x25
+#define ACK_ModemFSM_FailReasonGet_S_INTENDED_LOCAL_SHUTDOWN 0x26
+#define ACK_ModemFSM_FailReasonGet_S_HW 0x27
+#define ACK_ModemFSM_FailReasonGet_S_CALIBRATION 0x28
+#define ACK_ModemFSM_FailReasonGet_S_AUTOMSG 0x29
+#define ACK_ModemFSM_FailReasonGet_S_PP_ERB_INIT 0x2A
+#define ACK_ModemFSM_FailReasonGet_S_REBOOT_REQ 0x2B
+#define ACK_ModemFSM_FailReasonGet_E_OK 0x0
+#define ACK_ModemFSM_FailReasonGet_E_CONFIG 0x1
+#define ACK_ModemFSM_FailReasonGet_E_NOTFEASIBLE 0x2
+#define ACK_ModemFSM_FailReasonGet_E_COMM 0x3
+#define ACK_ModemFSM_FailReasonGet_E_COMMCRC 0x4
+#define ACK_ModemFSM_FailReasonGet_E_NOPEER 0x5
+#define ACK_ModemFSM_FailReasonGet_E_CHIPSET 0x6
+#define ACK_ModemFSM_FailReasonGet_E_UNKNOWN 0x7
+#define ACK_ModemFSM_FailReasonGet_E_RESERVED 0x8
+#define ACK_ModemFSM_FailReasonGet_E_SHOWTIME_NE 0x10
+#define ACK_ModemFSM_FailReasonGet_E_SHOWTIME_FE 0x11
+#define ACK_TxL3RequestStatusGet_L3PENDING 0
+#define ACK_TxL3RequestStatusGet_L3REJECTED 1
+#define ACK_TxL3RequestStatusGet_L3ACCEPTED 2
+#define ACK_TxL3RequestStatusGet_L3FAIL 3
+#define ACK_TxL3ReqFailReasonGet_BUSY 0x01
+#define ACK_TxL3ReqFailReasonGet_INVALID 0x02
+#define ACK_TxL3ReqFailReasonGet_STATE_NOT_DESIRED 0x03
+#define ACK_TxL3ReqFailReasonGet_NOT_L0 0x50
+#define ACK_TxL3ReqFailReasonGet_TIMEOUT 0x90
+#define CMD_ModemFSM_Freeze_FREEZE_OFF 0
+#define CMD_ModemFSM_Freeze_PERIODIC 1
+#define CMD_ModemFSM_Freeze_RP_CHDISC2 2
+#define CMD_ModemFSM_Freeze_MEDLEY 4
+#define CMD_ModemFSM_Freeze_SHOWTIME 8
+#define CMD_ModemFSM_Freeze_SHOWTIME_GI1 16
+#define ACK_FW_ImageInfoGet_STANDALONE 0x0
+#define ACK_FW_ImageInfoGet_COMBINED 0x1
+#define ACK_FW_ImageInfoGet_VDSL_FW 0x0
+#define ACK_FW_ImageInfoGet_ADSL_FW 0x1
+#define ACK_FW_ImageInfoGet_CPE_FW 0x1
+#define CMD_APS_Status_Set_1PORT 1
+#define CMD_APS_Status_Set_2PORT 2
+#define CMD_APS_Status_Set_APIDEF 0
+#define CMD_APS_Status_Set_ADSL 1
+#define CMD_APS_Status_Set_VDSL 2
+#define CMD_APS_Status_Set_FAST 3
+#define CMD_APS_Status_Set_AUTO 0
+#define CMD_APS_Status_Set_STANDARD 1
+#define CMD_APS_Status_Set_NONSTANDARD 2
+#define CMD_APS_Status_Set_GHSMODE 1
+#define CMD_APS_Status_Set_T1413MODE 2
+#define CMD_BearerCh0_DS_Set_FV 21
+#define CMD_BearerCh0_DS_Set_MAX_BER3 0
+#define CMD_BearerCh0_DS_Set_MAX_BER5 1
+#define CMD_BearerCh0_DS_Set_MAX_BER7 2
+#define ACK_BearerCh0_DS_Set_FV 21
+#define CMD_BearerCh0_US_Set_FV 21
+#define CMD_BearerCh0_US_Set_MAX_BER3 0
+#define CMD_BearerCh0_US_Set_MAX_BER5 1
+#define CMD_BearerCh0_US_Set_MAX_BER7 2
+#define ACK_BearerCh0_US_Set_FV 21
+#define CMD_InitPolicySet_MAX_NETRATE 0x0
+#define CMD_InitPolicySet_MAX_INP 0x1
+#define CMD_ErasureControlSet_MAX_NETRATE 0x0
+#define CMD_ErasureControlSet_MAX_INP 0x1
+#define CMD_Misc_ConfigSet_GHSMODE 0x0
+#define CMD_Misc_ConfigSet_T1413MODE 0x1
+#define CMD_OperatorSelect_TELCO_OFF 0
+#define CMD_OperatorSelect_TELCO_DTAG 1
+#define CMD_OperatorSelect_TELCO_BT 2
+#define CMD_OperatorSelect_TELCO_TS 3
+#define CMD_OperatorSelect_TELCO_FT 4
+#define CMD_OperatorSelect_TELCO_KPN 5
+#define CMD_OperatorSelect_TELCO_TELIA 6
+#define CMD_OperatorSelect_TELCO_FIBERHOME 7
+#define CMD_OperatorSelect_TELCO_CT 8
+#define CMD_OperatorSelect_TELCO_TW 9
+#define CMD_OperatorSelect_TELCO_VODAFONE 10
+#define CMD_OperatorSelect_TELCO_CN 11
+#define CMD_OperatorSelect_TELCO_OTE 12
+#define CMD_OperatorSelect_TELCO_TELMEX 13
+#define CMD_OperatorSelect_TELCO_ATT 14
+#define CMD_OperatorSelect_TELCO_SWISSCOM 15
+#define CMD_OperatorSelect_TELCO_NETGEAR 16
+#define CMD_OperatorSelect_TELCO_CTL 17
+#define CMD_OperatorSelect_TELCO_TI 18
+#define CMD_OperatorSelect_TELCO_MAGYAR 19
+#define ACK_OperatorSelectionGet_TELCO_OFF 0
+#define ACK_OperatorSelectionGet_TELCO_DTAG 1
+#define ACK_OperatorSelectionGet_TELCO_BT 2
+#define ACK_OperatorSelectionGet_TELCO_TS 3
+#define ACK_OperatorSelectionGet_TELCO_FT 4
+#define ACK_OperatorSelectionGet_TELCO_KPN 5
+#define ACK_OperatorSelectionGet_TELCO_TELIA 6
+#define ACK_OperatorSelectionGet_TELCO_FIBERHOME 7
+#define ACK_OperatorSelectionGet_TELCO_CT 8
+#define ACK_OperatorSelectionGet_TELCO_TW 9
+#define ACK_OperatorSelectionGet_TELCO_VODAFONE 10
+#define ACK_OperatorSelectionGet_TELCO_CN 11
+#define ACK_OperatorSelectionGet_TELCO_OTE 12
+#define ACK_OperatorSelectionGet_TELCO_TELMEX 13
+#define ACK_OperatorSelectionGet_TELCO_ATT 14
+#define ACK_OperatorSelectionGet_TELCO_SWISSCOM 15
+#define ACK_OperatorSelectionGet_TELCO_NETGEAR 16
+#define ACK_OperatorSelectionGet_TELCO_CTL 17
+#define ACK_OperatorSelectionGet_TELCO_TI 18
+#define ACK_OperatorSelectionGet_TELCO_MAGYAR 19
+#define CMD_ClockSet_M1 1
+#define CMD_ClockSet_M2 2
+#define CMD_ClockSet_M3 3
+#define CMD_ClockSet_M4 4
+#define CMD_PPE_ClockConfigure_FSCALE_AUTO_OFF 0
+#define CMD_PPE_ClockConfigure_FSCALE_AUTO_A 1
+#define ACK_PPE_ClockGet_M1 1
+#define ACK_PPE_ClockGet_M2 2
+#define ACK_PPE_ClockGet_M3 3
+#define ACK_PPE_ClockGet_M4 4
+#define ACK_PPE_ClockConfigGet_FSCALE_AUTO_OFF 0
+#define ACK_PPE_ClockConfigGet_FSCALE_AUTO_A 1
+/* ----- Message Specific Constants Definition section (End) ----- */
+
+/** Message ID for CMD_ModemFSM_StateGet */
+#define CMD_MODEMFSM_STATEGET 0x0002
+
+/**
+   Requests information about the current state of the modem state-machine.The
+   command can be sent in all states of the modem state machine (see Figure 2).
+*/
+typedef struct CMD_ModemFSM_StateGet CMD_ModemFSM_StateGet_t;
+
+/** Message ID for ACK_ModemFSM_StateGet */
+#define ACK_MODEMFSM_STATEGET 0x0002
+
+/**
+   Returns information about the current state of the modem state-machine.
+*/
+typedef struct ACK_ModemFSM_StateGet ACK_ModemFSM_StateGet_t;
+
+/** Message ID for EVT_ModemFSM_StateGet */
+#define EVT_MODEMFSM_STATEGET 0x0002
+
+/**
+   Returns information about the current state of the modem state-machine. This
+   message is sent autonomously, if the modem enters a new state and reporting
+   is enabled for that state (see CMD_ModemFSM_EventConfigure).
+*/
+typedef struct EVT_ModemFSM_StateGet EVT_ModemFSM_StateGet_t;
+
+/** Message ID for EVT_ModemReady */
+#define EVT_MODEMREADY 0xFF02
+
+/**
+   Autonomous message indicating that the modem online code was reached and that
+   initialization was completed. The management entity may not perform any
+   query-response messaging until the EVT_ModemReady message is received. Its
+   generation cannot be disabled. If it is not received this indicates a
+   problem, possibly with the boot sequence. If the message is received, it
+   contains a result code that may also indicate that an error was detected by
+   the firmware during initialization.
+*/
+typedef struct EVT_ModemReady EVT_ModemReady_t;
+
+/** Message ID for CMD_ModemFSM_StateSet */
+#define CMD_MODEMFSM_STATESET 0x0041
+
+/**
+   Controls state transitions of the modem state-machine.
+*/
+typedef struct CMD_ModemFSM_StateSet CMD_ModemFSM_StateSet_t;
+
+/** Message ID for ACK_ModemFSM_StateSet */
+#define ACK_MODEMFSM_STATESET 0x0041
+
+/**
+   Acknowledgement for message CMD_ModemFSM_StateSet
+*/
+typedef struct ACK_ModemFSM_StateSet ACK_ModemFSM_StateSet_t;
+
+/** Message ID for ALM_ModemFSM_FailReasonGet */
+#define ALM_MODEMFSM_FAILREASONGET 0x0502
+
+/**
+   Reports failure information after entering FAIL state. This message is sent
+   autonomously without host request after entrance into FAIL was indicated by
+   EVT_ModemFSM_StateGet. Both messages are generated only if enabled with
+   CMD_ModemFSM_EventConfigure (common Bit E8 "FAIL").
+*/
+typedef struct ALM_ModemFSM_FailReasonGet ALM_ModemFSM_FailReasonGet_t;
+
+/** Message ID for CMD_ModemFSM_FailReasonGet */
+#define CMD_MODEMFSM_FAILREASONGET 0x0502
+
+/**
+   Requests failure information after entering FAIL state.
+*/
+typedef struct CMD_ModemFSM_FailReasonGet CMD_ModemFSM_FailReasonGet_t;
+
+/** Message ID for ACK_ModemFSM_FailReasonGet */
+#define ACK_MODEMFSM_FAILREASONGET 0x0502
+
+/**
+   Returns failure information after entering FAIL state.
+*/
+typedef struct ACK_ModemFSM_FailReasonGet ACK_ModemFSM_FailReasonGet_t;
+
+/** Message ID for CMD_ModemFSM_PrevFailReasonGet */
+#define CMD_MODEMFSM_PREVFAILREASONGET 0x2522
+
+/**
+   Requests failure information of the last previous FAIL state.
+*/
+typedef struct CMD_ModemFSM_PrevFailReasonGet CMD_ModemFSM_PrevFailReasonGet_t;
+
+/** Message ID for ACK_ModemFSM_PrevFailReasonGet */
+#define ACK_MODEMFSM_PREVFAILREASONGET 0x2522
+
+/**
+   Returns failure information from last previous FAIL state. The message
+   structure is the same as ACK_ModemFSM_FailReasonGet (used for the current
+   FAIL state.)
+*/
+typedef struct ACK_ModemFSM_PrevFailReasonGet ACK_ModemFSM_PrevFailReasonGet_t;
+
+/** Message ID for CMD_FailReasonHistoryGet */
+#define CMD_FAILREASONHISTORYGET 0x2622
+
+/**
+   Requests a failure reason history of the last few transitions to FAIL state.
+*/
+typedef struct CMD_FailReasonHistoryGet CMD_FailReasonHistoryGet_t;
+
+/** Message ID for ACK_FailReasonHistoryGet */
+#define ACK_FAILREASONHISTORYGET 0x2622
+
+/**
+   Provides a failure reason history of the last few transitions to FAIL state.
+*/
+typedef struct ACK_FailReasonHistoryGet ACK_FailReasonHistoryGet_t;
+
+/** Message ID for CMD_ModemFSM_OptionsSet */
+#define CMD_MODEMFSM_OPTIONSSET 0x0449
+
+/**
+   Configuration of options for the modem state machine.
+*/
+typedef struct CMD_ModemFSM_OptionsSet CMD_ModemFSM_OptionsSet_t;
+
+/** Message ID for ACK_ModemFSM_OptionsSet */
+#define ACK_MODEMFSM_OPTIONSSET 0x0449
+
+/**
+   Acknowledgement to CMD_ModemFSM_OptionsSet.
+*/
+typedef struct ACK_ModemFSM_OptionsSet ACK_ModemFSM_OptionsSet_t;
+
+/** Message ID for CMD_ModemOptionsSet */
+#define CMD_MODEMOPTIONSSET 0x0062
+
+/**
+   Configuration of options for the modem state machine.
+*/
+typedef struct CMD_ModemOptionsSet CMD_ModemOptionsSet_t;
+
+/** Message ID for ACK_ModemOptionsSet */
+#define ACK_MODEMOPTIONSSET 0x0062
+
+/**
+   Acknowledgement to CMD_ModemOptionsSet.
+*/
+typedef struct ACK_ModemOptionsSet ACK_ModemOptionsSet_t;
+
+/** Message ID for CMD_ModemFSM_EventConfigure */
+#define CMD_MODEMFSM_EVENTCONFIGURE 0x0049
+
+/**
+   Sets options for the modem state-machine. Enables/Disables autonomous
+   messages for specific state transitions (EVT_ModemFSM_StateGet). The EVT
+   message is generated after entering the particular state listed in the
+   parameter description of the enable bits.
+*/
+typedef struct CMD_ModemFSM_EventConfigure CMD_ModemFSM_EventConfigure_t;
+
+/** Message ID for ACK_ModemFSM_EventConfigure */
+#define ACK_MODEMFSM_EVENTCONFIGURE 0x0049
+
+/**
+   Acknowledgement for CMD_ModemFSM_EventConfigure. (Enabling/Disabling EVENT
+   messages (EVTs) for specific state transitions.)
+*/
+typedef struct ACK_ModemFSM_EventConfigure ACK_ModemFSM_EventConfigure_t;
+
+/** Message ID for CMD_FailuresNE_AlarmConfigure */
+#define CMD_FAILURESNE_ALARMCONFIGURE 0x0149
+
+/**
+   Enables/Disables the generation of ALARM messages (ALM) for specific near-end
+   line failures. If the corresponding Enable bit for a line failure is set,
+   then the modem firmware will send an autonomous message ALM_LineFailureNE_Get
+   if this failure occurs.
+*/
+typedef struct CMD_FailuresNE_AlarmConfigure CMD_FailuresNE_AlarmConfigure_t;
+
+/** Message ID for ACK_FailuresNE_AlarmConfigure */
+#define ACK_FAILURESNE_ALARMCONFIGURE 0x0149
+
+/**
+   Acknowledgement to CMD_FailuresNE_AlarmConfigure.
+*/
+typedef struct ACK_FailuresNE_AlarmConfigure ACK_FailuresNE_AlarmConfigure_t;
+
+/** Message ID for CMD_FailuresFE_AlarmConfigure */
+#define CMD_FAILURESFE_ALARMCONFIGURE 0x0249
+
+/**
+   Enables/Disables the generation of ALARM messages (ALM) for specific far-end
+   line failures. If the corresponding Enable bit for a line failure is set,
+   then the modem firmware will send an autonomous message ALM_LineFailureFE_Get
+   if this failure occurs.
+*/
+typedef struct CMD_FailuresFE_AlarmConfigure CMD_FailuresFE_AlarmConfigure_t;
+
+/** Message ID for ACK_FailuresFE_AlarmConfigure */
+#define ACK_FAILURESFE_ALARMCONFIGURE 0x0249
+
+/**
+   Acknowledgement to CMD_FailuresFE_AlarmConfigure.
+*/
+typedef struct ACK_FailuresFE_AlarmConfigure ACK_FailuresFE_AlarmConfigure_t;
+
+/** Message ID for CMD_ReInitNE_Configure */
+#define CMD_REINITNE_CONFIGURE 0x0549
+
+/**
+   Configures re-initialization triggers for near-end failure conditions in
+   modem state STEADY STATE transmission (see Figure 1). This command is
+   accepted in RESET state only.
+*/
+typedef struct CMD_ReInitNE_Configure CMD_ReInitNE_Configure_t;
+
+/** Message ID for ACK_ReInitNE_Configure */
+#define ACK_REINITNE_CONFIGURE 0x0549
+
+/**
+   Acknowledgment to CMD_ReInitNE_Configure (Configuration of re-initialization
+   triggers for near-end failures).
+*/
+typedef struct ACK_ReInitNE_Configure ACK_ReInitNE_Configure_t;
+
+/** Message ID for CMD_ReinitThreshConfigure */
+#define CMD_REINITTHRESHCONFIGURE 0x1E62
+
+/**
+   Configuration of reinitialization trigger definitions.
+*/
+typedef struct CMD_ReinitThreshConfigure CMD_ReinitThreshConfigure_t;
+
+/** Message ID for ACK_ReinitThreshConfigure */
+#define ACK_REINITTHRESHCONFIGURE 0x1E62
+
+/**
+   Acknowledgement for the message ACK_ReinitThreshConfigure.
+*/
+typedef struct ACK_ReinitThreshConfigure ACK_ReinitThreshConfigure_t;
+
+/** Message ID for CMD_ShutdownRequest */
+#define CMD_SHUTDOWNREQUEST 0x0341
+
+/**
+   Triggers a shutdown request, either as "L3 orderly shutdown" towards the
+   remote side or as "locally forced shutdown" to the DSL-FW without sending a
+   request to the remote side.After an "L3 orderly shutdown" request was
+   accepted by the CO, the following shall happen: The CPE-Host forces L3 entry
+   with transition to RESET state by applying CMD_ModemFSM_StateGet.A "locally
+   forced shutdown" always results in exiting Showtime.
+*/
+typedef struct CMD_ShutdownRequest CMD_ShutdownRequest_t;
+
+/** Message ID for ACK_ShutdownRequest */
+#define ACK_SHUTDOWNREQUEST 0x0341
+
+/**
+   Acknowledgement for CMD_ShutdownRequest.
+*/
+typedef struct ACK_ShutdownRequest ACK_ShutdownRequest_t;
+
+/** Message ID for CMD_RxL3RequestStatusGet */
+#define CMD_RXL3REQUESTSTATUSGET 0x0402
+
+/**
+   Requests information about L3 orderly shutdown requests initiated from the
+   remote side.Applying CMD_RxL3RequestStatusGet allows the host to determine
+   whether a near-end LOS or LOM failure is due to an L3 shutdown or an
+   unexpected line failure.
+*/
+typedef struct CMD_RxL3RequestStatusGet CMD_RxL3RequestStatusGet_t;
+
+/** Message ID for ACK_RxL3RequestStatusGet */
+#define ACK_RXL3REQUESTSTATUSGET 0x0402
+
+/**
+   Acknowledgement for CMD_RxL3RequestStatusGet.As long as the modem is in L0
+   (Showtime), an ATU-R will automatically respond to any L3 request from the
+   ATU-C by sending an accept message.  If the ATU-R is in L2 mode when it
+   receives the request, it will send a reject message. Upon receiving an
+   acceptance, the remote side should enter L3 state and shut off its
+   transmitter.
+*/
+typedef struct ACK_RxL3RequestStatusGet ACK_RxL3RequestStatusGet_t;
+
+/** Message ID for CMD_TxL3RequestStatusGet */
+#define CMD_TXL3REQUESTSTATUSGET 0x1402
+
+/**
+   Requests the status of a near-end initiated L3 shutdown request. If the
+   remote side accepted the request, in ADSL the host will force L3 entry using
+   CMD_ModemFSM_StateSet.
+*/
+typedef struct CMD_TxL3RequestStatusGet CMD_TxL3RequestStatusGet_t;
+
+/** Message ID for ACK_TxL3RequestStatusGet */
+#define ACK_TXL3REQUESTSTATUSGET 0x1402
+
+/**
+   Acknowledgement for CMD_TxL3RequestStatusGet.
+*/
+typedef struct ACK_TxL3RequestStatusGet ACK_TxL3RequestStatusGet_t;
+
+/** Message ID for CMD_TxL3ReqFailReasonGet */
+#define CMD_TXL3REQFAILREASONGET 0x1502
+
+/**
+   Requests the fail reason of a failed near-end initiated L3 request. (see also
+   ACK_TxL3RequestStatusGet)
+*/
+typedef struct CMD_TxL3ReqFailReasonGet CMD_TxL3ReqFailReasonGet_t;
+
+/** Message ID for ACK_TxL3ReqFailReasonGet */
+#define ACK_TXL3REQFAILREASONGET 0x1502
+
+/**
+   Reports the fail reason of a near-end initiated L3 request, as response to
+   CMD_TxL3ReqFailReasonGet.
+*/
+typedef struct ACK_TxL3ReqFailReasonGet ACK_TxL3ReqFailReasonGet_t;
+
+/** Message ID for CMD_ModemFSM_Freeze */
+#define CMD_MODEMFSM_FREEZE 0x2C44
+
+/**
+   The message selects and enables one of several points during the
+   initialization process where -after a normal link start had been triggered-
+   the modem FSM "freezes". Freezing means the CO can be disconnected from the
+   line and still the CPE continues transmitting the signal of the current
+   phase. To exit from the freeze a state transition to RESET state has to be
+   triggered. In case of a Showtime Freeze the reinit-triggers do not have any
+   effect.
+*/
+typedef struct CMD_ModemFSM_Freeze CMD_ModemFSM_Freeze_t;
+
+/** Message ID for ACK_ModemFSM_Freeze */
+#define ACK_MODEMFSM_FREEZE 0x2C44
+
+/**
+   Acknowledgement for message CMD_ModemFSM_Freeze.
+*/
+typedef struct ACK_ModemFSM_Freeze ACK_ModemFSM_Freeze_t;
+
+/** Message ID for CMD_FW_ImageInfoGet */
+#define CMD_FW_IMAGEINFOGET 0xD103
+
+/**
+   Requests information about the loaded FW image. This info is used e.g. for
+   swapping between ADSL and VDSL.
+*/
+typedef struct CMD_FW_ImageInfoGet CMD_FW_ImageInfoGet_t;
+
+/** Message ID for ACK_FW_ImageInfoGet */
+#define ACK_FW_IMAGEINFOGET 0xD103
+
+/**
+   Provides the information about the FW image requested by CMD_FW_ImageInfoGet
+*/
+typedef struct ACK_FW_ImageInfoGet ACK_FW_ImageInfoGet_t;
+
+/** Message ID for CMD_APS_Status_Set */
+#define CMD_APS_STATUS_SET 0x2062
+
+/**
+   The message informs the FW about the status of SW parameters relevant for the
+   multimode state machine (APS). This can be used to trace the APS behaviour
+   with FW tools. The message does not influence the APS behaviour.
+*/
+typedef struct CMD_APS_Status_Set CMD_APS_Status_Set_t;
+
+/** Message ID for ACK_APS_Status_Set */
+#define ACK_APS_STATUS_SET 0x2062
+
+/**
+   Acknowledgement for message CMD_APS_Status_Set.
+*/
+typedef struct ACK_APS_Status_Set ACK_APS_Status_Set_t;
+
+/** Message ID for CMD_XTSE_Configure */
+#define CMD_XTSE_CONFIGURE 0x0045
+
+/**
+   Configuration of the VTU Transmission System Enabling (XTSE).Configures the
+   transmission system coding types to be supported on the line (VDSL flavour
+   and annex support).(References: Section 7.3.1.1.1 of G.997.1 and G.994.1 Amd4
+   [10] Tables "Standard information field - SPar(1) coding")
+*/
+typedef struct CMD_XTSE_Configure CMD_XTSE_Configure_t;
+
+/** Message ID for ACK_XTSE_Configure */
+#define ACK_XTSE_CONFIGURE 0x0045
+
+/**
+   Acknowledgement for message CMD_XTSE_Configure.
+*/
+typedef struct ACK_XTSE_Configure ACK_XTSE_Configure_t;
+
+/** Message ID for CMD_BandControl_US_Set */
+#define CMD_BANDCONTROL_US_SET 0x2548
+
+/**
+   Controls the upstream band usage.The message can only be used for DMTscope
+   tests without handshake and training phases.
+*/
+typedef struct CMD_BandControl_US_Set CMD_BandControl_US_Set_t;
+
+/** Message ID for ACK_BandControl_US_Set */
+#define ACK_BANDCONTROL_US_SET 0x2548
+
+/**
+   Acknowledgement for message CMD_BandControl_US_Set.
+*/
+typedef struct ACK_BandControl_US_Set ACK_BandControl_US_Set_t;
+
+/** Message ID for CMD_PSD_Set */
+#define CMD_PSD_SET 0x2348
+
+/**
+   Configuration of PSD and Power parameters. Only used for DMTscope tests
+   without handshake and training phases.
+*/
+typedef struct CMD_PSD_Set CMD_PSD_Set_t;
+
+/** Message ID for ACK_PSD_Set */
+#define ACK_PSD_SET 0x2348
+
+/**
+   Acknowledgement for the message CMD_PSD_Set.
+*/
+typedef struct ACK_PSD_Set ACK_PSD_Set_t;
+
+/** Message ID for CMD_PSD_BreakpointsTxUS_Set */
+#define CMD_PSD_BREAKPOINTSTXUS_SET 0x2848
+
+/**
+   Specifies the maximum upstream transmit PSD by means of breakpoints.To be
+   used only for DMTscope tests without handshake and training phases.
+*/
+typedef struct CMD_PSD_BreakpointsTxUS_Set CMD_PSD_BreakpointsTxUS_Set_t;
+
+/** Message ID for ACK_PSD_BreakpointsTxUS_Set */
+#define ACK_PSD_BREAKPOINTSTXUS_SET 0x2848
+
+/**
+   Acknowledgement for the message CMD_PSD_BreakpointsTxUS_Set.
+*/
+typedef struct ACK_PSD_BreakpointsTxUS_Set ACK_PSD_BreakpointsTxUS_Set_t;
+
+/** Message ID for  CMD_PSD_Calibration_DS_Set */
+#define  CMD_PSD_CALIBRATION_DS_SET 0x5748
+
+/**
+   Sends downstream calibration information for "per-tone" test parameters. It
+   is effective for Loop Diagnostic Mode (DELT) and Showtime. It is the
+   responsibility of the manufacturer to provide the data.
+*/
+typedef struct  CMD_PSD_Calibration_DS_Set CMD_PSD_Calibration_DS_Set_t;
+
+/** Message ID for ACK_PSD_Calibration_DS_Set */
+#define ACK_PSD_CALIBRATION_DS_SET 0x5748
+
+/**
+   Acknowledgement for the message CMD_PSD_Calibration_DS_Set.
+*/
+typedef struct ACK_PSD_Calibration_DS_Set ACK_PSD_Calibration_DS_Set_t;
+
+/** Message ID for  CMD_PSD_Calibration_US_Set */
+#define  CMD_PSD_CALIBRATION_US_SET 0x5848
+
+/**
+   Sends upstream calibration information for the upstream transmit PSD. It is
+   effective for loop diagnostic mode (DELT) and Showtime. It is the
+   responsibility of the manufacturer to provide the data.
+*/
+typedef struct  CMD_PSD_Calibration_US_Set CMD_PSD_Calibration_US_Set_t;
+
+/** Message ID for ACK_PSD_Calibration_US_Set */
+#define ACK_PSD_CALIBRATION_US_SET 0x5848
+
+/**
+   Acknowledgement for the message CMD_PSD_Calibration_US_Set.
+*/
+typedef struct ACK_PSD_Calibration_US_Set ACK_PSD_Calibration_US_Set_t;
+
+/** Message ID for CMD_PSD_OptionsSet */
+#define CMD_PSD_OPTIONSSET 0x0262
+
+/**
+   Configuration of PSD related options.
+*/
+typedef struct CMD_PSD_OptionsSet CMD_PSD_OptionsSet_t;
+
+/** Message ID for ACK_PSD_OptionsSet */
+#define ACK_PSD_OPTIONSSET 0x0262
+
+/**
+   Acknowledgement to CMD_PSD_OptionsSet.
+*/
+typedef struct ACK_PSD_OptionsSet ACK_PSD_OptionsSet_t;
+
+/** Message ID for CMD_UPBO_KL0Get */
+#define CMD_UPBO_KL0GET 0xD603
+
+/**
+   Requests the electrical loop length estimate kl0.
+*/
+typedef struct CMD_UPBO_KL0Get CMD_UPBO_KL0Get_t;
+
+/** Message ID for ACK_UPBO_KL0Get */
+#define ACK_UPBO_KL0GET 0xD603
+
+/**
+   Delivers the data requested by CMD_UPBO_KL0Get.(Section 7.5.1.23 of G.997.1
+   [11])
+*/
+typedef struct ACK_UPBO_KL0Get ACK_UPBO_KL0Get_t;
+
+/** Message ID for CMD_PBO_AELEM_Status_Get */
+#define CMD_PBO_AELEM_STATUS_GET 0xEA03
+
+/**
+   Requests status parameters for the Upstream  Power  Back-Off  (UPBO)
+   alternative  electrical  length  estimation  method (AELEM).
+*/
+typedef struct CMD_PBO_AELEM_Status_Get CMD_PBO_AELEM_Status_Get_t;
+
+/** Message ID for ACK_PBO_AELEM_Status_Get */
+#define ACK_PBO_AELEM_STATUS_GET 0xEA03
+
+/**
+   Upstream  Power  Back-Off  (UPBO)  status  parameters  for  the  alternative
+   electrical  length  estimation  method (AELEM) are reported.
+*/
+typedef struct ACK_PBO_AELEM_Status_Get ACK_PBO_AELEM_Status_Get_t;
+
+/** Message ID for CMD_NoiseMarginDeltaSet */
+#define CMD_NOISEMARGINDELTASET 0x1C45
+
+/**
+   Configuration of a target noise margin delta, which is added to the target
+   noise margin value configured at the CO (and in case of the CPE received from
+   there). The resulting value is then taken as target noise margin, e.g. for
+   bit loading.
+*/
+typedef struct CMD_NoiseMarginDeltaSet CMD_NoiseMarginDeltaSet_t;
+
+/** Message ID for ACK_NoiseMarginDeltaSet */
+#define ACK_NOISEMARGINDELTASET 0x1C45
+
+/**
+   Acknowledgement for the message CMD_NoiseMarginDeltaSet.
+*/
+typedef struct ACK_NoiseMarginDeltaSet ACK_NoiseMarginDeltaSet_t;
+
+/** Message ID for CMD_BearerCh0_DS_Set */
+#define CMD_BEARERCH0_DS_SET 0x0048
+
+/**
+   Sets parameters for downstream bearer channel 0 (Chapters 7.3.2.1-5 of
+   G.997.1 [11]). Bearer channel configuration at the CPE is optional and just
+   used to further limit the parameters usually configured at the CO.The mode,
+   ATM or PTM, is selected with the configuration controls "ATMControl" and
+   "PTMControl" in Parameter 2. Exactly one of them must be enabled, not both!
+*/
+typedef struct CMD_BearerCh0_DS_Set CMD_BearerCh0_DS_Set_t;
+
+/** Message ID for ACK_BearerCh0_DS_Set */
+#define ACK_BEARERCH0_DS_SET 0x0048
+
+/**
+   Acknowledgement for CMD_BearerCh0_DS_Set. (Configuration of bearer channel
+   0).
+*/
+typedef struct ACK_BearerCh0_DS_Set ACK_BearerCh0_DS_Set_t;
+
+/** Message ID for CMD_BearerCh0_US_Set */
+#define CMD_BEARERCH0_US_SET 0x0248
+
+/**
+   Sets parameters for upstream bearer channel 0 (Chapters 7.3.2.1-5 of G.997.1
+   [11]). Bearer channel configuration at the CPE is optional and just used to
+   further limit the parameters usually configured at the CO.The mode, ATM or
+   PTM, is selected with the configuration controls "ATMControl" and
+   "PTMControl" in Parameter 2. Exactly one of them must be enabled, not both!
+*/
+typedef struct CMD_BearerCh0_US_Set CMD_BearerCh0_US_Set_t;
+
+/** Message ID for ACK_BearerCh0_US_Set */
+#define ACK_BEARERCH0_US_SET 0x0248
+
+/**
+   Acknowledgement for CMD_BearerCh0_US_Set. (Configuration of bearer channel
+   0).
+*/
+typedef struct ACK_BearerCh0_US_Set ACK_BearerCh0_US_Set_t;
+
+/** Message ID for CMD_InitPolicySet */
+#define CMD_INITPOLICYSET 0x1A45
+
+/**
+   The message selects the channel initialization policy (CIPOLICY) to be
+   applied for the tranceiver configuration. (Section 7.3.2.10 of G.997.1)In
+   ADSL mode, the message is applicable only for ADSL2/2+ (Section 7.10.3 of
+   G.992.3 Amd 3). The standard defines the parameter for the CO only. Here, the
+   message is applied at the ADSL-CPE, then it overrides the policy given by the
+   CO!
+*/
+typedef struct CMD_InitPolicySet CMD_InitPolicySet_t;
+
+/** Message ID for ACK_InitPolicySet */
+#define ACK_INITPOLICYSET 0x1A45
+
+/**
+   Acknowledgment for message CMD_InitPolicySet.
+*/
+typedef struct ACK_InitPolicySet ACK_InitPolicySet_t;
+
+/** Message ID for CMD_ErasureControlSet */
+#define CMD_ERASURECONTROLSET 0x0162
+
+/**
+   Configuration of options for the modem state machine.
+*/
+typedef struct CMD_ErasureControlSet CMD_ErasureControlSet_t;
+
+/** Message ID for ACK_ErasureControlSet */
+#define ACK_ERASURECONTROLSET 0x0162
+
+/**
+   Acknowledgement to CMD_ErasureControlSet.
+*/
+typedef struct ACK_ErasureControlSet ACK_ErasureControlSet_t;
+
+/** Message ID for CMD_Misc_ConfigSet */
+#define CMD_MISC_CONFIGSET 0x3A48
+
+/**
+   Performs some miscellaneous chip set configurations.
+*/
+typedef struct CMD_Misc_ConfigSet CMD_Misc_ConfigSet_t;
+
+/** Message ID for ACK_Misc_ConfigSet */
+#define ACK_MISC_CONFIGSET 0x3A48
+
+/**
+   This is the acknowledgement for ACK_Misc_ConfigSet.
+*/
+typedef struct ACK_Misc_ConfigSet ACK_Misc_ConfigSet_t;
+
+/** Message ID for CMD_OperationOptionsSet */
+#define CMD_OPERATIONOPTIONSSET 0x0D62
+
+/**
+   Performs some miscellaneous chip set configurations.
+*/
+typedef struct CMD_OperationOptionsSet CMD_OperationOptionsSet_t;
+
+/** Message ID for ACK_OperationOptionsSet */
+#define ACK_OPERATIONOPTIONSSET 0x0D62
+
+/**
+   This is the acknowledgement for CMD_OperationOptionsSet.
+*/
+typedef struct ACK_OperationOptionsSet ACK_OperationOptionsSet_t;
+
+/** Message ID for CMD_OperatorSelect */
+#define CMD_OPERATORSELECT 0x1562
+
+/**
+   The message selects a DSL operator. The information is used to configure
+   operator specific settings inside the DSL firmware.
+*/
+typedef struct CMD_OperatorSelect CMD_OperatorSelect_t;
+
+/** Message ID for ACK_OperatorSelect */
+#define ACK_OPERATORSELECT 0x1562
+
+/**
+   This is the acknowledgement for ACK_OperatorSelect.
+*/
+typedef struct ACK_OperatorSelect ACK_OperatorSelect_t;
+
+/** Message ID for CMD_OperatorSelectionGet */
+#define CMD_OPERATORSELECTIONGET 0x1522
+
+/**
+   The message reads back the selected DSL operator, as selected by
+   ACK_OperatorSelect.
+*/
+typedef struct CMD_OperatorSelectionGet CMD_OperatorSelectionGet_t;
+
+/** Message ID for ACK_OperatorSelectionGet */
+#define ACK_OPERATORSELECTIONGET 0x1522
+
+/**
+   The message provides the selected DSL operator.
+*/
+typedef struct ACK_OperatorSelectionGet ACK_OperatorSelectionGet_t;
+
+/** Message ID for CMD_TestOptionsSet */
+#define CMD_TESTOPTIONSSET 0x1C44
+
+/**
+   The messages configures settings for test modes.
+*/
+typedef struct CMD_TestOptionsSet CMD_TestOptionsSet_t;
+
+/** Message ID for ACK_TestOptionsSet */
+#define ACK_TESTOPTIONSSET 0x1C44
+
+/**
+   This is the acknowledgement for CMD_TestOptionsSet.
+*/
+typedef struct ACK_TestOptionsSet ACK_TestOptionsSet_t;
+
+/** Message ID for CMD_ClockSet */
+#define CMD_CLOCKSET 0x0F62
+
+/**
+   Sets the PPE clock. The message is supposed to be used for debug/test
+   purposes only. If applied this PPE clock is forced and will be kept
+   throughout the link. The PPE frequency scaling automode (see
+   CMD_PPE_ClockConfigure) will then not change it but behave as being disabled.
+*/
+typedef struct CMD_ClockSet CMD_ClockSet_t;
+
+/** Message ID for ACK_ClockSet */
+#define ACK_CLOCKSET 0x0F62
+
+/**
+   This is the acknowledgement for CMD_ClockSet.
+*/
+typedef struct ACK_ClockSet ACK_ClockSet_t;
+
+/** Message ID for CMD_PPE_ClockConfigure */
+#define CMD_PPE_CLOCKCONFIGURE 0x2262
+
+/**
+   Configures PPE clock options.The message CMD_ClockSet used for debug/test
+   purposes forces a PPE clock frequency which will be kept throughout the
+   link.. The PPE frequency scaling automode will then not change it but behave
+   as being disabled.
+*/
+typedef struct CMD_PPE_ClockConfigure CMD_PPE_ClockConfigure_t;
+
+/** Message ID for ACK_PPE_ClockConfigure */
+#define ACK_PPE_CLOCKCONFIGURE 0x2262
+
+/**
+   This is the acknowledgement for CMD_PPE_ClockConfigure.
+*/
+typedef struct ACK_PPE_ClockConfigure ACK_PPE_ClockConfigure_t;
+
+/** Message ID for CMD_PPE_ClockGet */
+#define CMD_PPE_CLOCKGET 0xF403
+
+/**
+   Reads PPE clock settings.
+*/
+typedef struct CMD_PPE_ClockGet CMD_PPE_ClockGet_t;
+
+/** Message ID for ACK_PPE_ClockGet */
+#define ACK_PPE_CLOCKGET 0xF403
+
+/**
+   Provides PPE clock settings.
+*/
+typedef struct ACK_PPE_ClockGet ACK_PPE_ClockGet_t;
+
+/** Message ID for CMD_PPE_ClockConfigGet */
+#define CMD_PPE_CLOCKCONFIGGET 0x2222
+
+/**
+   Reads back PPE clock options.
+*/
+typedef struct CMD_PPE_ClockConfigGet CMD_PPE_ClockConfigGet_t;
+
+/** Message ID for ACK_PPE_ClockConfigGet */
+#define ACK_PPE_CLOCKCONFIGGET 0x2222
+
+/**
+   Provides PPE clock options.
+*/
+typedef struct ACK_PPE_ClockConfigGet ACK_PPE_ClockConfigGet_t;
+
+/** Message ID for CMD_PLL_ClockSet */
+#define CMD_PLL_CLOCKSET 0x1962
+
+/**
+   Sets an offset for the PLL frequency compared to the crystals rated nominal
+   frequency of 36 MHz. This allows e.g. to fine tune the handshake tone
+   frequencies to exactly match the standard values.
+*/
+typedef struct CMD_PLL_ClockSet CMD_PLL_ClockSet_t;
+
+/** Message ID for ACK_PLL_ClockSet */
+#define ACK_PLL_CLOCKSET 0x1962
+
+/**
+   This is the acknowledgement for CMD_PLL_ClockSet.
+*/
+typedef struct ACK_PLL_ClockSet ACK_PLL_ClockSet_t;
+
+/**
+   Requests information about the current state of the modem state-machine.The
+   command can be sent in all states of the modem state machine (see Figure 2).
+*/
+struct CMD_ModemFSM_StateGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the current state of the modem state-machine.
+*/
+struct ACK_ModemFSM_StateGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Modem Status */
+   DSL_uint16_t ModemState;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** Line Power Management State */
+   DSL_uint16_t LxState : 2;
+   /** Last HS State or SOC Message */
+   DSL_uint16_t State_HsOrSoc;
+   /** RX Signal */
+   DSL_uint16_t RxSignal;
+   /** TX Signal */
+   DSL_uint16_t TxSignal;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Modem Status */
+   DSL_uint16_t ModemState;
+   /** Line Power Management State */
+   DSL_uint16_t LxState : 2;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** Last HS State or SOC Message */
+   DSL_uint16_t State_HsOrSoc;
+   /** RX Signal */
+   DSL_uint16_t RxSignal;
+   /** TX Signal */
+   DSL_uint16_t TxSignal;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the current state of the modem state-machine. This
+   message is sent autonomously, if the modem enters a new state and reporting
+   is enabled for that state (see CMD_ModemFSM_EventConfigure).
+*/
+struct EVT_ModemFSM_StateGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Modem Status */
+   DSL_uint16_t ModemState;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** Line Power Management State */
+   DSL_uint16_t LxState : 2;
+   /** Last HS State or SOC Message */
+   DSL_uint16_t State_HsOrSoc;
+   /** RX Signal */
+   DSL_uint16_t RxSignal;
+   /** TX Signal */
+   DSL_uint16_t TxSignal;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Modem Status */
+   DSL_uint16_t ModemState;
+   /** Line Power Management State */
+   DSL_uint16_t LxState : 2;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** Last HS State or SOC Message */
+   DSL_uint16_t State_HsOrSoc;
+   /** RX Signal */
+   DSL_uint16_t RxSignal;
+   /** TX Signal */
+   DSL_uint16_t TxSignal;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Autonomous message indicating that the modem online code was reached and that
+   initialization was completed. The management entity may not perform any
+   query-response messaging until the EVT_ModemReady message is received. Its
+   generation cannot be disabled. If it is not received this indicates a
+   problem, possibly with the boot sequence. If the message is received, it
+   contains a result code that may also indicate that an error was detected by
+   the firmware during initialization.
+*/
+struct EVT_ModemReady
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Error Code */
+   DSL_uint8_t ErrorCode;
+   /** Warning Code */
+   DSL_uint8_t WarningCode;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Warning Code */
+   DSL_uint8_t WarningCode;
+   /** Error Code */
+   DSL_uint8_t ErrorCode;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Controls state transitions of the modem state-machine.
+*/
+struct CMD_ModemFSM_StateSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 12;
+   /** Link Control */
+   DSL_uint16_t LinkControl : 4;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Link Control */
+   DSL_uint16_t LinkControl : 4;
+   /** Reserved */
+   DSL_uint16_t Res0 : 12;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for message CMD_ModemFSM_StateSet
+*/
+struct ACK_ModemFSM_StateSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reports failure information after entering FAIL state. This message is sent
+   autonomously without host request after entrance into FAIL was indicated by
+   EVT_ModemFSM_StateGet. Both messages are generated only if enabled with
+   CMD_ModemFSM_EventConfigure (common Bit E8 "FAIL").
+*/
+struct ALM_ModemFSM_FailReasonGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** System Sub Error Code */
+   DSL_uint8_t SubErrorCode;
+   /** System Error Code */
+   DSL_uint8_t ErrorCode;
+   /** Failure State Information */
+   DSL_uint16_t FW_FailCode;
+   /** Reserved */
+   DSL_uint16_t Res0[8];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** System Error Code */
+   DSL_uint8_t ErrorCode;
+   /** System Sub Error Code */
+   DSL_uint8_t SubErrorCode;
+   /** Failure State Information */
+   DSL_uint16_t FW_FailCode;
+   /** Reserved */
+   DSL_uint16_t Res0[8];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests failure information after entering FAIL state.
+*/
+struct CMD_ModemFSM_FailReasonGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns failure information after entering FAIL state.
+*/
+struct ACK_ModemFSM_FailReasonGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** System Sub Error Code */
+   DSL_uint8_t SubErrorCode;
+   /** System Error Code */
+   DSL_uint8_t ErrorCode;
+   /** Failure State Information */
+   DSL_uint16_t FW_FailCode;
+   /** Reserved */
+   DSL_uint16_t Res0[8];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** System Error Code */
+   DSL_uint8_t ErrorCode;
+   /** System Sub Error Code */
+   DSL_uint8_t SubErrorCode;
+   /** Failure State Information */
+   DSL_uint16_t FW_FailCode;
+   /** Reserved */
+   DSL_uint16_t Res0[8];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests failure information of the last previous FAIL state.
+*/
+struct CMD_ModemFSM_PrevFailReasonGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns failure information from last previous FAIL state. The message
+   structure is the same as ACK_ModemFSM_FailReasonGet (used for the current
+   FAIL state.)
+*/
+struct ACK_ModemFSM_PrevFailReasonGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** System Sub Error Code */
+   DSL_uint8_t SubErrorCode;
+   /** System Error Code */
+   DSL_uint8_t ErrorCode;
+   /** Failure State Information */
+   DSL_uint16_t FW_FailCode;
+   /** Reserved */
+   DSL_uint16_t Res0[8];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** System Error Code */
+   DSL_uint8_t ErrorCode;
+   /** System Sub Error Code */
+   DSL_uint8_t SubErrorCode;
+   /** Failure State Information */
+   DSL_uint16_t FW_FailCode;
+   /** Reserved */
+   DSL_uint16_t Res0[8];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests a failure reason history of the last few transitions to FAIL state.
+*/
+struct CMD_FailReasonHistoryGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides a failure reason history of the last few transitions to FAIL state.
+*/
+struct ACK_FailReasonHistoryGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** System Sub Error Code of 1st Previous Fail State */
+   DSL_uint8_t SubErrorCode1;
+   /** System Error Code of Previous Fail State */
+   DSL_uint8_t ErrorCode1;
+   /** FW Fail Code of of Previous Fail State */
+   DSL_uint16_t FW_FailCode1;
+   /** System Sub Error Code of 2nd Previous Fail State */
+   DSL_uint8_t SubErrorCode2;
+   /** System Error Code of 2nd Previous Fail State */
+   DSL_uint8_t ErrorCode2;
+   /** FW Fail Code of of 2nd Previous Fail State */
+   DSL_uint16_t FW_FailCode2;
+   /** System Sub Error Code of 3rd Previous Fail State */
+   DSL_uint8_t SubErrorCode3;
+   /** System Error Code of 3rd Previous Fail State */
+   DSL_uint8_t ErrorCode3;
+   /** FW Fail Code of of 3rd Previous Fail State */
+   DSL_uint16_t FW_FailCode3;
+   /** System Sub Error Code of 4th Previous Fail State */
+   DSL_uint8_t SubErrorCode4;
+   /** System Error Code of 4th Previous Fail State */
+   DSL_uint8_t ErrorCode4;
+   /** FW Fail Code of of 4th Previous Fail State */
+   DSL_uint16_t FW_FailCode4;
+   /** System Sub Error Code of 5th Previous Fail State */
+   DSL_uint8_t SubErrorCode5;
+   /** System Error Code of 5th Previous Fail State */
+   DSL_uint8_t ErrorCode5;
+   /** FW Fail Code of of 5thPrevious Fail State */
+   DSL_uint16_t FW_FailCode5;
+   /** Reserved */
+   DSL_uint16_t Res0[8];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** System Error Code of Previous Fail State */
+   DSL_uint8_t ErrorCode1;
+   /** System Sub Error Code of 1st Previous Fail State */
+   DSL_uint8_t SubErrorCode1;
+   /** FW Fail Code of of Previous Fail State */
+   DSL_uint16_t FW_FailCode1;
+   /** System Error Code of 2nd Previous Fail State */
+   DSL_uint8_t ErrorCode2;
+   /** System Sub Error Code of 2nd Previous Fail State */
+   DSL_uint8_t SubErrorCode2;
+   /** FW Fail Code of of 2nd Previous Fail State */
+   DSL_uint16_t FW_FailCode2;
+   /** System Error Code of 3rd Previous Fail State */
+   DSL_uint8_t ErrorCode3;
+   /** System Sub Error Code of 3rd Previous Fail State */
+   DSL_uint8_t SubErrorCode3;
+   /** FW Fail Code of of 3rd Previous Fail State */
+   DSL_uint16_t FW_FailCode3;
+   /** System Error Code of 4th Previous Fail State */
+   DSL_uint8_t ErrorCode4;
+   /** System Sub Error Code of 4th Previous Fail State */
+   DSL_uint8_t SubErrorCode4;
+   /** FW Fail Code of of 4th Previous Fail State */
+   DSL_uint16_t FW_FailCode4;
+   /** System Error Code of 5th Previous Fail State */
+   DSL_uint8_t ErrorCode5;
+   /** System Sub Error Code of 5th Previous Fail State */
+   DSL_uint8_t SubErrorCode5;
+   /** FW Fail Code of of 5thPrevious Fail State */
+   DSL_uint16_t FW_FailCode5;
+   /** Reserved */
+   DSL_uint16_t Res0[8];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Configuration of options for the modem state machine.
+*/
+struct CMD_ModemFSM_OptionsSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 5;
+   /** L2 Extensions of G.992.3 Amd4 (2011), (ADSL only), Bit 10 */
+   DSL_uint16_t E10 : 1;
+   /** L2 Automatic Exit (ADSL only), Bit 9 */
+   DSL_uint16_t E9 : 1;
+   /** L2 Low-Power Mode Enable (ADSL only), Bit 8 */
+   DSL_uint16_t E8 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 5;
+   /** Loop Diagnostic Mode Control, Bit 2 */
+   DSL_uint16_t E2 : 1;
+   /** Reserved 0 */
+   DSL_uint16_t E1 : 1;
+   /** Automatic Re-Start Control, Bit 0 */
+   DSL_uint16_t E0 : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Automatic Re-Start Control, Bit 0 */
+   DSL_uint16_t E0 : 1;
+   /** Reserved 0 */
+   DSL_uint16_t E1 : 1;
+   /** Loop Diagnostic Mode Control, Bit 2 */
+   DSL_uint16_t E2 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 5;
+   /** L2 Low-Power Mode Enable (ADSL only), Bit 8 */
+   DSL_uint16_t E8 : 1;
+   /** L2 Automatic Exit (ADSL only), Bit 9 */
+   DSL_uint16_t E9 : 1;
+   /** L2 Extensions of G.992.3 Amd4 (2011), (ADSL only), Bit 10 */
+   DSL_uint16_t E10 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 5;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_ModemFSM_OptionsSet.
+*/
+struct ACK_ModemFSM_OptionsSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Configuration of options for the modem state machine.
+*/
+struct CMD_ModemOptionsSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 10;
+   /** Steady-State Algorithm Control, Bit5 */
+   DSL_uint16_t Trellis : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 1;
+   /** AELEM Control (VDSL only), Bit 3 */
+   DSL_uint16_t enableAelem : 1;
+   /** Short Init Control (ADSL only), Bit 2 */
+   DSL_uint16_t shortInit : 1;
+   /** US Virtual Noise Support, Bit 1 */
+   DSL_uint16_t enableVN_US : 1;
+   /** DS Virtual Noise Support, Bit 0 */
+   DSL_uint16_t enableVN_DS : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** DS Virtual Noise Support, Bit 0 */
+   DSL_uint16_t enableVN_DS : 1;
+   /** US Virtual Noise Support, Bit 1 */
+   DSL_uint16_t enableVN_US : 1;
+   /** Short Init Control (ADSL only), Bit 2 */
+   DSL_uint16_t shortInit : 1;
+   /** AELEM Control (VDSL only), Bit 3 */
+   DSL_uint16_t enableAelem : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 1;
+   /** Steady-State Algorithm Control, Bit5 */
+   DSL_uint16_t Trellis : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 10;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_ModemOptionsSet.
+*/
+struct ACK_ModemOptionsSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Sets options for the modem state-machine. Enables/Disables autonomous
+   messages for specific state transitions (EVT_ModemFSM_StateGet). The EVT
+   message is generated after entering the particular state listed in the
+   parameter description of the enable bits.
+*/
+struct CMD_ModemFSM_EventConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Enable Bit 15 */
+   DSL_uint16_t E15 : 1;
+   /** Enable Bit 14 */
+   DSL_uint16_t E14 : 1;
+   /** Enable Bit 13 */
+   DSL_uint16_t E13 : 1;
+   /** Enable Bit 12 */
+   DSL_uint16_t E12 : 1;
+   /** Enable Bit 11 */
+   DSL_uint16_t E11 : 1;
+   /** Enable Bit 10 */
+   DSL_uint16_t E10 : 1;
+   /** Enable Bit 9 */
+   DSL_uint16_t E9 : 1;
+   /** Enable Bit 8 */
+   DSL_uint16_t E8 : 1;
+   /** Enable Bit 7 */
+   DSL_uint16_t E7 : 1;
+   /** Enable Bit 6 */
+   DSL_uint16_t E6 : 1;
+   /** Enable Bit 5 */
+   DSL_uint16_t E5 : 1;
+   /** Enable Bit 4 */
+   DSL_uint16_t E4 : 1;
+   /** Enable Bit 3 */
+   DSL_uint16_t E3 : 1;
+   /** Enable Bit 2 */
+   DSL_uint16_t E2 : 1;
+   /** Enable Bit 1 (ADSL only) */
+   DSL_uint16_t E1 : 1;
+   /** Enable Bit 0 */
+   DSL_uint16_t E0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 15;
+   /** Enable Bit 16 */
+   DSL_uint16_t E16 : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Enable Bit 0 */
+   DSL_uint16_t E0 : 1;
+   /** Enable Bit 1 (ADSL only) */
+   DSL_uint16_t E1 : 1;
+   /** Enable Bit 2 */
+   DSL_uint16_t E2 : 1;
+   /** Enable Bit 3 */
+   DSL_uint16_t E3 : 1;
+   /** Enable Bit 4 */
+   DSL_uint16_t E4 : 1;
+   /** Enable Bit 5 */
+   DSL_uint16_t E5 : 1;
+   /** Enable Bit 6 */
+   DSL_uint16_t E6 : 1;
+   /** Enable Bit 7 */
+   DSL_uint16_t E7 : 1;
+   /** Enable Bit 8 */
+   DSL_uint16_t E8 : 1;
+   /** Enable Bit 9 */
+   DSL_uint16_t E9 : 1;
+   /** Enable Bit 10 */
+   DSL_uint16_t E10 : 1;
+   /** Enable Bit 11 */
+   DSL_uint16_t E11 : 1;
+   /** Enable Bit 12 */
+   DSL_uint16_t E12 : 1;
+   /** Enable Bit 13 */
+   DSL_uint16_t E13 : 1;
+   /** Enable Bit 14 */
+   DSL_uint16_t E14 : 1;
+   /** Enable Bit 15 */
+   DSL_uint16_t E15 : 1;
+   /** Enable Bit 16 */
+   DSL_uint16_t E16 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 15;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for CMD_ModemFSM_EventConfigure. (Enabling/Disabling EVENT
+   messages (EVTs) for specific state transitions.)
+*/
+struct ACK_ModemFSM_EventConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Enables/Disables the generation of ALARM messages (ALM) for specific near-end
+   line failures. If the corresponding Enable bit for a line failure is set,
+   then the modem firmware will send an autonomous message ALM_LineFailureNE_Get
+   if this failure occurs.
+*/
+struct CMD_FailuresNE_AlarmConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 2;
+   /** Enable Bit 13 */
+   DSL_uint16_t E13 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 9;
+   /** Enable Bit3 */
+   DSL_uint16_t E3 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 1;
+   /** Enable Bit1 */
+   DSL_uint16_t E1 : 1;
+   /** Enable Bit0 */
+   DSL_uint16_t E0 : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Enable Bit0 */
+   DSL_uint16_t E0 : 1;
+   /** Enable Bit1 */
+   DSL_uint16_t E1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 1;
+   /** Enable Bit3 */
+   DSL_uint16_t E3 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 9;
+   /** Enable Bit 13 */
+   DSL_uint16_t E13 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 2;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_FailuresNE_AlarmConfigure.
+*/
+struct ACK_FailuresNE_AlarmConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Enables/Disables the generation of ALARM messages (ALM) for specific far-end
+   line failures. If the corresponding Enable bit for a line failure is set,
+   then the modem firmware will send an autonomous message ALM_LineFailureFE_Get
+   if this failure occurs.
+*/
+struct CMD_FailuresFE_AlarmConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 12;
+   /** Enable Bit3 */
+   DSL_uint16_t E3 : 1;
+   /** Enable Bit2 */
+   DSL_uint16_t E2 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 1;
+   /** Enable Bit0 */
+   DSL_uint16_t E0 : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Enable Bit0 */
+   DSL_uint16_t E0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 1;
+   /** Enable Bit2 */
+   DSL_uint16_t E2 : 1;
+   /** Enable Bit3 */
+   DSL_uint16_t E3 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 12;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_FailuresFE_AlarmConfigure.
+*/
+struct ACK_FailuresFE_AlarmConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Configures re-initialization triggers for near-end failure conditions in
+   modem state STEADY STATE transmission (see Figure 1). This command is
+   accepted in RESET state only.
+*/
+struct CMD_ReInitNE_Configure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 2;
+   /** ESE */
+   DSL_uint16_t E13 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 2;
+   /** OOS BC0 */
+   DSL_uint16_t E10 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 1;
+   /** NCD BC0 */
+   DSL_uint16_t E8 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 1;
+   /** LCD BC0 */
+   DSL_uint16_t E6 : 1;
+   /** Reserved */
+   DSL_uint16_t Res4 : 2;
+   /** LOM */
+   DSL_uint16_t E3 : 1;
+   /** Reserved */
+   DSL_uint16_t Res5 : 1;
+   /** LOF */
+   DSL_uint16_t E1 : 1;
+   /** LOS */
+   DSL_uint16_t E0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res6 : 14;
+   /** ESx */
+   DSL_uint16_t F1 : 1;
+   /** SESx */
+   DSL_uint16_t F0 : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** LOS */
+   DSL_uint16_t E0 : 1;
+   /** LOF */
+   DSL_uint16_t E1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res5 : 1;
+   /** LOM */
+   DSL_uint16_t E3 : 1;
+   /** Reserved */
+   DSL_uint16_t Res4 : 2;
+   /** LCD BC0 */
+   DSL_uint16_t E6 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 1;
+   /** NCD BC0 */
+   DSL_uint16_t E8 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 1;
+   /** OOS BC0 */
+   DSL_uint16_t E10 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 2;
+   /** ESE */
+   DSL_uint16_t E13 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 2;
+   /** SESx */
+   DSL_uint16_t F0 : 1;
+   /** ESx */
+   DSL_uint16_t F1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res6 : 14;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgment to CMD_ReInitNE_Configure (Configuration of re-initialization
+   triggers for near-end failures).
+*/
+struct ACK_ReInitNE_Configure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Configuration of reinitialization trigger definitions.
+*/
+struct CMD_ReinitThreshConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** SESx Reinit Period */
+   DSL_uint16_t SESxPeriod;
+   /** LOM Persistency Time for Reinit */
+   DSL_uint16_t LomRiPeriod;
+   /** ESx Reinit Period */
+   DSL_uint16_t ESxPeriod;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** SESx Reinit Period */
+   DSL_uint16_t SESxPeriod;
+   /** LOM Persistency Time for Reinit */
+   DSL_uint16_t LomRiPeriod;
+   /** ESx Reinit Period */
+   DSL_uint16_t ESxPeriod;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for the message ACK_ReinitThreshConfigure.
+*/
+struct ACK_ReinitThreshConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Triggers a shutdown request, either as "L3 orderly shutdown" towards the
+   remote side or as "locally forced shutdown" to the DSL-FW without sending a
+   request to the remote side.After an "L3 orderly shutdown" request was
+   accepted by the CO, the following shall happen: The CPE-Host forces L3 entry
+   with transition to RESET state by applying CMD_ModemFSM_StateGet.A "locally
+   forced shutdown" always results in exiting Showtime.
+*/
+struct CMD_ShutdownRequest
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** Locally Forced Shutdown */
+   DSL_uint16_t ForcedShutdown : 1;
+   /** L3 Orderly Shutdown Request */
+   DSL_uint16_t L3shutdown : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** L3 Orderly Shutdown Request */
+   DSL_uint16_t L3shutdown : 1;
+   /** Locally Forced Shutdown */
+   DSL_uint16_t ForcedShutdown : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for CMD_ShutdownRequest.
+*/
+struct ACK_ShutdownRequest
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests information about L3 orderly shutdown requests initiated from the
+   remote side.Applying CMD_RxL3RequestStatusGet allows the host to determine
+   whether a near-end LOS or LOM failure is due to an L3 shutdown or an
+   unexpected line failure.
+*/
+struct CMD_RxL3RequestStatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for CMD_RxL3RequestStatusGet.As long as the modem is in L0
+   (Showtime), an ATU-R will automatically respond to any L3 request from the
+   ATU-C by sending an accept message.  If the ATU-R is in L2 mode when it
+   receives the request, it will send a reject message. Upon receiving an
+   acceptance, the remote side should enter L3 state and shut off its
+   transmitter.
+*/
+struct ACK_RxL3RequestStatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** L3 Request Response */
+   DSL_uint16_t L3ReqResponse : 1;
+   /** L3 Request Received */
+   DSL_uint16_t L3ReqReceived : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** L3 Request Received */
+   DSL_uint16_t L3ReqReceived : 1;
+   /** L3 Request Response */
+   DSL_uint16_t L3ReqResponse : 1;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the status of a near-end initiated L3 shutdown request. If the
+   remote side accepted the request, in ADSL the host will force L3 entry using
+   CMD_ModemFSM_StateSet.
+*/
+struct CMD_TxL3RequestStatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for CMD_TxL3RequestStatusGet.
+*/
+struct ACK_TxL3RequestStatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** Status L3 Request */
+   DSL_uint16_t L3ReqStatus : 2;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Status L3 Request */
+   DSL_uint16_t L3ReqStatus : 2;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the fail reason of a failed near-end initiated L3 request. (see also
+   ACK_TxL3RequestStatusGet)
+*/
+struct CMD_TxL3ReqFailReasonGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reports the fail reason of a near-end initiated L3 request, as response to
+   CMD_TxL3ReqFailReasonGet.
+*/
+struct ACK_TxL3ReqFailReasonGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 8;
+   /** L3 Fail Reason */
+   DSL_uint8_t L3FailReason;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** L3 Fail Reason */
+   DSL_uint8_t L3FailReason;
+   /** Reserved */
+   DSL_uint16_t Res0 : 8;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message selects and enables one of several points during the
+   initialization process where -after a normal link start had been triggered-
+   the modem FSM "freezes". Freezing means the CO can be disconnected from the
+   line and still the CPE continues transmitting the signal of the current
+   phase. To exit from the freeze a state transition to RESET state has to be
+   triggered. In case of a Showtime Freeze the reinit-triggers do not have any
+   effect.
+*/
+struct CMD_ModemFSM_Freeze
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Freeze Points */
+   DSL_uint16_t FreezePoint;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Freeze Points */
+   DSL_uint16_t FreezePoint;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for message CMD_ModemFSM_Freeze.
+*/
+struct ACK_ModemFSM_Freeze
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests information about the loaded FW image. This info is used e.g. for
+   swapping between ADSL and VDSL.
+*/
+struct CMD_FW_ImageInfoGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the information about the FW image requested by CMD_FW_ImageInfoGet
+*/
+struct ACK_FW_ImageInfoGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+   /** Site */
+   DSL_uint16_t imageType : 1;
+   /** DSL mode */
+   DSL_uint16_t dslMode : 1;
+   /** Site */
+   DSL_uint16_t location : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Site */
+   DSL_uint16_t location : 1;
+   /** DSL mode */
+   DSL_uint16_t dslMode : 1;
+   /** Site */
+   DSL_uint16_t imageType : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message informs the FW about the status of SW parameters relevant for the
+   multimode state machine (APS). This can be used to trace the APS behaviour
+   with FW tools. The message does not influence the APS behaviour.
+*/
+struct CMD_APS_Status_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Port Mode */
+   DSL_uint16_t DualPortMode;
+   /** NextMode */
+   DSL_uint16_t NextMode;
+   /** Remember Function */
+   DSL_uint16_t bRemember;
+   /** Activation Sequence */
+   DSL_uint16_t ActSeq;
+   /** Activation Start Mode (ADSL only) */
+   DSL_uint16_t ActMode;
+   /** nRetry  */
+   DSL_uint16_t nRetry;
+   /** nFwRetry  */
+   DSL_uint16_t nFwRetry;
+   /** nGhsRetry  */
+   DSL_uint16_t nGhsRetry;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Port Mode */
+   DSL_uint16_t DualPortMode;
+   /** NextMode */
+   DSL_uint16_t NextMode;
+   /** Remember Function */
+   DSL_uint16_t bRemember;
+   /** Activation Sequence */
+   DSL_uint16_t ActSeq;
+   /** Activation Start Mode (ADSL only) */
+   DSL_uint16_t ActMode;
+   /** nRetry  */
+   DSL_uint16_t nRetry;
+   /** nFwRetry  */
+   DSL_uint16_t nFwRetry;
+   /** nGhsRetry  */
+   DSL_uint16_t nGhsRetry;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for message CMD_APS_Status_Set.
+*/
+struct ACK_APS_Status_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Configuration of the VTU Transmission System Enabling (XTSE).Configures the
+   transmission system coding types to be supported on the line (VDSL flavour
+   and annex support).(References: Section 7.3.1.1.1 of G.997.1 and G.994.1 Amd4
+   [10] Tables "Standard information field - SPar(1) coding")
+*/
+struct CMD_XTSE_Configure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** ADSL Mode-Bit15: G.992.5, Annex A */
+   DSL_uint16_t A15 : 1;
+   /** ADSL Mode-Bit14: G.992.5, Annex B */
+   DSL_uint16_t A14 : 1;
+   /** ADSL Mode-Bit13: G.992.3, Annex M */
+   DSL_uint16_t A13 : 1;
+   /** ADSL Mode-Bit12: G.992.3, Annex L, US Mask2 */
+   DSL_uint16_t A12 : 1;
+   /** ADSL Mode-Bit11: G.992.3, Annex L, US Mask1 */
+   DSL_uint16_t A11 : 1;
+   /** ADSL Mode-Bit10: G.992.2, Annex A */
+   DSL_uint16_t A10 : 1;
+   /** ADSL Mode-Bit9: G.992.3, Annex B */
+   DSL_uint16_t A9 : 1;
+   /** ADSL Mode-Bit8: G.992.3, Annex A */
+   DSL_uint16_t A8 : 1;
+   /** ADSL Mode-Bit7: G.992.5, Annex J */
+   DSL_uint16_t A7 : 1;
+   /** ADSL Mode-Bit6: G.992.5, Annex I */
+   DSL_uint16_t A6 : 1;
+   /** ADSL Mode-Bit5: G.992.3, Annex J */
+   DSL_uint16_t A5 : 1;
+   /** ADSL Mode-Bit4: G.992.3, Annex I */
+   DSL_uint16_t A4 : 1;
+   /** ADSL Mode-Bit3: G.992.1, Annex B */
+   DSL_uint16_t A3 : 1;
+   /** ADSL Mode-Bit2: G.992.1, Annex A */
+   DSL_uint16_t A2 : 1;
+   /** ADSL Mode-Bit1: G.992.5, Annex M */
+   DSL_uint16_t A1 : 1;
+   /** ADSL Mode-Bit0: T1.413 */
+   DSL_uint16_t A0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 7;
+   /** Bit8: G.FAST */
+   DSL_uint16_t F8 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 5;
+   /** VDSL Mode-Bit2: VDSL2 */
+   DSL_uint16_t V2 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 2;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** ADSL Mode-Bit0: T1.413 */
+   DSL_uint16_t A0 : 1;
+   /** ADSL Mode-Bit1: G.992.5, Annex M */
+   DSL_uint16_t A1 : 1;
+   /** ADSL Mode-Bit2: G.992.1, Annex A */
+   DSL_uint16_t A2 : 1;
+   /** ADSL Mode-Bit3: G.992.1, Annex B */
+   DSL_uint16_t A3 : 1;
+   /** ADSL Mode-Bit4: G.992.3, Annex I */
+   DSL_uint16_t A4 : 1;
+   /** ADSL Mode-Bit5: G.992.3, Annex J */
+   DSL_uint16_t A5 : 1;
+   /** ADSL Mode-Bit6: G.992.5, Annex I */
+   DSL_uint16_t A6 : 1;
+   /** ADSL Mode-Bit7: G.992.5, Annex J */
+   DSL_uint16_t A7 : 1;
+   /** ADSL Mode-Bit8: G.992.3, Annex A */
+   DSL_uint16_t A8 : 1;
+   /** ADSL Mode-Bit9: G.992.3, Annex B */
+   DSL_uint16_t A9 : 1;
+   /** ADSL Mode-Bit10: G.992.2, Annex A */
+   DSL_uint16_t A10 : 1;
+   /** ADSL Mode-Bit11: G.992.3, Annex L, US Mask1 */
+   DSL_uint16_t A11 : 1;
+   /** ADSL Mode-Bit12: G.992.3, Annex L, US Mask2 */
+   DSL_uint16_t A12 : 1;
+   /** ADSL Mode-Bit13: G.992.3, Annex M */
+   DSL_uint16_t A13 : 1;
+   /** ADSL Mode-Bit14: G.992.5, Annex B */
+   DSL_uint16_t A14 : 1;
+   /** ADSL Mode-Bit15: G.992.5, Annex A */
+   DSL_uint16_t A15 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 2;
+   /** VDSL Mode-Bit2: VDSL2 */
+   DSL_uint16_t V2 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 5;
+   /** Bit8: G.FAST */
+   DSL_uint16_t F8 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 7;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for message CMD_XTSE_Configure.
+*/
+struct ACK_XTSE_Configure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Controls the upstream band usage.The message can only be used for DMTscope
+   tests without handshake and training phases.
+*/
+struct CMD_BandControl_US_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint8_t Res0;
+   /** Number of Upstream Bands */
+   DSL_uint8_t NumBandsUS;
+   /** Band Descriptor US */
+   VRX_ToneIndex_t band[8];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Number of Upstream Bands */
+   DSL_uint8_t NumBandsUS;
+   /** Reserved */
+   DSL_uint8_t Res0;
+   /** Band Descriptor US */
+   VRX_ToneIndex_t band[8];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for message CMD_BandControl_US_Set.
+*/
+struct ACK_BandControl_US_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Configuration of PSD and Power parameters. Only used for DMTscope tests
+   without handshake and training phases.
+*/
+struct CMD_PSD_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** MAXNOMPSDus */
+   DSL_uint16_t MAXNOMPSDus;
+   /** Reserved */
+   DSL_uint16_t Res1;
+   /** MAXNOMATPus */
+   DSL_uint16_t MAXNOMATPus;
+   /** Reserved */
+   DSL_uint16_t Res2;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** MAXNOMPSDus */
+   DSL_uint16_t MAXNOMPSDus;
+   /** Reserved */
+   DSL_uint16_t Res1;
+   /** MAXNOMATPus */
+   DSL_uint16_t MAXNOMATPus;
+   /** Reserved */
+   DSL_uint16_t Res2;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for the message CMD_PSD_Set.
+*/
+struct ACK_PSD_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Specifies the maximum upstream transmit PSD by means of breakpoints.To be
+   used only for DMTscope tests without handshake and training phases.
+*/
+struct CMD_PSD_BreakpointsTxUS_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint8_t Res0;
+   /** Number of Breakpoints */
+   DSL_uint8_t NumBreakPts;
+   /** Breakpoint Descriptor TxPSDus */
+   VRX_PSDbreak_t breakpoint[32];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Number of Breakpoints */
+   DSL_uint8_t NumBreakPts;
+   /** Reserved */
+   DSL_uint8_t Res0;
+   /** Breakpoint Descriptor TxPSDus */
+   VRX_PSDbreak_t breakpoint[32];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for the message CMD_PSD_BreakpointsTxUS_Set.
+*/
+struct ACK_PSD_BreakpointsTxUS_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Sends downstream calibration information for "per-tone" test parameters. It
+   is effective for Loop Diagnostic Mode (DELT) and Showtime. It is the
+   responsibility of the manufacturer to provide the data.
+*/
+struct  CMD_PSD_Calibration_DS_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Number of Breakpoints */
+   DSL_uint16_t NumBreakPts;
+   /** Breakpoint Descriptor RxPSD Compensation */
+   VRX_PSD_CompBreak_t breakpoint[16];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Number of Breakpoints */
+   DSL_uint16_t NumBreakPts;
+   /** Breakpoint Descriptor RxPSD Compensation */
+   VRX_PSD_CompBreak_t breakpoint[16];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for the message CMD_PSD_Calibration_DS_Set.
+*/
+struct ACK_PSD_Calibration_DS_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Sends upstream calibration information for the upstream transmit PSD. It is
+   effective for loop diagnostic mode (DELT) and Showtime. It is the
+   responsibility of the manufacturer to provide the data.
+*/
+struct  CMD_PSD_Calibration_US_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Number of Breakpoints */
+   DSL_uint16_t NumBreakPts;
+   /** Breakpoint Descriptor TxPSD Compensation */
+   VRX_PSD_CompBreak_t breakpoint[32];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Number of Breakpoints */
+   DSL_uint16_t NumBreakPts;
+   /** Breakpoint Descriptor TxPSD Compensation */
+   VRX_PSD_CompBreak_t breakpoint[32];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for the message CMD_PSD_Calibration_US_Set.
+*/
+struct ACK_PSD_Calibration_US_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Configuration of PSD related options.
+*/
+struct CMD_PSD_OptionsSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 15;
+   /** US TSSI Control, Bit 0 */
+   DSL_uint16_t useTssiUS : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** US TSSI Control, Bit 0 */
+   DSL_uint16_t useTssiUS : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 15;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_PSD_OptionsSet.
+*/
+struct ACK_PSD_OptionsSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the electrical loop length estimate kl0.
+*/
+struct CMD_UPBO_KL0Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the data requested by CMD_UPBO_KL0Get.(Section 7.5.1.23 of G.997.1
+   [11])
+*/
+struct ACK_UPBO_KL0Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Kl0 Estimate VTU-R */
+   DSL_uint16_t kl0_EstimR;
+   /** Kl0 Estimate VTU-O */
+   DSL_uint16_t kl0_EstimO;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Kl0 Estimate VTU-R */
+   DSL_uint16_t kl0_EstimR;
+   /** Kl0 Estimate VTU-O */
+   DSL_uint16_t kl0_EstimO;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests status parameters for the Upstream  Power  Back-Off  (UPBO)
+   alternative  electrical  length  estimation  method (AELEM).
+*/
+struct CMD_PBO_AELEM_Status_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Upstream  Power  Back-Off  (UPBO)  status  parameters  for  the  alternative
+   electrical  length  estimation  method (AELEM) are reported.
+*/
+struct ACK_PBO_AELEM_Status_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** AELE-MODE Used */
+   DSL_uint16_t AeleMode;
+   /** Kl0 Estimate per Band VTU-R */
+   DSL_uint16_t Kl0EstimRPb[4];
+   /** Final Kl0 per Band VTU-O */
+   DSL_uint16_t Kl0EstimOPb[4];
+   /** UPBOELMT */
+   DSL_uint16_t UpboElmt;
+   /** RXTHRSHDS */
+   DSL_int16_t RxThreshDs;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** AELE-MODE Used */
+   DSL_uint16_t AeleMode;
+   /** Kl0 Estimate per Band VTU-R */
+   DSL_uint16_t Kl0EstimRPb[4];
+   /** Final Kl0 per Band VTU-O */
+   DSL_uint16_t Kl0EstimOPb[4];
+   /** UPBOELMT */
+   DSL_uint16_t UpboElmt;
+   /** RXTHRSHDS */
+   DSL_int16_t RxThreshDs;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Configuration of a target noise margin delta, which is added to the target
+   noise margin value configured at the CO (and in case of the CPE received from
+   there). The resulting value is then taken as target noise margin, e.g. for
+   bit loading.
+*/
+struct CMD_NoiseMarginDeltaSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Target Noise Margin Delta DS */
+   DSL_int16_t deltaTARSNRMds;
+   /** Reserved (VDSL only) */
+   DSL_uint16_t Res0 : 14;
+   /** Reserved (VDSL only) */
+   DSL_uint16_t Res1 : 1;
+   /** Reserved (VDSL only) */
+   DSL_uint16_t Res2 : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Target Noise Margin Delta DS */
+   DSL_int16_t deltaTARSNRMds;
+   /** Reserved (VDSL only) */
+   DSL_uint16_t Res2 : 1;
+   /** Reserved (VDSL only) */
+   DSL_uint16_t Res1 : 1;
+   /** Reserved (VDSL only) */
+   DSL_uint16_t Res0 : 14;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for the message CMD_NoiseMarginDeltaSet.
+*/
+struct ACK_NoiseMarginDeltaSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Sets parameters for downstream bearer channel 0 (Chapters 7.3.2.1-5 of
+   G.997.1 [11]). Bearer channel configuration at the CPE is optional and just
+   used to further limit the parameters usually configured at the CO.The mode,
+   ATM or PTM, is selected with the configuration controls "ATMControl" and
+   "PTMControl" in Parameter 2. Exactly one of them must be enabled, not both!
+*/
+struct CMD_BearerCh0_DS_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+   /** Reserved (STM) */
+   DSL_uint16_t Res1 : 1;
+   /** ATM Configuration Control */
+   DSL_uint16_t ATMControl : 1;
+   /** PTM Configuration Control */
+   DSL_uint16_t PTMControl : 1;
+   /** Reserved */
+   DSL_uint16_t Res2;
+   /** Minimum Data Rate BC0 PTM DS, LSW */
+   DSL_uint16_t minRate0_PTMds_LSW;
+   /** Minimum Data Rate BC0 PTM DS, MSW */
+   DSL_uint16_t minRate0_PTMds_MSW;
+   /** Maximum Data Rate BC0 PTM DS, LSW */
+   DSL_uint16_t maxRate0_PTMds_LSW;
+   /** Maximum Data Rate BC0 PTM DS, MSW */
+   DSL_uint16_t maxRate0_PTMds_MSW;
+   /** Minimum Reserved Data Rate BC0 PTM DS, LSW */
+   DSL_uint16_t minResRate0_PTMds_LSW;
+   /** Minimum Reserved Data Rate BC0 PTM DS, MSW */
+   DSL_uint16_t minResRate0_PTMds_MSW;
+   /** Reserved */
+   DSL_uint8_t Res3;
+   /** Maximum Interleaving Delay BC0 PTM DS */
+   DSL_uint8_t maxDelay0_PTMds;
+   /** Reserved */
+   DSL_uint16_t Res4 : 4;
+   /** OPTIONAL CIPOLICY 2, BC0 PTM DS */
+   DSL_uint16_t CIPolicy2_PTMds : 1;
+   /** OPTIONAL CIPOLICY 1, BC0 PTM DS */
+   DSL_uint16_t CIPolicy1_PTMds : 1;
+   /** "SHORT PACKETS" OPTION BC0 PTM DS */
+   DSL_uint16_t ShortPacket_PTMds : 1;
+   /** "PRE-EMPTION" OPTION BC0 PTM DS */
+   DSL_uint16_t Preempt_PTMds : 1;
+   /** Reserved */
+   DSL_uint16_t Res5 : 6;
+   /** Maximum BER BC0 PTM DS */
+   DSL_uint16_t BER_PTMds : 2;
+   /** Reserved */
+   DSL_uint16_t Res6 : 4;
+   /** Minimum INP BC0 PTM DS */
+   DSL_uint16_t minINP_PTMds : 12;
+   /** Reserved */
+   DSL_uint16_t Res7;
+   /** Minimum Data Rate BC0 ATM DS, LSW */
+   DSL_uint16_t minRate0_ATMds_LSW;
+   /** Minimum Data Rate BC0 ATM DS, MSW */
+   DSL_uint16_t minRate0_ATMds_MSW;
+   /** Maximum Data Rate BC0 ATM DS, LSW */
+   DSL_uint16_t maxRate0_ATMds_LSW;
+   /** Maximum Data Rate BC0 ATM DS, MSW */
+   DSL_uint16_t maxRate0_ATMds_MSW;
+   /** Minimum Reserved Data Rate BC0 ATM DS, LSW */
+   DSL_uint16_t minResRate0_ATMds_LSW;
+   /** Minimum Reserved Data Rate BC0 ATM DS, MSW */
+   DSL_uint16_t minResRate0_ATMds_MSW;
+   /** Reserved */
+   DSL_uint8_t Res8;
+   /** Maximum Interleaving Delay BC0 ATM DS */
+   DSL_uint8_t maxDelay0_ATMds;
+   /** Reserved */
+   DSL_uint16_t Res9 : 4;
+   /** OPTIONAL CIPOLICY 2, BC0 ATM DS */
+   DSL_uint16_t CIPolicy2_ATMds : 1;
+   /** OPTIONAL CIPOLICY 1, BC0 ATM DS */
+   DSL_uint16_t CIPolicy1_ATMds : 1;
+   /** Reserved */
+   DSL_uint16_t Res10 : 8;
+   /** Maximum BER BC0 ATM DS */
+   DSL_uint16_t BER_ATMds : 2;
+   /** Reserved */
+   DSL_uint16_t Res11 : 4;
+   /** Minimum INP BC0 ATM DS */
+   DSL_uint16_t minINP_ATMds : 12;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PTM Configuration Control */
+   DSL_uint16_t PTMControl : 1;
+   /** ATM Configuration Control */
+   DSL_uint16_t ATMControl : 1;
+   /** Reserved (STM) */
+   DSL_uint16_t Res1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+   /** Reserved */
+   DSL_uint16_t Res2;
+   /** Minimum Data Rate BC0 PTM DS, LSW */
+   DSL_uint16_t minRate0_PTMds_LSW;
+   /** Minimum Data Rate BC0 PTM DS, MSW */
+   DSL_uint16_t minRate0_PTMds_MSW;
+   /** Maximum Data Rate BC0 PTM DS, LSW */
+   DSL_uint16_t maxRate0_PTMds_LSW;
+   /** Maximum Data Rate BC0 PTM DS, MSW */
+   DSL_uint16_t maxRate0_PTMds_MSW;
+   /** Minimum Reserved Data Rate BC0 PTM DS, LSW */
+   DSL_uint16_t minResRate0_PTMds_LSW;
+   /** Minimum Reserved Data Rate BC0 PTM DS, MSW */
+   DSL_uint16_t minResRate0_PTMds_MSW;
+   /** Maximum Interleaving Delay BC0 PTM DS */
+   DSL_uint8_t maxDelay0_PTMds;
+   /** Reserved */
+   DSL_uint8_t Res3;
+   /** Maximum BER BC0 PTM DS */
+   DSL_uint16_t BER_PTMds : 2;
+   /** Reserved */
+   DSL_uint16_t Res5 : 6;
+   /** "PRE-EMPTION" OPTION BC0 PTM DS */
+   DSL_uint16_t Preempt_PTMds : 1;
+   /** "SHORT PACKETS" OPTION BC0 PTM DS */
+   DSL_uint16_t ShortPacket_PTMds : 1;
+   /** OPTIONAL CIPOLICY 1, BC0 PTM DS */
+   DSL_uint16_t CIPolicy1_PTMds : 1;
+   /** OPTIONAL CIPOLICY 2, BC0 PTM DS */
+   DSL_uint16_t CIPolicy2_PTMds : 1;
+   /** Reserved */
+   DSL_uint16_t Res4 : 4;
+   /** Minimum INP BC0 PTM DS */
+   DSL_uint16_t minINP_PTMds : 12;
+   /** Reserved */
+   DSL_uint16_t Res6 : 4;
+   /** Reserved */
+   DSL_uint16_t Res7;
+   /** Minimum Data Rate BC0 ATM DS, LSW */
+   DSL_uint16_t minRate0_ATMds_LSW;
+   /** Minimum Data Rate BC0 ATM DS, MSW */
+   DSL_uint16_t minRate0_ATMds_MSW;
+   /** Maximum Data Rate BC0 ATM DS, LSW */
+   DSL_uint16_t maxRate0_ATMds_LSW;
+   /** Maximum Data Rate BC0 ATM DS, MSW */
+   DSL_uint16_t maxRate0_ATMds_MSW;
+   /** Minimum Reserved Data Rate BC0 ATM DS, LSW */
+   DSL_uint16_t minResRate0_ATMds_LSW;
+   /** Minimum Reserved Data Rate BC0 ATM DS, MSW */
+   DSL_uint16_t minResRate0_ATMds_MSW;
+   /** Maximum Interleaving Delay BC0 ATM DS */
+   DSL_uint8_t maxDelay0_ATMds;
+   /** Reserved */
+   DSL_uint8_t Res8;
+   /** Maximum BER BC0 ATM DS */
+   DSL_uint16_t BER_ATMds : 2;
+   /** Reserved */
+   DSL_uint16_t Res10 : 8;
+   /** OPTIONAL CIPOLICY 1, BC0 ATM DS */
+   DSL_uint16_t CIPolicy1_ATMds : 1;
+   /** OPTIONAL CIPOLICY 2, BC0 ATM DS */
+   DSL_uint16_t CIPolicy2_ATMds : 1;
+   /** Reserved */
+   DSL_uint16_t Res9 : 4;
+   /** Minimum INP BC0 ATM DS */
+   DSL_uint16_t minINP_ATMds : 12;
+   /** Reserved */
+   DSL_uint16_t Res11 : 4;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for CMD_BearerCh0_DS_Set. (Configuration of bearer channel
+   0).
+*/
+struct ACK_BearerCh0_DS_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Sets parameters for upstream bearer channel 0 (Chapters 7.3.2.1-5 of G.997.1
+   [11]). Bearer channel configuration at the CPE is optional and just used to
+   further limit the parameters usually configured at the CO.The mode, ATM or
+   PTM, is selected with the configuration controls "ATMControl" and
+   "PTMControl" in Parameter 2. Exactly one of them must be enabled, not both!
+*/
+struct CMD_BearerCh0_US_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+   /** Reserved (STM) */
+   DSL_uint16_t Res1 : 1;
+   /** ATM Configuration Control */
+   DSL_uint16_t ATMControl : 1;
+   /** PTM Configuration Control */
+   DSL_uint16_t PTMControl : 1;
+   /** Reserved */
+   DSL_uint16_t Res2;
+   /** Minimum Data Rate BC0 PTM US, LSW */
+   DSL_uint16_t minRate0_PTMus_LSW;
+   /** Minimum Data Rate BC0 PTM US, MSW */
+   DSL_uint16_t minRate0_PTMus_MSW;
+   /** Maximum Data Rate BC0 PTM US, LSW */
+   DSL_uint16_t maxRate0_PTMus_LSW;
+   /** Maximum Data Rate BC0 PTM US, MSW */
+   DSL_uint16_t maxRate0_PTMus_MSW;
+   /** Minimum Reserved Data Rate BC0 PTM US, LSW */
+   DSL_uint16_t minResRate0_PTMus_LSW;
+   /** Minimum Reserved Data Rate BC0 PTM US, MSW */
+   DSL_uint16_t minResRate0_PTMus_MSW;
+   /** Reserved */
+   DSL_uint8_t Res3;
+   /** Maximum Interleaving Delay BC0 PTM US */
+   DSL_uint8_t maxDelay0_PTMus;
+   /** Reserved */
+   DSL_uint16_t Res4 : 4;
+   /** OPTIONAL CIPOLICY 2, BC0 PTM US */
+   DSL_uint16_t CIPolicy2_PTMus : 1;
+   /** OPTIONAL CIPOLICY 1, BC0 PTM US */
+   DSL_uint16_t CIPolicy1_PTMus : 1;
+   /** "SHORT PACKETS" OPTION BC0 PTM US */
+   DSL_uint16_t ShortPacket_PTMus : 1;
+   /** "PRE-EMPTION" OPTION BC0 PTM US */
+   DSL_uint16_t Preempt_PTMus : 1;
+   /** Reserved */
+   DSL_uint16_t Res5 : 6;
+   /** Maximum BER BC0 PTM US */
+   DSL_uint16_t BER_PTMus : 2;
+   /** Reserved */
+   DSL_uint16_t Res6 : 4;
+   /** Minimum INP BC0 PTM US */
+   DSL_uint16_t minINP_PTMus : 12;
+   /** Reserved */
+   DSL_uint16_t Res7;
+   /** Minimum Data Rate BC0 ATM US, LSW */
+   DSL_uint16_t minRate0_ATMus_LSW;
+   /** Minimum Data Rate BC0 ATM US, MSW */
+   DSL_uint16_t minRate0_ATMus_MSW;
+   /** Maximum Data Rate BC0 ATM US, LSW */
+   DSL_uint16_t maxRate0_ATMus_LSW;
+   /** Maximum Data Rate BC0 ATM US, MSW */
+   DSL_uint16_t maxRate0_ATMus_MSW;
+   /** Minimum Reserved Data Rate BC0 ATM US, LSW */
+   DSL_uint16_t minResRate0_ATMus_LSW;
+   /** Minimum Reserved Data Rate BC0 ATM US, MSW */
+   DSL_uint16_t minResRate0_ATMus_MSW;
+   /** Reserved */
+   DSL_uint8_t Res8;
+   /** Maximum Interleaving Delay BC0 ATM US */
+   DSL_uint8_t maxDelay0_ATMus;
+   /** Reserved */
+   DSL_uint16_t Res9 : 4;
+   /** OPTIONAL CIPOLICY 1, BC0 ATM US */
+   DSL_uint16_t CIPolicy2_ATMus : 1;
+   /** OPTIONAL CIPOLICY 2, BC0 ATM US */
+   DSL_uint16_t CIPolicy1_ATMus : 1;
+   /** Reserved */
+   DSL_uint16_t Res10 : 8;
+   /** Maximum BER BC0 ATM US */
+   DSL_uint16_t BER_ATMus : 2;
+   /** Reserved */
+   DSL_uint16_t Res11 : 4;
+   /** Minimum INP BC0 ATM US */
+   DSL_uint16_t minINP_ATMus : 12;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PTM Configuration Control */
+   DSL_uint16_t PTMControl : 1;
+   /** ATM Configuration Control */
+   DSL_uint16_t ATMControl : 1;
+   /** Reserved (STM) */
+   DSL_uint16_t Res1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+   /** Reserved */
+   DSL_uint16_t Res2;
+   /** Minimum Data Rate BC0 PTM US, LSW */
+   DSL_uint16_t minRate0_PTMus_LSW;
+   /** Minimum Data Rate BC0 PTM US, MSW */
+   DSL_uint16_t minRate0_PTMus_MSW;
+   /** Maximum Data Rate BC0 PTM US, LSW */
+   DSL_uint16_t maxRate0_PTMus_LSW;
+   /** Maximum Data Rate BC0 PTM US, MSW */
+   DSL_uint16_t maxRate0_PTMus_MSW;
+   /** Minimum Reserved Data Rate BC0 PTM US, LSW */
+   DSL_uint16_t minResRate0_PTMus_LSW;
+   /** Minimum Reserved Data Rate BC0 PTM US, MSW */
+   DSL_uint16_t minResRate0_PTMus_MSW;
+   /** Maximum Interleaving Delay BC0 PTM US */
+   DSL_uint8_t maxDelay0_PTMus;
+   /** Reserved */
+   DSL_uint8_t Res3;
+   /** Maximum BER BC0 PTM US */
+   DSL_uint16_t BER_PTMus : 2;
+   /** Reserved */
+   DSL_uint16_t Res5 : 6;
+   /** "PRE-EMPTION" OPTION BC0 PTM US */
+   DSL_uint16_t Preempt_PTMus : 1;
+   /** "SHORT PACKETS" OPTION BC0 PTM US */
+   DSL_uint16_t ShortPacket_PTMus : 1;
+   /** OPTIONAL CIPOLICY 1, BC0 PTM US */
+   DSL_uint16_t CIPolicy1_PTMus : 1;
+   /** OPTIONAL CIPOLICY 2, BC0 PTM US */
+   DSL_uint16_t CIPolicy2_PTMus : 1;
+   /** Reserved */
+   DSL_uint16_t Res4 : 4;
+   /** Minimum INP BC0 PTM US */
+   DSL_uint16_t minINP_PTMus : 12;
+   /** Reserved */
+   DSL_uint16_t Res6 : 4;
+   /** Reserved */
+   DSL_uint16_t Res7;
+   /** Minimum Data Rate BC0 ATM US, LSW */
+   DSL_uint16_t minRate0_ATMus_LSW;
+   /** Minimum Data Rate BC0 ATM US, MSW */
+   DSL_uint16_t minRate0_ATMus_MSW;
+   /** Maximum Data Rate BC0 ATM US, LSW */
+   DSL_uint16_t maxRate0_ATMus_LSW;
+   /** Maximum Data Rate BC0 ATM US, MSW */
+   DSL_uint16_t maxRate0_ATMus_MSW;
+   /** Minimum Reserved Data Rate BC0 ATM US, LSW */
+   DSL_uint16_t minResRate0_ATMus_LSW;
+   /** Minimum Reserved Data Rate BC0 ATM US, MSW */
+   DSL_uint16_t minResRate0_ATMus_MSW;
+   /** Maximum Interleaving Delay BC0 ATM US */
+   DSL_uint8_t maxDelay0_ATMus;
+   /** Reserved */
+   DSL_uint8_t Res8;
+   /** Maximum BER BC0 ATM US */
+   DSL_uint16_t BER_ATMus : 2;
+   /** Reserved */
+   DSL_uint16_t Res10 : 8;
+   /** OPTIONAL CIPOLICY 2, BC0 ATM US */
+   DSL_uint16_t CIPolicy1_ATMus : 1;
+   /** OPTIONAL CIPOLICY 1, BC0 ATM US */
+   DSL_uint16_t CIPolicy2_ATMus : 1;
+   /** Reserved */
+   DSL_uint16_t Res9 : 4;
+   /** Minimum INP BC0 ATM US */
+   DSL_uint16_t minINP_ATMus : 12;
+   /** Reserved */
+   DSL_uint16_t Res11 : 4;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for CMD_BearerCh0_US_Set. (Configuration of bearer channel
+   0).
+*/
+struct ACK_BearerCh0_US_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message selects the channel initialization policy (CIPOLICY) to be
+   applied for the tranceiver configuration. (Section 7.3.2.10 of G.997.1)In
+   ADSL mode, the message is applicable only for ADSL2/2+ (Section 7.10.3 of
+   G.992.3 Amd 3). The standard defines the parameter for the CO only. Here, the
+   message is applied at the ADSL-CPE, then it overrides the policy given by the
+   CO!
+*/
+struct CMD_InitPolicySet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** Reserved for Init Policy BC1 */
+   DSL_uint16_t Res1 : 1;
+   /** Init Policy BC0 */
+   DSL_uint16_t policy0 : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Init Policy BC0 */
+   DSL_uint16_t policy0 : 1;
+   /** Reserved for Init Policy BC1 */
+   DSL_uint16_t Res1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgment for message CMD_InitPolicySet.
+*/
+struct ACK_InitPolicySet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Configuration of options for the modem state machine.
+*/
+struct CMD_ErasureControlSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+   /** "Trust-Me"-Bit, Bit 2 (ADSL only) */
+   DSL_uint16_t trustMe : 1;
+   /** Erasure Policy, Bit 1 */
+   DSL_uint16_t erasurePolicy : 1;
+   /** Reserved, Bit0 */
+   DSL_uint16_t Res1 : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved, Bit0 */
+   DSL_uint16_t Res1 : 1;
+   /** Erasure Policy, Bit 1 */
+   DSL_uint16_t erasurePolicy : 1;
+   /** "Trust-Me"-Bit, Bit 2 (ADSL only) */
+   DSL_uint16_t trustMe : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_ErasureControlSet.
+*/
+struct ACK_ErasureControlSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Performs some miscellaneous chip set configurations.
+*/
+struct CMD_Misc_ConfigSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 7;
+   /** TPS-TC Type Event Enable */
+   DSL_uint16_t TcTypeEvt : 1;
+   /** Hlog Invalidation */
+   DSL_uint16_t HlogValidation : 1;
+   /** Short CLR for ADSL2+ */
+   DSL_uint16_t ShortClrA2p : 1;
+   /** Short CLR for ADSL2 */
+   DSL_uint16_t ShortClrA2 : 1;
+   /** Short CLR for ADSL1 */
+   DSL_uint16_t ShortClrA1 : 1;
+   /** INP Protection Improvement (VDSL only) */
+   DSL_uint16_t FrameParams : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 1;
+   /** Activation Start Mode (ADSL only) */
+   DSL_uint16_t StartMode : 1;
+   /** Non-standard GHS-ANSI Activation (ADSL only) */
+   DSL_uint16_t GhsAnsiSeq : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Non-standard GHS-ANSI Activation (ADSL only) */
+   DSL_uint16_t GhsAnsiSeq : 1;
+   /** Activation Start Mode (ADSL only) */
+   DSL_uint16_t StartMode : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 1;
+   /** INP Protection Improvement (VDSL only) */
+   DSL_uint16_t FrameParams : 1;
+   /** Short CLR for ADSL1 */
+   DSL_uint16_t ShortClrA1 : 1;
+   /** Short CLR for ADSL2 */
+   DSL_uint16_t ShortClrA2 : 1;
+   /** Short CLR for ADSL2+ */
+   DSL_uint16_t ShortClrA2p : 1;
+   /** Hlog Invalidation */
+   DSL_uint16_t HlogValidation : 1;
+   /** TPS-TC Type Event Enable */
+   DSL_uint16_t TcTypeEvt : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 7;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This is the acknowledgement for ACK_Misc_ConfigSet.
+*/
+struct ACK_Misc_ConfigSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Performs some miscellaneous chip set configurations.
+*/
+struct CMD_OperationOptionsSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+   /** VRX_ENABLE, Fixed value */
+   DSL_uint16_t Mfd : 1;
+   /** Enhanced Upstream Framing (ADSL-Only) */
+   DSL_uint16_t UsFramingExt : 1;
+   /** NTR (currently VDSL-Only) */
+   DSL_uint16_t Ntr : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** NTR (currently VDSL-Only) */
+   DSL_uint16_t Ntr : 1;
+   /** Enhanced Upstream Framing (ADSL-Only) */
+   DSL_uint16_t UsFramingExt : 1;
+   /** VRX_ENABLE, Fixed value */
+   DSL_uint16_t Mfd : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This is the acknowledgement for CMD_OperationOptionsSet.
+*/
+struct ACK_OperationOptionsSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message selects a DSL operator. The information is used to configure
+   operator specific settings inside the DSL firmware.
+*/
+struct CMD_OperatorSelect
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** DSL Operator Selection */
+   DSL_uint16_t DslOperator;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** DSL Operator Selection */
+   DSL_uint16_t DslOperator;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This is the acknowledgement for ACK_OperatorSelect.
+*/
+struct ACK_OperatorSelect
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message reads back the selected DSL operator, as selected by
+   ACK_OperatorSelect.
+*/
+struct CMD_OperatorSelectionGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message provides the selected DSL operator.
+*/
+struct ACK_OperatorSelectionGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Selected DSL Operator */
+   DSL_uint16_t DslOperator;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Selected DSL Operator */
+   DSL_uint16_t DslOperator;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The messages configures settings for test modes.
+*/
+struct CMD_TestOptionsSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 11;
+   /** ATTNDR Improved Method Support (VDSL only) */
+   DSL_uint16_t AttndrImproved : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 2;
+   /** US Finegain Control */
+   DSL_uint16_t FgainControlUs : 1;
+   /** DS Finegain Control */
+   DSL_uint16_t FgainControlDs : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** DS Finegain Control */
+   DSL_uint16_t FgainControlDs : 1;
+   /** US Finegain Control */
+   DSL_uint16_t FgainControlUs : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 2;
+   /** ATTNDR Improved Method Support (VDSL only) */
+   DSL_uint16_t AttndrImproved : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 11;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This is the acknowledgement for CMD_TestOptionsSet.
+*/
+struct ACK_TestOptionsSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Sets the PPE clock. The message is supposed to be used for debug/test
+   purposes only. If applied this PPE clock is forced and will be kept
+   throughout the link. The PPE frequency scaling automode (see
+   CMD_PPE_ClockConfigure) will then not change it but behave as being disabled.
+*/
+struct CMD_ClockSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 11;
+   /** Clock Change Trigger */
+   DSL_uint16_t ppeClkSet : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 1;
+   /** PPE Clock */
+   DSL_uint16_t ppeClock : 3;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PPE Clock */
+   DSL_uint16_t ppeClock : 3;
+   /** Reserved */
+   DSL_uint16_t Res1 : 1;
+   /** Clock Change Trigger */
+   DSL_uint16_t ppeClkSet : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 11;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This is the acknowledgement for CMD_ClockSet.
+*/
+struct ACK_ClockSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Configures PPE clock options.The message CMD_ClockSet used for debug/test
+   purposes forces a PPE clock frequency which will be kept throughout the
+   link.. The PPE frequency scaling automode will then not change it but behave
+   as being disabled.
+*/
+struct CMD_PPE_ClockConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PPE Frequency Scaling Mode */
+   DSL_uint16_t FreqScaleMode;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PPE Frequency Scaling Mode */
+   DSL_uint16_t FreqScaleMode;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This is the acknowledgement for CMD_PPE_ClockConfigure.
+*/
+struct ACK_PPE_ClockConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reads PPE clock settings.
+*/
+struct CMD_PPE_ClockGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides PPE clock settings.
+*/
+struct ACK_PPE_ClockGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+   /** PPE Clock */
+   DSL_uint16_t ppeClock : 3;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PPE Clock */
+   DSL_uint16_t ppeClock : 3;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reads back PPE clock options.
+*/
+struct CMD_PPE_ClockConfigGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides PPE clock options.
+*/
+struct ACK_PPE_ClockConfigGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PPE Frequency Scaling Mode */
+   DSL_uint16_t FreqScaleMode;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PPE Frequency Scaling Mode */
+   DSL_uint16_t FreqScaleMode;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Sets an offset for the PLL frequency compared to the crystals rated nominal
+   frequency of 36 MHz. This allows e.g. to fine tune the handshake tone
+   frequencies to exactly match the standard values.
+*/
+struct CMD_PLL_ClockSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PLL Clock Offset in ppm */
+   DSL_int16_t pllClockOffset;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PLL Clock Offset in ppm */
+   DSL_int16_t pllClockOffset;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This is the acknowledgement for CMD_PLL_ClockSet.
+*/
+struct ACK_PLL_ClockSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#ifdef __PACKED_DEFINED__
+   #if !(defined (__GNUC__) || defined (__GNUG__))
+      #pragma pack()
+   #endif
+   #undef __PACKED_DEFINED__
+#endif /* __PACKED_DEFINED__ */
+
+/** @} */
+
+#endif /** _DRV_DSL_CPE_VRX_MSG_CONFIG_PMD_H_*/
--- /dev/null
+++ b/src/include/mcat3.2/drv_dsl_cpe_vrx_msg_const.h
@@ -0,0 +1,615 @@
+/******************************************************************************
+
+         Copyright 2016 - 2018 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+
+#ifndef _DRV_DSL_CPE_VRX_MSG_CONST_H_
+#define _DRV_DSL_CPE_VRX_MSG_CONST_H_
+
+/** \file
+
+*/
+
+#ifndef __PACKED__
+   #if defined (__GNUC__) || defined (__GNUG__)
+      /* GNU C or C++ compiler */
+      #define __PACKED__ __attribute__ ((packed))
+   #else
+      /* Byte alignment adjustment */
+      #pragma pack(1)
+      #define __PACKED__      /* nothing */
+   #endif
+   #define __PACKED_DEFINED__ 1
+#endif
+
+
+/** @defgroup _CONST_
+ *  @{
+ */
+
+#ifdef __cplusplus
+   extern "C" {
+#endif
+
+/* ----- Common Constants Definition section ----- */
+/** Disable a functionality or state */
+#define VRX_DISABLE 0
+/** Enable a functionality or state */
+#define VRX_ENABLE 1
+/** Disable a functionality or state */
+#define VRX_DISABLE_N 1
+/** Enable a functionality or state */
+#define VRX_ENABLE_N 0
+/** Logical value TRUE */
+#define VRX_TRUE 1
+/** Logical value FALSE */
+#define VRX_FALSE 0
+/** Functionality is supported */
+#define SUPPORTED 1
+/** Functionality is not supported */
+#define NOT_SUPPORTED 0
+/** Counter value is below threshold */
+#define CNTR_OK 0
+/** Counter threshold met or exceeded */
+#define CNTR_THRESH_HIT 1
+/** Fixed Value of 0; Used for numbering parameters (like Array Index number or Length number) */
+#define FV0 0
+/** Fixed Value of 1; Used for numbering parameters (like Array Index number or Length number) */
+#define FV1 1
+/** Fixed Value of 2; Used for numbering parameters (like Array Index number or Length number) */
+#define FV2 2
+/** Fixed Value of 3; Used for numbering parameters (like Array Index number or Length number) */
+#define FV3 3
+/** Fixed Value of 4; Used for numbering parameters (like Array Index number or Length number) */
+#define FV4 4
+/** Fixed Value of 5; Used for numbering parameters (like Array Index number or Length number) */
+#define FV5 5
+/** Fixed Value of 6; Used for numbering parameters (like Array Index number or Length number) */
+#define FV6 6
+/** Fixed Value of 7; Used for numbering parameters (like Array Index number or Length number) */
+#define FV7 7
+/** Fixed Value of 8; Used for numbering parameters (like Array Index number or Length number) */
+#define FV8 8
+/** Fixed Value of 9; Used for numbering parameters (like Array Index number or Length number) */
+#define FV9 9
+/** Fixed Value of 10; Used for numbering parameters (like Array Index number or Length number) */
+#define FV10 10
+/** Fixed Value of 11; Used for numbering parameters (like Array Index number or Length number) */
+#define FV11 11
+/** Fixed Value of 12; Used for numbering parameters (like Array Index number or Length number) */
+#define FV12 12
+/** Fixed Value of 13; Used for numbering parameters (like Array Index number or Length number) */
+#define FV13 13
+/** Fixed Value of 15; Used for numbering parameters (like Array Index number or Length number) */
+#define FV15 15
+/** Fixed Value of 16; Used for numbering parameters (like Array Index number or Length number) */
+#define FV16 16
+/** Fixed Value of 17; Used for numbering parameters (like Array Index number or Length number) */
+#define FV17 17
+/** Fixed Value of 20; Used for numbering parameters (like Array Index number or Length number) */
+#define FV20 20
+/** Fixed Value of 32; Used for numbering parameters (like Array Index number or Length number) */
+#define FV32 32
+/** Fixed Value of 64; Used for numbering parameters (like Array Index number or Length number) */
+#define FV64 64
+/** Fixed Value of 127; Used for numbering parameters (like Array Index number or Length number) */
+#define FV127 127
+/** Fixed Value of 128; Used for numbering parameters (like Array Index number or Length number) */
+#define FV128 128
+/** Fixed Value of 256; Used for numbering parameters (like Array Index number or Length number) */
+#define FV256 256
+/** Link 0 is selected */
+#define LINK0 0x0
+/** Link 1 is selected */
+#define LINK1 0x1
+/** No Failure */
+#define VRX_OK 0x0
+/** Failure */
+#define VRX_FAIL 0x1
+/** EOC Failure */
+#define VRX_EOCFAIL 0x2
+/** Request was rejected */
+#define VRX_REJECTED 0x1
+/* ----- Common Constants Definition section (End) ----- */
+/* ----- Message Specific Constants Definition section ----- */
+/* ----- Message Specific Constants Definition section (End) ----- */
+/**
+
+*/
+typedef struct VRX_BAT_TableEntry VRX_BAT_TableEntry_t;
+
+/**
+
+*/
+typedef struct VRX_ToneIndex VRX_ToneIndex_t;
+
+/**
+
+*/
+typedef struct VRX_PSDbreak VRX_PSDbreak_t;
+
+/**
+
+*/
+typedef struct VRX_PSD_TxDS VRX_PSD_TxDS_t;
+
+/**
+
+*/
+typedef struct VRX_PSDbreak2 VRX_PSDbreak2_t;
+
+/**
+
+*/
+typedef struct VRX_PSD_CompBreak VRX_PSD_CompBreak_t;
+
+/**
+
+*/
+typedef struct VRX_RxRef2PSD VRX_RxRef2PSD_t;
+
+/**
+
+*/
+typedef struct VRX_LineStatus_pb VRX_LineStatus_pb_t;
+
+/**
+
+*/
+typedef struct VRX_TSSIbreak VRX_TSSIbreak_t;
+
+/**
+
+*/
+typedef struct VRX_TSSI VRX_TSSI_t;
+
+/**
+
+*/
+typedef struct VRX_QLN_NE VRX_QLN_NE_t;
+
+/**
+
+*/
+typedef struct VRX_TestParam VRX_TestParam_t;
+
+/**
+
+*/
+typedef struct VRX_SNR VRX_SNR_t;
+
+/**
+
+*/
+typedef struct VRX_HLIN VRX_HLIN_t;
+
+/**
+
+*/
+typedef struct VRX_ClearEOC VRX_ClearEOC_t;
+
+/**
+
+*/
+typedef struct VRX_UER VRX_UER_t;
+
+/**
+
+*/
+typedef struct VRX_TIME VRX_TIME_t;
+
+/**
+
+*/
+typedef struct VRX_ATMcell VRX_ATMcell_t;
+
+/**
+
+*/
+struct VRX_BAT_TableEntry
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Bit Allocation */
+   DSL_uint8_t data_01;
+   /** Bit Allocation */
+   DSL_uint8_t data_00;
+#else
+   /** Bit Allocation */
+   DSL_uint8_t data_00;
+   /** Bit Allocation */
+   DSL_uint8_t data_01;
+#endif
+} __PACKED__ ;
+
+
+/**
+
+*/
+struct VRX_ToneIndex
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** First Tone Index */
+   DSL_uint16_t first;
+   /** Last Tone Index */
+   DSL_uint16_t last;
+#else
+   /** First Tone Index */
+   DSL_uint16_t first;
+   /** Last Tone Index */
+   DSL_uint16_t last;
+#endif
+} __PACKED__ ;
+
+
+/**
+
+*/
+struct VRX_PSDbreak
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Tone Index of Breakpoint */
+   DSL_uint16_t toneIndex;
+   /** PSD Level of Breakpoint */
+   DSL_uint16_t level;
+   /** Reserved */
+   DSL_uint16_t Res0;
+#else
+   /** Tone Index of Breakpoint */
+   DSL_uint16_t toneIndex;
+   /** PSD Level of Breakpoint */
+   DSL_uint16_t level;
+   /** Reserved */
+   DSL_uint16_t Res0;
+#endif
+} __PACKED__ ;
+
+
+/**
+
+*/
+struct VRX_PSD_TxDS
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Reserved */
+   DSL_uint8_t Res0;
+   /** Number of Breakpoints */
+   DSL_uint8_t NumBreakPts;
+   /** Breakpoint Descriptor TxPSDds */
+   VRX_PSDbreak_t breakpoint[48];
+#else
+   /** Number of Breakpoints */
+   DSL_uint8_t NumBreakPts;
+   /** Reserved */
+   DSL_uint8_t Res0;
+   /** Breakpoint Descriptor TxPSDds */
+   VRX_PSDbreak_t breakpoint[48];
+#endif
+} __PACKED__ ;
+
+
+/**
+
+*/
+struct VRX_PSDbreak2
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Tone Index of Breakpoint */
+   DSL_uint16_t toneIndex;
+   /** PSD Level of Breakpoint */
+   DSL_uint16_t level;
+#else
+   /** Tone Index of Breakpoint */
+   DSL_uint16_t toneIndex;
+   /** PSD Level of Breakpoint */
+   DSL_uint16_t level;
+#endif
+} __PACKED__ ;
+
+
+/**
+
+*/
+struct VRX_PSD_CompBreak
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Tone Index of Breakpoint */
+   DSL_uint16_t toneIndex;
+   /** Compensation Level of Breakpoint */
+   DSL_int16_t level;
+#else
+   /** Tone Index of Breakpoint */
+   DSL_uint16_t toneIndex;
+   /** Compensation Level of Breakpoint */
+   DSL_int16_t level;
+#endif
+} __PACKED__ ;
+
+
+/**
+
+*/
+struct VRX_RxRef2PSD
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** UPBO RxRefPSD Parameter "a" */
+   DSL_int16_t a;
+   /** UPBO RxRefPSD Parameter "b" */
+   DSL_int16_t b;
+#else
+   /** UPBO RxRefPSD Parameter "a" */
+   DSL_int16_t a;
+   /** UPBO RxRefPSD Parameter "b" */
+   DSL_int16_t b;
+#endif
+} __PACKED__ ;
+
+
+/**
+
+*/
+struct VRX_LineStatus_pb
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** LATN per Band */
+   DSL_uint16_t LATNpb;
+   /** SATN per Band */
+   DSL_uint16_t SATNpb;
+   /** SNRM per Band */
+   DSL_uint16_t SNRMpb;
+#else
+   /** LATN per Band */
+   DSL_uint16_t LATNpb;
+   /** SATN per Band */
+   DSL_uint16_t SATNpb;
+   /** SNRM per Band */
+   DSL_uint16_t SNRMpb;
+#endif
+} __PACKED__ ;
+
+
+/**
+
+*/
+struct VRX_TSSIbreak
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Supported Set Status */
+   DSL_uint16_t supset : 1;
+   /** Tone Index of Breakpoint */
+   DSL_uint16_t toneIndex : 15;
+   /** Transmit Spectrum Shaping Value of Breakpoint */
+   DSL_uint16_t level;
+#else
+   /** Tone Index of Breakpoint */
+   DSL_uint16_t toneIndex : 15;
+   /** Supported Set Status */
+   DSL_uint16_t supset : 1;
+   /** Transmit Spectrum Shaping Value of Breakpoint */
+   DSL_uint16_t level;
+#endif
+} __PACKED__ ;
+
+
+/**
+
+*/
+struct VRX_TSSI
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Number of breakpoints */
+   DSL_uint16_t Num;
+   /** TSSI breakpoints */
+   VRX_TSSIbreak_t TSSIbrkp[64];
+#else
+   /** Number of breakpoints */
+   DSL_uint16_t Num;
+   /** TSSI breakpoints */
+   VRX_TSSIbreak_t TSSIbrkp[64];
+#endif
+} __PACKED__ ;
+
+
+/**
+
+*/
+struct VRX_QLN_NE
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** QLN per Subcarrier Group */
+   DSL_uint8_t qln_01;
+   /** QLN per Subcarrier Group */
+   DSL_uint8_t qln_00;
+#else
+   /** QLN per Subcarrier Group */
+   DSL_uint8_t qln_00;
+   /** QLN per Subcarrier Group */
+   DSL_uint8_t qln_01;
+#endif
+} __PACKED__ ;
+
+
+/**
+
+*/
+struct VRX_TestParam
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** HLOG per Subcarrier Group */
+   DSL_uint16_t hlog;
+   /** SNR per Subcarrier Group */
+   DSL_uint8_t snr;
+   /** QLN per Subcarrier Group */
+   DSL_uint8_t qln;
+#else
+   /** HLOG per Subcarrier Group */
+   DSL_uint16_t hlog;
+   /** QLN per Subcarrier Group */
+   DSL_uint8_t qln;
+   /** SNR per Subcarrier Group */
+   DSL_uint8_t snr;
+#endif
+} __PACKED__ ;
+
+
+/**
+
+*/
+struct VRX_SNR
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** SNR per Subcarrier Group */
+   DSL_uint8_t snr_01;
+   /** SNR per Subcarrier Group */
+   DSL_uint8_t snr_00;
+#else
+   /** SNR per Subcarrier Group */
+   DSL_uint8_t snr_00;
+   /** SNR per Subcarrier Group */
+   DSL_uint8_t snr_01;
+#endif
+} __PACKED__ ;
+
+
+/**
+
+*/
+struct VRX_HLIN
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** HLIN per Subcarrier Group, Real Part */
+   DSL_int16_t hlin_real;
+   /** HLIN per Subcarrier Group, Imaginary Part */
+   DSL_int16_t hlin_imag;
+#else
+   /** HLIN per Subcarrier Group, Real Part */
+   DSL_int16_t hlin_real;
+   /** HLIN per Subcarrier Group, Imaginary Part */
+   DSL_int16_t hlin_imag;
+#endif
+} __PACKED__ ;
+
+
+/**
+
+*/
+struct VRX_ClearEOC
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Reserved  */
+   DSL_uint16_t Res0 : 6;
+   /** Length of the Clear EOC Message  */
+   DSL_uint16_t Length : 10;
+   /** Protocol Identifier */
+   DSL_uint16_t ProtIdent;
+   /** Clear EOC data field */
+   DSL_uint8_t Data[508];
+#else
+   /** Length of the Clear EOC Message  */
+   DSL_uint16_t Length : 10;
+   /** Reserved  */
+   DSL_uint16_t Res0 : 6;
+   /** Protocol Identifier */
+   DSL_uint16_t ProtIdent;
+   /** Clear EOC data field */
+   DSL_uint8_t Data[508];
+#endif
+} __PACKED__ ;
+
+
+/**
+
+*/
+struct VRX_UER
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** UERps Real Part, LSW */
+   DSL_uint16_t UER_Real_LSW;
+   /** UERps Real Part, MSW */
+   DSL_uint16_t UER_Real_MSW;
+   /** UERps Imaginary Part, LSW */
+   DSL_uint16_t UER_Imag_LSW;
+   /** UERps Imaginary Part, MSW */
+   DSL_uint16_t UER_Imag_MSW;
+#else
+   /** UERps Real Part, LSW */
+   DSL_uint16_t UER_Real_LSW;
+   /** UERps Real Part, MSW */
+   DSL_uint16_t UER_Real_MSW;
+   /** UERps Imaginary Part, LSW */
+   DSL_uint16_t UER_Imag_LSW;
+   /** UERps Imaginary Part, MSW */
+   DSL_uint16_t UER_Imag_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+
+*/
+struct VRX_TIME
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Hours */
+   DSL_uint8_t hours;
+   /** Minutes */
+   DSL_uint8_t minutes;
+   /** Seconds */
+   DSL_uint8_t seconds;
+   /** Reserved */
+   DSL_uint8_t Res0;
+#else
+   /** Minutes */
+   DSL_uint8_t minutes;
+   /** Hours */
+   DSL_uint8_t hours;
+   /** Reserved */
+   DSL_uint8_t Res0;
+   /** Seconds */
+   DSL_uint8_t seconds;
+#endif
+} __PACKED__ ;
+
+
+/**
+
+*/
+struct VRX_ATMcell
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** ATM cell (53 bytes) */
+   DSL_uint8_t ATMcell[53];
+   /** Reserved */
+   DSL_uint8_t Res0[3];
+#else
+   /** ATM cell (53 bytes) */
+   DSL_uint8_t ATMcell[53];
+   /** Reserved */
+   DSL_uint8_t Res0[3];
+#endif
+} __PACKED__ ;
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#ifdef __PACKED_DEFINED__
+   #if !(defined (__GNUC__) || defined (__GNUG__))
+      #pragma pack()
+   #endif
+   #undef __PACKED_DEFINED__
+#endif /* __PACKED_DEFINED__ */
+
+/** @} */
+
+#endif /** _DRV_DSL_CPE_VRX_MSG_CONST_H_*/
--- /dev/null
+++ b/src/include/mcat3.2/drv_dsl_cpe_vrx_msg_dmt_scope.h
@@ -0,0 +1,573 @@
+/******************************************************************************
+
+         Copyright 2016 - 2018 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+
+#ifndef _DRV_DSL_CPE_VRX_MSG_DMT_SCOPE_H_
+#define _DRV_DSL_CPE_VRX_MSG_DMT_SCOPE_H_
+
+/** \file
+
+*/
+
+#ifndef __PACKED__
+   #if defined (__GNUC__) || defined (__GNUG__)
+      /* GNU C or C++ compiler */
+      #define __PACKED__ __attribute__ ((packed))
+   #else
+      /* Byte alignment adjustment */
+      #pragma pack(1)
+      #define __PACKED__      /* nothing */
+   #endif
+   #define __PACKED_DEFINED__ 1
+#endif
+
+
+/** @defgroup _DMT_SCOPE_
+ *  @{
+ */
+
+#ifdef __cplusplus
+   extern "C" {
+#endif
+
+/* ----- Message Specific Constants Definition section ----- */
+#define CMD_TEST_AFE_LoopControl_NO_LOOP 0x0
+#define CMD_TEST_AFE_LoopControl_ALOOP 0x1
+#define CMD_TEST_TxControlSet_SEND_QUIET 0
+#define CMD_TEST_TxControlSet_SEND_REVERB 1
+#define CMD_TEST_TxControlSet_SEND_SEGUE 2
+#define CMD_TEST_TxControlSet_SEND_MEDLEY 3
+#define CMD_TEST_RxControlSet_MEASURE_PSD 14
+#define CMD_TEST_RxControlSet_FDQ_TRAINING 16
+#define CMD_TEST_RxControlSet_MEASURE_SNR 17
+#define CMD_TEST_RxControlSet_PGA_TRAINING 19
+#define CMD_TEST_RxPSD_MeasureModeSet_AVERAGE 0x0
+#define CMD_TEST_RxPSD_MeasureModeSet_PEAKHOLD 0x1
+#define CMD_TEST_RxPSD_MeasureModeSet_BOTTOMHOLD 0x2
+#define CMD_TEST_RxGainControl_DEFGAIN 0x0
+#define CMD_TEST_RxGainControl_MAXGAIN 0x1
+/* ----- Message Specific Constants Definition section (End) ----- */
+
+/** Message ID for CMD_TEST_AFE_LoopControl */
+#define CMD_TEST_AFE_LOOPCONTROL 0x0156
+
+/**
+   This message can be used to enable or disable the (analog) loop within the
+   Analog Front-End (AFE) to loop back data from the transmit to the receive
+   part.
+*/
+typedef struct CMD_TEST_AFE_LoopControl CMD_TEST_AFE_LoopControl_t;
+
+/** Message ID for ACK_TEST_AFE_LoopControl */
+#define ACK_TEST_AFE_LOOPCONTROL 0x0156
+
+/**
+   This message acknowledges the message CMD_TEST_AFE_LoopControl.For TEST state
+   only!
+*/
+typedef struct ACK_TEST_AFE_LoopControl ACK_TEST_AFE_LoopControl_t;
+
+/** Message ID for CMD_TEST_TxControlSet */
+#define CMD_TEST_TXCONTROLSET 0x0844
+
+/**
+   The message controls the transmit signal in TEST state. Each setting is valid
+   until either another value is set with this message that requires the
+   previous setting to be overwritten or until TEST state is left.
+*/
+typedef struct CMD_TEST_TxControlSet CMD_TEST_TxControlSet_t;
+
+/** Message ID for ACK_TEST_TxControlSet */
+#define ACK_TEST_TXCONTROLSET 0x0844
+
+/**
+   Acknowledgement for message CMD_TEST_TxControlSet.
+*/
+typedef struct ACK_TEST_TxControlSet ACK_TEST_TxControlSet_t;
+
+/** Message ID for CMD_TEST_CarrierMaskingTxSet */
+#define CMD_TEST_CARRIERMASKINGTXSET 0x0256
+
+/**
+   Masks out every 100th subcarrier starting from an arbitrary index number
+   1...99.The carrier-mask is applied to signals in the frequency domain ("Send
+   REVERB" and "Send MEDLEY"). The signal must be activated before!
+*/
+typedef struct CMD_TEST_CarrierMaskingTxSet CMD_TEST_CarrierMaskingTxSet_t;
+
+/** Message ID for ACK_TEST_CarrierMaskingTxSet */
+#define ACK_TEST_CARRIERMASKINGTXSET 0x0256
+
+/**
+   Acknowledgement for message CMD_TEST_CarrierMaskingTxSet.
+*/
+typedef struct ACK_TEST_CarrierMaskingTxSet ACK_TEST_CarrierMaskingTxSet_t;
+
+/** Message ID for CMD_TEST_RxControlSet */
+#define CMD_TEST_RXCONTROLSET 0x0944
+
+/**
+   The message triggers measurements of the receive signal.
+*/
+typedef struct CMD_TEST_RxControlSet CMD_TEST_RxControlSet_t;
+
+/** Message ID for ACK_TEST_RxControlSet */
+#define ACK_TEST_RXCONTROLSET 0x0944
+
+/**
+   Acknowledgement for message CMD_TEST_RxControlSet.
+*/
+typedef struct ACK_TEST_RxControlSet ACK_TEST_RxControlSet_t;
+
+/** Message ID for CMD_TEST_RxPSD_TableEntriesGet */
+#define CMD_TEST_RXPSD_TABLEENTRIESGET 0x5403
+
+/**
+   The message requests information about the receive PSD per subcarrier
+   available at the near-end side, which means for downstream direction at the
+   CPE. It is the hosts responsibility to select the tone indices accordingly.
+*/
+typedef struct CMD_TEST_RxPSD_TableEntriesGet CMD_TEST_RxPSD_TableEntriesGet_t;
+
+/** Message ID for ACK_TEST_RxPSD_TableEntriesGet */
+#define ACK_TEST_RXPSD_TABLEENTRIESGET 0x5403
+
+/**
+   Returns information about the receive PSD per subcarrier available at the
+   near-end side, which means for downstream direction at the CPE.
+*/
+typedef struct ACK_TEST_RxPSD_TableEntriesGet ACK_TEST_RxPSD_TableEntriesGet_t;
+
+/** Message ID for CMD_TEST_RxPSD_Calibrate */
+#define CMD_TEST_RXPSD_CALIBRATE 0x0356
+
+/**
+   Sets the board specific calibration factor necessary to calculate the
+   absolute PSD value per subcarrier.Attention: The command needs to be applied
+   only once after power-up for a calibration value determined according to the
+   sequence described below ("Getting the calibration value:"). Applying the
+   command a second time requires another determination of the calibration value
+   too, because the shift is always relative to the current values.
+*/
+typedef struct CMD_TEST_RxPSD_Calibrate CMD_TEST_RxPSD_Calibrate_t;
+
+/** Message ID for ACK_TEST_RxPSD_Calibrate */
+#define ACK_TEST_RXPSD_CALIBRATE 0x0356
+
+/**
+   Acknowledgement to CMD_TEST_RxPSD_Calibrate.
+*/
+typedef struct ACK_TEST_RxPSD_Calibrate ACK_TEST_RxPSD_Calibrate_t;
+
+/** Message ID for CMD_TEST_RxPSD_MeasureModeSet */
+#define CMD_TEST_RXPSD_MEASUREMODESET 0x0456
+
+/**
+   Configures options for the measurement of the PSD value per subcarrier.
+*/
+typedef struct CMD_TEST_RxPSD_MeasureModeSet CMD_TEST_RxPSD_MeasureModeSet_t;
+
+/** Message ID for ACK_TEST_RxPSD_MeasureModeSet */
+#define ACK_TEST_RXPSD_MEASUREMODESET 0x0456
+
+/**
+   Acknowledgement to CMD_TEST_RxPSD_MeasureModeSet.
+*/
+typedef struct ACK_TEST_RxPSD_MeasureModeSet ACK_TEST_RxPSD_MeasureModeSet_t;
+
+/** Message ID for CMD_TEST_RxGainControl */
+#define CMD_TEST_RXGAINCONTROL 0x0556
+
+/**
+   Sets the gains in the receive path (AGC, ACE, PREFI).
+*/
+typedef struct CMD_TEST_RxGainControl CMD_TEST_RxGainControl_t;
+
+/** Message ID for ACK_TEST_RxGainControl */
+#define ACK_TEST_RXGAINCONTROL 0x0556
+
+/**
+   Acknowledgement to CMD_TEST_RxGainControl.
+*/
+typedef struct ACK_TEST_RxGainControl ACK_TEST_RxGainControl_t;
+
+/**
+   This message can be used to enable or disable the (analog) loop within the
+   Analog Front-End (AFE) to loop back data from the transmit to the receive
+   part.
+*/
+struct CMD_TEST_AFE_LoopControl
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** AFE Loop Control */
+   DSL_uint32_t loopControl;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** AFE Loop Control */
+   DSL_uint32_t loopControl;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This message acknowledges the message CMD_TEST_AFE_LoopControl.For TEST state
+   only!
+*/
+struct ACK_TEST_AFE_LoopControl
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message controls the transmit signal in TEST state. Each setting is valid
+   until either another value is set with this message that requires the
+   previous setting to be overwritten or until TEST state is left.
+*/
+struct CMD_TEST_TxControlSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TEST State's Transmit Signal Control */
+   DSL_uint16_t TxControl;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TEST State's Transmit Signal Control */
+   DSL_uint16_t TxControl;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for message CMD_TEST_TxControlSet.
+*/
+struct ACK_TEST_TxControlSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Masks out every 100th subcarrier starting from an arbitrary index number
+   1...99.The carrier-mask is applied to signals in the frequency domain ("Send
+   REVERB" and "Send MEDLEY"). The signal must be activated before!
+*/
+struct CMD_TEST_CarrierMaskingTxSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** First Masked Tone */
+   DSL_uint32_t MaskTone0;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** First Masked Tone */
+   DSL_uint32_t MaskTone0;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for message CMD_TEST_CarrierMaskingTxSet.
+*/
+struct ACK_TEST_CarrierMaskingTxSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message triggers measurements of the receive signal.
+*/
+struct CMD_TEST_RxControlSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TEST State's Receive Control */
+   DSL_uint16_t RxControl;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TEST State's Receive Control */
+   DSL_uint16_t RxControl;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for message CMD_TEST_RxControlSet.
+*/
+struct ACK_TEST_RxControlSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message requests information about the receive PSD per subcarrier
+   available at the near-end side, which means for downstream direction at the
+   CPE. It is the hosts responsibility to select the tone indices accordingly.
+*/
+struct CMD_TEST_RxPSD_TableEntriesGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the receive PSD per subcarrier available at the
+   near-end side, which means for downstream direction at the CPE.
+*/
+struct ACK_TEST_RxPSD_TableEntriesGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Receive PSD */
+   DSL_uint16_t PSDps[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Receive PSD */
+   DSL_uint16_t PSDps[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Sets the board specific calibration factor necessary to calculate the
+   absolute PSD value per subcarrier.Attention: The command needs to be applied
+   only once after power-up for a calibration value determined according to the
+   sequence described below ("Getting the calibration value:"). Applying the
+   command a second time requires another determination of the calibration value
+   too, because the shift is always relative to the current values.
+*/
+struct CMD_TEST_RxPSD_Calibrate
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** RxPSD Calibration Value */
+   DSL_uint32_t calibration;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** RxPSD Calibration Value */
+   DSL_uint32_t calibration;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_TEST_RxPSD_Calibrate.
+*/
+struct ACK_TEST_RxPSD_Calibrate
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Configures options for the measurement of the PSD value per subcarrier.
+*/
+struct CMD_TEST_RxPSD_MeasureModeSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** RxPSD Measurement Mode */
+   DSL_uint32_t MeasureMode;
+   /** Number of Frames */
+   DSL_uint32_t numOfFrames;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** RxPSD Measurement Mode */
+   DSL_uint32_t MeasureMode;
+   /** Number of Frames */
+   DSL_uint32_t numOfFrames;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_TEST_RxPSD_MeasureModeSet.
+*/
+struct ACK_TEST_RxPSD_MeasureModeSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Sets the gains in the receive path (AGC, ACE, PREFI).
+*/
+struct CMD_TEST_RxGainControl
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Rx Gain Level */
+   DSL_uint32_t RxGainLevel;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Rx Gain Level */
+   DSL_uint32_t RxGainLevel;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_TEST_RxGainControl.
+*/
+struct ACK_TEST_RxGainControl
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#ifdef __PACKED_DEFINED__
+   #if !(defined (__GNUC__) || defined (__GNUG__))
+      #pragma pack()
+   #endif
+   #undef __PACKED_DEFINED__
+#endif /* __PACKED_DEFINED__ */
+
+/** @} */
+
+#endif /** _DRV_DSL_CPE_VRX_MSG_DMT_SCOPE_H_*/
--- /dev/null
+++ b/src/include/mcat3.2/drv_dsl_cpe_vrx_msg_ghs_status.h
@@ -0,0 +1,5452 @@
+/******************************************************************************
+
+         Copyright 2016 - 2018 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+
+#ifndef _DRV_DSL_CPE_VRX_MSG_GHS_STATUS_H_
+#define _DRV_DSL_CPE_VRX_MSG_GHS_STATUS_H_
+
+/** \file
+
+*/
+
+#ifndef __PACKED__
+   #if defined (__GNUC__) || defined (__GNUG__)
+      /* GNU C or C++ compiler */
+      #define __PACKED__ __attribute__ ((packed))
+   #else
+      /* Byte alignment adjustment */
+      #pragma pack(1)
+      #define __PACKED__      /* nothing */
+   #endif
+   #define __PACKED_DEFINED__ 1
+#endif
+
+
+/** @defgroup _GHS_STATUS_
+ *  @{
+ */
+
+#ifdef __cplusplus
+   extern "C" {
+#endif
+
+/* ----- Message Specific Constants Definition section ----- */
+#define ACK_T1413_RevNo_O_Get_T1413REV1 0x0
+#define ACK_T1413_RevNo_O_Get_T1413REV2 0x1
+#define ACK_T1413_RevNo_R_Get_T1413REV1 0x0
+#define ACK_T1413_RevNo_R_Get_T1413REV2 0x1
+#define CMD_RFI_BandControlGet_FV 33
+#define ACK_RFI_BandControlGet_FV 33
+#define CMD_LineStatusPerBandDS_Get_FV 25
+#define ACK_LineStatusPerBandDS_Get_FV 25
+#define CMD_LineStatusPerBandUS_Get_FV 25
+#define ACK_LineStatusPerBandUS_Get_FV 25
+#define CMD_PSD_BreakpointsUS_Get_FV 97
+#define ACK_PSD_BreakpointsUS_Get_FV 97
+#define CMD_BearerChsDS_Get_FV 18
+#define ACK_BearerChsDS_Get_FV 18
+#define CMD_BearerChsUS_Get_FV 18
+#define ACK_BearerChsUS_Get_FV 18
+#define CMD_FrameDataExt2DS_Get_FV 42
+#define ACK_FrameDataExt2DS_Get_FV 42
+#define CMD_FrameDataExt2US_Get_FV 42
+#define ACK_FrameDataExt2US_Get_FV 42
+#define ACK_HybridGet_POTS 0x1
+#define ACK_HybridGet_ISDN_B 0x2
+#define ACK_HybridGet_ISDN_BJ 0x3
+#define ACK_HybridGet_UNIVERSAL 0x4
+#define ACK_MFD_ResultsGet_NONLNF 0x0
+#define ACK_MFD_ResultsGet_NLNFTRIGGERED 0x1
+#define ACK_MFD_ResultsGet_NLNFSTARTED 0x2
+#define ACK_MFD_ResultsGet_NLNFDONE 0x3
+#define ACK_MFD_ResultsGet_NORANGE 0x0
+#define ACK_MFD_ResultsGet_SHORTRANGE 0x1
+#define ACK_MFD_ResultsGet_MIDRANGE 0x2
+#define ACK_MFD_ResultsGet_LONGRANGE 0x3
+#define ACK_MFD_ResultsGet_READY 0x1
+#define ACK_MFD_ResultsGet_NOT_READY 0x0
+/* ----- Message Specific Constants Definition section (End) ----- */
+
+/** Message ID for CMD_HS_ToneGroupSet */
+#define CMD_HS_TONEGROUPSET 0x2D48
+
+/**
+   Selects one or more groups of tones to be used during the handshake phase.
+   (See G.994.1 Amendment 2 [8], Table 1/G.994.1).
+*/
+typedef struct CMD_HS_ToneGroupSet CMD_HS_ToneGroupSet_t;
+
+/** Message ID for ACK_HS_ToneGroupSet */
+#define ACK_HS_TONEGROUPSET 0x2D48
+
+/**
+   Acknowledgement to CMD_HS_ToneGroupSet.
+*/
+typedef struct ACK_HS_ToneGroupSet ACK_HS_ToneGroupSet_t;
+
+/** Message ID for CMD_HS_VDSL2ProfileControl */
+#define CMD_HS_VDSL2PROFILECONTROL 0x2C48
+
+/**
+   Configures the profile settings to be used for the handshake phase. (See
+   G.994.1 Amendment 4 [10], NPAR(3) coding).
+*/
+typedef struct CMD_HS_VDSL2ProfileControl CMD_HS_VDSL2ProfileControl_t;
+
+/** Message ID for ACK_HS_VDSL2ProfileControl */
+#define ACK_HS_VDSL2PROFILECONTROL 0x2C48
+
+/**
+   Acknowledgement to CMD_HS_VDSL2ProfileControl.
+*/
+typedef struct ACK_HS_VDSL2ProfileControl ACK_HS_VDSL2ProfileControl_t;
+
+/** Message ID for CMD_HS_StandardInfoFE_VDSL2Get */
+#define CMD_HS_STANDARDINFOFE_VDSL2GET 0xCC03
+
+/**
+   Requests the VDSL2 far-end Standard Info (See G.994.1 Amendment 4 [10],
+   NPAR(3) coding).
+*/
+typedef struct CMD_HS_StandardInfoFE_VDSL2Get CMD_HS_StandardInfoFE_VDSL2Get_t;
+
+/** Message ID for ACK_HS_StandardInfoFE_VDSL2Get */
+#define ACK_HS_STANDARDINFOFE_VDSL2GET 0xCC03
+
+/**
+   Delivers the VDSL2 far-end info as requested by
+   CMD_HS_StandardInfoFE_VDSL2Get (see G.994.1 Amendment 4 [10], NPAR(3)
+   coding).
+*/
+typedef struct ACK_HS_StandardInfoFE_VDSL2Get ACK_HS_StandardInfoFE_VDSL2Get_t;
+
+/** Message ID for CMD_HS_SelectedProfileVDSL2Get */
+#define CMD_HS_SELECTEDPROFILEVDSL2GET 0xCD03
+
+/**
+   Requests the actual selected VDSL2 Profile (See G.994.1 Amendment 4 [10],
+   NPAR(3) coding).
+*/
+typedef struct CMD_HS_SelectedProfileVDSL2Get CMD_HS_SelectedProfileVDSL2Get_t;
+
+/** Message ID for ACK_HS_SelectedProfileVDSL2Get */
+#define ACK_HS_SELECTEDPROFILEVDSL2GET 0xCD03
+
+/**
+   Provides the actual selected VDSL2 Profile as requested by
+   CMD_HS_SelectedProfileVDSL2Get (see G.994.1 Amendment 4 [10], NPAR(3)
+   coding).
+*/
+typedef struct ACK_HS_SelectedProfileVDSL2Get ACK_HS_SelectedProfileVDSL2Get_t;
+
+/** Message ID for CMD_HS_StandardInfoFE_SPAR1Get */
+#define CMD_HS_STANDARDINFOFE_SPAR1GET 0xCB03
+
+/**
+   Requests the handshake information about the far-end operating mode (See
+   G.994.1 [6] and Amendments 1-4 [7]-[10], standard information fields- SPAR(1)
+   coding).
+*/
+typedef struct CMD_HS_StandardInfoFE_SPAR1Get CMD_HS_StandardInfoFE_SPAR1Get_t;
+
+/** Message ID for ACK_HS_StandardInfoFE_SPAR1Get */
+#define ACK_HS_STANDARDINFOFE_SPAR1GET 0xCB03
+
+/**
+   Provides the handshake information about the far-end operating mode (See
+   G.994.1 [6] and Amendments 1-4 [7]-[10], Standard information field - SPAR(1)
+   coding). The bit numbering per octet below follows the standard (starting
+   with "1").
+*/
+typedef struct ACK_HS_StandardInfoFE_SPAR1Get ACK_HS_StandardInfoFE_SPAR1Get_t;
+
+/** Message ID for CMD_SysVendorID_R_Set */
+#define CMD_SYSVENDORID_R_SET 0x3C43
+
+/**
+   Sets the in System Vendor ID at the xTU-R. (Section 7.4.4 of G.997.1 [11])
+*/
+typedef struct CMD_SysVendorID_R_Set CMD_SysVendorID_R_Set_t;
+
+/** Message ID for ACK_SysVendorID_R_Set */
+#define ACK_SYSVENDORID_R_SET 0x3C43
+
+/**
+   Acknowledgement to CMD_SysVendorID_R_Set.
+*/
+typedef struct ACK_SysVendorID_R_Set ACK_SysVendorID_R_Set_t;
+
+/** Message ID for CMD_SysVendorVersionNum_R_Set */
+#define CMD_SYSVENDORVERSIONNUM_R_SET 0x3D43
+
+/**
+   Sets the system vendor version number at the xTU-R. (Section 7.4.6 of G.997.1
+   [11])
+*/
+typedef struct CMD_SysVendorVersionNum_R_Set CMD_SysVendorVersionNum_R_Set_t;
+
+/** Message ID for ACK_SysVendorVersionNum_R_Set */
+#define ACK_SYSVENDORVERSIONNUM_R_SET 0x3D43
+
+/**
+   Acknowledgement to CMD_SysVendorVersionNum_R_Set.
+*/
+typedef struct ACK_SysVendorVersionNum_R_Set ACK_SysVendorVersionNum_R_Set_t;
+
+/** Message ID for CMD_SysVendorSerialNum_R_Set */
+#define CMD_SYSVENDORSERIALNUM_R_SET 0x3E43
+
+/**
+   Sets the system vendor serial number at the xTU-R. (Section 7.4.8 of G.997.1
+   [11])
+*/
+typedef struct CMD_SysVendorSerialNum_R_Set CMD_SysVendorSerialNum_R_Set_t;
+
+/** Message ID for ACK_SysVendorSerialNum_R_Set */
+#define ACK_SYSVENDORSERIALNUM_R_SET 0x3E43
+
+/**
+   Acknowledgement to CMD_SysVendorSerialNum_R_Set.
+*/
+typedef struct ACK_SysVendorSerialNum_R_Set ACK_SysVendorSerialNum_R_Set_t;
+
+/** Message ID for CMD_AuxInventoryInfo_R_Set */
+#define CMD_AUXINVENTORYINFO_R_SET 0x4343
+
+/**
+   Sets auxiliary inventory information at the VTU-R (Section 11.2.3.2.4 of
+   G993.2 [5]).
+*/
+typedef struct CMD_AuxInventoryInfo_R_Set CMD_AuxInventoryInfo_R_Set_t;
+
+/** Message ID for ACK_AuxInventoryInfo_R_Set */
+#define ACK_AUXINVENTORYINFO_R_SET 0x4343
+
+/**
+   Acknowledgement to CMD_AuxInventoryInfo_R_Set.
+*/
+typedef struct ACK_AuxInventoryInfo_R_Set ACK_AuxInventoryInfo_R_Set_t;
+
+/** Message ID for CMD_VendorID_O_Get */
+#define CMD_VENDORID_O_GET 0x4003
+
+/**
+   Requests the xTU-C Vendor ID. (Section 7.4.1 of G.997.1 [11])
+*/
+typedef struct CMD_VendorID_O_Get CMD_VendorID_O_Get_t;
+
+/** Message ID for ACK_VendorID_O_Get */
+#define ACK_VENDORID_O_GET 0x4003
+
+/**
+   Provides the xTU-C Vendor ID as requested by CMD_VendorID_O_Get.
+*/
+typedef struct ACK_VendorID_O_Get ACK_VendorID_O_Get_t;
+
+/** Message ID for CMD_VendorID_R_Get */
+#define CMD_VENDORID_R_GET 0x4103
+
+/**
+   Requests the xTU-R Vendor ID. (Section 7.4.2 of G.997.1 [11])
+*/
+typedef struct CMD_VendorID_R_Get CMD_VendorID_R_Get_t;
+
+/** Message ID for ACK_VendorID_R_Get */
+#define ACK_VENDORID_R_GET 0x4103
+
+/**
+   Provides the xTU-R Vendor ID as requested by CMD_VendorID_R_Get.
+*/
+typedef struct ACK_VendorID_R_Get ACK_VendorID_R_Get_t;
+
+/** Message ID for CMD_SysVendorID_O_Get */
+#define CMD_SYSVENDORID_O_GET 0x3803
+
+/**
+   Requests the xTU-C System Vendor ID. (Section 7.4.3 of G.997.1 [11])
+*/
+typedef struct CMD_SysVendorID_O_Get CMD_SysVendorID_O_Get_t;
+
+/** Message ID for ACK_SysVendorID_O_Get */
+#define ACK_SYSVENDORID_O_GET 0x3803
+
+/**
+   Delivers the xTU-C System Vendor ID as requested by CMD_SysVendorID_O_Get.
+*/
+typedef struct ACK_SysVendorID_O_Get ACK_SysVendorID_O_Get_t;
+
+/** Message ID for CMD_SysVendorID_R_Get */
+#define CMD_SYSVENDORID_R_GET 0x3C03
+
+/**
+   Requests the xTU-R System Vendor ID. (Section 7.4.4 of G.997.1 [11])
+*/
+typedef struct CMD_SysVendorID_R_Get CMD_SysVendorID_R_Get_t;
+
+/** Message ID for ACK_SysVendorID_R_Get */
+#define ACK_SYSVENDORID_R_GET 0x3C03
+
+/**
+   Delivers the xTU-R System Vendor ID as requested by CMD_SysVendorID_R_Get.
+*/
+typedef struct ACK_SysVendorID_R_Get ACK_SysVendorID_R_Get_t;
+
+/** Message ID for CMD_SysVendorVersionNumO_Get */
+#define CMD_SYSVENDORVERSIONNUMO_GET 0x3A03
+
+/**
+   Requests the xTU-C system vendor version number. (Section 7.4.5 of G.997.1
+   [11])
+*/
+typedef struct CMD_SysVendorVersionNumO_Get CMD_SysVendorVersionNumO_Get_t;
+
+/** Message ID for ACK_SysVendorVersionNum_O_Get */
+#define ACK_SYSVENDORVERSIONNUM_O_GET 0x3A03
+
+/**
+   Delivers the xTU-C system vendor version number as requested by
+   CMD_SysVendorVersionNumO_Get.
+*/
+typedef struct ACK_SysVendorVersionNum_O_Get ACK_SysVendorVersionNum_O_Get_t;
+
+/** Message ID for CMD_SysVendorVersionNum_R_Get */
+#define CMD_SYSVENDORVERSIONNUM_R_GET 0x3D03
+
+/**
+   Requests the xTU-R system vendor version number. (Section 7.4.6 of G.997.1
+   [11])
+*/
+typedef struct CMD_SysVendorVersionNum_R_Get CMD_SysVendorVersionNum_R_Get_t;
+
+/** Message ID for ACK_SysVendorVersionNum_R_Get */
+#define ACK_SYSVENDORVERSIONNUM_R_GET 0x3D03
+
+/**
+   Delivers the xTU-R system vendor version number as requested by
+   CMD_SysVendorVersionNum_R_Get.
+*/
+typedef struct ACK_SysVendorVersionNum_R_Get ACK_SysVendorVersionNum_R_Get_t;
+
+/** Message ID for CMD_SysVendorSerialNum_O_Get */
+#define CMD_SYSVENDORSERIALNUM_O_GET 0x3903
+
+/**
+   Requests the xTU-C system vendor serial number. (Section 7.4.7 of G.997.1
+   [11])
+*/
+typedef struct CMD_SysVendorSerialNum_O_Get CMD_SysVendorSerialNum_O_Get_t;
+
+/** Message ID for ACK_SysVendorSerialNum_O_Get */
+#define ACK_SYSVENDORSERIALNUM_O_GET 0x3903
+
+/**
+   Delivers the xTU-C system vendor serial number as requested by
+   CMD_SysVendorSerialNum_O_Get.
+*/
+typedef struct ACK_SysVendorSerialNum_O_Get ACK_SysVendorSerialNum_O_Get_t;
+
+/** Message ID for CMD_SysVendorSerialNum_R_Get */
+#define CMD_SYSVENDORSERIALNUM_R_GET 0x3E03
+
+/**
+   Requests the xTU-R system vendor serial number. (Section 7.4.8 of G.997.1
+   [11])
+*/
+typedef struct CMD_SysVendorSerialNum_R_Get CMD_SysVendorSerialNum_R_Get_t;
+
+/** Message ID for ACK_SysVendorSerialNum_R_Get */
+#define ACK_SYSVENDORSERIALNUM_R_GET 0x3E03
+
+/**
+   Delivers the xTU-R system vendor version number as requested by
+   CMD_SysVendorSerialNum_R_Get.
+*/
+typedef struct ACK_SysVendorSerialNum_R_Get ACK_SysVendorSerialNum_R_Get_t;
+
+/** Message ID for CMD_AuxInventoryInfo_O_Get */
+#define CMD_AUXINVENTORYINFO_O_GET 0x4203
+
+/**
+   Requests VTU-O auxiliary inventory information (Section 11.2.3.2.4 of G993.2
+   [5]).
+*/
+typedef struct CMD_AuxInventoryInfo_O_Get CMD_AuxInventoryInfo_O_Get_t;
+
+/** Message ID for ACK_AuxInventoryInfo_O_Get */
+#define ACK_AUXINVENTORYINFO_O_GET 0x4203
+
+/**
+   Delivers the VTU-O auxiliary inventory information as requested by
+   CMD_AuxInventoryInfo_O_Get.
+*/
+typedef struct ACK_AuxInventoryInfo_O_Get ACK_AuxInventoryInfo_O_Get_t;
+
+/** Message ID for CMD_AuxInventoryInfo_R_Get */
+#define CMD_AUXINVENTORYINFO_R_GET 0x4303
+
+/**
+   Requests VTU-R auxiliary inventory information (Section 11.2.3.2.4 of G993.2
+   [5]).
+*/
+typedef struct CMD_AuxInventoryInfo_R_Get CMD_AuxInventoryInfo_R_Get_t;
+
+/** Message ID for ACK_AuxInventoryInfo_R_Get */
+#define ACK_AUXINVENTORYINFO_R_GET 0x4303
+
+/**
+   Delivers the VTU-R auxiliary inventory information as requested by
+   CMD_AuxInventoryInfo_R_Get.
+*/
+typedef struct ACK_AuxInventoryInfo_R_Get ACK_AuxInventoryInfo_R_Get_t;
+
+/** Message ID for CMD_T1413_VendorID_O_Get */
+#define CMD_T1413_VENDORID_O_GET 0x7C03
+
+/**
+   Requests the ATU-C's T1.413 Vendor identification. (Section 9.6.4.2 of ANSI
+   T1.413 [16])
+*/
+typedef struct CMD_T1413_VendorID_O_Get CMD_T1413_VendorID_O_Get_t;
+
+/** Message ID for ACK_T1413_VendorID_O_Get */
+#define ACK_T1413_VENDORID_O_GET 0x7C03
+
+/**
+   Delivers the ATU-C's T1.413 vendor identification number.
+*/
+typedef struct ACK_T1413_VendorID_O_Get ACK_T1413_VendorID_O_Get_t;
+
+/** Message ID for CMD_T1413_VendorID_R_Get */
+#define CMD_T1413_VENDORID_R_GET 0x7D03
+
+/**
+   Requests the ATU-R's T1.413 Vendor identification. (Section 9.6.4.2 of ANSI
+   T1.413 [16])
+*/
+typedef struct CMD_T1413_VendorID_R_Get CMD_T1413_VendorID_R_Get_t;
+
+/** Message ID for ACK_T1413_VendorID_R_Get */
+#define ACK_T1413_VENDORID_R_GET 0x7D03
+
+/**
+   Reports the ATU-R's T1.413 vendor identification number.
+*/
+typedef struct ACK_T1413_VendorID_R_Get ACK_T1413_VendorID_R_Get_t;
+
+/** Message ID for CMD_T1413_RevNo_O_Get */
+#define CMD_T1413_REVNO_O_GET 0x7E03
+
+/**
+   Requests the xTU-C's T1.413 revision number. (Section 9.6.4.3 of ANSI T1.413
+   [16])
+*/
+typedef struct CMD_T1413_RevNo_O_Get CMD_T1413_RevNo_O_Get_t;
+
+/** Message ID for ACK_T1413_RevNo_O_Get */
+#define ACK_T1413_REVNO_O_GET 0x7E03
+
+/**
+   Delivers the xTU-C's T1.413 revision number.
+*/
+typedef struct ACK_T1413_RevNo_O_Get ACK_T1413_RevNo_O_Get_t;
+
+/** Message ID for CMD_T1413_RevNo_R_Get */
+#define CMD_T1413_REVNO_R_GET 0x7F03
+
+/**
+   Requests the xTU-R's T1.413 revision number. (Section 9.7.6.2 of ANSI T1.413
+   [16])
+*/
+typedef struct CMD_T1413_RevNo_R_Get CMD_T1413_RevNo_R_Get_t;
+
+/** Message ID for ACK_T1413_RevNo_R_Get */
+#define ACK_T1413_REVNO_R_GET 0x7F03
+
+/**
+   Delivers the xTU-R's T1.413 revision number.
+*/
+typedef struct ACK_T1413_RevNo_R_Get ACK_T1413_RevNo_R_Get_t;
+
+/** Message ID for CMD_T1413_VendorRevNo_O_Get */
+#define CMD_T1413_VENDORREVNO_O_GET 0x8003
+
+/**
+   Requests the xTU-C's T1.413 vendor revision number. (Section 9.6.4.4 of ANSI
+   T1.413 [16])
+*/
+typedef struct CMD_T1413_VendorRevNo_O_Get CMD_T1413_VendorRevNo_O_Get_t;
+
+/** Message ID for ACK_T1413_VendorRevNo_O_Get */
+#define ACK_T1413_VENDORREVNO_O_GET 0x8003
+
+/**
+   Delivers the xTU-C's T1.413 vendor revision number.
+*/
+typedef struct ACK_T1413_VendorRevNo_O_Get ACK_T1413_VendorRevNo_O_Get_t;
+
+/** Message ID for CMD_T1413_VendorRevNo_R_Get */
+#define CMD_T1413_VENDORREVNO_R_GET 0x8103
+
+/**
+   Requests the xTU-R's T1.413 vendor revision number. (Section 9.7.6.3 of ANSI
+   T1.413 [16])
+*/
+typedef struct CMD_T1413_VendorRevNo_R_Get CMD_T1413_VendorRevNo_R_Get_t;
+
+/** Message ID for ACK_T1413_VendorRevNo_R_Get */
+#define ACK_T1413_VENDORREVNO_R_GET 0x8103
+
+/**
+   Delivers the xTU-R's T1.413 vendor revision number.
+*/
+typedef struct ACK_T1413_VendorRevNo_R_Get ACK_T1413_VendorRevNo_R_Get_t;
+
+/** Message ID for CMD_XTSE_StatusGet */
+#define CMD_XTSE_STATUSGET 0x0102
+
+/**
+   Requests the transmission system in use on the line (DSL flavour). (Section
+   7.5.1.1. of G.997.1 [11]) See note at ACK_XTSE_StatusGet about the expected
+   behaviour.
+*/
+typedef struct CMD_XTSE_StatusGet CMD_XTSE_StatusGet_t;
+
+/** Message ID for ACK_XTSE_StatusGet */
+#define ACK_XTSE_STATUSGET 0x0102
+
+/**
+   Reports the transmission system mode in use as requested by
+   CMD_XTSE_StatusGet.The information is set by the FW after mode select (MS)
+   during the handshake phase or during T1.413 state. Before mode selection the
+   value "0" is reported (=none), after selection of a common mode exactly this
+   single mode must be indicated. If there is a common mode but it requires
+   another FW to be loaded (e.g. ADSL instead of VDSL), this does not happen
+   ("0" is reported ), then the FW goes to FAIL state and indicates a specific
+   suberror code (S_XDSL_MODE). If there is no common mode, "0" is to be
+   reported (here modem enters FAIL state).
+*/
+typedef struct ACK_XTSE_StatusGet ACK_XTSE_StatusGet_t;
+
+/** Message ID for CMD_BandControl_DS_Get */
+#define CMD_BANDCONTROL_DS_GET 0xC803
+
+/**
+   Reads the used downstream band configuration.
+*/
+typedef struct CMD_BandControl_DS_Get CMD_BandControl_DS_Get_t;
+
+/** Message ID for ACK_BandControl_DS_Get */
+#define ACK_BANDCONTROL_DS_GET 0xC803
+
+/**
+   Acknowledgement for message CMD_BandControl_DS_Get.
+*/
+typedef struct ACK_BandControl_DS_Get ACK_BandControl_DS_Get_t;
+
+/** Message ID for CMD_BandControl_US_Get */
+#define CMD_BANDCONTROL_US_GET 0xC903
+
+/**
+   Reads the used upstream band configuration.
+*/
+typedef struct CMD_BandControl_US_Get CMD_BandControl_US_Get_t;
+
+/** Message ID for ACK_BandControl_US_Get */
+#define ACK_BANDCONTROL_US_GET 0xC903
+
+/**
+   Acknowledgement for message CMD_BandControl_US_Get.
+*/
+typedef struct ACK_BandControl_US_Get ACK_BandControl_US_Get_t;
+
+/** Message ID for CMD_RFI_BandControlGet */
+#define CMD_RFI_BANDCONTROLGET 0xCA03
+
+/**
+   Reads the RFI band configuration.
+*/
+typedef struct CMD_RFI_BandControlGet CMD_RFI_BandControlGet_t;
+
+/** Message ID for ACK_RFI_BandControlGet */
+#define ACK_RFI_BANDCONTROLGET 0xCA03
+
+/**
+   Acknowledgement for message CMD_RFI_BandControlGet.
+*/
+typedef struct ACK_RFI_BandControlGet ACK_RFI_BandControlGet_t;
+
+/** Message ID for CMD_LineStatusDS_Get */
+#define CMD_LINESTATUSDS_GET 0x4403
+
+/**
+   This message requests data about the line status (like noise margin) for
+   downstream direction.
+*/
+typedef struct CMD_LineStatusDS_Get CMD_LineStatusDS_Get_t;
+
+/** Message ID for ACK_LineStatusDS_Get */
+#define ACK_LINESTATUSDS_GET 0x4403
+
+/**
+   The message delivers the line status data for downstream direction requested
+   by CMD_LineStatusDS_Get.
+*/
+typedef struct ACK_LineStatusDS_Get ACK_LineStatusDS_Get_t;
+
+/** Message ID for CMD_LineStatusUS_Get */
+#define CMD_LINESTATUSUS_GET 0x4503
+
+/**
+   This message requests data about the upstream line status (like noise
+   margin).
+*/
+typedef struct CMD_LineStatusUS_Get CMD_LineStatusUS_Get_t;
+
+/** Message ID for ACK_LineStatusUS_Get */
+#define ACK_LINESTATUSUS_GET 0x4503
+
+/**
+   The message delivers the line status data for upstream direction requested by
+   CMD_LineStatusUS_Get.
+*/
+typedef struct ACK_LineStatusUS_Get ACK_LineStatusUS_Get_t;
+
+/** Message ID for CMD_LineStatusPerBandDS_Get */
+#define CMD_LINESTATUSPERBANDDS_GET 0xD203
+
+/**
+   This message requests data about the line status (noise margin, line
+   attenuation and signal attenuation) for downstream direction in a "per band"
+   granularity.
+*/
+typedef struct CMD_LineStatusPerBandDS_Get CMD_LineStatusPerBandDS_Get_t;
+
+/** Message ID for ACK_LineStatusPerBandDS_Get */
+#define ACK_LINESTATUSPERBANDDS_GET 0xD203
+
+/**
+   The message delivers the line status data (line attenuation, signal
+   attenuation and noise margin) for downstream direction in a "per band"
+   granularity as requested by CMD_LineStatusPerBandDS_Get.
+*/
+typedef struct ACK_LineStatusPerBandDS_Get ACK_LineStatusPerBandDS_Get_t;
+
+/** Message ID for CMD_LineStatusPerBandUS_Get */
+#define CMD_LINESTATUSPERBANDUS_GET 0xD303
+
+/**
+   This message requests data about the line status (noise margin, line - and
+   signal attenuation) for upstream direction in a "per band" granularity.
+*/
+typedef struct CMD_LineStatusPerBandUS_Get CMD_LineStatusPerBandUS_Get_t;
+
+/** Message ID for ACK_LineStatusPerBandUS_Get */
+#define ACK_LINESTATUSPERBANDUS_GET 0xD303
+
+/**
+   The message delivers the line status data (line attenuation, signal
+   attenuation and noise margin) for upstream direction in a "per band"
+   granularity as requested by CMD_LineStatusPerBandUS_Get.
+*/
+typedef struct ACK_LineStatusPerBandUS_Get ACK_LineStatusPerBandUS_Get_t;
+
+/** Message ID for CMD_AttndrStatusGet */
+#define CMD_ATTNDRSTATUSGET 0xF003
+
+/**
+   Requests parameters used for the calculation of the downstream attainable net
+   data rate (ATTNDRds).
+*/
+typedef struct CMD_AttndrStatusGet CMD_AttndrStatusGet_t;
+
+/** Message ID for ACK_AttndrStatusGet */
+#define ACK_ATTNDRSTATUSGET 0xF003
+
+/**
+   Delivers the data requested by CMD_AttndrStatusGet.(Section 7.5.1.41 of
+   G.997.1 [12]).
+*/
+typedef struct ACK_AttndrStatusGet ACK_AttndrStatusGet_t;
+
+/** Message ID for CMD_PSD_BreakpointsDS_Get */
+#define CMD_PSD_BREAKPOINTSDS_GET 0xD403
+
+/**
+   Requests the breakpoints of the actual PSD for the downstream direction. PSDs
+   consisting of more than 42 PSD breakpoints must be read with 2 messages due
+   to the the mailbox size. (The first parameter in the retrieved data structure
+   contains the "Number of Breakpoints" parameter.)
+*/
+typedef struct CMD_PSD_BreakpointsDS_Get CMD_PSD_BreakpointsDS_Get_t;
+
+/** Message ID for ACK_PSD_BreakpointsDS_Get */
+#define ACK_PSD_BREAKPOINTSDS_GET 0xD403
+
+/**
+   Delivers the breakpoints of the actual PSD for the downstream direction as
+   requested by CMD_PSD_BreakpointsDS_Get.
+*/
+typedef struct ACK_PSD_BreakpointsDS_Get ACK_PSD_BreakpointsDS_Get_t;
+
+/** Message ID for CMD_PSD_BreakpointsUS_Get */
+#define CMD_PSD_BREAKPOINTSUS_GET 0xD503
+
+/**
+   Requests the breakpoints of the actual PSD for the upstream direction.
+*/
+typedef struct CMD_PSD_BreakpointsUS_Get CMD_PSD_BreakpointsUS_Get_t;
+
+/** Message ID for ACK_PSD_BreakpointsUS_Get */
+#define ACK_PSD_BREAKPOINTSUS_GET 0xD503
+
+/**
+   Delivers the breakpoints of the actual PSD for the upstream direction as
+   requested by CMD_PSD_BreakpointsUS_Get.
+*/
+typedef struct ACK_PSD_BreakpointsUS_Get ACK_PSD_BreakpointsUS_Get_t;
+
+/** Message ID for CMD_TssiDS_VDSL2_Get */
+#define CMD_TSSIDS_VDSL2_GET 0x2803
+
+/**
+   The Downstream TSSI Breakpoints are specified by the transmitter (VTU-O) and
+   communicated to the receiver (VTU-R) via the O-PRM message.   The TSSI
+   Breakpoints are used to shape the O-P-TEQ signal. This message provides read
+   only access to the DS TSSI Breakpoints. The DS TSSI Breakpoints are not
+   configurable via messages.
+*/
+typedef struct CMD_TssiDS_VDSL2_Get CMD_TssiDS_VDSL2_Get_t;
+
+/** Message ID for ACK_TssiDS_VDSL2_Get */
+#define ACK_TSSIDS_VDSL2_GET 0x2803
+
+/**
+   This is the acknowledgement of CMD_TssiDS_VDSL2_Get.
+*/
+typedef struct ACK_TssiDS_VDSL2_Get ACK_TssiDS_VDSL2_Get_t;
+
+/** Message ID for CMD_TssiUS_VDSL2_Get */
+#define CMD_TSSIUS_VDSL2_GET 0x2903
+
+/**
+   The Upstream TSSI Breakpoints are specified by the transmitter (VTU-R) and
+   communicated to the receiver (VTU-O) via the R-PRM message.   The TSSI
+   Breakpoints are used to shape the R-P-TEQ signal.  The TSSI Breakpoints can
+   be read only but are not configurable via messages.
+*/
+typedef struct CMD_TssiUS_VDSL2_Get CMD_TssiUS_VDSL2_Get_t;
+
+/** Message ID for ACK_TssiUS_VDSL2_Get */
+#define ACK_TSSIUS_VDSL2_GET 0x2903
+
+/**
+   This is the acknowledgement of CMD_TssiUS_VDSL2_Get.
+*/
+typedef struct ACK_TssiUS_VDSL2_Get ACK_TssiUS_VDSL2_Get_t;
+
+/** Message ID for CMD_ADSL_PCB_Get */
+#define CMD_ADSL_PCB_GET 0x000E
+
+/**
+   Reads the actual power cutback value.
+*/
+typedef struct CMD_ADSL_PCB_Get CMD_ADSL_PCB_Get_t;
+
+/** Message ID for ACK_ADSL_PCB_Get */
+#define ACK_ADSL_PCB_GET 0x000E
+
+/**
+   Provides the actual power cutback values requested with CMD_ADSL_PCB_Get.
+*/
+typedef struct ACK_ADSL_PCB_Get ACK_ADSL_PCB_Get_t;
+
+/** Message ID for CMD_ActualPSD_Get */
+#define CMD_ACTUALPSD_GET 0xD803
+
+/**
+   Requests the PSD and power parameter values actually used by the firmware.
+*/
+typedef struct CMD_ActualPSD_Get CMD_ActualPSD_Get_t;
+
+/** Message ID for ACK_ActualPSD_Get */
+#define ACK_ACTUALPSD_GET 0xD803
+
+/**
+   Provides actually used PSD and power parameters as requested by
+   CMD_ActualPSD_Get.
+*/
+typedef struct ACK_ActualPSD_Get ACK_ActualPSD_Get_t;
+
+/** Message ID for CMD_ADSL_MJ_UsMaskGet */
+#define CMD_ADSL_MJ_USMASKGET 0x1802
+
+/**
+   Requests the actually used ADSL upstream mask for ADSL2/2+ Annexes M and J.
+   To be applied only in combination with G.992.3/5 Annex M support in
+   ACK_XTSE_StatusGet.
+*/
+typedef struct CMD_ADSL_MJ_UsMaskGet CMD_ADSL_MJ_UsMaskGet_t;
+
+/** Message ID for ACK_ADSL_MJ_UsMaskGet */
+#define ACK_ADSL_MJ_USMASKGET 0x1802
+
+/**
+   Provides the actually used ADSL upstream mask for ADSL2/2+ Annexes M and J.
+*/
+typedef struct ACK_ADSL_MJ_UsMaskGet ACK_ADSL_MJ_UsMaskGet_t;
+
+/** Message ID for CMD_PSDMASK_DS_Get */
+#define CMD_PSDMASK_DS_GET 0xF203
+
+/**
+   Reports the downstream transmit PSD mask (PSDMASKds) which is received from
+   CO with O-SIGNATURE message.
+*/
+typedef struct CMD_PSDMASK_DS_Get CMD_PSDMASK_DS_Get_t;
+
+/** Message ID for ACK_PSDMASK_DS_Get */
+#define ACK_PSDMASK_DS_GET 0xF203
+
+/**
+   Reports the downstream transmit PSD mask (PSDMASKds) for both passbands and
+   stopbands, which is received from CO with O-SIGNATURE message. (Format is now
+   as absolute value without the offset.)
+*/
+typedef struct ACK_PSDMASK_DS_Get ACK_PSDMASK_DS_Get_t;
+
+/** Message ID for CMD_RxPSD_TableEntriesGet */
+#define CMD_RXPSD_TABLEENTRIESGET 0x5403
+
+/**
+   The message requests information about the receive PSD per subcarrier
+   available at the near-end side, which means for downstream direction at the
+   CPE. It is the hosts responsibility to select the tone indices accordingly.In
+   Showtime the message reports the receive PSD measured in Channel Discovery
+   phase after the final hybrid training (no Showtime update).
+*/
+typedef struct CMD_RxPSD_TableEntriesGet CMD_RxPSD_TableEntriesGet_t;
+
+/** Message ID for ACK_RxPSD_TableEntriesGet */
+#define ACK_RXPSD_TABLEENTRIESGET 0x5403
+
+/**
+   Returns information about the receive PSD per subcarrier available at the
+   near-end side, which means for downstream direction at the CPE.In Showtime
+   the message reports the receive PSD measured in Channel Discovery phase after
+   the final hybrid training (no Showtime update).
+*/
+typedef struct ACK_RxPSD_TableEntriesGet ACK_RxPSD_TableEntriesGet_t;
+
+/** Message ID for CMD_BearerChsDS_Get */
+#define CMD_BEARERCHSDS_GET 0x0106
+
+/**
+   Requests status information for the downstream bearer channels.
+*/
+typedef struct CMD_BearerChsDS_Get CMD_BearerChsDS_Get_t;
+
+/** Message ID for ACK_BearerChsDS_Get */
+#define ACK_BEARERCHSDS_GET 0x0106
+
+/**
+   Delivers status information for the downstream bearer channels. **: The terms
+   "LP0/Interleaved Path" and "LP1/Fast Path" below refer to the terminology
+   used in ITU DSL standards [1],[2], [3], [5] which means:- LP0 or LP1 in case
+   of VDSL2, ADSL2/2+- "Interleaved Path" or "Fast Path" in case of ADSL1/ADSL1
+   Lite.Attention: In VRX Device1 the "LP1/Fast Path" parameters are populated
+   only in ADSL1 and ADSL1 Lilte mode with selected fast path.
+*/
+typedef struct ACK_BearerChsDS_Get ACK_BearerChsDS_Get_t;
+
+/** Message ID for CMD_BearerChsUS_Get */
+#define CMD_BEARERCHSUS_GET 0x0006
+
+/**
+   Requests status information for the upstream bearer channels.
+*/
+typedef struct CMD_BearerChsUS_Get CMD_BearerChsUS_Get_t;
+
+/** Message ID for ACK_BearerChsUS_Get */
+#define ACK_BEARERCHSUS_GET 0x0006
+
+/**
+   Delivers status information for the upstream bearer channels. **: The terms
+   "LP0/Interleaved Path" and "LP1/Fast Path" below refer to the terminology
+   used in ITU DSL standards [1],[2], [3], [5] which means:- LP0 or LP1 in case
+   of VDSL2, ADSL2/2+- "Interleaved Path" or "Fast Path" in case of ADSL1/ADSL1
+   Lite.Attention: In VRX Device1 the "LP1/Fast Path" parameters are populated
+   only in ADSL1 and ADSL1 Lite mode with selected fast path.
+*/
+typedef struct ACK_BearerChsUS_Get ACK_BearerChsUS_Get_t;
+
+/** Message ID for CMD_FrameDataExt2DS_Get */
+#define CMD_FRAMEDATAEXT2DS_GET 0x2203
+
+/**
+   Requests an extended set of VDSL2 framing parameters for the downstream
+   direction.
+*/
+typedef struct CMD_FrameDataExt2DS_Get CMD_FrameDataExt2DS_Get_t;
+
+/** Message ID for ACK_FrameDataExt2DS_Get */
+#define ACK_FRAMEDATAEXT2DS_GET 0x2203
+
+/**
+   Delivers an extended set of VDSL2 framing parameters for the downstream
+   direction requested by CMD_FrameDataExt2DS_Get. (Sections 7.5.2.6 of G.997.1
+   and 9.5 & 9.6 of G.993.2 [5])
+*/
+typedef struct ACK_FrameDataExt2DS_Get ACK_FrameDataExt2DS_Get_t;
+
+/** Message ID for CMD_FrameDataExt2US_Get */
+#define CMD_FRAMEDATAEXT2US_GET 0x2303
+
+/**
+   Requests an extended set of VDSL2 framing parameters for the upstream
+   direction.
+*/
+typedef struct CMD_FrameDataExt2US_Get CMD_FrameDataExt2US_Get_t;
+
+/** Message ID for ACK_FrameDataExt2US_Get */
+#define ACK_FRAMEDATAEXT2US_GET 0x2303
+
+/**
+   Delivers an extended set of VDSL2 framing parameters for the upstream
+   direction requested by CMD_FrameDataExt2US_Get. (Sections 7.5.2.6 of G.997.1
+   and 9.5 & 9.6 of G.993.2 [5])
+*/
+typedef struct ACK_FrameDataExt2US_Get ACK_FrameDataExt2US_Get_t;
+
+/** Message ID for CMD_ADSL_FrameDataDS_LP0Get */
+#define CMD_ADSL_FRAMEDATADS_LP0GET 0x010E
+
+/**
+   Requests ADSL framing parameters for the downstream direction, latency path
+   0/Interleaved Path.
+*/
+typedef struct CMD_ADSL_FrameDataDS_LP0Get CMD_ADSL_FrameDataDS_LP0Get_t;
+
+/** Message ID for ACK_ADSL_FrameDataDS_LP0Get */
+#define ACK_ADSL_FRAMEDATADS_LP0GET 0x010E
+
+/**
+   Delivers the ADSL framing parameters for the downstream direction,
+   LP0/Interleaved path, as requested by CMD_ADSL_FrameDataDS_LP0Get. (Sections
+   7.5 & 7.6 of G.992.3 [2] and 7.4 of G.992.1 [1])
+*/
+typedef struct ACK_ADSL_FrameDataDS_LP0Get ACK_ADSL_FrameDataDS_LP0Get_t;
+
+/** Message ID for CMD_ADSL_FrameDataUS_LP0Get */
+#define CMD_ADSL_FRAMEDATAUS_LP0GET 0x020E
+
+/**
+   Requests ADSL framing parameters for the upstream direction, latency path
+   0/Interleaved path.
+*/
+typedef struct CMD_ADSL_FrameDataUS_LP0Get CMD_ADSL_FrameDataUS_LP0Get_t;
+
+/** Message ID for ACK_ADSL_FrameDataUS_LP0Get */
+#define ACK_ADSL_FRAMEDATAUS_LP0GET 0x020E
+
+/**
+   Delivers the ADSL framing parameters for the upstream direction, latency path
+   0/Interleaved path, as requested by CMD_ADSL_FrameDataUS_LP0Get. (Sections
+   7.5 & 7.6 of G.992.3 [2] and 7.4 of G.992.1 [1])
+*/
+typedef struct ACK_ADSL_FrameDataUS_LP0Get ACK_ADSL_FrameDataUS_LP0Get_t;
+
+/** Message ID for CMD_ADSL_FrameDataDS_LP1Get */
+#define CMD_ADSL_FRAMEDATADS_LP1GET 0x030E
+
+/**
+   Requests ADSL framing parameters for the downstream direction, latency path 1
+   (LP1)/ Fast path.In VRX Rev. 1.x to be used for ADSL1, "fast path" only.
+*/
+typedef struct CMD_ADSL_FrameDataDS_LP1Get CMD_ADSL_FrameDataDS_LP1Get_t;
+
+/** Message ID for ACK_ADSL_FrameDataDS_LP1Get */
+#define ACK_ADSL_FRAMEDATADS_LP1GET 0x030E
+
+/**
+   Delivers the ADSL framing parameters for the downstream direction, LP1/Fast
+   path, as requested by CMD_ADSL_FrameDataDS_LP1Get. (Sections 7.5 & 7.6 of
+   G.992.3 [2] and 7.4 of G.992.1 [1])
+*/
+typedef struct ACK_ADSL_FrameDataDS_LP1Get ACK_ADSL_FrameDataDS_LP1Get_t;
+
+/** Message ID for CMD_ADSL_FrameDataUS_LP1Get */
+#define CMD_ADSL_FRAMEDATAUS_LP1GET 0x040E
+
+/**
+   Requests ADSL framing parameters for the upstream direction, latency path 1
+   (LP1)/Fast path.In VRX Rev. 1.x to be used for ADSL1, "fast path" only.
+*/
+typedef struct CMD_ADSL_FrameDataUS_LP1Get CMD_ADSL_FrameDataUS_LP1Get_t;
+
+/** Message ID for ACK_ADSL_FrameDataUS_LP1Get */
+#define ACK_ADSL_FRAMEDATAUS_LP1GET 0x040E
+
+/**
+   Delivers the ADSL framing parameters for the upstream direction, LP1/Fast
+   path, as requested by CMD_ADSL_FrameDataUS_LP1Get. (Sections 7.5 & 7.6 of
+   G.992.3 [2] and 7.4 of G.992.1 [1])
+*/
+typedef struct ACK_ADSL_FrameDataUS_LP1Get ACK_ADSL_FrameDataUS_LP1Get_t;
+
+/** Message ID for CMD_HybridGet */
+#define CMD_HYBRIDGET 0x0922
+
+/**
+   Reads the connected hybrid type.
+*/
+typedef struct CMD_HybridGet CMD_HybridGet_t;
+
+/** Message ID for ACK_HybridGet */
+#define ACK_HYBRIDGET 0x0922
+
+/**
+   Contains the connected hybrid type.
+*/
+typedef struct ACK_HybridGet ACK_HybridGet_t;
+
+/** Message ID for CMD_PilotTonesGet */
+#define CMD_PILOTTONESGET 0x0322
+
+/**
+   Requests the pilot tones used in Showtime.
+*/
+typedef struct CMD_PilotTonesGet CMD_PilotTonesGet_t;
+
+/** Message ID for ACK_PilotTonesGet */
+#define ACK_PILOTTONESGET 0x0322
+
+/**
+   Provides the Showtime pilot tones as requested by CMD_PilotTonesGet.
+*/
+typedef struct ACK_PilotTonesGet ACK_PilotTonesGet_t;
+
+/** Message ID for CMD_MFD_ResultsGet */
+#define CMD_MFD_RESULTSGET 0x1022
+
+/**
+   Requests the results of the micro filter detection (MFD) function. Valid
+   information in Showtime and FAIL will be available only if the microfilter
+   detection mechanism has been run before.
+*/
+typedef struct CMD_MFD_ResultsGet CMD_MFD_ResultsGet_t;
+
+/** Message ID for ACK_MFD_ResultsGet */
+#define ACK_MFD_RESULTSGET 0x1022
+
+/**
+   Reports the results of the micro filter detection (MFD) function.
+*/
+typedef struct ACK_MFD_ResultsGet ACK_MFD_ResultsGet_t;
+
+/** Message ID for CMD_MFD_LooplengthGet */
+#define CMD_MFD_LOOPLENGTHGET 0x1122
+
+/**
+   Requests the loop length estimates done by the microfilter detection
+   function.In Showtime the data are always available.The availability of data
+   is indicated by the flag TrainingLoopLengthReady in ACK_MFD_ResultsGet.In
+   Showtime the data are always available.
+*/
+typedef struct CMD_MFD_LooplengthGet CMD_MFD_LooplengthGet_t;
+
+/** Message ID for ACK_MFD_LooplengthGet */
+#define ACK_MFD_LOOPLENGTHGET 0x1122
+
+/**
+   Reports the loop length estimates done by the microfilter detection (MFD)
+   function.
+*/
+typedef struct ACK_MFD_LooplengthGet ACK_MFD_LooplengthGet_t;
+
+/** Message ID for CMD_MFD_HybridInfoGet */
+#define CMD_MFD_HYBRIDINFOGET 0x1222
+
+/**
+   Requests hybrid information used by the microfilter detection function.In
+   Showtime the data are always available.The availability of data is indicated
+   by the flag TrainingHybridInfoReady in ACK_MFD_ResultsGet. In Showtime the
+   data are always available.
+*/
+typedef struct CMD_MFD_HybridInfoGet CMD_MFD_HybridInfoGet_t;
+
+/** Message ID for ACK_MFD_HybridInfoGet */
+#define ACK_MFD_HYBRIDINFOGET 0x1222
+
+/**
+   Reports the hybrid information used by the microfilter detection function.
+*/
+typedef struct ACK_MFD_HybridInfoGet ACK_MFD_HybridInfoGet_t;
+
+/**
+   Selects one or more groups of tones to be used during the handshake phase.
+   (See G.994.1 Amendment 2 [8], Table 1/G.994.1).
+*/
+struct CMD_HS_ToneGroupSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 7;
+   /** Tone Group 8: CAR_SET_V43I */
+   DSL_uint16_t Group8 : 1;
+   /** Tone Group 7: CAR_SET_V43P */
+   DSL_uint16_t Group7 : 1;
+   /** Tone Group 6: CAR_SET_V43 */
+   DSL_uint16_t Group6 : 1;
+   /** Tone Group 5: CAR_SET_J43 */
+   DSL_uint16_t Group5 : 1;
+   /** Tone Group 4: CAR_SET_C43 */
+   DSL_uint16_t Group4 : 1;
+   /** Tone Group 3: CAR_SET_B43C */
+   DSL_uint16_t Group3 : 1;
+   /** Tone Group 2: CAR_SET_B43 */
+   DSL_uint16_t Group2 : 1;
+   /** Tone Group 1: CAR_SET_A43C */
+   DSL_uint16_t Group1 : 1;
+   /** Tone Group 0: CAR_SET_A43 */
+   DSL_uint16_t Group0 : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Tone Group 0: CAR_SET_A43 */
+   DSL_uint16_t Group0 : 1;
+   /** Tone Group 1: CAR_SET_A43C */
+   DSL_uint16_t Group1 : 1;
+   /** Tone Group 2: CAR_SET_B43 */
+   DSL_uint16_t Group2 : 1;
+   /** Tone Group 3: CAR_SET_B43C */
+   DSL_uint16_t Group3 : 1;
+   /** Tone Group 4: CAR_SET_C43 */
+   DSL_uint16_t Group4 : 1;
+   /** Tone Group 5: CAR_SET_J43 */
+   DSL_uint16_t Group5 : 1;
+   /** Tone Group 6: CAR_SET_V43 */
+   DSL_uint16_t Group6 : 1;
+   /** Tone Group 7: CAR_SET_V43P */
+   DSL_uint16_t Group7 : 1;
+   /** Tone Group 8: CAR_SET_V43I */
+   DSL_uint16_t Group8 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 7;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_HS_ToneGroupSet.
+*/
+struct ACK_HS_ToneGroupSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Configures the profile settings to be used for the handshake phase. (See
+   G.994.1 Amendment 4 [10], NPAR(3) coding).
+*/
+struct CMD_HS_VDSL2ProfileControl
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t  Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 7;
+   /** 35b, Profile Support Bit 8 */
+   DSL_uint16_t profileSup8 : 1;
+   /** 30a, Profile Support Bit 7 */
+   DSL_uint16_t profileSup7 : 1;
+   /** 17a, Profile Support Bit 6 */
+   DSL_uint16_t profileSup6 : 1;
+   /** 12b, Profile Support Bit 5 */
+   DSL_uint16_t profileSup5 : 1;
+   /** 12a, Profile Support Bit 4 */
+   DSL_uint16_t profileSup4 : 1;
+   /** 8d, Profile Support Bit 3 */
+   DSL_uint16_t profileSup3 : 1;
+   /** 8c, Profile Support Bit 2 */
+   DSL_uint16_t profileSup2 : 1;
+   /** 8b, Profile Support Bit 1 */
+   DSL_uint16_t profileSup1 : 1;
+   /** 8a, Profile Support Bit 0 */
+   DSL_uint16_t profileSup0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 7;
+   /** 35b, Profile Preferred Bit 8 */
+   DSL_uint16_t profilePref8 : 1;
+   /** 30a, Profile Preferred Bit 7 */
+   DSL_uint16_t profilePref7 : 1;
+   /** 17a, Profile Preferred Bit 6 */
+   DSL_uint16_t profilePref6 : 1;
+   /** 12b, Profile Preferred Bit 5 */
+   DSL_uint16_t profilePref5 : 1;
+   /** 12a, Profile Preferred Bit 4 */
+   DSL_uint16_t profilePref4 : 1;
+   /** 8d, Profile Preferred Bit 3 */
+   DSL_uint16_t profilePref3 : 1;
+   /** 8c, Profile Preferred Bit 2 */
+   DSL_uint16_t profilePref2 : 1;
+   /** 8b, Profile Preferred Bit 1 */
+   DSL_uint16_t profilePref1 : 1;
+   /** 8a, Profile Preferred Bit 0 */
+   DSL_uint16_t profilePref0 : 1;
+   /** ADLU-56, Annex A US0 PSDs Supported Bit 15 */
+   DSL_uint16_t A_US0PsdSup15 : 1;
+   /** ADLU-52, Annex A US0 PSDs Supported Bit 14 */
+   DSL_uint16_t A_US0PsdSup14 : 1;
+   /** ADLU-48, Annex A US0 PSDs Supported Bit 13 */
+   DSL_uint16_t A_US0PsdSup13 : 1;
+   /** ADLU-44, Annex A US0 PSDs Supported Bit 12 */
+   DSL_uint16_t A_US0PsdSup12 : 1;
+   /** ADLU-40, Annex A US0 PSDs Supported Bit 11 */
+   DSL_uint16_t A_US0PsdSup11 : 1;
+   /** ADLU-36, Annex A US0 PSDs Supported Bit 10 */
+   DSL_uint16_t A_US0PsdSup10 : 1;
+   /** ADLU-32, Annex A US0 PSDs Supported Bit 9 */
+   DSL_uint16_t A_US0PsdSup9 : 1;
+   /** EU-64, Annex A US0 PSDs Supported Bit 8 */
+   DSL_uint16_t A_US0PsdSup8 : 1;
+   /** EU-60, Annex A US0 PSDs Supported Bit 7 */
+   DSL_uint16_t A_US0PsdSup7 : 1;
+   /** EU-56, Annex A US0 PSDs Supported Bit 6 */
+   DSL_uint16_t A_US0PsdSup6 : 1;
+   /** EU-52, Annex A US0 PSDs Supported Bit 5 */
+   DSL_uint16_t A_US0PsdSup5 : 1;
+   /** EU-48, Annex A US0 PSDs Supported Bit 4 */
+   DSL_uint16_t A_US0PsdSup4 : 1;
+   /** EU-44, Annex A US0 PSDs Supported Bit 3 */
+   DSL_uint16_t A_US0PsdSup3 : 1;
+   /** EU-40, Annex A US0 PSDs Supported Bit 2 */
+   DSL_uint16_t A_US0PsdSup2 : 1;
+   /** EU-36, Annex A US0 PSDs Supported Bit 1 */
+   DSL_uint16_t A_US0PsdSup1 : 1;
+   /** EU-32, Annex A US0 PSDs Supported Bit 0 */
+   DSL_uint16_t A_US0PsdSup0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 10;
+   /** ADLU-128, Annex A US0 PSDs Supported Bit 21 */
+   DSL_uint16_t A_US0PsdSup21 : 1;
+   /** EU-128, Annex A US0 PSDs Supported Bit 20 */
+   DSL_uint16_t A_US0PsdSup20 : 1;
+   /** 17a Profile, Annex A US0 PSDs Supported Bit 19 */
+   DSL_uint16_t A_US0PsdSup19 : 1;
+   /** 12b Profile, Annex A US0 PSDs Supported Bit 18 */
+   DSL_uint16_t A_US0PsdSup18 : 1;
+   /** ADLU-64, Annex A US0 PSDs Supported Bit 17 */
+   DSL_uint16_t A_US0PsdSup17 : 1;
+   /** ADLU-60, Annex A US0 PSDs Supported Bit 16 */
+   DSL_uint16_t A_US0PsdSup16 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3[2];
+   /** Reserved */
+   DSL_uint16_t Res4 : 11;
+   /** 17a Profile, Annex B US0 PSDs Supported Bit 4 */
+   DSL_uint16_t B_US0PsdSup4 : 1;
+   /** 12b Profile, Annex B US0 PSDs Supported Bit 3 */
+   DSL_uint16_t B_US0PsdSup3 : 1;
+   /** US0 In 120 to 276 kHz, Annex B US0 PSDs Supported Bit 2 */
+   DSL_uint16_t B_US0PsdSup2 : 1;
+   /** US0 In 25 to 276 kHz, Annex B US0 PSDs Supported Bit 1 */
+   DSL_uint16_t B_US0PsdSup1 : 1;
+   /** US0 In 25 to 138 kHz, Annex B US0 PSDs Supported Bit 0 */
+   DSL_uint16_t B_US0PsdSup0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res5;
+   /** Reserved */
+   DSL_uint16_t Res6 : 2;
+   /** 17a Profile, Annex C US0 PSDs Supported Bit 13 */
+   DSL_uint16_t C_US0PsdSup13 : 1;
+   /** 12b Profile, Annex C US0 PSDs Supported Bit 12 */
+   DSL_uint16_t C_US0PsdSup12 : 1;
+   /** Reserved */
+   DSL_uint16_t Res7 : 6;
+   /** US0 In 25 to 276 kHz, Annex C US0 PSDs Supported Bit 5 */
+   DSL_uint16_t C_US0PsdSup5 : 1;
+   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Supported Bit 4 */
+   DSL_uint16_t C_US0PsdSup4 : 1;
+   /** Reserved */
+   DSL_uint16_t Res8 : 2;
+   /** US0 In 25 to 276kHz, Annex C US0 PSDs Supported Bit 1 */
+   DSL_uint16_t C_US0PsdSup1 : 1;
+   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Supported Bit 0 */
+   DSL_uint16_t C_US0PsdSup0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res9;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t  Length;
+   /** 8a, Profile Support Bit 0 */
+   DSL_uint16_t profileSup0 : 1;
+   /** 8b, Profile Support Bit 1 */
+   DSL_uint16_t profileSup1 : 1;
+   /** 8c, Profile Support Bit 2 */
+   DSL_uint16_t profileSup2 : 1;
+   /** 8d, Profile Support Bit 3 */
+   DSL_uint16_t profileSup3 : 1;
+   /** 12a, Profile Support Bit 4 */
+   DSL_uint16_t profileSup4 : 1;
+   /** 12b, Profile Support Bit 5 */
+   DSL_uint16_t profileSup5 : 1;
+   /** 17a, Profile Support Bit 6 */
+   DSL_uint16_t profileSup6 : 1;
+   /** 30a, Profile Support Bit 7 */
+   DSL_uint16_t profileSup7 : 1;
+   /** 35b, Profile Support Bit 8 */
+   DSL_uint16_t profileSup8 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 7;
+   /** 8a, Profile Preferred Bit 0 */
+   DSL_uint16_t profilePref0 : 1;
+   /** 8b, Profile Preferred Bit 1 */
+   DSL_uint16_t profilePref1 : 1;
+   /** 8c, Profile Preferred Bit 2 */
+   DSL_uint16_t profilePref2 : 1;
+   /** 8d, Profile Preferred Bit 3 */
+   DSL_uint16_t profilePref3 : 1;
+   /** 12a, Profile Preferred Bit 4 */
+   DSL_uint16_t profilePref4 : 1;
+   /** 12b, Profile Preferred Bit 5 */
+   DSL_uint16_t profilePref5 : 1;
+   /** 17a, Profile Preferred Bit 6 */
+   DSL_uint16_t profilePref6 : 1;
+   /** 30a, Profile Preferred Bit 7 */
+   DSL_uint16_t profilePref7 : 1;
+   /** 35b, Profile Preferred Bit 8 */
+   DSL_uint16_t profilePref8 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 7;
+   /** EU-32, Annex A US0 PSDs Supported Bit 0 */
+   DSL_uint16_t A_US0PsdSup0 : 1;
+   /** EU-36, Annex A US0 PSDs Supported Bit 1 */
+   DSL_uint16_t A_US0PsdSup1 : 1;
+   /** EU-40, Annex A US0 PSDs Supported Bit 2 */
+   DSL_uint16_t A_US0PsdSup2 : 1;
+   /** EU-44, Annex A US0 PSDs Supported Bit 3 */
+   DSL_uint16_t A_US0PsdSup3 : 1;
+   /** EU-48, Annex A US0 PSDs Supported Bit 4 */
+   DSL_uint16_t A_US0PsdSup4 : 1;
+   /** EU-52, Annex A US0 PSDs Supported Bit 5 */
+   DSL_uint16_t A_US0PsdSup5 : 1;
+   /** EU-56, Annex A US0 PSDs Supported Bit 6 */
+   DSL_uint16_t A_US0PsdSup6 : 1;
+   /** EU-60, Annex A US0 PSDs Supported Bit 7 */
+   DSL_uint16_t A_US0PsdSup7 : 1;
+   /** EU-64, Annex A US0 PSDs Supported Bit 8 */
+   DSL_uint16_t A_US0PsdSup8 : 1;
+   /** ADLU-32, Annex A US0 PSDs Supported Bit 9 */
+   DSL_uint16_t A_US0PsdSup9 : 1;
+   /** ADLU-36, Annex A US0 PSDs Supported Bit 10 */
+   DSL_uint16_t A_US0PsdSup10 : 1;
+   /** ADLU-40, Annex A US0 PSDs Supported Bit 11 */
+   DSL_uint16_t A_US0PsdSup11 : 1;
+   /** ADLU-44, Annex A US0 PSDs Supported Bit 12 */
+   DSL_uint16_t A_US0PsdSup12 : 1;
+   /** ADLU-48, Annex A US0 PSDs Supported Bit 13 */
+   DSL_uint16_t A_US0PsdSup13 : 1;
+   /** ADLU-52, Annex A US0 PSDs Supported Bit 14 */
+   DSL_uint16_t A_US0PsdSup14 : 1;
+   /** ADLU-56, Annex A US0 PSDs Supported Bit 15 */
+   DSL_uint16_t A_US0PsdSup15 : 1;
+   /** ADLU-60, Annex A US0 PSDs Supported Bit 16 */
+   DSL_uint16_t A_US0PsdSup16 : 1;
+   /** ADLU-64, Annex A US0 PSDs Supported Bit 17 */
+   DSL_uint16_t A_US0PsdSup17 : 1;
+   /** 12b Profile, Annex A US0 PSDs Supported Bit 18 */
+   DSL_uint16_t A_US0PsdSup18 : 1;
+   /** 17a Profile, Annex A US0 PSDs Supported Bit 19 */
+   DSL_uint16_t A_US0PsdSup19 : 1;
+   /** EU-128, Annex A US0 PSDs Supported Bit 20 */
+   DSL_uint16_t A_US0PsdSup20 : 1;
+   /** ADLU-128, Annex A US0 PSDs Supported Bit 21 */
+   DSL_uint16_t A_US0PsdSup21 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 10;
+   /** Reserved */
+   DSL_uint16_t Res3[2];
+   /** US0 In 25 to 138 kHz, Annex B US0 PSDs Supported Bit 0 */
+   DSL_uint16_t B_US0PsdSup0 : 1;
+   /** US0 In 25 to 276 kHz, Annex B US0 PSDs Supported Bit 1 */
+   DSL_uint16_t B_US0PsdSup1 : 1;
+   /** US0 In 120 to 276 kHz, Annex B US0 PSDs Supported Bit 2 */
+   DSL_uint16_t B_US0PsdSup2 : 1;
+   /** 12b Profile, Annex B US0 PSDs Supported Bit 3 */
+   DSL_uint16_t B_US0PsdSup3 : 1;
+   /** 17a Profile, Annex B US0 PSDs Supported Bit 4 */
+   DSL_uint16_t B_US0PsdSup4 : 1;
+   /** Reserved */
+   DSL_uint16_t Res4 : 11;
+   /** Reserved */
+   DSL_uint16_t Res5;
+   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Supported Bit 0 */
+   DSL_uint16_t C_US0PsdSup0 : 1;
+   /** US0 In 25 to 276kHz, Annex C US0 PSDs Supported Bit 1 */
+   DSL_uint16_t C_US0PsdSup1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res8 : 2;
+   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Supported Bit 4 */
+   DSL_uint16_t C_US0PsdSup4 : 1;
+   /** US0 In 25 to 276 kHz, Annex C US0 PSDs Supported Bit 5 */
+   DSL_uint16_t C_US0PsdSup5 : 1;
+   /** Reserved */
+   DSL_uint16_t Res7 : 6;
+   /** 12b Profile, Annex C US0 PSDs Supported Bit 12 */
+   DSL_uint16_t C_US0PsdSup12 : 1;
+   /** 17a Profile, Annex C US0 PSDs Supported Bit 13 */
+   DSL_uint16_t C_US0PsdSup13 : 1;
+   /** Reserved */
+   DSL_uint16_t Res6 : 2;
+   /** Reserved */
+   DSL_uint16_t Res9;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_HS_VDSL2ProfileControl.
+*/
+struct ACK_HS_VDSL2ProfileControl
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the VDSL2 far-end Standard Info (See G.994.1 Amendment 4 [10],
+   NPAR(3) coding).
+*/
+struct CMD_HS_StandardInfoFE_VDSL2Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t  Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t  Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the VDSL2 far-end info as requested by
+   CMD_HS_StandardInfoFE_VDSL2Get (see G.994.1 Amendment 4 [10], NPAR(3)
+   coding).
+*/
+struct ACK_HS_StandardInfoFE_VDSL2Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t  Length;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** Reserved */
+   DSL_uint16_t Res1 : 7;
+   /** 35b, Profile Support Bit 8 */
+   DSL_uint16_t profileSup8 : 1;
+   /** 30a, Profile Support Bit 7 */
+   DSL_uint16_t profileSup7 : 1;
+   /** 17a, Profile Support Bit 6 */
+   DSL_uint16_t profileSup6 : 1;
+   /** 12b, Profile Support Bit 5 */
+   DSL_uint16_t profileSup5 : 1;
+   /** 12a, Profile Support Bit 4 */
+   DSL_uint16_t profileSup4 : 1;
+   /** 8d, Profile Support Bit 3 */
+   DSL_uint16_t profileSup3 : 1;
+   /** 8c, Profile Support Bit 2 */
+   DSL_uint16_t profileSup2 : 1;
+   /** 8b, Profile Support Bit 1 */
+   DSL_uint16_t profileSup1 : 1;
+   /** 8a, Profile Support Bit 0 */
+   DSL_uint16_t profileSup0 : 1;
+   /** ADLU-56, Annex A US0 PSDs Supported Bit 15 */
+   DSL_uint16_t A_US0PsdSup15 : 1;
+   /** ADLU-52, Annex A US0 PSDs Supported Bit 14 */
+   DSL_uint16_t A_US0PsdSup14 : 1;
+   /** ADLU-48, Annex A US0 PSDs Supported Bit 13 */
+   DSL_uint16_t A_US0PsdSup13 : 1;
+   /** ADLU-44, Annex A US0 PSDs Supported Bit 12 */
+   DSL_uint16_t A_US0PsdSup12 : 1;
+   /** ADLU-40, Annex A US0 PSDs Supported Bit 11 */
+   DSL_uint16_t A_US0PsdSup11 : 1;
+   /** ADLU-36, Annex A US0 PSDs Supported Bit 10 */
+   DSL_uint16_t A_US0PsdSup10 : 1;
+   /** ADLU-32, Annex A US0 PSDs Supported Bit 9 */
+   DSL_uint16_t A_US0PsdSup9 : 1;
+   /** EU-64, Annex A US0 PSDs Supported Bit 8 */
+   DSL_uint16_t A_US0PsdSup8 : 1;
+   /** EU-60, Annex A US0 PSDs Supported Bit 7 */
+   DSL_uint16_t A_US0PsdSup7 : 1;
+   /** EU-56, Annex A US0 PSDs Supported Bit 6 */
+   DSL_uint16_t A_US0PsdSup6 : 1;
+   /** EU-52, Annex A US0 PSDs Supported Bit 5 */
+   DSL_uint16_t A_US0PsdSup5 : 1;
+   /** EU-48, Annex A US0 PSDs Supported Bit 4 */
+   DSL_uint16_t A_US0PsdSup4 : 1;
+   /** EU-44, Annex A US0 PSDs Supported Bit 3 */
+   DSL_uint16_t A_US0PsdSup3 : 1;
+   /** EU-40, Annex A US0 PSDs Supported Bit 2 */
+   DSL_uint16_t A_US0PsdSup2 : 1;
+   /** EU-36, Annex A US0 PSDs Supported Bit 1 */
+   DSL_uint16_t A_US0PsdSup1 : 1;
+   /** EU-32, Annex A US0 PSDs Supported Bit 0 */
+   DSL_uint16_t A_US0PsdSup0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 10;
+   /** ADLU-128 Annex A US0 PSDs Supported Bit 21 */
+   DSL_uint16_t A_US0PsdSup21 : 1;
+   /** EU-128, Annex A US0 PSDs Supported Bit 20 */
+   DSL_uint16_t A_US0PsdSup20 : 1;
+   /** 17a Profile, Annex A US0 PSDs Supported Bit 19 */
+   DSL_uint16_t A_US0PsdSup19 : 1;
+   /** 12b Profile, Annex A US0 PSDs Supported Bit 18 */
+   DSL_uint16_t A_US0PsdSup18 : 1;
+   /** ADLU-64, Annex A US0 PSDs Supported Bit 17 */
+   DSL_uint16_t A_US0PsdSup17 : 1;
+   /** ADLU-60, Annex A US0 PSDs Supported Bit 16 */
+   DSL_uint16_t A_US0PsdSup16 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 11;
+   /** 17a Profile, Annex B US0 PSDs Supported Bit 4 */
+   DSL_uint16_t B_US0PsdSup4 : 1;
+   /** 12b Profile, Annex B US0 PSDs Supported Bit 3 */
+   DSL_uint16_t B_US0PsdSup3 : 1;
+   /** US0 In 138 to 276 kHz, Annex B US0 PSDs Supported Bit 2 */
+   DSL_uint16_t B_US0PsdSup2 : 1;
+   /** US0 In 25 to 276 kHz, Annex B US0 PSDs Supported Bit 1 */
+   DSL_uint16_t B_US0PsdSup1 : 1;
+   /** US0 In 25 to 138 kHz, Annex B US0 PSDs Supported Bit 0 */
+   DSL_uint16_t B_US0PsdSup0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res4 : 2;
+   /** 17a Profile, Annex C US0 PSDs Supported Bit 13 */
+   DSL_uint16_t C_US0PsdSup13 : 1;
+   /** 12b Profile, Annex C US0 PSDs Supported Bit 12 */
+   DSL_uint16_t C_US0PsdSup12 : 1;
+   /** Reserved */
+   DSL_uint16_t Res5 : 6;
+   /** US0 In 25 to 276 kHz, Annex C US0 PSDs Supported Bit 5 */
+   DSL_uint16_t C_US0PsdSup5 : 1;
+   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Supported Bit 4 */
+   DSL_uint16_t C_US0PsdSup4 : 1;
+   /** Reserved */
+   DSL_uint16_t Res6 : 2;
+   /** US0 In 25 to 276kHz, Annex C US0 PSDs Supported Bit 1 */
+   DSL_uint16_t C_US0PsdSup1 : 1;
+   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Supported Bit 0 */
+   DSL_uint16_t C_US0PsdSup0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res7 : 7;
+   /** G.998.4 Anx D Supported Bit 8 (VDSL only) */
+   DSL_uint16_t RtxExtMemSup8 : 1;
+   /** Reserved */
+   DSL_uint16_t Res8 : 2;
+   /** O-P-VECTOR1 Flag Tones Only, Supported Bit 5 (VDSL only) */
+   DSL_uint16_t OpVect1FlagTonesSup5 : 1;
+   /** Extended O-P-VECTOR1, Supported Bit 4 (VDSL only) */
+   DSL_uint16_t ExtOpVect1Sup4 : 1;
+   /** Upstream FDPS, Supported Bit 3 (VDSL only) */
+   DSL_uint16_t FdpsUsSup3 : 1;
+   /** Pilot Sequence Length Multiple of 4, Supported Bit 2 (VDSL only) */
+   DSL_uint16_t PilotLen4xSup2 : 1;
+   /** Upstream Vectoring Supported Bit 1 (VDSL only) */
+   DSL_uint16_t VectUsSup1 : 1;
+   /** Downstream Vectoring Supported Bit 0 (VDSL only) */
+   DSL_uint16_t VectDsSup0 : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t  Length;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** 8a, Profile Support Bit 0 */
+   DSL_uint16_t profileSup0 : 1;
+   /** 8b, Profile Support Bit 1 */
+   DSL_uint16_t profileSup1 : 1;
+   /** 8c, Profile Support Bit 2 */
+   DSL_uint16_t profileSup2 : 1;
+   /** 8d, Profile Support Bit 3 */
+   DSL_uint16_t profileSup3 : 1;
+   /** 12a, Profile Support Bit 4 */
+   DSL_uint16_t profileSup4 : 1;
+   /** 12b, Profile Support Bit 5 */
+   DSL_uint16_t profileSup5 : 1;
+   /** 17a, Profile Support Bit 6 */
+   DSL_uint16_t profileSup6 : 1;
+   /** 30a, Profile Support Bit 7 */
+   DSL_uint16_t profileSup7 : 1;
+   /** 35b, Profile Support Bit 8 */
+   DSL_uint16_t profileSup8 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 7;
+   /** EU-32, Annex A US0 PSDs Supported Bit 0 */
+   DSL_uint16_t A_US0PsdSup0 : 1;
+   /** EU-36, Annex A US0 PSDs Supported Bit 1 */
+   DSL_uint16_t A_US0PsdSup1 : 1;
+   /** EU-40, Annex A US0 PSDs Supported Bit 2 */
+   DSL_uint16_t A_US0PsdSup2 : 1;
+   /** EU-44, Annex A US0 PSDs Supported Bit 3 */
+   DSL_uint16_t A_US0PsdSup3 : 1;
+   /** EU-48, Annex A US0 PSDs Supported Bit 4 */
+   DSL_uint16_t A_US0PsdSup4 : 1;
+   /** EU-52, Annex A US0 PSDs Supported Bit 5 */
+   DSL_uint16_t A_US0PsdSup5 : 1;
+   /** EU-56, Annex A US0 PSDs Supported Bit 6 */
+   DSL_uint16_t A_US0PsdSup6 : 1;
+   /** EU-60, Annex A US0 PSDs Supported Bit 7 */
+   DSL_uint16_t A_US0PsdSup7 : 1;
+   /** EU-64, Annex A US0 PSDs Supported Bit 8 */
+   DSL_uint16_t A_US0PsdSup8 : 1;
+   /** ADLU-32, Annex A US0 PSDs Supported Bit 9 */
+   DSL_uint16_t A_US0PsdSup9 : 1;
+   /** ADLU-36, Annex A US0 PSDs Supported Bit 10 */
+   DSL_uint16_t A_US0PsdSup10 : 1;
+   /** ADLU-40, Annex A US0 PSDs Supported Bit 11 */
+   DSL_uint16_t A_US0PsdSup11 : 1;
+   /** ADLU-44, Annex A US0 PSDs Supported Bit 12 */
+   DSL_uint16_t A_US0PsdSup12 : 1;
+   /** ADLU-48, Annex A US0 PSDs Supported Bit 13 */
+   DSL_uint16_t A_US0PsdSup13 : 1;
+   /** ADLU-52, Annex A US0 PSDs Supported Bit 14 */
+   DSL_uint16_t A_US0PsdSup14 : 1;
+   /** ADLU-56, Annex A US0 PSDs Supported Bit 15 */
+   DSL_uint16_t A_US0PsdSup15 : 1;
+   /** ADLU-60, Annex A US0 PSDs Supported Bit 16 */
+   DSL_uint16_t A_US0PsdSup16 : 1;
+   /** ADLU-64, Annex A US0 PSDs Supported Bit 17 */
+   DSL_uint16_t A_US0PsdSup17 : 1;
+   /** 12b Profile, Annex A US0 PSDs Supported Bit 18 */
+   DSL_uint16_t A_US0PsdSup18 : 1;
+   /** 17a Profile, Annex A US0 PSDs Supported Bit 19 */
+   DSL_uint16_t A_US0PsdSup19 : 1;
+   /** EU-128, Annex A US0 PSDs Supported Bit 20 */
+   DSL_uint16_t A_US0PsdSup20 : 1;
+   /** ADLU-128 Annex A US0 PSDs Supported Bit 21 */
+   DSL_uint16_t A_US0PsdSup21 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 10;
+   /** US0 In 25 to 138 kHz, Annex B US0 PSDs Supported Bit 0 */
+   DSL_uint16_t B_US0PsdSup0 : 1;
+   /** US0 In 25 to 276 kHz, Annex B US0 PSDs Supported Bit 1 */
+   DSL_uint16_t B_US0PsdSup1 : 1;
+   /** US0 In 138 to 276 kHz, Annex B US0 PSDs Supported Bit 2 */
+   DSL_uint16_t B_US0PsdSup2 : 1;
+   /** 12b Profile, Annex B US0 PSDs Supported Bit 3 */
+   DSL_uint16_t B_US0PsdSup3 : 1;
+   /** 17a Profile, Annex B US0 PSDs Supported Bit 4 */
+   DSL_uint16_t B_US0PsdSup4 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 11;
+   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Supported Bit 0 */
+   DSL_uint16_t C_US0PsdSup0 : 1;
+   /** US0 In 25 to 276kHz, Annex C US0 PSDs Supported Bit 1 */
+   DSL_uint16_t C_US0PsdSup1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res6 : 2;
+   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Supported Bit 4 */
+   DSL_uint16_t C_US0PsdSup4 : 1;
+   /** US0 In 25 to 276 kHz, Annex C US0 PSDs Supported Bit 5 */
+   DSL_uint16_t C_US0PsdSup5 : 1;
+   /** Reserved */
+   DSL_uint16_t Res5 : 6;
+   /** 12b Profile, Annex C US0 PSDs Supported Bit 12 */
+   DSL_uint16_t C_US0PsdSup12 : 1;
+   /** 17a Profile, Annex C US0 PSDs Supported Bit 13 */
+   DSL_uint16_t C_US0PsdSup13 : 1;
+   /** Reserved */
+   DSL_uint16_t Res4 : 2;
+   /** Downstream Vectoring Supported Bit 0 (VDSL only) */
+   DSL_uint16_t VectDsSup0 : 1;
+   /** Upstream Vectoring Supported Bit 1 (VDSL only) */
+   DSL_uint16_t VectUsSup1 : 1;
+   /** Pilot Sequence Length Multiple of 4, Supported Bit 2 (VDSL only) */
+   DSL_uint16_t PilotLen4xSup2 : 1;
+   /** Upstream FDPS, Supported Bit 3 (VDSL only) */
+   DSL_uint16_t FdpsUsSup3 : 1;
+   /** Extended O-P-VECTOR1, Supported Bit 4 (VDSL only) */
+   DSL_uint16_t ExtOpVect1Sup4 : 1;
+   /** O-P-VECTOR1 Flag Tones Only, Supported Bit 5 (VDSL only) */
+   DSL_uint16_t OpVect1FlagTonesSup5 : 1;
+   /** Reserved */
+   DSL_uint16_t Res8 : 2;
+   /** G.998.4 Anx D Supported Bit 8 (VDSL only) */
+   DSL_uint16_t RtxExtMemSup8 : 1;
+   /** Reserved */
+   DSL_uint16_t Res7 : 7;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the actual selected VDSL2 Profile (See G.994.1 Amendment 4 [10],
+   NPAR(3) coding).
+*/
+struct CMD_HS_SelectedProfileVDSL2Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t  Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t  Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the actual selected VDSL2 Profile as requested by
+   CMD_HS_SelectedProfileVDSL2Get (see G.994.1 Amendment 4 [10], NPAR(3)
+   coding).
+*/
+struct ACK_HS_SelectedProfileVDSL2Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t  Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 4;
+   /** O-P-VECTOR1 Flag Tones Only, Selected Bit 11 */
+   DSL_uint16_t dsmSel11 : 1;
+   /** Extended O-P-VECTOR1,Selected Bit 10 */
+   DSL_uint16_t dsmSel10 : 1;
+   /** Upstream FDPS, Selected Bit 9 */
+   DSL_uint16_t dsmSel9 : 1;
+   /** Pilot Sequence Length Multiple of 4, Selected Bit 8 */
+   DSL_uint16_t dsmSel8 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 4;
+   /** G.993.2 Annex X, Selected Bit 3 */
+   DSL_uint16_t dsmSel3 : 1;
+   /** G.993.2 Annex Y, Selected Bit 2 */
+   DSL_uint16_t dsmSel2 : 1;
+   /** G.993.5 DS Vectoring, Selected Bit 1 */
+   DSL_uint16_t dsmSel1 : 1;
+   /** G.993.5 DS+US Vectoring, Selected Bit 0 */
+   DSL_uint16_t dsmSel0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 7;
+   /** 35b, Profile Selected Bit 8 */
+   DSL_uint16_t profileSel8 : 1;
+   /** 30a, Profile Selected Bit 7 */
+   DSL_uint16_t profileSel7 : 1;
+   /** 17a, Profile Selected Bit 6 */
+   DSL_uint16_t profileSel6 : 1;
+   /** 12b, Profile Selected Bit 5 */
+   DSL_uint16_t profileSel5 : 1;
+   /** 12a, Profile Selected Bit 4 */
+   DSL_uint16_t profileSel4 : 1;
+   /** 8d, Profile Selected Bit 3 */
+   DSL_uint16_t profileSel3 : 1;
+   /** 8c, Profile Selected Bit 2 */
+   DSL_uint16_t profileSel2 : 1;
+   /** 8b, Profile Selected Bit 1 */
+   DSL_uint16_t profileSel1 : 1;
+   /** 8a, Profile Selected Bit 0 */
+   DSL_uint16_t profileSel0 : 1;
+   /** ADLU-56, Annex A US0 PSDs Selected Bit  15 */
+   DSL_uint16_t A_US0PsdSel15 : 1;
+   /** ADLU-52, Annex A US0 PSDs Selected Bit  14 */
+   DSL_uint16_t A_US0PsdSel14 : 1;
+   /** ADLU-48, Annex A US0 PSDs Selected Bit  13 */
+   DSL_uint16_t A_US0PsdSel13 : 1;
+   /** ADLU-44, Annex A US0 PSDs Selected Bit  12 */
+   DSL_uint16_t A_US0PsdSel12 : 1;
+   /** ADLU-40, Annex A US0 PSDs Selected Bit  11 */
+   DSL_uint16_t A_US0PsdSel11 : 1;
+   /** ADLU-36, Annex A US0 PSDs Selected Bit  10 */
+   DSL_uint16_t A_US0PsdSel10 : 1;
+   /** ADLU-32, Annex A US0 PSDs Selected Bit  9 */
+   DSL_uint16_t A_US0PsdSel9 : 1;
+   /** EU-64, Annex A US0 PSDs Selected Bit  8 */
+   DSL_uint16_t A_US0PsdSel8 : 1;
+   /** EU-60, Annex A US0 PSDs Selected Bit  7 */
+   DSL_uint16_t A_US0PsdSel7 : 1;
+   /** EU-56, Annex A US0 PSDs Selected Bit  6 */
+   DSL_uint16_t A_US0PsdSel6 : 1;
+   /** EU-52, Annex A US0 PSDs Selected Bit  5 */
+   DSL_uint16_t A_US0PsdSel5 : 1;
+   /** EU-48, Annex A US0 PSDs Selected Bit  4 */
+   DSL_uint16_t A_US0PsdSel4 : 1;
+   /** EU-44, Annex A US0 PSDs Selected Bit  3 */
+   DSL_uint16_t A_US0PsdSel3 : 1;
+   /** EU-40, Annex A US0 PSDs Selected Bit  2 */
+   DSL_uint16_t A_US0PsdSel2 : 1;
+   /** EU-36, Annex A US0 PSDs Selected Bit  1 */
+   DSL_uint16_t A_US0PsdSel1 : 1;
+   /** EU-32, Annex A US0 PSDs Selected Bit  0 */
+   DSL_uint16_t A_US0PsdSel0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 10;
+   /** ADLU-128 Annex A US0 PSDs Selected Bit 21 */
+   DSL_uint16_t A_US0PsdSel21 : 1;
+   /** EU-128, Annex A US0 PSDs Selected Bit 20 */
+   DSL_uint16_t A_US0PsdSel20 : 1;
+   /** Reserved */
+   DSL_uint16_t Res4 : 2;
+   /** ADLU-64, Annex A US0 PSDs Selected Bit 17 */
+   DSL_uint16_t A_US0PsdSel17 : 1;
+   /** ADLU-60, Annex A US0 PSDs Selected Bit 16 */
+   DSL_uint16_t A_US0PsdSel16 : 1;
+   /** Reserved */
+   DSL_uint16_t Res5 : 13;
+   /** US0 In 120 to 276 kHz, Annex B US0 PSDs Selected Bit 2 */
+   DSL_uint16_t B_US0PsdSel2 : 1;
+   /** US0 In 25 to 276 kHz, Annex B US0 PSDs Selected Bit 1 */
+   DSL_uint16_t B_US0PsdSel1 : 1;
+   /** US0 In 25 to 138 kHz, Annex B US0 PSDs Selected Bit 0 */
+   DSL_uint16_t B_US0PsdSel0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res6 : 10;
+   /** US0 In 25 to 276 kHz, Annex C US0 PSDs Selected Bit 5 */
+   DSL_uint16_t C_US0PsdSel5 : 1;
+   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Selected Bit 4 */
+   DSL_uint16_t C_US0PsdSel4 : 1;
+   /** Reserved */
+   DSL_uint16_t Res7 : 2;
+   /** US0 In 25 to 276kHz, Annex C US0 PSDs Selected Bit 1 */
+   DSL_uint16_t C_US0PsdSel1 : 1;
+   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Selected Bit 0 */
+   DSL_uint16_t C_US0PsdSel0 : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t  Length;
+   /** G.993.5 DS+US Vectoring, Selected Bit 0 */
+   DSL_uint16_t dsmSel0 : 1;
+   /** G.993.5 DS Vectoring, Selected Bit 1 */
+   DSL_uint16_t dsmSel1 : 1;
+   /** G.993.2 Annex Y, Selected Bit 2 */
+   DSL_uint16_t dsmSel2 : 1;
+   /** G.993.2 Annex X, Selected Bit 3 */
+   DSL_uint16_t dsmSel3 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 4;
+   /** Pilot Sequence Length Multiple of 4, Selected Bit 8 */
+   DSL_uint16_t dsmSel8 : 1;
+   /** Upstream FDPS, Selected Bit 9 */
+   DSL_uint16_t dsmSel9 : 1;
+   /** Extended O-P-VECTOR1,Selected Bit 10 */
+   DSL_uint16_t dsmSel10 : 1;
+   /** O-P-VECTOR1 Flag Tones Only, Selected Bit 11 */
+   DSL_uint16_t dsmSel11 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 4;
+   /** 8a, Profile Selected Bit 0 */
+   DSL_uint16_t profileSel0 : 1;
+   /** 8b, Profile Selected Bit 1 */
+   DSL_uint16_t profileSel1 : 1;
+   /** 8c, Profile Selected Bit 2 */
+   DSL_uint16_t profileSel2 : 1;
+   /** 8d, Profile Selected Bit 3 */
+   DSL_uint16_t profileSel3 : 1;
+   /** 12a, Profile Selected Bit 4 */
+   DSL_uint16_t profileSel4 : 1;
+   /** 12b, Profile Selected Bit 5 */
+   DSL_uint16_t profileSel5 : 1;
+   /** 17a, Profile Selected Bit 6 */
+   DSL_uint16_t profileSel6 : 1;
+   /** 30a, Profile Selected Bit 7 */
+   DSL_uint16_t profileSel7 : 1;
+   /** 35b, Profile Selected Bit 8 */
+   DSL_uint16_t profileSel8 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 7;
+   /** EU-32, Annex A US0 PSDs Selected Bit  0 */
+   DSL_uint16_t A_US0PsdSel0 : 1;
+   /** EU-36, Annex A US0 PSDs Selected Bit  1 */
+   DSL_uint16_t A_US0PsdSel1 : 1;
+   /** EU-40, Annex A US0 PSDs Selected Bit  2 */
+   DSL_uint16_t A_US0PsdSel2 : 1;
+   /** EU-44, Annex A US0 PSDs Selected Bit  3 */
+   DSL_uint16_t A_US0PsdSel3 : 1;
+   /** EU-48, Annex A US0 PSDs Selected Bit  4 */
+   DSL_uint16_t A_US0PsdSel4 : 1;
+   /** EU-52, Annex A US0 PSDs Selected Bit  5 */
+   DSL_uint16_t A_US0PsdSel5 : 1;
+   /** EU-56, Annex A US0 PSDs Selected Bit  6 */
+   DSL_uint16_t A_US0PsdSel6 : 1;
+   /** EU-60, Annex A US0 PSDs Selected Bit  7 */
+   DSL_uint16_t A_US0PsdSel7 : 1;
+   /** EU-64, Annex A US0 PSDs Selected Bit  8 */
+   DSL_uint16_t A_US0PsdSel8 : 1;
+   /** ADLU-32, Annex A US0 PSDs Selected Bit  9 */
+   DSL_uint16_t A_US0PsdSel9 : 1;
+   /** ADLU-36, Annex A US0 PSDs Selected Bit  10 */
+   DSL_uint16_t A_US0PsdSel10 : 1;
+   /** ADLU-40, Annex A US0 PSDs Selected Bit  11 */
+   DSL_uint16_t A_US0PsdSel11 : 1;
+   /** ADLU-44, Annex A US0 PSDs Selected Bit  12 */
+   DSL_uint16_t A_US0PsdSel12 : 1;
+   /** ADLU-48, Annex A US0 PSDs Selected Bit  13 */
+   DSL_uint16_t A_US0PsdSel13 : 1;
+   /** ADLU-52, Annex A US0 PSDs Selected Bit  14 */
+   DSL_uint16_t A_US0PsdSel14 : 1;
+   /** ADLU-56, Annex A US0 PSDs Selected Bit  15 */
+   DSL_uint16_t A_US0PsdSel15 : 1;
+   /** ADLU-60, Annex A US0 PSDs Selected Bit 16 */
+   DSL_uint16_t A_US0PsdSel16 : 1;
+   /** ADLU-64, Annex A US0 PSDs Selected Bit 17 */
+   DSL_uint16_t A_US0PsdSel17 : 1;
+   /** Reserved */
+   DSL_uint16_t Res4 : 2;
+   /** EU-128, Annex A US0 PSDs Selected Bit 20 */
+   DSL_uint16_t A_US0PsdSel20 : 1;
+   /** ADLU-128 Annex A US0 PSDs Selected Bit 21 */
+   DSL_uint16_t A_US0PsdSel21 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 10;
+   /** US0 In 25 to 138 kHz, Annex B US0 PSDs Selected Bit 0 */
+   DSL_uint16_t B_US0PsdSel0 : 1;
+   /** US0 In 25 to 276 kHz, Annex B US0 PSDs Selected Bit 1 */
+   DSL_uint16_t B_US0PsdSel1 : 1;
+   /** US0 In 120 to 276 kHz, Annex B US0 PSDs Selected Bit 2 */
+   DSL_uint16_t B_US0PsdSel2 : 1;
+   /** Reserved */
+   DSL_uint16_t Res5 : 13;
+   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Selected Bit 0 */
+   DSL_uint16_t C_US0PsdSel0 : 1;
+   /** US0 In 25 to 276kHz, Annex C US0 PSDs Selected Bit 1 */
+   DSL_uint16_t C_US0PsdSel1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res7 : 2;
+   /** US0 In 25 to 138 kHz, Annex C US0 PSDs Selected Bit 4 */
+   DSL_uint16_t C_US0PsdSel4 : 1;
+   /** US0 In 25 to 276 kHz, Annex C US0 PSDs Selected Bit 5 */
+   DSL_uint16_t C_US0PsdSel5 : 1;
+   /** Reserved */
+   DSL_uint16_t Res6 : 10;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the handshake information about the far-end operating mode (See
+   G.994.1 [6] and Amendments 1-4 [7]-[10], standard information fields- SPAR(1)
+   coding).
+*/
+struct CMD_HS_StandardInfoFE_SPAR1Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t  Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t  Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the handshake information about the far-end operating mode (See
+   G.994.1 [6] and Amendments 1-4 [7]-[10], Standard information field - SPAR(1)
+   coding). The bit numbering per octet below follows the standard (starting
+   with "1").
+*/
+struct ACK_HS_StandardInfoFE_SPAR1Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t  Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 1;
+   /** Octet 2, Bit 7: Committee T1 enhanced SHDSL */
+   DSL_uint16_t Oct2B7 : 1;
+   /** Octet 2, Bit 6: ETSI SCM VDSL */
+   DSL_uint16_t Oct2B6 : 1;
+   /** Octet 2, Bit 5: ETSI MCM VDSL */
+   DSL_uint16_t Oct2B5 : 1;
+   /** Octet 2, Bit 4: T1E1 Trial-use SCM VDSL */
+   DSL_uint16_t Oct2B4 : 1;
+   /** Octet 2, Bit 3: T1E1 Trial-use MCM VDSL */
+   DSL_uint16_t Oct2B3 : 1;
+   /** Octet 2, Bit 2: G991.2 Annex B/G */
+   DSL_uint16_t Oct2B2 : 1;
+   /** Octet 2, Bit 1: G991.2 Annex A/F */
+   DSL_uint16_t Oct2B1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 1;
+   /** Octet 1, Bit 7: G992.1 Annex I */
+   DSL_uint16_t Oct1B7 : 1;
+   /** Octet 1, Bit 6: G992.1 Annex H */
+   DSL_uint16_t Oct1B6 : 1;
+   /** Octet 1, Bit 5: G992.2 Annex C */
+   DSL_uint16_t Oct1B5 : 1;
+   /** Octet 1, Bit 4: G992.2 Annex A/B */
+   DSL_uint16_t Oct1B4 : 1;
+   /** Octet 1, Bit 3: G992.1 Annex C */
+   DSL_uint16_t Oct1B3 : 1;
+   /** Octet 1, Bit 2: G992.1 Annex B */
+   DSL_uint16_t Oct1B2 : 1;
+   /** Octet 1, Bit 1: G992.1 Annex A */
+   DSL_uint16_t Oct1B1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 1;
+   /** Octet 4, Bit 7: IEEE 802.3ah 2BASE-TS */
+   DSL_uint16_t Oct4B7 : 1;
+   /** Octet 4, Bit 6: IEEE 802.3ah 2BASE-TL */
+   DSL_uint16_t Oct4B6 : 1;
+   /** Octet 4, Bit 5: G992.5 Annex J */
+   DSL_uint16_t Oct4B5 : 1;
+   /** Octet 4, Bit 4: G992.3 Annex M */
+   DSL_uint16_t Oct4B4 : 1;
+   /** Octet 4, Bit 3: G992.5 Annex I */
+   DSL_uint16_t Oct4B3 : 1;
+   /** Octet 4, Bit 2: G992.5 Annex B */
+   DSL_uint16_t Oct4B2 : 1;
+   /** Octet 4, Bit 1: G992.5 Annex A */
+   DSL_uint16_t Oct4B1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 1;
+   /** Octet 3, Bit 7: G992.3 Annex C */
+   DSL_uint16_t Oct3B7 : 1;
+   /** Octet 3, Bit 6: G992.4 Annex I */
+   DSL_uint16_t Oct3B6 : 1;
+   /** Octet 3, Bit 5: G992.4 Annex A */
+   DSL_uint16_t Oct3B5 : 1;
+   /** Octet 3, Bit 4: G992.3 Annex J */
+   DSL_uint16_t Oct3B4 : 1;
+   /** Octet 3, Bit 3: G992.3 Annex I */
+   DSL_uint16_t Oct3B3 : 1;
+   /** Octet 3, Bit 2: G992.3 Annex B */
+   DSL_uint16_t Oct3B2 : 1;
+   /** Octet 3, Bit 1: G992.3 Annex A/L */
+   DSL_uint16_t Oct3B1 : 1;
+   /** Reserved */
+   DSL_uint8_t Res4;
+   /** Reserved */
+   DSL_uint16_t Res5 : 1;
+   /** Octet 5, Bit 6: G.FAST */
+   DSL_uint16_t Oct5B7 : 1;
+   /** Octet 5, Bit 5: G993.2 */
+   DSL_uint16_t Oct5B6 : 1;
+   /** Octet 5, Bit 4: G992.5 Annex C */
+   DSL_uint16_t Oct5B5 : 1;
+   /** Octet 5, Bit 3: Variable Silence Period */
+   DSL_uint16_t Oct5B4 : 1;
+   /** Octet 5, Bit 2: G992.1 Annex I / T1E1 TRQ 12 */
+   DSL_uint16_t Oct5B3 : 1;
+   /** Octet 5, Bit 1: G993.1 / ANSI T1.424 */
+   DSL_uint16_t Oct5B2 : 1;
+   /** Octet 5, Bit 0: G992.5 Annex M */
+   DSL_uint16_t Oct5B1 : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t  Length;
+   /** Octet 1, Bit 1: G992.1 Annex A */
+   DSL_uint16_t Oct1B1 : 1;
+   /** Octet 1, Bit 2: G992.1 Annex B */
+   DSL_uint16_t Oct1B2 : 1;
+   /** Octet 1, Bit 3: G992.1 Annex C */
+   DSL_uint16_t Oct1B3 : 1;
+   /** Octet 1, Bit 4: G992.2 Annex A/B */
+   DSL_uint16_t Oct1B4 : 1;
+   /** Octet 1, Bit 5: G992.2 Annex C */
+   DSL_uint16_t Oct1B5 : 1;
+   /** Octet 1, Bit 6: G992.1 Annex H */
+   DSL_uint16_t Oct1B6 : 1;
+   /** Octet 1, Bit 7: G992.1 Annex I */
+   DSL_uint16_t Oct1B7 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 1;
+   /** Octet 2, Bit 1: G991.2 Annex A/F */
+   DSL_uint16_t Oct2B1 : 1;
+   /** Octet 2, Bit 2: G991.2 Annex B/G */
+   DSL_uint16_t Oct2B2 : 1;
+   /** Octet 2, Bit 3: T1E1 Trial-use MCM VDSL */
+   DSL_uint16_t Oct2B3 : 1;
+   /** Octet 2, Bit 4: T1E1 Trial-use SCM VDSL */
+   DSL_uint16_t Oct2B4 : 1;
+   /** Octet 2, Bit 5: ETSI MCM VDSL */
+   DSL_uint16_t Oct2B5 : 1;
+   /** Octet 2, Bit 6: ETSI SCM VDSL */
+   DSL_uint16_t Oct2B6 : 1;
+   /** Octet 2, Bit 7: Committee T1 enhanced SHDSL */
+   DSL_uint16_t Oct2B7 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 1;
+   /** Octet 3, Bit 1: G992.3 Annex A/L */
+   DSL_uint16_t Oct3B1 : 1;
+   /** Octet 3, Bit 2: G992.3 Annex B */
+   DSL_uint16_t Oct3B2 : 1;
+   /** Octet 3, Bit 3: G992.3 Annex I */
+   DSL_uint16_t Oct3B3 : 1;
+   /** Octet 3, Bit 4: G992.3 Annex J */
+   DSL_uint16_t Oct3B4 : 1;
+   /** Octet 3, Bit 5: G992.4 Annex A */
+   DSL_uint16_t Oct3B5 : 1;
+   /** Octet 3, Bit 6: G992.4 Annex I */
+   DSL_uint16_t Oct3B6 : 1;
+   /** Octet 3, Bit 7: G992.3 Annex C */
+   DSL_uint16_t Oct3B7 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 1;
+   /** Octet 4, Bit 1: G992.5 Annex A */
+   DSL_uint16_t Oct4B1 : 1;
+   /** Octet 4, Bit 2: G992.5 Annex B */
+   DSL_uint16_t Oct4B2 : 1;
+   /** Octet 4, Bit 3: G992.5 Annex I */
+   DSL_uint16_t Oct4B3 : 1;
+   /** Octet 4, Bit 4: G992.3 Annex M */
+   DSL_uint16_t Oct4B4 : 1;
+   /** Octet 4, Bit 5: G992.5 Annex J */
+   DSL_uint16_t Oct4B5 : 1;
+   /** Octet 4, Bit 6: IEEE 802.3ah 2BASE-TL */
+   DSL_uint16_t Oct4B6 : 1;
+   /** Octet 4, Bit 7: IEEE 802.3ah 2BASE-TS */
+   DSL_uint16_t Oct4B7 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 1;
+   /** Octet 5, Bit 0: G992.5 Annex M */
+   DSL_uint16_t Oct5B1 : 1;
+   /** Octet 5, Bit 1: G993.1 / ANSI T1.424 */
+   DSL_uint16_t Oct5B2 : 1;
+   /** Octet 5, Bit 2: G992.1 Annex I / T1E1 TRQ 12 */
+   DSL_uint16_t Oct5B3 : 1;
+   /** Octet 5, Bit 3: Variable Silence Period */
+   DSL_uint16_t Oct5B4 : 1;
+   /** Octet 5, Bit 4: G992.5 Annex C */
+   DSL_uint16_t Oct5B5 : 1;
+   /** Octet 5, Bit 5: G993.2 */
+   DSL_uint16_t Oct5B6 : 1;
+   /** Octet 5, Bit 6: G.FAST */
+   DSL_uint16_t Oct5B7 : 1;
+   /** Reserved */
+   DSL_uint16_t Res5 : 1;
+   /** Reserved */
+   DSL_uint8_t Res4;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Sets the in System Vendor ID at the xTU-R. (Section 7.4.4 of G.997.1 [11])
+*/
+struct CMD_SysVendorID_R_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-R System Vendor ID */
+   DSL_uint16_t sysVendorID[4];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-R System Vendor ID */
+   DSL_uint16_t sysVendorID[4];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_SysVendorID_R_Set.
+*/
+struct ACK_SysVendorID_R_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Sets the system vendor version number at the xTU-R. (Section 7.4.6 of G.997.1
+   [11])
+*/
+struct CMD_SysVendorVersionNum_R_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-R System Vendor Version Number */
+   DSL_uint16_t versionNum[8];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-R System Vendor Version Number */
+   DSL_uint16_t versionNum[8];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_SysVendorVersionNum_R_Set.
+*/
+struct ACK_SysVendorVersionNum_R_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Sets the system vendor serial number at the xTU-R. (Section 7.4.8 of G.997.1
+   [11])
+*/
+struct CMD_SysVendorSerialNum_R_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-R System Vendor Serial Number */
+   DSL_uint16_t serialNum[16];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-R System Vendor Serial Number */
+   DSL_uint16_t serialNum[16];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_SysVendorSerialNum_R_Set.
+*/
+struct ACK_SysVendorSerialNum_R_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Sets auxiliary inventory information at the VTU-R (Section 11.2.3.2.4 of
+   G993.2 [5]).
+*/
+struct CMD_AuxInventoryInfo_R_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** VTU-R Auxiliary Inventory Information */
+   DSL_uint16_t auxInfo[32];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** VTU-R Auxiliary Inventory Information */
+   DSL_uint16_t auxInfo[32];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_AuxInventoryInfo_R_Set.
+*/
+struct ACK_AuxInventoryInfo_R_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the xTU-C Vendor ID. (Section 7.4.1 of G.997.1 [11])
+*/
+struct CMD_VendorID_O_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the xTU-C Vendor ID as requested by CMD_VendorID_O_Get.
+*/
+struct ACK_VendorID_O_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-C G.994.1 Vendor ID */
+   DSL_uint16_t vendorID[4];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-C G.994.1 Vendor ID */
+   DSL_uint16_t vendorID[4];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the xTU-R Vendor ID. (Section 7.4.2 of G.997.1 [11])
+*/
+struct CMD_VendorID_R_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the xTU-R Vendor ID as requested by CMD_VendorID_R_Get.
+*/
+struct ACK_VendorID_R_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-R G.994.1 Vendor ID */
+   DSL_uint16_t vendorID[4];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-R G.994.1 Vendor ID */
+   DSL_uint16_t vendorID[4];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the xTU-C System Vendor ID. (Section 7.4.3 of G.997.1 [11])
+*/
+struct CMD_SysVendorID_O_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the xTU-C System Vendor ID as requested by CMD_SysVendorID_O_Get.
+*/
+struct ACK_SysVendorID_O_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-C System Vendor ID */
+   DSL_uint16_t sysVendorID[4];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-C System Vendor ID */
+   DSL_uint16_t sysVendorID[4];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the xTU-R System Vendor ID. (Section 7.4.4 of G.997.1 [11])
+*/
+struct CMD_SysVendorID_R_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the xTU-R System Vendor ID as requested by CMD_SysVendorID_R_Get.
+*/
+struct ACK_SysVendorID_R_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-R System Vendor ID */
+   DSL_uint16_t sysVendorID[4];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-R System Vendor ID */
+   DSL_uint16_t sysVendorID[4];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the xTU-C system vendor version number. (Section 7.4.5 of G.997.1
+   [11])
+*/
+struct CMD_SysVendorVersionNumO_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the xTU-C system vendor version number as requested by
+   CMD_SysVendorVersionNumO_Get.
+*/
+struct ACK_SysVendorVersionNum_O_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-C System Vendor Version Number */
+   DSL_uint16_t versionNum[8];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-C System Vendor Version Number */
+   DSL_uint16_t versionNum[8];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the xTU-R system vendor version number. (Section 7.4.6 of G.997.1
+   [11])
+*/
+struct CMD_SysVendorVersionNum_R_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the xTU-R system vendor version number as requested by
+   CMD_SysVendorVersionNum_R_Get.
+*/
+struct ACK_SysVendorVersionNum_R_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-R System Vendor Version Number */
+   DSL_uint16_t versionNum[8];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-R System Vendor Version Number */
+   DSL_uint16_t versionNum[8];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the xTU-C system vendor serial number. (Section 7.4.7 of G.997.1
+   [11])
+*/
+struct CMD_SysVendorSerialNum_O_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the xTU-C system vendor serial number as requested by
+   CMD_SysVendorSerialNum_O_Get.
+*/
+struct ACK_SysVendorSerialNum_O_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-C System Vendor Serial Number */
+   DSL_uint16_t serialNum[16];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-C System Vendor Serial Number */
+   DSL_uint16_t serialNum[16];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the xTU-R system vendor serial number. (Section 7.4.8 of G.997.1
+   [11])
+*/
+struct CMD_SysVendorSerialNum_R_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the xTU-R system vendor version number as requested by
+   CMD_SysVendorSerialNum_R_Get.
+*/
+struct ACK_SysVendorSerialNum_R_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-R System Vendor Serial Number */
+   DSL_uint16_t serialNum[16];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** xTU-R System Vendor Serial Number */
+   DSL_uint16_t serialNum[16];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests VTU-O auxiliary inventory information (Section 11.2.3.2.4 of G993.2
+   [5]).
+*/
+struct CMD_AuxInventoryInfo_O_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the VTU-O auxiliary inventory information as requested by
+   CMD_AuxInventoryInfo_O_Get.
+*/
+struct ACK_AuxInventoryInfo_O_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** VTU-O Auxiliary Inventory Information */
+   DSL_uint16_t auxInfo[32];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** VTU-O Auxiliary Inventory Information */
+   DSL_uint16_t auxInfo[32];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests VTU-R auxiliary inventory information (Section 11.2.3.2.4 of G993.2
+   [5]).
+*/
+struct CMD_AuxInventoryInfo_R_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the VTU-R auxiliary inventory information as requested by
+   CMD_AuxInventoryInfo_R_Get.
+*/
+struct ACK_AuxInventoryInfo_R_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** VTU-O Auxiliary Inventory Information */
+   DSL_uint16_t auxInfo[32];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** VTU-O Auxiliary Inventory Information */
+   DSL_uint16_t auxInfo[32];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the ATU-C's T1.413 Vendor identification. (Section 9.6.4.2 of ANSI
+   T1.413 [16])
+*/
+struct CMD_T1413_VendorID_O_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the ATU-C's T1.413 vendor identification number.
+*/
+struct ACK_T1413_VendorID_O_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** T1.413 Vendor ID */
+   DSL_uint16_t T1413VendorID;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** T1.413 Vendor ID */
+   DSL_uint16_t T1413VendorID;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the ATU-R's T1.413 Vendor identification. (Section 9.6.4.2 of ANSI
+   T1.413 [16])
+*/
+struct CMD_T1413_VendorID_R_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reports the ATU-R's T1.413 vendor identification number.
+*/
+struct ACK_T1413_VendorID_R_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** T1.413 Vendor ID */
+   DSL_uint16_t T1413VendorID;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** T1.413 Vendor ID */
+   DSL_uint16_t T1413VendorID;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the xTU-C's T1.413 revision number. (Section 9.6.4.3 of ANSI T1.413
+   [16])
+*/
+struct CMD_T1413_RevNo_O_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the xTU-C's T1.413 revision number.
+*/
+struct ACK_T1413_RevNo_O_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** T1.413 Revision Number */
+   DSL_uint16_t T1413RevNo;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** T1.413 Revision Number */
+   DSL_uint16_t T1413RevNo;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the xTU-R's T1.413 revision number. (Section 9.7.6.2 of ANSI T1.413
+   [16])
+*/
+struct CMD_T1413_RevNo_R_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the xTU-R's T1.413 revision number.
+*/
+struct ACK_T1413_RevNo_R_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** T1.413 Revision Number */
+   DSL_uint16_t T1413RevNo;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** T1.413 Revision Number */
+   DSL_uint16_t T1413RevNo;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the xTU-C's T1.413 vendor revision number. (Section 9.6.4.4 of ANSI
+   T1.413 [16])
+*/
+struct CMD_T1413_VendorRevNo_O_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the xTU-C's T1.413 vendor revision number.
+*/
+struct ACK_T1413_VendorRevNo_O_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** T1.413 Vendor Revision Number */
+   DSL_uint16_t T1413VendorRevNo;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** T1.413 Vendor Revision Number */
+   DSL_uint16_t T1413VendorRevNo;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the xTU-R's T1.413 vendor revision number. (Section 9.7.6.3 of ANSI
+   T1.413 [16])
+*/
+struct CMD_T1413_VendorRevNo_R_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the xTU-R's T1.413 vendor revision number.
+*/
+struct ACK_T1413_VendorRevNo_R_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** T1.413 Vendor Revision Number */
+   DSL_uint16_t T1413VendorRevNo;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** T1.413 Vendor Revision Number */
+   DSL_uint16_t T1413VendorRevNo;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the transmission system in use on the line (DSL flavour). (Section
+   7.5.1.1. of G.997.1 [11]) See note at ACK_XTSE_StatusGet about the expected
+   behaviour.
+*/
+struct CMD_XTSE_StatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reports the transmission system mode in use as requested by
+   CMD_XTSE_StatusGet.The information is set by the FW after mode select (MS)
+   during the handshake phase or during T1.413 state. Before mode selection the
+   value "0" is reported (=none), after selection of a common mode exactly this
+   single mode must be indicated. If there is a common mode but it requires
+   another FW to be loaded (e.g. ADSL instead of VDSL), this does not happen
+   ("0" is reported ), then the FW goes to FAIL state and indicates a specific
+   suberror code (S_XDSL_MODE). If there is no common mode, "0" is to be
+   reported (here modem enters FAIL state).
+*/
+struct ACK_XTSE_StatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** ADSL Mode-Bit15: G.992.5, Annex A */
+   DSL_uint16_t A15 : 1;
+   /** ADSL Mode-Bit14: G.992.5, Annex B */
+   DSL_uint16_t A14 : 1;
+   /** ADSL Mode-Bit13: G.992.3, Annex M */
+   DSL_uint16_t A13 : 1;
+   /** ADSL Mode-Bit12: G.992.3, Annex L, US Mask2 */
+   DSL_uint16_t A12 : 1;
+   /** ADSL Mode-Bit11: G.992.3, Annex L, US Mask1 */
+   DSL_uint16_t A11 : 1;
+   /** ADSL Mode-Bit10: G.992.2, Annex A */
+   DSL_uint16_t A10 : 1;
+   /** ADSL Mode-Bit9: G.992.3, Annex B */
+   DSL_uint16_t A9 : 1;
+   /** ADSL Mode-Bit8: G.992.3, Annex A */
+   DSL_uint16_t A8 : 1;
+   /** ADSL Mode-Bit7: G.992.5, Annex J */
+   DSL_uint16_t A7 : 1;
+   /** ADSL Mode-Bit6: G.992.5, Annex I */
+   DSL_uint16_t A6 : 1;
+   /** ADSL Mode-Bit5: G.992.3, Annex J */
+   DSL_uint16_t A5 : 1;
+   /** ADSL Mode-Bit4: G.992.3, Annex I */
+   DSL_uint16_t A4 : 1;
+   /** ADSL Mode-Bit3: G.992.1, Annex B */
+   DSL_uint16_t A3 : 1;
+   /** ADSL Mode-Bit2: G.992.1, Annex A */
+   DSL_uint16_t A2 : 1;
+   /** ADSL Mode-Bit1: G.992.5, Annex M */
+   DSL_uint16_t A1 : 1;
+   /** ADSL Mode-Bit0: T1.413 */
+   DSL_uint16_t A0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+   /** VDSL Mode-Bit2: VDSL2 */
+   DSL_uint16_t V2 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 2;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** ADSL Mode-Bit0: T1.413 */
+   DSL_uint16_t A0 : 1;
+   /** ADSL Mode-Bit1: G.992.5, Annex M */
+   DSL_uint16_t A1 : 1;
+   /** ADSL Mode-Bit2: G.992.1, Annex A */
+   DSL_uint16_t A2 : 1;
+   /** ADSL Mode-Bit3: G.992.1, Annex B */
+   DSL_uint16_t A3 : 1;
+   /** ADSL Mode-Bit4: G.992.3, Annex I */
+   DSL_uint16_t A4 : 1;
+   /** ADSL Mode-Bit5: G.992.3, Annex J */
+   DSL_uint16_t A5 : 1;
+   /** ADSL Mode-Bit6: G.992.5, Annex I */
+   DSL_uint16_t A6 : 1;
+   /** ADSL Mode-Bit7: G.992.5, Annex J */
+   DSL_uint16_t A7 : 1;
+   /** ADSL Mode-Bit8: G.992.3, Annex A */
+   DSL_uint16_t A8 : 1;
+   /** ADSL Mode-Bit9: G.992.3, Annex B */
+   DSL_uint16_t A9 : 1;
+   /** ADSL Mode-Bit10: G.992.2, Annex A */
+   DSL_uint16_t A10 : 1;
+   /** ADSL Mode-Bit11: G.992.3, Annex L, US Mask1 */
+   DSL_uint16_t A11 : 1;
+   /** ADSL Mode-Bit12: G.992.3, Annex L, US Mask2 */
+   DSL_uint16_t A12 : 1;
+   /** ADSL Mode-Bit13: G.992.3, Annex M */
+   DSL_uint16_t A13 : 1;
+   /** ADSL Mode-Bit14: G.992.5, Annex B */
+   DSL_uint16_t A14 : 1;
+   /** ADSL Mode-Bit15: G.992.5, Annex A */
+   DSL_uint16_t A15 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 2;
+   /** VDSL Mode-Bit2: VDSL2 */
+   DSL_uint16_t V2 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reads the used downstream band configuration.
+*/
+struct CMD_BandControl_DS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for message CMD_BandControl_DS_Get.
+*/
+struct ACK_BandControl_DS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint8_t Res0;
+   /** Number of Downstream Bands */
+   DSL_uint8_t NumBandsDS;
+   /** Band Descriptor DS */
+   VRX_ToneIndex_t band[8];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Number of Downstream Bands */
+   DSL_uint8_t NumBandsDS;
+   /** Reserved */
+   DSL_uint8_t Res0;
+   /** Band Descriptor DS */
+   VRX_ToneIndex_t band[8];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reads the used upstream band configuration.
+*/
+struct CMD_BandControl_US_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for message CMD_BandControl_US_Get.
+*/
+struct ACK_BandControl_US_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint8_t Res0;
+   /** Number of Upstream Bands */
+   DSL_uint8_t NumBandsUS;
+   /** Band Descriptor US */
+   VRX_ToneIndex_t band[8];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Number of Upstream Bands */
+   DSL_uint8_t NumBandsUS;
+   /** Reserved */
+   DSL_uint8_t Res0;
+   /** Band Descriptor US */
+   VRX_ToneIndex_t band[8];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reads the RFI band configuration.
+*/
+struct CMD_RFI_BandControlGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for message CMD_RFI_BandControlGet.
+*/
+struct ACK_RFI_BandControlGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint8_t Res0;
+   /** Number of RFI Bands */
+   DSL_uint8_t NumRfiBands;
+   /** RFI Band Descriptor */
+   VRX_ToneIndex_t RfiBand[16];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Number of RFI Bands */
+   DSL_uint8_t NumRfiBands;
+   /** Reserved */
+   DSL_uint8_t Res0;
+   /** RFI Band Descriptor */
+   VRX_ToneIndex_t RfiBand[16];
+#endif
+} __PACKED__ ;
+
+
+/**
+   This message requests data about the line status (like noise margin) for
+   downstream direction.
+*/
+struct CMD_LineStatusDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message delivers the line status data for downstream direction requested
+   by CMD_LineStatusDS_Get.
+*/
+struct ACK_LineStatusDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** Downstream LATN */
+   DSL_uint16_t LATNds;
+   /** Downstream SATN */
+   DSL_uint16_t SATNds;
+   /** Downstream SNRM */
+   DSL_uint16_t SNRMds;
+   /** Downstream ATTNDR, LSW */
+   DSL_uint16_t ATTNDRds_LSW;
+   /** Downstream ATTNDR, MSW */
+   DSL_uint16_t ATTNDRds_MSW;
+   /** Downstream ACTATP */
+   DSL_int16_t ACTATPds;
+   /** Downstream ACTPSD (ADSL only) */
+   DSL_uint16_t ACTPSDds;
+   /** Reserved */
+   DSL_uint16_t Res1 : 7;
+   /** Virtual Noise Status DS */
+   DSL_uint16_t VNstatus_ds : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 5;
+   /** ROC Status DS */
+   DSL_uint16_t ROCstatus_ds : 1;
+   /** NTR Status DS */
+   DSL_uint16_t NTRstatus_ds : 1;
+   /** TCM Status DS */
+   DSL_uint16_t TCMstatus_ds : 1;
+   /** Reserved */
+   DSL_uint16_t Res3;
+   /** Downstream SNRM-ROC (VDSL only) */
+   DSL_uint16_t SNRM_ROCds;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** Downstream LATN */
+   DSL_uint16_t LATNds;
+   /** Downstream SATN */
+   DSL_uint16_t SATNds;
+   /** Downstream SNRM */
+   DSL_uint16_t SNRMds;
+   /** Downstream ATTNDR, LSW */
+   DSL_uint16_t ATTNDRds_LSW;
+   /** Downstream ATTNDR, MSW */
+   DSL_uint16_t ATTNDRds_MSW;
+   /** Downstream ACTATP */
+   DSL_int16_t ACTATPds;
+   /** Downstream ACTPSD (ADSL only) */
+   DSL_uint16_t ACTPSDds;
+   /** TCM Status DS */
+   DSL_uint16_t TCMstatus_ds : 1;
+   /** NTR Status DS */
+   DSL_uint16_t NTRstatus_ds : 1;
+   /** ROC Status DS */
+   DSL_uint16_t ROCstatus_ds : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 5;
+   /** Virtual Noise Status DS */
+   DSL_uint16_t VNstatus_ds : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 7;
+   /** Reserved */
+   DSL_uint16_t Res3;
+   /** Downstream SNRM-ROC (VDSL only) */
+   DSL_uint16_t SNRM_ROCds;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This message requests data about the upstream line status (like noise
+   margin).
+*/
+struct CMD_LineStatusUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message delivers the line status data for upstream direction requested by
+   CMD_LineStatusUS_Get.
+*/
+struct ACK_LineStatusUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** Upstream LATN */
+   DSL_uint16_t LATNus;
+   /** Upstream SATN */
+   DSL_uint16_t SATNus;
+   /** Upstream SNRM */
+   DSL_uint16_t SNRMus;
+   /** Upstream ATTNDR, LSW */
+   DSL_uint16_t ATTNDRus_LSW;
+   /** Upstream ATTNDR, MSW */
+   DSL_uint16_t ATTNDRus_MSW;
+   /** Upstream ACTATP */
+   DSL_int16_t ACTATPus;
+   /** Upstream ACTPSD (ADSL only) */
+   DSL_uint16_t ACTPSDus;
+   /** Reserved */
+   DSL_uint16_t Res1 : 7;
+   /** Virtual Noise Status US */
+   DSL_uint16_t VNstatus_us : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 5;
+   /** ROC Status US */
+   DSL_uint16_t ROCstatus_us : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 1;
+   /** TCM Status US */
+   DSL_uint16_t TCMstatus_us : 1;
+   /** ERB BDR US */
+   DSL_uint16_t BDRus;
+   /** Upstream SNRM-ROC (VDSL only) */
+   DSL_uint16_t SNRM_ROCus;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** Upstream LATN */
+   DSL_uint16_t LATNus;
+   /** Upstream SATN */
+   DSL_uint16_t SATNus;
+   /** Upstream SNRM */
+   DSL_uint16_t SNRMus;
+   /** Upstream ATTNDR, LSW */
+   DSL_uint16_t ATTNDRus_LSW;
+   /** Upstream ATTNDR, MSW */
+   DSL_uint16_t ATTNDRus_MSW;
+   /** Upstream ACTATP */
+   DSL_int16_t ACTATPus;
+   /** Upstream ACTPSD (ADSL only) */
+   DSL_uint16_t ACTPSDus;
+   /** TCM Status US */
+   DSL_uint16_t TCMstatus_us : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 1;
+   /** ROC Status US */
+   DSL_uint16_t ROCstatus_us : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 5;
+   /** Virtual Noise Status US */
+   DSL_uint16_t VNstatus_us : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 7;
+   /** ERB BDR US */
+   DSL_uint16_t BDRus;
+   /** Upstream SNRM-ROC (VDSL only) */
+   DSL_uint16_t SNRM_ROCus;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This message requests data about the line status (noise margin, line
+   attenuation and signal attenuation) for downstream direction in a "per band"
+   granularity.
+*/
+struct CMD_LineStatusPerBandDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message delivers the line status data (line attenuation, signal
+   attenuation and noise margin) for downstream direction in a "per band"
+   granularity as requested by CMD_LineStatusPerBandDS_Get.
+*/
+struct ACK_LineStatusPerBandDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** Line Status Descriptor DS  */
+   VRX_LineStatus_pb_t LineStatus_pb_ds[8];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** Line Status Descriptor DS  */
+   VRX_LineStatus_pb_t LineStatus_pb_ds[8];
+#endif
+} __PACKED__ ;
+
+
+/**
+   This message requests data about the line status (noise margin, line - and
+   signal attenuation) for upstream direction in a "per band" granularity.
+*/
+struct CMD_LineStatusPerBandUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message delivers the line status data (line attenuation, signal
+   attenuation and noise margin) for upstream direction in a "per band"
+   granularity as requested by CMD_LineStatusPerBandUS_Get.
+*/
+struct ACK_LineStatusPerBandUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** Line Status Descriptor US  */
+   VRX_LineStatus_pb_t LineStatus_pb_us[8];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** Line Status Descriptor US  */
+   VRX_LineStatus_pb_t LineStatus_pb_us[8];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests parameters used for the calculation of the downstream attainable net
+   data rate (ATTNDRds).
+*/
+struct CMD_AttndrStatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the data requested by CMD_AttndrStatusGet.(Section 7.5.1.41 of
+   G.997.1 [12]).
+*/
+struct ACK_AttndrStatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** ATTNDR Actual Method (ATTNDR_ACTMETHOD). */
+   DSL_uint16_t AttndrActMethod;
+   /** ATTNDR Downstream Actual INP (ATTNDR_ACTINPds). */
+   DSL_uint16_t AttndrActInpDs;
+   /** ATTNDR DS Actual INP against REIN (ATTNDR_ACTINP_REINds). */
+   DSL_uint16_t AttndrActInpReinDs;
+   /** ATTNDR DS Actual Delay (ATTNDR_ACTDELAYds). */
+   DSL_uint16_t AttndrActDelayDs;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** ATTNDR Actual Method (ATTNDR_ACTMETHOD). */
+   DSL_uint16_t AttndrActMethod;
+   /** ATTNDR Downstream Actual INP (ATTNDR_ACTINPds). */
+   DSL_uint16_t AttndrActInpDs;
+   /** ATTNDR DS Actual INP against REIN (ATTNDR_ACTINP_REINds). */
+   DSL_uint16_t AttndrActInpReinDs;
+   /** ATTNDR DS Actual Delay (ATTNDR_ACTDELAYds). */
+   DSL_uint16_t AttndrActDelayDs;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the breakpoints of the actual PSD for the downstream direction. PSDs
+   consisting of more than 42 PSD breakpoints must be read with 2 messages due
+   to the the mailbox size. (The first parameter in the retrieved data structure
+   contains the "Number of Breakpoints" parameter.)
+*/
+struct CMD_PSD_BreakpointsDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the breakpoints of the actual PSD for the downstream direction as
+   requested by CMD_PSD_BreakpointsDS_Get.
+*/
+struct ACK_PSD_BreakpointsDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Data */
+   DSL_uint16_t Data[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Data */
+   DSL_uint16_t Data[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the breakpoints of the actual PSD for the upstream direction.
+*/
+struct CMD_PSD_BreakpointsUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the breakpoints of the actual PSD for the upstream direction as
+   requested by CMD_PSD_BreakpointsUS_Get.
+*/
+struct ACK_PSD_BreakpointsUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint8_t Res0;
+   /** Number of Breakpoints */
+   DSL_uint8_t NumBreakPts;
+   /** Breakpoint Descriptor US PSD */
+   VRX_PSDbreak_t breakpoint[32];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Number of Breakpoints */
+   DSL_uint8_t NumBreakPts;
+   /** Reserved */
+   DSL_uint8_t Res0;
+   /** Breakpoint Descriptor US PSD */
+   VRX_PSDbreak_t breakpoint[32];
+#endif
+} __PACKED__ ;
+
+
+/**
+   The Downstream TSSI Breakpoints are specified by the transmitter (VTU-O) and
+   communicated to the receiver (VTU-R) via the O-PRM message.   The TSSI
+   Breakpoints are used to shape the O-P-TEQ signal. This message provides read
+   only access to the DS TSSI Breakpoints. The DS TSSI Breakpoints are not
+   configurable via messages.
+*/
+struct CMD_TssiDS_VDSL2_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This is the acknowledgement of CMD_TssiDS_VDSL2_Get.
+*/
+struct ACK_TssiDS_VDSL2_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Data from the DS TSSI breakpoint buffer */
+   DSL_uint16_t Data[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Data from the DS TSSI breakpoint buffer */
+   DSL_uint16_t Data[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   The Upstream TSSI Breakpoints are specified by the transmitter (VTU-R) and
+   communicated to the receiver (VTU-O) via the R-PRM message.   The TSSI
+   Breakpoints are used to shape the R-P-TEQ signal.  The TSSI Breakpoints can
+   be read only but are not configurable via messages.
+*/
+struct CMD_TssiUS_VDSL2_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This is the acknowledgement of CMD_TssiUS_VDSL2_Get.
+*/
+struct ACK_TssiUS_VDSL2_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Data from the US TSSI breakpoint buffer */
+   DSL_uint16_t Data[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Data from the US TSSI breakpoint buffer */
+   DSL_uint16_t Data[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reads the actual power cutback value.
+*/
+struct CMD_ADSL_PCB_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the actual power cutback values requested with CMD_ADSL_PCB_Get.
+*/
+struct ACK_ADSL_PCB_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Downstream Power Cutback */
+   DSL_uint16_t dspcb;
+   /** Upstream Power Cutback */
+   DSL_uint16_t uspcb;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Downstream Power Cutback */
+   DSL_uint16_t dspcb;
+   /** Upstream Power Cutback */
+   DSL_uint16_t uspcb;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the PSD and power parameter values actually used by the firmware.
+*/
+struct CMD_ActualPSD_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides actually used PSD and power parameters as requested by
+   CMD_ActualPSD_Get.
+*/
+struct ACK_ActualPSD_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Power/PSD Configuration Parameter: MAXNOMPSDds */
+   DSL_uint16_t MAXNOMPSDds;
+   /** Power/PSD Configuration Parameter: MAXNOMPSDus */
+   DSL_uint16_t MAXNOMPSDus;
+   /** Power/PSD Configuration Parameter: MAXNOMATPds */
+   DSL_uint16_t MAXNOMATPds;
+   /** Power/PSD Configuration Parameters */
+   DSL_uint16_t MAXNOMATPus;
+   /** Reserved */
+   DSL_uint16_t Res0;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Power/PSD Configuration Parameter: MAXNOMPSDds */
+   DSL_uint16_t MAXNOMPSDds;
+   /** Power/PSD Configuration Parameter: MAXNOMPSDus */
+   DSL_uint16_t MAXNOMPSDus;
+   /** Power/PSD Configuration Parameter: MAXNOMATPds */
+   DSL_uint16_t MAXNOMATPds;
+   /** Power/PSD Configuration Parameters */
+   DSL_uint16_t MAXNOMATPus;
+   /** Reserved */
+   DSL_uint16_t Res0;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the actually used ADSL upstream mask for ADSL2/2+ Annexes M and J.
+   To be applied only in combination with G.992.3/5 Annex M support in
+   ACK_XTSE_StatusGet.
+*/
+struct CMD_ADSL_MJ_UsMaskGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the actually used ADSL upstream mask for ADSL2/2+ Annexes M and J.
+*/
+struct ACK_ADSL_MJ_UsMaskGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 7;
+   /** G.992.3/5 Annex M/J Upstream Mask 9 */
+   DSL_uint16_t mask9 : 1;
+   /** G.992.3/5 Annex M/J Upstream Mask 8 */
+   DSL_uint16_t mask8 : 1;
+   /** G.992.3/5 Annex M/J Upstream Mask 7 */
+   DSL_uint16_t mask7 : 1;
+   /** G.992.3/5 Annex M/J Upstream Mask 6 */
+   DSL_uint16_t mask6 : 1;
+   /** G.992.3/5 Annex M/J Upstream Mask 5 */
+   DSL_uint16_t mask5 : 1;
+   /** G.992.3/5 Annex M/J Upstream Mask 4 */
+   DSL_uint16_t mask4 : 1;
+   /** G.992.3/5 Annex M/J Upstream Mask 3 */
+   DSL_uint16_t mask3 : 1;
+   /** G.992.3/5 Annex M/J Upstream Mask 2 */
+   DSL_uint16_t mask2 : 1;
+   /** G.992.3/5 Annex M/J Upstream Mask 1 */
+   DSL_uint16_t mask1 : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** G.992.3/5 Annex M/J Upstream Mask 1 */
+   DSL_uint16_t mask1 : 1;
+   /** G.992.3/5 Annex M/J Upstream Mask 2 */
+   DSL_uint16_t mask2 : 1;
+   /** G.992.3/5 Annex M/J Upstream Mask 3 */
+   DSL_uint16_t mask3 : 1;
+   /** G.992.3/5 Annex M/J Upstream Mask 4 */
+   DSL_uint16_t mask4 : 1;
+   /** G.992.3/5 Annex M/J Upstream Mask 5 */
+   DSL_uint16_t mask5 : 1;
+   /** G.992.3/5 Annex M/J Upstream Mask 6 */
+   DSL_uint16_t mask6 : 1;
+   /** G.992.3/5 Annex M/J Upstream Mask 7 */
+   DSL_uint16_t mask7 : 1;
+   /** G.992.3/5 Annex M/J Upstream Mask 8 */
+   DSL_uint16_t mask8 : 1;
+   /** G.992.3/5 Annex M/J Upstream Mask 9 */
+   DSL_uint16_t mask9 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 7;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reports the downstream transmit PSD mask (PSDMASKds) which is received from
+   CO with O-SIGNATURE message.
+*/
+struct CMD_PSDMASK_DS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reports the downstream transmit PSD mask (PSDMASKds) for both passbands and
+   stopbands, which is received from CO with O-SIGNATURE message. (Format is now
+   as absolute value without the offset.)
+*/
+struct ACK_PSDMASK_DS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Number of Breakpoints */
+   DSL_uint16_t NumBreakPts;
+   /** PSDMASKds Data */
+   VRX_PSDbreak2_t PSDMASK[48];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Number of Breakpoints */
+   DSL_uint16_t NumBreakPts;
+   /** PSDMASKds Data */
+   VRX_PSDbreak2_t PSDMASK[48];
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message requests information about the receive PSD per subcarrier
+   available at the near-end side, which means for downstream direction at the
+   CPE. It is the hosts responsibility to select the tone indices accordingly.In
+   Showtime the message reports the receive PSD measured in Channel Discovery
+   phase after the final hybrid training (no Showtime update).
+*/
+struct CMD_RxPSD_TableEntriesGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the receive PSD per subcarrier available at the
+   near-end side, which means for downstream direction at the CPE.In Showtime
+   the message reports the receive PSD measured in Channel Discovery phase after
+   the final hybrid training (no Showtime update).
+*/
+struct ACK_RxPSD_TableEntriesGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Receive PSD */
+   DSL_uint16_t PSDps[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Receive PSD */
+   DSL_uint16_t PSDps[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests status information for the downstream bearer channels.
+*/
+struct CMD_BearerChsDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers status information for the downstream bearer channels. **: The terms
+   "LP0/Interleaved Path" and "LP1/Fast Path" below refer to the terminology
+   used in ITU DSL standards [1],[2], [3], [5] which means:- LP0 or LP1 in case
+   of VDSL2, ADSL2/2+- "Interleaved Path" or "Fast Path" in case of ADSL1/ADSL1
+   Lite.Attention: In VRX Device1 the "LP1/Fast Path" parameters are populated
+   only in ADSL1 and ADSL1 Lilte mode with selected fast path.
+*/
+struct ACK_BearerChsDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** ACTNDR DS for LP0, LSW */
+   DSL_uint16_t DRdsLP0_LSW;
+   /** ACTNDR DS for LP0, MSW */
+   DSL_uint16_t DRdsLP0_MSW;
+   /** ACTNDR DS for LP1, LSW */
+   DSL_uint16_t DRdsLP1_LSW;
+   /** ACTNDR DS for LP1, MSW */
+   DSL_uint16_t DRdsLP1_MSW;
+   /** Reserved */
+   DSL_uint16_t Res0[4];
+   /** Actual Interleaving Delay DS, LP0 */
+   DSL_uint16_t delay_dsLP0;
+   /** Actual Interleaving Delay DS, LP1 */
+   DSL_uint16_t delay_dsLP1;
+   /** Actual Interleaver Depth DS, LP0 */
+   DSL_uint16_t intlDepth_dsLP0;
+   /** Actual Interleaver Depth DS, LP1 */
+   DSL_uint16_t intlDepth_dsLP1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 7;
+   /** TCM Status DS, LP0  */
+   DSL_uint16_t TCMstatus_dsLP0 : 1;
+   /** Parity Bytes DS, LP0 */
+   DSL_uint16_t parity_dsLP0 : 8;
+   /** Reserved */
+   DSL_uint8_t Res2;
+   /** Parity Bytes DS, LP1 */
+   DSL_uint16_t parity_dsLP1 : 8;
+   /** Actual INP NoErasure DS , LP0 */
+   DSL_uint16_t actInpNoErasure_LP0;
+   /** Actual INP NoErasure DS, LP1 */
+   DSL_uint16_t actInpNoErasure_LP1;
+   /** RX Estimated Actual INP DS, LP0 */
+   DSL_uint16_t actInpErasure_LP0;
+   /** RX Estimated Actual INP DS, LP1 */
+   DSL_uint16_t actInpErasure_LP1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** ACTNDR DS for LP0, LSW */
+   DSL_uint16_t DRdsLP0_LSW;
+   /** ACTNDR DS for LP0, MSW */
+   DSL_uint16_t DRdsLP0_MSW;
+   /** ACTNDR DS for LP1, LSW */
+   DSL_uint16_t DRdsLP1_LSW;
+   /** ACTNDR DS for LP1, MSW */
+   DSL_uint16_t DRdsLP1_MSW;
+   /** Reserved */
+   DSL_uint16_t Res0[4];
+   /** Actual Interleaving Delay DS, LP0 */
+   DSL_uint16_t delay_dsLP0;
+   /** Actual Interleaving Delay DS, LP1 */
+   DSL_uint16_t delay_dsLP1;
+   /** Actual Interleaver Depth DS, LP0 */
+   DSL_uint16_t intlDepth_dsLP0;
+   /** Actual Interleaver Depth DS, LP1 */
+   DSL_uint16_t intlDepth_dsLP1;
+   /** Parity Bytes DS, LP0 */
+   DSL_uint16_t parity_dsLP0 : 8;
+   /** TCM Status DS, LP0  */
+   DSL_uint16_t TCMstatus_dsLP0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 7;
+   /** Parity Bytes DS, LP1 */
+   DSL_uint16_t parity_dsLP1 : 8;
+   /** Reserved */
+   DSL_uint8_t Res2;
+   /** Actual INP NoErasure DS , LP0 */
+   DSL_uint16_t actInpNoErasure_LP0;
+   /** Actual INP NoErasure DS, LP1 */
+   DSL_uint16_t actInpNoErasure_LP1;
+   /** RX Estimated Actual INP DS, LP0 */
+   DSL_uint16_t actInpErasure_LP0;
+   /** RX Estimated Actual INP DS, LP1 */
+   DSL_uint16_t actInpErasure_LP1;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests status information for the upstream bearer channels.
+*/
+struct CMD_BearerChsUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers status information for the upstream bearer channels. **: The terms
+   "LP0/Interleaved Path" and "LP1/Fast Path" below refer to the terminology
+   used in ITU DSL standards [1],[2], [3], [5] which means:- LP0 or LP1 in case
+   of VDSL2, ADSL2/2+- "Interleaved Path" or "Fast Path" in case of ADSL1/ADSL1
+   Lite.Attention: In VRX Device1 the "LP1/Fast Path" parameters are populated
+   only in ADSL1 and ADSL1 Lite mode with selected fast path.
+*/
+struct ACK_BearerChsUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** ACTNDR US for LP0, LSW */
+   DSL_uint16_t DRusLP0_LSW;
+   /** ACTNDR US for LP0, MSW */
+   DSL_uint16_t DRusLP0_MSW;
+   /** ACTNDR US for LP1, LSW */
+   DSL_uint16_t DRusLP1_LSW;
+   /** ACTNDR US for LP1, MSW */
+   DSL_uint16_t DRusLP1_MSW;
+   /** Reserved */
+   DSL_uint16_t Res0[4];
+   /** Actual Interleaving Delay US, LP0 */
+   DSL_uint16_t delay_usLP0;
+   /** Actual Interleaving Delay US, LP1 */
+   DSL_uint16_t delay_usLP1;
+   /** Actual Interleaver Depth US, LP0 */
+   DSL_uint16_t intlDepth_usLP0;
+   /** Actual Interleaver Depth US, LP1 */
+   DSL_uint16_t intlDepth_usLP1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 7;
+   /** TCM Status US, LP0  */
+   DSL_uint16_t TCMstatus_usLP0 : 1;
+   /** Parity Bytes US, LP0 */
+   DSL_uint16_t parity_usLP0 : 8;
+   /** Reserved */
+   DSL_uint8_t Res2;
+   /** Parity Bytes US, LP1 */
+   DSL_uint16_t parity_usLP1 : 8;
+   /** Actual INP NoErasure US , LP0 */
+   DSL_uint16_t actInpNoErasure_LP0;
+   /** Actual INP NoErasure US, LP1 */
+   DSL_uint16_t actInpNoErasure_LP1;
+   /** RX Estimated Actual INP US , LP0 */
+   DSL_uint16_t actInpErasure_LP0;
+   /** RX Estimated Actual INP US, LP1 */
+   DSL_uint16_t actInpErasure_LP1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** ACTNDR US for LP0, LSW */
+   DSL_uint16_t DRusLP0_LSW;
+   /** ACTNDR US for LP0, MSW */
+   DSL_uint16_t DRusLP0_MSW;
+   /** ACTNDR US for LP1, LSW */
+   DSL_uint16_t DRusLP1_LSW;
+   /** ACTNDR US for LP1, MSW */
+   DSL_uint16_t DRusLP1_MSW;
+   /** Reserved */
+   DSL_uint16_t Res0[4];
+   /** Actual Interleaving Delay US, LP0 */
+   DSL_uint16_t delay_usLP0;
+   /** Actual Interleaving Delay US, LP1 */
+   DSL_uint16_t delay_usLP1;
+   /** Actual Interleaver Depth US, LP0 */
+   DSL_uint16_t intlDepth_usLP0;
+   /** Actual Interleaver Depth US, LP1 */
+   DSL_uint16_t intlDepth_usLP1;
+   /** Parity Bytes US, LP0 */
+   DSL_uint16_t parity_usLP0 : 8;
+   /** TCM Status US, LP0  */
+   DSL_uint16_t TCMstatus_usLP0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 7;
+   /** Parity Bytes US, LP1 */
+   DSL_uint16_t parity_usLP1 : 8;
+   /** Reserved */
+   DSL_uint8_t Res2;
+   /** Actual INP NoErasure US , LP0 */
+   DSL_uint16_t actInpNoErasure_LP0;
+   /** Actual INP NoErasure US, LP1 */
+   DSL_uint16_t actInpNoErasure_LP1;
+   /** RX Estimated Actual INP US , LP0 */
+   DSL_uint16_t actInpErasure_LP0;
+   /** RX Estimated Actual INP US, LP1 */
+   DSL_uint16_t actInpErasure_LP1;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests an extended set of VDSL2 framing parameters for the downstream
+   direction.
+*/
+struct CMD_FrameDataExt2DS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers an extended set of VDSL2 framing parameters for the downstream
+   direction requested by CMD_FrameDataExt2DS_Get. (Sections 7.5.2.6 of G.997.1
+   and 9.5 & 9.6 of G.993.2 [5])
+*/
+struct ACK_FrameDataExt2DS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Bytes "Bp" from BC0 per MDF LP0 DS */
+   DSL_uint16_t B0_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** Reserved */
+   DSL_uint16_t Res1;
+   /** Reserved */
+   DSL_uint16_t Res2;
+   /** MDFs per OH Sub-Frame "Tp" LP0 DS */
+   DSL_uint16_t Tp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res3;
+   /** OH Bytes per OH sub-frame "Gp" LP0 DS */
+   DSL_uint16_t Gp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res4;
+   /** OH Frames per OH Superframe "Fp" LP0 DS */
+   DSL_uint16_t Fp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res5;
+   /** MDFs per RS-Codeword "Mp" LP0 DS */
+   DSL_uint16_t Mp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res6;
+   /** Bits per Symbol "Lp" LP0 DS, LSW */
+   DSL_uint16_t Lp_LP0ds_LSW;
+   /** Bits per Symbol "Lp" LP0 DS, MSW */
+   DSL_uint16_t Lp_LP0ds_MSW;
+   /** Reserved */
+   DSL_uint16_t Res7;
+   /** Reserved */
+   DSL_uint16_t Res8;
+   /** RS Check Bytes "Rp" LP0 DS */
+   DSL_uint16_t Rp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res9;
+   /** Interleaver Block Length "Ip", LP0 DS */
+   DSL_uint16_t Ip_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res10;
+   /** Interleaving Depth "Dp" LP0 DS */
+   DSL_uint16_t Dp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res11;
+   /** OH Frame Period "PERp", LP0 DS */
+   DSL_uint16_t PERp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res12;
+   /** Line Data Rate DS for LP0, LSW */
+   DSL_uint16_t DRp_LP0ds_LSW;
+   /** Line Data Rate DS for LP0, MSW */
+   DSL_uint16_t DRp_LP0ds_MSW;
+   /** Reserved */
+   DSL_uint16_t Res13;
+   /** Reserved */
+   DSL_uint16_t Res14;
+   /** RS Codeword Size "N_fecp" LP0 DS */
+   DSL_uint16_t N_fecp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res15;
+   /** Framing Parameter "q", LP0 DS */
+   DSL_uint16_t q_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res16;
+   /** OH Bytes per OH FrameLP0 "SEQp" DS */
+   DSL_uint16_t SEQp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res17;
+   /** OH sub-frames "Up" per OH frame LP0 DS */
+   DSL_uint16_t Up_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res18;
+   /** Bytes per OH Frame LP0 DS, LSW */
+   DSL_uint16_t PERBp_LP0ds_LSW;
+   /** Bytes per OH Frame LP0 DS, MSW */
+   DSL_uint16_t PERBp_LP0ds_MSW;
+   /** Reserved */
+   DSL_uint16_t Res19;
+   /** Reserved */
+   DSL_uint16_t Res20;
+   /** Bytes in MSG OH "MSGc" LP0 DS */
+   DSL_uint16_t MSGc_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res21;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Bytes "Bp" from BC0 per MDF LP0 DS */
+   DSL_uint16_t B0_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** Reserved */
+   DSL_uint16_t Res1;
+   /** Reserved */
+   DSL_uint16_t Res2;
+   /** MDFs per OH Sub-Frame "Tp" LP0 DS */
+   DSL_uint16_t Tp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res3;
+   /** OH Bytes per OH sub-frame "Gp" LP0 DS */
+   DSL_uint16_t Gp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res4;
+   /** OH Frames per OH Superframe "Fp" LP0 DS */
+   DSL_uint16_t Fp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res5;
+   /** MDFs per RS-Codeword "Mp" LP0 DS */
+   DSL_uint16_t Mp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res6;
+   /** Bits per Symbol "Lp" LP0 DS, LSW */
+   DSL_uint16_t Lp_LP0ds_LSW;
+   /** Bits per Symbol "Lp" LP0 DS, MSW */
+   DSL_uint16_t Lp_LP0ds_MSW;
+   /** Reserved */
+   DSL_uint16_t Res7;
+   /** Reserved */
+   DSL_uint16_t Res8;
+   /** RS Check Bytes "Rp" LP0 DS */
+   DSL_uint16_t Rp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res9;
+   /** Interleaver Block Length "Ip", LP0 DS */
+   DSL_uint16_t Ip_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res10;
+   /** Interleaving Depth "Dp" LP0 DS */
+   DSL_uint16_t Dp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res11;
+   /** OH Frame Period "PERp", LP0 DS */
+   DSL_uint16_t PERp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res12;
+   /** Line Data Rate DS for LP0, LSW */
+   DSL_uint16_t DRp_LP0ds_LSW;
+   /** Line Data Rate DS for LP0, MSW */
+   DSL_uint16_t DRp_LP0ds_MSW;
+   /** Reserved */
+   DSL_uint16_t Res13;
+   /** Reserved */
+   DSL_uint16_t Res14;
+   /** RS Codeword Size "N_fecp" LP0 DS */
+   DSL_uint16_t N_fecp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res15;
+   /** Framing Parameter "q", LP0 DS */
+   DSL_uint16_t q_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res16;
+   /** OH Bytes per OH FrameLP0 "SEQp" DS */
+   DSL_uint16_t SEQp_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res17;
+   /** OH sub-frames "Up" per OH frame LP0 DS */
+   DSL_uint16_t Up_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res18;
+   /** Bytes per OH Frame LP0 DS, LSW */
+   DSL_uint16_t PERBp_LP0ds_LSW;
+   /** Bytes per OH Frame LP0 DS, MSW */
+   DSL_uint16_t PERBp_LP0ds_MSW;
+   /** Reserved */
+   DSL_uint16_t Res19;
+   /** Reserved */
+   DSL_uint16_t Res20;
+   /** Bytes in MSG OH "MSGc" LP0 DS */
+   DSL_uint16_t MSGc_LP0ds;
+   /** Reserved */
+   DSL_uint16_t Res21;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests an extended set of VDSL2 framing parameters for the upstream
+   direction.
+*/
+struct CMD_FrameDataExt2US_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers an extended set of VDSL2 framing parameters for the upstream
+   direction requested by CMD_FrameDataExt2US_Get. (Sections 7.5.2.6 of G.997.1
+   and 9.5 & 9.6 of G.993.2 [5])
+*/
+struct ACK_FrameDataExt2US_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Bytes "Bp" from BC0 per MDF LP0 US */
+   DSL_uint16_t B0_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** Reserved */
+   DSL_uint16_t Res1;
+   /** Reserved */
+   DSL_uint16_t Res2;
+   /** MDFs per OH Sub-Frame "Tp" LP0 US */
+   DSL_uint16_t Tp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res3;
+   /** OH Bytes per OH sub-frame "Gp" LP0 US */
+   DSL_uint16_t Gp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res4;
+   /** OH Frames per OH Superframe "Fp" LP0 US */
+   DSL_uint16_t Fp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res5;
+   /** MDFs per RS-Codeword "Mp" LP0 US */
+   DSL_uint16_t Mp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res6;
+   /** Bits per Symbol "Lp" LP0 US, LSW */
+   DSL_uint16_t Lp_LP0us_LSW;
+   /** Bits per Symbol "Lp" LP0 US, MSW */
+   DSL_uint16_t Lp_LP0us_MSW;
+   /** Reserved */
+   DSL_uint16_t Res7;
+   /** Reserved */
+   DSL_uint16_t Res8;
+   /** RS Check Bytes "Rp" LP0 US */
+   DSL_uint16_t Rp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res9;
+   /** Interleaver Block Length "Ip", LP0 US */
+   DSL_uint16_t Ip_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res10;
+   /** Interleaving Depth "Dp" LP0 US */
+   DSL_uint16_t Dp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res11;
+   /** OH Frame Period "PERp", LP0 US */
+   DSL_uint16_t PERp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res12;
+   /** Line Data Rate US for LP0, LSW */
+   DSL_uint16_t DRp_LP0us_LSW;
+   /** Line Data Rate US for LP0, MSW */
+   DSL_uint16_t DRp_LP0us_MSW;
+   /** Reserved */
+   DSL_uint16_t Res13;
+   /** Reserved */
+   DSL_uint16_t Res14;
+   /** RS Codeword Size "N_fecp" LP0 US */
+   DSL_uint16_t N_fecp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res15;
+   /** Framing Parameter "q", LP0 US */
+   DSL_uint16_t q_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res16;
+   /** OH Bytes per OH FrameLP0 "SEQp" US */
+   DSL_uint16_t SEQp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res17;
+   /** OH sub-frames "Up" per OH frame LP0 US */
+   DSL_uint16_t Up_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res18;
+   /** Bytes per OH Frame LP0 US, LSW */
+   DSL_uint16_t PERBp_LP0us_LSW;
+   /** Bytes per OH Frame LP0 US, MSW */
+   DSL_uint16_t PERBp_LP0us_MSW;
+   /** Reserved */
+   DSL_uint16_t Res19;
+   /** Reserved */
+   DSL_uint16_t Res20;
+   /** Bytes in MSG OH "MSGc" LP0 US */
+   DSL_uint16_t MSGc_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res21;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Bytes "Bp" from BC0 per MDF LP0 US */
+   DSL_uint16_t B0_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** Reserved */
+   DSL_uint16_t Res1;
+   /** Reserved */
+   DSL_uint16_t Res2;
+   /** MDFs per OH Sub-Frame "Tp" LP0 US */
+   DSL_uint16_t Tp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res3;
+   /** OH Bytes per OH sub-frame "Gp" LP0 US */
+   DSL_uint16_t Gp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res4;
+   /** OH Frames per OH Superframe "Fp" LP0 US */
+   DSL_uint16_t Fp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res5;
+   /** MDFs per RS-Codeword "Mp" LP0 US */
+   DSL_uint16_t Mp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res6;
+   /** Bits per Symbol "Lp" LP0 US, LSW */
+   DSL_uint16_t Lp_LP0us_LSW;
+   /** Bits per Symbol "Lp" LP0 US, MSW */
+   DSL_uint16_t Lp_LP0us_MSW;
+   /** Reserved */
+   DSL_uint16_t Res7;
+   /** Reserved */
+   DSL_uint16_t Res8;
+   /** RS Check Bytes "Rp" LP0 US */
+   DSL_uint16_t Rp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res9;
+   /** Interleaver Block Length "Ip", LP0 US */
+   DSL_uint16_t Ip_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res10;
+   /** Interleaving Depth "Dp" LP0 US */
+   DSL_uint16_t Dp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res11;
+   /** OH Frame Period "PERp", LP0 US */
+   DSL_uint16_t PERp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res12;
+   /** Line Data Rate US for LP0, LSW */
+   DSL_uint16_t DRp_LP0us_LSW;
+   /** Line Data Rate US for LP0, MSW */
+   DSL_uint16_t DRp_LP0us_MSW;
+   /** Reserved */
+   DSL_uint16_t Res13;
+   /** Reserved */
+   DSL_uint16_t Res14;
+   /** RS Codeword Size "N_fecp" LP0 US */
+   DSL_uint16_t N_fecp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res15;
+   /** Framing Parameter "q", LP0 US */
+   DSL_uint16_t q_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res16;
+   /** OH Bytes per OH FrameLP0 "SEQp" US */
+   DSL_uint16_t SEQp_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res17;
+   /** OH sub-frames "Up" per OH frame LP0 US */
+   DSL_uint16_t Up_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res18;
+   /** Bytes per OH Frame LP0 US, LSW */
+   DSL_uint16_t PERBp_LP0us_LSW;
+   /** Bytes per OH Frame LP0 US, MSW */
+   DSL_uint16_t PERBp_LP0us_MSW;
+   /** Reserved */
+   DSL_uint16_t Res19;
+   /** Reserved */
+   DSL_uint16_t Res20;
+   /** Bytes in MSG OH "MSGc" LP0 US */
+   DSL_uint16_t MSGc_LP0us;
+   /** Reserved */
+   DSL_uint16_t Res21;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests ADSL framing parameters for the downstream direction, latency path
+   0/Interleaved Path.
+*/
+struct CMD_ADSL_FrameDataDS_LP0Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the ADSL framing parameters for the downstream direction,
+   LP0/Interleaved path, as requested by CMD_ADSL_FrameDataDS_LP0Get. (Sections
+   7.5 & 7.6 of G.992.3 [2] and 7.4 of G.992.1 [1])
+*/
+struct ACK_ADSL_FrameDataDS_LP0Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** RS Check Bytes "Rp" DS LP0 */
+   DSL_uint16_t Rp;
+   /** Symbols per RS-Codeword "Sp" DS LP0 */
+   DSL_uint16_t Sp;
+   /** Interleaving Depth "Dp" DS LP0 */
+   DSL_uint16_t Dp;
+   /** Bytes per MDF "Kp" DS LP0 */
+   DSL_uint16_t Kp;
+   /** MDFs per RS-Codeword "Mp" DS LP0 */
+   DSL_uint16_t Mp;
+   /** Bits per Symbol "Lp" DS LP0 */
+   DSL_uint16_t Lp;
+   /** TCM Bits DS LP0 */
+   DSL_uint16_t TCM;
+   /** Framing Mode DS LP0 */
+   DSL_uint16_t fraMode;
+   /** "Tp" DS LP0 */
+   DSL_uint16_t Tp;
+   /** "SEQp" DS LP0 */
+   DSL_uint16_t SEQp;
+   /** Bytes in MSG-OH "MSGc" DS */
+   DSL_uint16_t MSGc;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** RS Check Bytes "Rp" DS LP0 */
+   DSL_uint16_t Rp;
+   /** Symbols per RS-Codeword "Sp" DS LP0 */
+   DSL_uint16_t Sp;
+   /** Interleaving Depth "Dp" DS LP0 */
+   DSL_uint16_t Dp;
+   /** Bytes per MDF "Kp" DS LP0 */
+   DSL_uint16_t Kp;
+   /** MDFs per RS-Codeword "Mp" DS LP0 */
+   DSL_uint16_t Mp;
+   /** Bits per Symbol "Lp" DS LP0 */
+   DSL_uint16_t Lp;
+   /** TCM Bits DS LP0 */
+   DSL_uint16_t TCM;
+   /** Framing Mode DS LP0 */
+   DSL_uint16_t fraMode;
+   /** "Tp" DS LP0 */
+   DSL_uint16_t Tp;
+   /** "SEQp" DS LP0 */
+   DSL_uint16_t SEQp;
+   /** Bytes in MSG-OH "MSGc" DS */
+   DSL_uint16_t MSGc;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests ADSL framing parameters for the upstream direction, latency path
+   0/Interleaved path.
+*/
+struct CMD_ADSL_FrameDataUS_LP0Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the ADSL framing parameters for the upstream direction, latency path
+   0/Interleaved path, as requested by CMD_ADSL_FrameDataUS_LP0Get. (Sections
+   7.5 & 7.6 of G.992.3 [2] and 7.4 of G.992.1 [1])
+*/
+struct ACK_ADSL_FrameDataUS_LP0Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** RS Check Bytes "Rp" US LP0 */
+   DSL_uint16_t Rp_LP0us;
+   /** Symbols per RS-Codeword "Sp" US LP0 */
+   DSL_uint16_t Sp;
+   /** Interleaving Depth "Dp" US LP0 */
+   DSL_uint16_t Dp;
+   /** Bytes per MDF "Kp" US LP0 */
+   DSL_uint16_t Kp;
+   /** MDFs per RS-Codeword "Mp" US LP0 */
+   DSL_uint16_t Mp;
+   /** Bits per Symbol "Lp" US LP0 */
+   DSL_uint16_t Lp;
+   /** TCM Bits US LP0 */
+   DSL_uint16_t TCM;
+   /** Framing Mode US LP0 */
+   DSL_uint16_t fraMode;
+   /** "Tp" US LP0 */
+   DSL_uint16_t Tp;
+   /** "SEQp" US LP0 */
+   DSL_uint16_t SEQp;
+   /** Bytes in MSG-OH "MSGc" US */
+   DSL_uint16_t MSGc;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** RS Check Bytes "Rp" US LP0 */
+   DSL_uint16_t Rp_LP0us;
+   /** Symbols per RS-Codeword "Sp" US LP0 */
+   DSL_uint16_t Sp;
+   /** Interleaving Depth "Dp" US LP0 */
+   DSL_uint16_t Dp;
+   /** Bytes per MDF "Kp" US LP0 */
+   DSL_uint16_t Kp;
+   /** MDFs per RS-Codeword "Mp" US LP0 */
+   DSL_uint16_t Mp;
+   /** Bits per Symbol "Lp" US LP0 */
+   DSL_uint16_t Lp;
+   /** TCM Bits US LP0 */
+   DSL_uint16_t TCM;
+   /** Framing Mode US LP0 */
+   DSL_uint16_t fraMode;
+   /** "Tp" US LP0 */
+   DSL_uint16_t Tp;
+   /** "SEQp" US LP0 */
+   DSL_uint16_t SEQp;
+   /** Bytes in MSG-OH "MSGc" US */
+   DSL_uint16_t MSGc;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests ADSL framing parameters for the downstream direction, latency path 1
+   (LP1)/ Fast path.In VRX Rev. 1.x to be used for ADSL1, "fast path" only.
+*/
+struct CMD_ADSL_FrameDataDS_LP1Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the ADSL framing parameters for the downstream direction, LP1/Fast
+   path, as requested by CMD_ADSL_FrameDataDS_LP1Get. (Sections 7.5 & 7.6 of
+   G.992.3 [2] and 7.4 of G.992.1 [1])
+*/
+struct ACK_ADSL_FrameDataDS_LP1Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** RS Check Bytes "Rp" DS LP1 */
+   DSL_uint16_t Rp;
+   /** Symbols per RS-Codeword "Sp" DS LP1 */
+   DSL_uint16_t Sp;
+   /** Interleaving Depth "Dp" DS LP1 */
+   DSL_uint16_t Dp;
+   /** Bytes per MDF "Kp" DS LP1 */
+   DSL_uint16_t Kp;
+   /** MDFs per RS-Codeword "Mp" DS LP1 */
+   DSL_uint16_t Mp;
+   /** Bits per Symbol "Lp" DS LP1 */
+   DSL_uint16_t Lp;
+   /** TCM Bits DS LP1 */
+   DSL_uint16_t TCM;
+   /** Framing Mode DS LP1 */
+   DSL_uint16_t fraMode;
+   /** "Tp" DS LP1 */
+   DSL_uint16_t Tp;
+   /** "SEQp" DS LP1 */
+   DSL_uint16_t SEQp;
+   /** Bytes in MSG-OH "MSGc" DS */
+   DSL_uint16_t MSGc;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** RS Check Bytes "Rp" DS LP1 */
+   DSL_uint16_t Rp;
+   /** Symbols per RS-Codeword "Sp" DS LP1 */
+   DSL_uint16_t Sp;
+   /** Interleaving Depth "Dp" DS LP1 */
+   DSL_uint16_t Dp;
+   /** Bytes per MDF "Kp" DS LP1 */
+   DSL_uint16_t Kp;
+   /** MDFs per RS-Codeword "Mp" DS LP1 */
+   DSL_uint16_t Mp;
+   /** Bits per Symbol "Lp" DS LP1 */
+   DSL_uint16_t Lp;
+   /** TCM Bits DS LP1 */
+   DSL_uint16_t TCM;
+   /** Framing Mode DS LP1 */
+   DSL_uint16_t fraMode;
+   /** "Tp" DS LP1 */
+   DSL_uint16_t Tp;
+   /** "SEQp" DS LP1 */
+   DSL_uint16_t SEQp;
+   /** Bytes in MSG-OH "MSGc" DS */
+   DSL_uint16_t MSGc;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests ADSL framing parameters for the upstream direction, latency path 1
+   (LP1)/Fast path.In VRX Rev. 1.x to be used for ADSL1, "fast path" only.
+*/
+struct CMD_ADSL_FrameDataUS_LP1Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the ADSL framing parameters for the upstream direction, LP1/Fast
+   path, as requested by CMD_ADSL_FrameDataUS_LP1Get. (Sections 7.5 & 7.6 of
+   G.992.3 [2] and 7.4 of G.992.1 [1])
+*/
+struct ACK_ADSL_FrameDataUS_LP1Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** RS Check Bytes "Rp" US LP1 */
+   DSL_uint16_t Rp_LP0us;
+   /** Symbols per RS-Codeword "Sp" US LP1 */
+   DSL_uint16_t Sp;
+   /** Interleaving Depth "Dp" US LP1 */
+   DSL_uint16_t Dp;
+   /** Bytes per MDF "Kp" US LP1 */
+   DSL_uint16_t Kp;
+   /** MDFs per RS-Codeword "Mp" US LP1 */
+   DSL_uint16_t Mp;
+   /** Bits per Symbol "Lp" US LP1 */
+   DSL_uint16_t Lp;
+   /** TCM Bits US LP1 */
+   DSL_uint16_t TCM;
+   /** Framing Mode US LP1 */
+   DSL_uint16_t fraMode;
+   /** "Tp" US LP1 */
+   DSL_uint16_t Tp;
+   /** "SEQp" US LP1 */
+   DSL_uint16_t SEQp;
+   /** Bytes in MSG-OH "MSGc" US */
+   DSL_uint16_t MSGc;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** RS Check Bytes "Rp" US LP1 */
+   DSL_uint16_t Rp_LP0us;
+   /** Symbols per RS-Codeword "Sp" US LP1 */
+   DSL_uint16_t Sp;
+   /** Interleaving Depth "Dp" US LP1 */
+   DSL_uint16_t Dp;
+   /** Bytes per MDF "Kp" US LP1 */
+   DSL_uint16_t Kp;
+   /** MDFs per RS-Codeword "Mp" US LP1 */
+   DSL_uint16_t Mp;
+   /** Bits per Symbol "Lp" US LP1 */
+   DSL_uint16_t Lp;
+   /** TCM Bits US LP1 */
+   DSL_uint16_t TCM;
+   /** Framing Mode US LP1 */
+   DSL_uint16_t fraMode;
+   /** "Tp" US LP1 */
+   DSL_uint16_t Tp;
+   /** "SEQp" US LP1 */
+   DSL_uint16_t SEQp;
+   /** Bytes in MSG-OH "MSGc" US */
+   DSL_uint16_t MSGc;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reads the connected hybrid type.
+*/
+struct CMD_HybridGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Contains the connected hybrid type.
+*/
+struct ACK_HybridGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Hybrid Type */
+   DSL_uint16_t HybridType;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Hybrid Type */
+   DSL_uint16_t HybridType;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the pilot tones used in Showtime.
+*/
+struct CMD_PilotTonesGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the Showtime pilot tones as requested by CMD_PilotTonesGet.
+*/
+struct ACK_PilotTonesGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Number of Pilot Tones */
+   DSL_uint16_t numPilot;
+   /** Pilot Tones */
+   DSL_uint16_t pilot[16];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Number of Pilot Tones */
+   DSL_uint16_t numPilot;
+   /** Pilot Tones */
+   DSL_uint16_t pilot[16];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the results of the micro filter detection (MFD) function. Valid
+   information in Showtime and FAIL will be available only if the microfilter
+   detection mechanism has been run before.
+*/
+struct CMD_MFD_ResultsGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reports the results of the micro filter detection (MFD) function.
+*/
+struct ACK_MFD_ResultsGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 1;
+   /** Filter Detection Process Indication, Bit 14:13 */
+   DSL_uint16_t FilterDetectStatus : 2;
+   /** Reserved */
+   DSL_uint16_t Res1 : 3;
+   /** Training Bridged Tap Range, Bit 9:8 */
+   DSL_uint16_t TrainingBTRange : 2;
+   /** Training Hybrid Info Ready Indication, Bit 7 */
+   DSL_uint16_t TrainingHybridInfoReady : 1;
+   /** Training Loop Length Ready Indication, Bit 6 */
+   DSL_uint16_t TrainingLoopLengthReady : 1;
+   /** Training Metric2 Ready Indication, Bit 5 */
+   DSL_uint16_t TrainingMetric2Ready : 1;
+   /** Reserved Bit 4:2 */
+   DSL_uint16_t Res2 : 3;
+   /** Bridge Tap Range, Bit 1:0 */
+   DSL_uint16_t BTRange : 2;
+   /** Metric1 for NLNF, Bit 15:4 */
+   DSL_uint16_t M1metric : 12;
+   /** "No Confidence" Bit, Bit 3 */
+   DSL_uint16_t M1NoConfidence : 1;
+   /** Metric1 QLN level, Bit 2:0 */
+   DSL_uint16_t M1QlnLevel : 3;
+   /** Metric2 */
+   DSL_int16_t M2Metric;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Bridge Tap Range, Bit 1:0 */
+   DSL_uint16_t BTRange : 2;
+   /** Reserved Bit 4:2 */
+   DSL_uint16_t Res2 : 3;
+   /** Training Metric2 Ready Indication, Bit 5 */
+   DSL_uint16_t TrainingMetric2Ready : 1;
+   /** Training Loop Length Ready Indication, Bit 6 */
+   DSL_uint16_t TrainingLoopLengthReady : 1;
+   /** Training Hybrid Info Ready Indication, Bit 7 */
+   DSL_uint16_t TrainingHybridInfoReady : 1;
+   /** Training Bridged Tap Range, Bit 9:8 */
+   DSL_uint16_t TrainingBTRange : 2;
+   /** Reserved */
+   DSL_uint16_t Res1 : 3;
+   /** Filter Detection Process Indication, Bit 14:13 */
+   DSL_uint16_t FilterDetectStatus : 2;
+   /** Reserved */
+   DSL_uint16_t Res0 : 1;
+   /** Metric1 QLN level, Bit 2:0 */
+   DSL_uint16_t M1QlnLevel : 3;
+   /** "No Confidence" Bit, Bit 3 */
+   DSL_uint16_t M1NoConfidence : 1;
+   /** Metric1 for NLNF, Bit 15:4 */
+   DSL_uint16_t M1metric : 12;
+   /** Metric2 */
+   DSL_int16_t M2Metric;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the loop length estimates done by the microfilter detection
+   function.In Showtime the data are always available.The availability of data
+   is indicated by the flag TrainingLoopLengthReady in ACK_MFD_ResultsGet.In
+   Showtime the data are always available.
+*/
+struct CMD_MFD_LooplengthGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reports the loop length estimates done by the microfilter detection (MFD)
+   function.
+*/
+struct ACK_MFD_LooplengthGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** AWG26 Length Estimate */
+   DSL_uint16_t Awg26Length;
+   /** AWG24 Length Estimate */
+   DSL_uint16_t Awg24Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** AWG26 Length Estimate */
+   DSL_uint16_t Awg26Length;
+   /** AWG24 Length Estimate */
+   DSL_uint16_t Awg24Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests hybrid information used by the microfilter detection function.In
+   Showtime the data are always available.The availability of data is indicated
+   by the flag TrainingHybridInfoReady in ACK_MFD_ResultsGet. In Showtime the
+   data are always available.
+*/
+struct CMD_MFD_HybridInfoGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reports the hybrid information used by the microfilter detection function.
+*/
+struct ACK_MFD_HybridInfoGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Hybrid Max Index */
+   DSL_uint16_t HybridMaxIndex;
+   /** Hybrid Max Metric */
+   DSL_uint16_t HybridMaxMetric;
+   /** Hybrid Second Best Index */
+   DSL_uint16_t Hybrid2ndBestIndex;
+   /** Hybrid Second Best Metric */
+   DSL_uint16_t Hybrid2ndBestMetric;
+   /** Hybrid Zero Metric */
+   DSL_uint16_t Hybrid0Metric;
+   /** Loaded Hybrid Index */
+   DSL_uint16_t LoadHybridIndex;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Hybrid Max Index */
+   DSL_uint16_t HybridMaxIndex;
+   /** Hybrid Max Metric */
+   DSL_uint16_t HybridMaxMetric;
+   /** Hybrid Second Best Index */
+   DSL_uint16_t Hybrid2ndBestIndex;
+   /** Hybrid Second Best Metric */
+   DSL_uint16_t Hybrid2ndBestMetric;
+   /** Hybrid Zero Metric */
+   DSL_uint16_t Hybrid0Metric;
+   /** Loaded Hybrid Index */
+   DSL_uint16_t LoadHybridIndex;
+#endif
+} __PACKED__ ;
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#ifdef __PACKED_DEFINED__
+   #if !(defined (__GNUC__) || defined (__GNUG__))
+      #pragma pack()
+   #endif
+   #undef __PACKED_DEFINED__
+#endif /* __PACKED_DEFINED__ */
+
+/** @} */
+
+#endif /** _DRV_DSL_CPE_VRX_MSG_GHS_STATUS_H_*/
--- /dev/null
+++ b/src/include/mcat3.2/drv_dsl_cpe_vrx_msg_olr.h
@@ -0,0 +1,4077 @@
+/******************************************************************************
+
+         Copyright 2016 - 2018 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+
+#ifndef _DRV_DSL_CPE_VRX_MSG_OLR_H_
+#define _DRV_DSL_CPE_VRX_MSG_OLR_H_
+
+/** \file
+
+*/
+
+#ifndef __PACKED__
+   #if defined (__GNUC__) || defined (__GNUG__)
+      /* GNU C or C++ compiler */
+      #define __PACKED__ __attribute__ ((packed))
+   #else
+      /* Byte alignment adjustment */
+      #pragma pack(1)
+      #define __PACKED__      /* nothing */
+   #endif
+   #define __PACKED_DEFINED__ 1
+#endif
+
+
+/** @defgroup _OLR_
+ *  @{
+ */
+
+#ifdef __cplusplus
+   extern "C" {
+#endif
+
+/* ----- Message Specific Constants Definition section ----- */
+#define CMD_TestParamsFE_Request_TRIGGER 0x1
+#define CMD_TestParamsFE_Request_ABORT 0x0
+#define ACK_TestParamsFE_Poll_ONGOING 0x1
+#define CMD_ClearEOC_TxTrigger_IDLE 0
+#define CMD_ClearEOC_TxTrigger_START 1
+#define ACK_ClearEOCStatusGet_IDLE 0
+#define ACK_ClearEOCStatusGet_TXPROG 1
+#define ACK_ClearEOCStatusGet_Reserved 2
+#define ACK_ClearEOCStatusGet_TXERR 3
+#define ACK_ClearEOCStatusGet_RXPROG 1
+#define ACK_ClearEOCStatusGet_RXDONE 2
+#define ACK_ClearEOCStatusGet_RXERR 3
+#define EVT_ClearEOCStatusGet_IDLE 0
+#define EVT_ClearEOCStatusGet_TXPROG 1
+#define EVT_ClearEOCStatusGet_TXDONE 2
+#define EVT_ClearEOCStatusGet_TXERR 3
+#define EVT_ClearEOCStatusGet_RXPROG 1
+#define EVT_ClearEOCStatusGet_RXDONE 2
+#define EVT_ClearEOCStatusGet_RXERR 3
+#define CMD_ClearEOCStatusSet_IDLE 0
+#define ACK_RA_ModeDS_Get_MANUAL 1
+#define ACK_RA_ModeDS_Get_AT_INIT 2
+#define ACK_RA_ModeDS_Get_DYNAMIC 3
+#define ACK_RA_ModeDS_Get_SOS 4
+#define ACK_RA_ModeUS_Get_MANUAL 1
+#define ACK_RA_ModeUS_Get_AT_INIT 2
+#define ACK_RA_ModeUS_Get_DYNAMIC 3
+#define ACK_RA_ModeUS_Get_SOS 4
+#define CMD_RTX_Control_RTX_DS_ENABLE 1
+#define CMD_RTX_Control_RTX_DSUS_ENABLE 2
+#define CMD_DSM_Control_OFF 0
+#define CMD_DSM_Control_FULL_VECTOR 1
+#define CMD_DSM_Control_FULL_VECTOR_FRIENDLY 2
+/* ----- Message Specific Constants Definition section (End) ----- */
+
+/** Message ID for CMD_BAT_TableEntriesGet */
+#define CMD_BAT_TABLEENTRIESGET 0x1703
+
+/**
+   Requests information about the bit-allocation per subcarrier in VDSL mode.
+   The values for all subcarriers of both directions can be retrieved. (For ADSL
+   use CMD_BAT_DS_Get and CMD_BAT_US_Get).
+*/
+typedef struct CMD_BAT_TableEntriesGet CMD_BAT_TableEntriesGet_t;
+
+/** Message ID for ACK_BAT_TableEntriesGet */
+#define ACK_BAT_TABLEENTRIESGET 0x1703
+
+/**
+   Returns information about the bit-allocation per tone for the chosen range of
+   subcarriers.(Section 7.5.1.29.1-2 of G.997.1)
+*/
+typedef struct ACK_BAT_TableEntriesGet ACK_BAT_TableEntriesGet_t;
+
+/** Message ID for CMD_GainTableEntriesGet */
+#define CMD_GAINTABLEENTRIESGET 0x1903
+
+/**
+   Requests information about the Gains per subcarrier. The values for all
+   subcarriers of both directions can be retrieved.(For ADSL use
+   CMD_GainTableDS_Get and CMD_GainTableUS_Get).
+*/
+typedef struct CMD_GainTableEntriesGet CMD_GainTableEntriesGet_t;
+
+/** Message ID for ACK_GainTableEntriesGet */
+#define ACK_GAINTABLEENTRIESGET 0x1903
+
+/**
+   Returns information about the Gain-per-tone for the chosen range of
+   subcarriers.(Section 7.5.1.29.3-4 of G.997.1)
+*/
+typedef struct ACK_GainTableEntriesGet ACK_GainTableEntriesGet_t;
+
+/** Message ID for CMD_SNR_NE_TableEntriesGet */
+#define CMD_SNR_NE_TABLEENTRIESGET 0x0B03
+
+/**
+   The message requests information about the SNR per subcarrier with virtual
+   noise for the near-end side , which means for downstream direction at the
+   CPE. It is the hosts responsibility to select the tone indices
+   accordingly.See also Table 20 "How to Retrieve Test Parameter Data" on Page
+   511.
+*/
+typedef struct CMD_SNR_NE_TableEntriesGet CMD_SNR_NE_TableEntriesGet_t;
+
+/** Message ID for ACK_SNR_NE_TableEntriesGet */
+#define ACK_SNR_NE_TABLEENTRIESGET 0x0B03
+
+/**
+   Returns information about the SNR per subcarrier with virtual noise for the
+   near-end side, meaning for downstream direction.
+*/
+typedef struct ACK_SNR_NE_TableEntriesGet ACK_SNR_NE_TableEntriesGet_t;
+
+/** Message ID for CMD_BAT_DS_Get */
+#define CMD_BAT_DS_GET 0x070E
+
+/**
+   Requests information about the downstream bit-allocation per subcarrier in
+   ADSL mode.
+*/
+typedef struct CMD_BAT_DS_Get CMD_BAT_DS_Get_t;
+
+/** Message ID for ACK_BAT_DS_Get */
+#define ACK_BAT_DS_GET 0x070E
+
+/**
+   Returns information about the downstream bit-allocation per tone for the
+   chosen range of subcarriers.(Section 7.5.1.29.1 of G.997.1)
+*/
+typedef struct ACK_BAT_DS_Get ACK_BAT_DS_Get_t;
+
+/** Message ID for CMD_BAT_US_Get */
+#define CMD_BAT_US_GET 0x060E
+
+/**
+   Requests information about the upstream bit-allocation per subcarrier in ADSL
+   mode.
+*/
+typedef struct CMD_BAT_US_Get CMD_BAT_US_Get_t;
+
+/** Message ID for ACK_BAT_US_Get */
+#define ACK_BAT_US_GET 0x060E
+
+/**
+   Returns information about the upstream bit-allocation per tone for the chosen
+   range of subcarriers.(Section 7.5.1.29.2 of G.997.1)
+*/
+typedef struct ACK_BAT_US_Get ACK_BAT_US_Get_t;
+
+/** Message ID for CMD_GainTableDS_Get */
+#define CMD_GAINTABLEDS_GET 0x090E
+
+/**
+   Requests information about the Gains per subcarrier for the downstream
+   direction.
+*/
+typedef struct CMD_GainTableDS_Get CMD_GainTableDS_Get_t;
+
+/** Message ID for ACK_GainTableDS_Get */
+#define ACK_GAINTABLEDS_GET 0x090E
+
+/**
+   Returns information about the Gain-per-tone for the chosen range of
+   subcarriers for the downstream direction.(Section 7.5.1.29.3 of G.997.1) as
+   requested by CMD_GainTableDS_Get.
+*/
+typedef struct ACK_GainTableDS_Get ACK_GainTableDS_Get_t;
+
+/** Message ID for CMD_GainTableUS_Get */
+#define CMD_GAINTABLEUS_GET 0x080E
+
+/**
+   Requests information about the Gains per subcarrier for the upstream
+   direction.
+*/
+typedef struct CMD_GainTableUS_Get CMD_GainTableUS_Get_t;
+
+/** Message ID for ACK_GainTableUS_Get */
+#define ACK_GAINTABLEUS_GET 0x080E
+
+/**
+   Returns information about the Gain-per-tone for the chosen range of
+   subcarriers for the upstream direction.(Section 7.5.1.29.4 of G.997.1)
+*/
+typedef struct ACK_GainTableUS_Get ACK_GainTableUS_Get_t;
+
+/** Message ID for CMD_ADSL_ExMarginReductionGet */
+#define CMD_ADSL_EXMARGINREDUCTIONGET 0x2F03
+
+/**
+   Requests information about the Excess Margin Reduction needed for the fine
+   gain calculation at the ATU_R.(See also ACK_GainTableDS_Get).
+*/
+typedef struct CMD_ADSL_ExMarginReductionGet CMD_ADSL_ExMarginReductionGet_t;
+
+/** Message ID for ACK_ADSL_ExMarginReductionGet */
+#define ACK_ADSL_EXMARGINREDUCTIONGET 0x2F03
+
+/**
+   Returns information about the Excess Margin Reduction for the downstream
+   direction.
+*/
+typedef struct ACK_ADSL_ExMarginReductionGet ACK_ADSL_ExMarginReductionGet_t;
+
+/** Message ID for CMD_HlogDS_Get */
+#define CMD_HLOGDS_GET 0x4A03
+
+/**
+   Requests information about the downstream HLOG information per subcarrier
+   group (Section 7.5.1.26.6 of G.997.1).During STEADY_STATE, the command can be
+   used in VDSL to request near-end data only (CPE). For the far-end HLOG to be
+   provided via the EOC channel CMD_TestParamsFE_Request must be used. In ADSL,
+   the command can be applied for near-end as well as far-end parameters.During
+   loop diagnostic mode, the command shall be used to request both near-end and
+   far-end data.
+*/
+typedef struct CMD_HlogDS_Get CMD_HlogDS_Get_t;
+
+/** Message ID for ACK_HlogDS_Get */
+#define ACK_HLOGDS_GET 0x4A03
+
+/**
+   Returns information about the downstream HLOG per subcarrier group for the
+   chosen range. (Section 7.5.1.26.6 of G.997.1)
+*/
+typedef struct ACK_HlogDS_Get ACK_HlogDS_Get_t;
+
+/** Message ID for CMD_HlogUS_Get */
+#define CMD_HLOGUS_GET 0x4B03
+
+/**
+   Requests information about the upstream HLOG information per subcarrier group
+   (Section 7.5.1.26.11 of G.997.1).
+*/
+typedef struct CMD_HlogUS_Get CMD_HlogUS_Get_t;
+
+/** Message ID for ACK_HlogUS_Get */
+#define ACK_HLOGUS_GET 0x4B03
+
+/**
+   Returns information about the upstream HLOG per subcarrier group for the
+   chosen range. (Section 7.5.1.26.11 of G.997.1)
+*/
+typedef struct ACK_HlogUS_Get ACK_HlogUS_Get_t;
+
+/** Message ID for CMD_HlinDS_Get */
+#define CMD_HLINDS_GET 0x4803
+
+/**
+   Requests information about the downstream HLIN information per subcarrier
+   group. (Section 7.5.1.26.3 of G.997.1).The HLIN data are available during
+   loop diagnostic mode only.
+*/
+typedef struct CMD_HlinDS_Get CMD_HlinDS_Get_t;
+
+/** Message ID for ACK_HlinDS_Get */
+#define ACK_HLINDS_GET 0x4803
+
+/**
+   Returns information about the downstream HLIN per subcarrier group for the
+   chosen range. (Section 7.5.1.26.3 of G.997.1)
+*/
+typedef struct ACK_HlinDS_Get ACK_HlinDS_Get_t;
+
+/** Message ID for CMD_HlinUS_Get */
+#define CMD_HLINUS_GET 0x4903
+
+/**
+   Requests information about the upstream HLIN information per subcarrier
+   group. (Section 7.5.1.26.9 of G.997.1).The HLIN data are available in loop
+   diagnostic mode only.
+*/
+typedef struct CMD_HlinUS_Get CMD_HlinUS_Get_t;
+
+/** Message ID for ACK_HlinUS_Get */
+#define ACK_HLINUS_GET 0x4903
+
+/**
+   Returns information about the upstream HLIN per subcarrier group for the
+   chosen range. (Section 7.5.1.26.9 of G.997.1)
+*/
+typedef struct ACK_HlinUS_Get ACK_HlinUS_Get_t;
+
+/** Message ID for CMD_QLN_DS_Get */
+#define CMD_QLN_DS_GET 0x4C03
+
+/**
+   Requests information about the downstream QLN information (QLNpsds) per
+   subcarrier group (Section 7.5.1.27.3 of G.997.1).During STEADY_STATE, the
+   command can be used in VDSL to request near-end data only (CPE).
+*/
+typedef struct CMD_QLN_DS_Get CMD_QLN_DS_Get_t;
+
+/** Message ID for ACK_QLN_DS_Get */
+#define ACK_QLN_DS_GET 0x4C03
+
+/**
+   Returns information about the QLN per subcarrier group for the chosen range.
+   (Section 7.5.1.27.3 of G.997.1)
+*/
+typedef struct ACK_QLN_DS_Get ACK_QLN_DS_Get_t;
+
+/** Message ID for CMD_QLN_US_Get */
+#define CMD_QLN_US_GET 0x4D03
+
+/**
+   Requests information about the upstream QLN (QLNpsus) per subcarrier group.
+   (Section 7.5.1.27.6 of G.997.1).
+*/
+typedef struct CMD_QLN_US_Get CMD_QLN_US_Get_t;
+
+/** Message ID for ACK_QLN_US_Get */
+#define ACK_QLN_US_GET 0x4D03
+
+/**
+   Returns information about the QLN per subcarrier group for the chosen range.
+   (Section 7.5.1.27.6 of G.997.1)
+*/
+typedef struct ACK_QLN_US_Get ACK_QLN_US_Get_t;
+
+/** Message ID for CMD_SNR_DS_Get */
+#define CMD_SNR_DS_GET 0x5503
+
+/**
+   Requests information about the downstream SNR per subcarrier group in VDSL or
+   the SNR per subcarrier in ADSL, both without considering virtual noise
+   (Section 7.5.1.28.3 of G.997.1).
+*/
+typedef struct CMD_SNR_DS_Get CMD_SNR_DS_Get_t;
+
+/** Message ID for ACK_SNR_DS_Get */
+#define ACK_SNR_DS_GET 0x5503
+
+/**
+   Returns information about the SNR per subcarrier (ADSL) or per subcarrier
+   group (VDSL) for the chosen range without considering virtual noise. (Section
+   7.5.1.28.3 of G.997.1)
+*/
+typedef struct ACK_SNR_DS_Get ACK_SNR_DS_Get_t;
+
+/** Message ID for CMD_SNR_US_Get */
+#define CMD_SNR_US_GET 0x4E03
+
+/**
+   Requests information about the upstream SNR per subcarrier group (Section
+   7.5.1.28.6 of G.997.1).
+*/
+typedef struct CMD_SNR_US_Get CMD_SNR_US_Get_t;
+
+/** Message ID for ACK_SNR_US_Get */
+#define ACK_SNR_US_GET 0x4E03
+
+/**
+   Returns information about the upstream SNR per subcarrier group for the
+   chosen range. (Section 7.5.1.28.6 of G.997.1)
+*/
+typedef struct ACK_SNR_US_Get ACK_SNR_US_Get_t;
+
+/** Message ID for CMD_TestParamsAuxDS_Get */
+#define CMD_TESTPARAMSAUXDS_GET 0x4F03
+
+/**
+   Requests test parameter related information for the downstream direction: The
+   HLIN scaling factor (HLINSCds), the subcarrier group size "G" and the
+   measurement times for HLOGpsds, QLNpsds, SNRpsds.(Sections 7.5.1.26.1/2/4/5,
+   7.5.1.27.1/2 and 7.5.1.28.1/2 of G.997.1)
+*/
+typedef struct CMD_TestParamsAuxDS_Get CMD_TestParamsAuxDS_Get_t;
+
+/** Message ID for ACK_TestParamsAuxDS_Get */
+#define ACK_TESTPARAMSAUXDS_GET 0x4F03
+
+/**
+   Provides the test-parameter related information as requested by
+   CMD_TestParamsAuxDS_Get: The HLIN scaling factor (HLINSCds), the subcarrier
+   group size "G" and the measurement times for HLOGpsds, QLNpsds,
+   SNRpsds.(Sections 7.5.1.26.1/2/4/5, 7.5.1.27.1/2 and 7.5.1.28.1/2 of G.997.1)
+*/
+typedef struct ACK_TestParamsAuxDS_Get ACK_TestParamsAuxDS_Get_t;
+
+/** Message ID for CMD_TestParamsAuxUS_Get */
+#define CMD_TESTPARAMSAUXUS_GET 0x5003
+
+/**
+   Requests test parameter related information for the upstream direction: The
+   HLIN scaling factor (HLINSCus), the subcarrier group size "G" and the
+   measurement times for HLOGpsus, QLNpsus, SNRpsus.For older VDSL FW versions
+   from w.6.x.y.z.a to 5.8.0.x.y.z: During STEADY_STATE, the command can be used
+   only to retrieve the "group size" parameters. To get the measurement time
+   parameters (via the EOC channel) the message CMD_TestParamsFE_Request must be
+   applied instead.(Sections 7.5.1.26.7/8/10/11, 7.5.1.27.4/5 and 7.5.1.28.4/5
+   of G.997.1)For older VDSL FW versions from w.6.x.y.z.a to 5.8.0.x.y.z: During
+   STEADY_STATE, the command can be used only to retrieve the "group size"
+   parameters. To get the measurement time parameters (via the EOC channel) the
+   message CMD_TestParamsFE_Request must be applied instead.The test parameters
+   can be requested during loop diagnostic mode (VDSL, ADSL) and in ADSL also
+   during STEADY_STATE.For older VDSL FW versions from w.6.x.y.z.a to
+   5.8.0.x.y.z: During STEADY_STATE, the command can be used only to retrieve
+   the "group size" parameters. To get the measurement time parameters (via the
+   EOC channel) the message CMD_TestParamsFE_Request must be applied instead.
+*/
+typedef struct CMD_TestParamsAuxUS_Get CMD_TestParamsAuxUS_Get_t;
+
+/** Message ID for ACK_TestParamsAuxUS_Get */
+#define ACK_TESTPARAMSAUXUS_GET 0x5003
+
+/**
+   Provides the test-parameter related information as requested by
+   CMD_TestParamsAuxUS_Get: The HLIN scaling factor (HLINSCus), the subcarrier
+   group size "G" and the measurement times for HLOGpsus, QLNpsus, SNRpsus.
+*/
+typedef struct ACK_TestParamsAuxUS_Get ACK_TestParamsAuxUS_Get_t;
+
+/** Message ID for CMD_TestParamsFE_Request */
+#define CMD_TESTPARAMSFE_REQUEST 0x0849
+
+/**
+   This message is used to trigger retrieval of the far-end PMD Test Parameters
+   Hlog, SNR and QLN via the EOC channel during Showtime. If StartIndex or
+   EndIndex do not contain values in a valid range then no autonomous message
+   will be sent by the firmware. Once the retrieval process is started, it can
+   also be aborted with this message via the control parameter. The status of
+   the parameter retrieval process can be polled via the CMD_TestParamsFE_Poll
+   message. Once the parameters are retrieved, they are provided with the
+   EVT_PMD_TestParamsGet message.
+*/
+typedef struct CMD_TestParamsFE_Request CMD_TestParamsFE_Request_t;
+
+/** Message ID for ACK_TestParamsFE_Request */
+#define ACK_TESTPARAMSFE_REQUEST 0x0849
+
+/**
+   This is the acknowledgement for CMD_TestParamsFE_Request.
+*/
+typedef struct ACK_TestParamsFE_Request ACK_TestParamsFE_Request_t;
+
+/** Message ID for CMD_TestParamsFE_Poll */
+#define CMD_TESTPARAMSFE_POLL 0x0809
+
+/**
+   This message polls the status of the far end parameter retrieval process.
+*/
+typedef struct CMD_TestParamsFE_Poll CMD_TestParamsFE_Poll_t;
+
+/** Message ID for ACK_TestParamsFE_Poll */
+#define ACK_TESTPARAMSFE_POLL 0x0809
+
+/**
+   This is the acknowledgement for CMD_TestParamsFE_Poll.
+*/
+typedef struct ACK_TestParamsFE_Poll ACK_TestParamsFE_Poll_t;
+
+/** Message ID for EVT_PMD_TestParamsGet */
+#define EVT_PMD_TESTPARAMSGET 0x5803
+
+/**
+   This event message provides the far-end data after the far end data retrieval
+   process. This message is a result of the CMD_TestParamsFE_Request message.
+*/
+typedef struct EVT_PMD_TestParamsGet EVT_PMD_TestParamsGet_t;
+
+/** Message ID for CMD_ClearEOC_Configure */
+#define CMD_CLEAREOC_CONFIGURE 0x0A49
+
+/**
+   The message is used to configure the autonomous messaging related to Clear
+   EOC transmission.
+*/
+typedef struct CMD_ClearEOC_Configure CMD_ClearEOC_Configure_t;
+
+/** Message ID for ACK_ClearEOC_Configure */
+#define ACK_CLEAREOC_CONFIGURE 0x0A49
+
+/**
+   This is the acknowledgement for CMD_ClearEOC_Configure.
+*/
+typedef struct ACK_ClearEOC_Configure ACK_ClearEOC_Configure_t;
+
+/** Message ID for CMD_ClearEOC_TxTrigger */
+#define CMD_CLEAREOC_TXTRIGGER 0x0949
+
+/**
+   The message is used to trigger the transmission of  Clear EOC messages that
+   were placed into the Clear EOC transmit buffer before with
+   CMD_ClearEOC_Write.
+*/
+typedef struct CMD_ClearEOC_TxTrigger CMD_ClearEOC_TxTrigger_t;
+
+/** Message ID for ACK_ClearEOC_TxTrigger */
+#define ACK_CLEAREOC_TXTRIGGER 0x0949
+
+/**
+   This is the acknowledgement for CMD_ClearEOC_TxTrigger.
+*/
+typedef struct ACK_ClearEOC_TxTrigger ACK_ClearEOC_TxTrigger_t;
+
+/** Message ID for CMD_ClearEOC_Write */
+#define CMD_CLEAREOC_WRITE 0x5143
+
+/**
+   This message is used to write data to the ClearEOC write buffer of type
+   VRX_ClearEOC_t. When the buffer is filled, the transmission is started
+   applying CMD_ClearEOC_TxTrigger. If the message to transmit is longer than
+   the mailbox size, a sequence of writes to the ClearEOC buffer has to be done
+   before the transmission is started with CMD_ClearEOC_TxTrigger. When
+   autonomous TX status messaging is activated via CMD_ClearEOC_Configure, then
+   the finished transmission is indicated by EVT_ClearEOCStatusGet.
+*/
+typedef struct CMD_ClearEOC_Write CMD_ClearEOC_Write_t;
+
+/** Message ID for ACK_ClearEOC_Write */
+#define ACK_CLEAREOC_WRITE 0x5143
+
+/**
+   This message is the acknowledgement for CMD_ClearEOC_Write.
+*/
+typedef struct ACK_ClearEOC_Write ACK_ClearEOC_Write_t;
+
+/** Message ID for CMD_ClearEOC_Read */
+#define CMD_CLEAREOC_READ 0x5203
+
+/**
+   This message is used to read data from the ClearEOC buffer of type
+   VRX_ClearEOC_t. The length of the actual Clear EOC message can be found in
+   the buffer. Please refer to VRX_ClearEOC_t. The availability of data can
+   either be checked via CMD_ClearEOCStatusGet in polling mode or it can be
+   reported by an autonomous EVT_ClearEOCStatusGet message when data is received
+   (to be enabled using CMD_ClearEOC_Configure).
+*/
+typedef struct CMD_ClearEOC_Read CMD_ClearEOC_Read_t;
+
+/** Message ID for ACK_ClearEOC_Read */
+#define ACK_CLEAREOC_READ 0x5203
+
+/**
+   This message is the acknowledgement to CMD_ClearEOC_Read.
+*/
+typedef struct ACK_ClearEOC_Read ACK_ClearEOC_Read_t;
+
+/** Message ID for EVT_ClearEOC_Read */
+#define EVT_CLEAREOC_READ 0x5203
+
+/**
+   This message is an autonomous message that is generated when ClearEOC data
+   was received and autonomous Clear EOC data messaging has been activated via
+   CMD_ClearEOC_Configure. If the ClearEOC data does not fit in one message,
+   then a sequence of messages is generated. The ClearEOC buffer is of type
+   VRX_ClearEOC_t.
+*/
+typedef struct EVT_ClearEOC_Read EVT_ClearEOC_Read_t;
+
+/** Message ID for CMD_ClearEOCStatusGet */
+#define CMD_CLEAREOCSTATUSGET 0x0B09
+
+/**
+   This message is used to retrieve the status of the clear eoc data
+   transmission.
+*/
+typedef struct CMD_ClearEOCStatusGet CMD_ClearEOCStatusGet_t;
+
+/** Message ID for ACK_ClearEOCStatusGet */
+#define ACK_CLEAREOCSTATUSGET 0x0B09
+
+/**
+   This is the acknowledgement for CMD_ClearEOCStatusGet.
+*/
+typedef struct ACK_ClearEOCStatusGet ACK_ClearEOCStatusGet_t;
+
+/** Message ID for EVT_ClearEOCStatusGet */
+#define EVT_CLEAREOCSTATUSGET 0x0B09
+
+/**
+   This autonomous message reports the Clear EOC status. It is sent only if the
+   "Autonomous Status Message Control" was enabled for TX and/or RX direction
+   with CMD_ClearEOC_Configure. If TX direction is enabled, the message is
+   generated when a TX transmission is finished or failed. If RX direction is
+   enabled, the message is generated when the RX status transitions from "Idle"
+   to "Data Available" for retrieval by the host.
+*/
+typedef struct EVT_ClearEOCStatusGet EVT_ClearEOCStatusGet_t;
+
+/** Message ID for CMD_ClearEOCStatusSet */
+#define CMD_CLEAREOCSTATUSSET 0x0B49
+
+/**
+   The message is used to reset the transmit or receive status of the clear eoc
+   data transmission to IDLE (for defined states see also
+   CMD_ClearEOCStatusGet). See the description on the Clear EOC handling on Page
+   555 for when it has to be applied. Transmit and receive status are
+   distinguished by the Index parameter.
+*/
+typedef struct CMD_ClearEOCStatusSet CMD_ClearEOCStatusSet_t;
+
+/** Message ID for ACK_ClearEOCStatusSet */
+#define ACK_CLEAREOCSTATUSSET 0x0B49
+
+/**
+   This is the acknowledgement for CMD_ClearEOCStatusSet.
+*/
+typedef struct ACK_ClearEOCStatusSet ACK_ClearEOCStatusSet_t;
+
+/** Message ID for CMD_OH_OptionsSet */
+#define CMD_OH_OPTIONSSET 0x1945
+
+/**
+   Configuration of options for the overhead handling.
+*/
+typedef struct CMD_OH_OptionsSet CMD_OH_OptionsSet_t;
+
+/** Message ID for ACK_OH_OptionsSet */
+#define ACK_OH_OPTIONSSET 0x1945
+
+/**
+   Acknowledgement for CMD_OH_OptionsSet.
+*/
+typedef struct ACK_OH_OptionsSet ACK_OH_OptionsSet_t;
+
+/** Message ID for CMD_OH_StatsGet */
+#define CMD_OH_STATSGET 0x0F03
+
+/**
+   Requests OH polling statistic information.
+*/
+typedef struct CMD_OH_StatsGet CMD_OH_StatsGet_t;
+
+/** Message ID for ACK_OH_StatsGet */
+#define ACK_OH_STATSGET 0x0F03
+
+/**
+   Reports the OH polling statistics as requested by CMD_OH_StatsGet.
+*/
+typedef struct ACK_OH_StatsGet ACK_OH_StatsGet_t;
+
+/** Message ID for CMD_RRC_ROC_Tones_DS_Get */
+#define CMD_RRC_ROC_TONES_DS_GET 0xF703
+
+/**
+   Requests RRC and ROC downstream tones for VDSL2 operated in RTX mode.
+*/
+typedef struct CMD_RRC_ROC_Tones_DS_Get CMD_RRC_ROC_Tones_DS_Get_t;
+
+/** Message ID for ACK_RRC_ROC_Tones_DS_Get */
+#define ACK_RRC_ROC_TONES_DS_GET 0xF703
+
+/**
+   Provides RRC and ROC downstream tones for VDSL2 operated in RTX mode.
+*/
+typedef struct ACK_RRC_ROC_Tones_DS_Get ACK_RRC_ROC_Tones_DS_Get_t;
+
+/** Message ID for CMD_RRC_ROC_Tones_US_Get */
+#define CMD_RRC_ROC_TONES_US_GET 0xF803
+
+/**
+   Requests RRC and ROC upstream tones for VDSL2 operated in RTX mode.
+*/
+typedef struct CMD_RRC_ROC_Tones_US_Get CMD_RRC_ROC_Tones_US_Get_t;
+
+/** Message ID for ACK_RRC_ROC_Tones_US_Get */
+#define ACK_RRC_ROC_TONES_US_GET 0xF803
+
+/**
+   Provides RRC and ROC upstream tones for VDSL2 operated in RTX mode.
+*/
+typedef struct ACK_RRC_ROC_Tones_US_Get ACK_RRC_ROC_Tones_US_Get_t;
+
+/** Message ID for CMD_OLR_Control */
+#define CMD_OLR_CONTROL 0x0F45
+
+/**
+   Enables/Disables support for OLR events (Bitswaps, SRA, SOS, ROC).An OLR
+   transition is always initiated by the receiving PMD, so the CPE requests the
+   OLR event for downstream direction.
+*/
+typedef struct CMD_OLR_Control CMD_OLR_Control_t;
+
+/** Message ID for ACK_OLR_Control */
+#define ACK_OLR_CONTROL 0x0F45
+
+/**
+   Acknowledgement for CMD_OLR_Control.
+*/
+typedef struct ACK_OLR_Control ACK_OLR_Control_t;
+
+/** Message ID for CMD_OLR_US_StatsGet */
+#define CMD_OLR_US_STATSGET 0x5F03
+
+/**
+   Requests the OLR status information on bit swaps, DRR, SRA and SOS events for
+   the upstream direction.
+*/
+typedef struct CMD_OLR_US_StatsGet CMD_OLR_US_StatsGet_t;
+
+/** Message ID for ACK_OLR_US_StatsGet */
+#define ACK_OLR_US_STATSGET 0x5F03
+
+/**
+   Reports the OLR status information for the upstream direction as requested by
+   CMD_OLR_US_StatsGet.
+*/
+typedef struct ACK_OLR_US_StatsGet ACK_OLR_US_StatsGet_t;
+
+/** Message ID for CMD_OLR_DS_StatsGet */
+#define CMD_OLR_DS_STATSGET 0x6003
+
+/**
+   Requests the OLR status information on bit swaps, DRR, SRA and SOS events for
+   the downstream direction.
+*/
+typedef struct CMD_OLR_DS_StatsGet CMD_OLR_DS_StatsGet_t;
+
+/** Message ID for ACK_OLR_DS_StatsGet */
+#define ACK_OLR_DS_STATSGET 0x6003
+
+/**
+   Reports the OLR status information for the downstream direction as requested
+   by CMD_OLR_DS_StatsGet.
+*/
+typedef struct ACK_OLR_DS_StatsGet ACK_OLR_DS_StatsGet_t;
+
+/** Message ID for CMD_RA_ModeDS_Get */
+#define CMD_RA_MODEDS_GET 0xD903
+
+/**
+   Requests the actual active downstream RA mode (ACT-RA-MODEds, Section
+   7.5.1.33.1 of G.997.1).
+*/
+typedef struct CMD_RA_ModeDS_Get CMD_RA_ModeDS_Get_t;
+
+/** Message ID for ACK_RA_ModeDS_Get */
+#define ACK_RA_MODEDS_GET 0xD903
+
+/**
+   Reports the actual active downstream RA mode (ACT-RA-MODEds) as requested by
+   CMD_RA_ModeDS_Get.
+*/
+typedef struct ACK_RA_ModeDS_Get ACK_RA_ModeDS_Get_t;
+
+/** Message ID for CMD_RA_ModeUS_Get */
+#define CMD_RA_MODEUS_GET 0xDB03
+
+/**
+   Requests the actual active upstream RA mode (ACT-RA-MODEus, Section
+   7.5.1.33.2 of G.997.1).
+*/
+typedef struct CMD_RA_ModeUS_Get CMD_RA_ModeUS_Get_t;
+
+/** Message ID for ACK_RA_ModeUS_Get */
+#define ACK_RA_MODEUS_GET 0xDB03
+
+/**
+   Reports the actual active upstream RA mode (ACT-RA-MODEus) as requested by
+   CMD_RA_ModeUS_Get.
+*/
+typedef struct ACK_RA_ModeUS_Get ACK_RA_ModeUS_Get_t;
+
+/** Message ID for EVT_OLR_US_EventGet */
+#define EVT_OLR_US_EVENTGET 0x0307
+
+/**
+   Autonomous message indicating a successful upstream OLR event (SRA or SOS).
+*/
+typedef struct EVT_OLR_US_EventGet EVT_OLR_US_EventGet_t;
+
+/** Message ID for EVT_OLR_DS_EventGet */
+#define EVT_OLR_DS_EVENTGET 0x0407
+
+/**
+   Autonomous message indicating a successful downstream OLR event (SRA or SOS).
+*/
+typedef struct EVT_OLR_DS_EventGet EVT_OLR_DS_EventGet_t;
+
+/** Message ID for CMD_OLR_US_EventConfigure */
+#define CMD_OLR_US_EVENTCONFIGURE 0x0F49
+
+/**
+   Enables/Disables the generation of EVENT messages (EVT) for specific upstream
+   OLR events. If the corresponding Enable bit for an OLR event is set, then the
+   modem firmware will send an autonomous message EVT_OLR_US_EventGet if the OLR
+   event happened in the last 1-second interval.
+*/
+typedef struct CMD_OLR_US_EventConfigure CMD_OLR_US_EventConfigure_t;
+
+/** Message ID for ACK_OLR_US_EventConfigure */
+#define ACK_OLR_US_EVENTCONFIGURE 0x0F49
+
+/**
+   Acknoledgement for CMD_OLR_US_EventConfigure.
+*/
+typedef struct ACK_OLR_US_EventConfigure ACK_OLR_US_EventConfigure_t;
+
+/** Message ID for CMD_OLR_DS_EventConfigure */
+#define CMD_OLR_DS_EVENTCONFIGURE 0x1049
+
+/**
+   Enables/Disables the generation of EVENT messages (EVT) for specific
+   downstream OLR events. If the corresponding Enable bit for an OLR event is
+   set, then the modem firmware will send an autonomous message
+   EVT_OLR_DS_EventGet if the OLR event happened in the last 1-second interval.
+*/
+typedef struct CMD_OLR_DS_EventConfigure CMD_OLR_DS_EventConfigure_t;
+
+/** Message ID for ACK_OLR_DS_EventConfigure */
+#define ACK_OLR_DS_EVENTCONFIGURE 0x1049
+
+/**
+   Acknoledgement for CMD_OLR_DS_EventConfigure.
+*/
+typedef struct ACK_OLR_DS_EventConfigure ACK_OLR_DS_EventConfigure_t;
+
+/** Message ID for CMD_RTX_Control */
+#define CMD_RTX_CONTROL 0x5048
+
+/**
+   Configures a link for retransmission of downstream data. For using the RTX
+   function, this message has to be sent.
+*/
+typedef struct CMD_RTX_Control CMD_RTX_Control_t;
+
+/** Message ID for ACK_RTX_Control */
+#define ACK_RTX_CONTROL 0x5048
+
+/**
+   Acknowledgement for CMD_RTX_Control.
+*/
+typedef struct ACK_RTX_Control ACK_RTX_Control_t;
+
+/** Message ID for CMD_RTX_BearerChsDS_Get */
+#define CMD_RTX_BEARERCHSDS_GET 0x0206
+
+/**
+   Requests RTX specific status information for the downstream bearer channels
+   if G.INP retransmission is used.
+*/
+typedef struct CMD_RTX_BearerChsDS_Get CMD_RTX_BearerChsDS_Get_t;
+
+/** Message ID for ACK_RTX_BearerChsDS_Get */
+#define ACK_RTX_BEARERCHSDS_GET 0x0206
+
+/**
+   Delivers status information for the downstream bearer channels when G.INP
+   retransmission is actually used.
+*/
+typedef struct ACK_RTX_BearerChsDS_Get ACK_RTX_BearerChsDS_Get_t;
+
+/** Message ID for CMD_RTX_BearerChsUS_Get */
+#define CMD_RTX_BEARERCHSUS_GET 0x0306
+
+/**
+   Requests RTX specific status information for the upstream bearer channels if
+   upstream G.INP retransmission is used.
+*/
+typedef struct CMD_RTX_BearerChsUS_Get CMD_RTX_BearerChsUS_Get_t;
+
+/** Message ID for ACK_RTX_BearerChsUS_Get */
+#define ACK_RTX_BEARERCHSUS_GET 0x0306
+
+/**
+   Delivers status information for the upstream bearer channels when upstream
+   G.INP retransmission is used.
+*/
+typedef struct ACK_RTX_BearerChsUS_Get ACK_RTX_BearerChsUS_Get_t;
+
+/** Message ID for CMD_RTX_PM_DS_Get */
+#define CMD_RTX_PM_DS_GET 0x2B0A
+
+/**
+   Requests performance monitoring counters for downstream G.INP retransmission.
+*/
+typedef struct CMD_RTX_PM_DS_Get CMD_RTX_PM_DS_Get_t;
+
+/** Message ID for ACK_RTX_PM_DS_Get */
+#define ACK_RTX_PM_DS_GET 0x2B0A
+
+/**
+   Delivers performance monitoring counters for downstream G.INP retransmission.
+*/
+typedef struct ACK_RTX_PM_DS_Get ACK_RTX_PM_DS_Get_t;
+
+/** Message ID for CMD_RTX_PM_US_Get */
+#define CMD_RTX_PM_US_GET 0x3B0A
+
+/**
+   Requests performance monitoring counters for upstream G.INP retransmission.
+*/
+typedef struct CMD_RTX_PM_US_Get CMD_RTX_PM_US_Get_t;
+
+/** Message ID for ACK_RTX_PM_US_Get */
+#define ACK_RTX_PM_US_GET 0x3B0A
+
+/**
+   Delivers performance monitoring counters for upstream G.INP retransmission.
+   They are all far-end parameters received from CO.
+*/
+typedef struct ACK_RTX_PM_US_Get ACK_RTX_PM_US_Get_t;
+
+/** Message ID for CMD_RTX_DS_StatsGet */
+#define CMD_RTX_DS_STATSGET 0x2C0A
+
+/**
+   Requests DTU counters for G.INP downstream retransmission.
+*/
+typedef struct CMD_RTX_DS_StatsGet CMD_RTX_DS_StatsGet_t;
+
+/** Message ID for ACK_RTX_DS_StatsGet */
+#define ACK_RTX_DS_STATSGET 0x2C0A
+
+/**
+   Delivers DTU counters for G.INP downstream retransmission. The counters are
+   Non-TR1 wrap-around counters, which are reset at reboot only.
+*/
+typedef struct ACK_RTX_DS_StatsGet ACK_RTX_DS_StatsGet_t;
+
+/** Message ID for CMD_RTX_US_StatsGet */
+#define CMD_RTX_US_STATSGET 0x3A0A
+
+/**
+   Requests DTU counters for G.INP upstream retransmission, which is defined for
+   VDSL only.
+*/
+typedef struct CMD_RTX_US_StatsGet CMD_RTX_US_StatsGet_t;
+
+/** Message ID for ACK_RTX_US_StatsGet */
+#define ACK_RTX_US_STATSGET 0x3A0A
+
+/**
+   Delivers DTU counters for G.INP upstream retransmission. The counters are
+   Non-TR1 wrap-around counters, which are reset at reboot only.
+*/
+typedef struct ACK_RTX_US_StatsGet ACK_RTX_US_StatsGet_t;
+
+/** Message ID for CMD_RTX_StatusGet */
+#define CMD_RTX_STATUSGET 0xE503
+
+/**
+   Requests the actually used G.INP retransmission status.
+*/
+typedef struct CMD_RTX_StatusGet CMD_RTX_StatusGet_t;
+
+/** Message ID for ACK_RTX_StatusGet */
+#define ACK_RTX_STATUSGET 0xE503
+
+/**
+   Provides the actually used G.INP retransmission status.
+*/
+typedef struct ACK_RTX_StatusGet ACK_RTX_StatusGet_t;
+
+/** Message ID for CMD_RTX_US_FrameDataGet */
+#define CMD_RTX_US_FRAMEDATAGET 0xED03
+
+/**
+   Requests upstream G.INP retransmission specific framing parameters and other
+   status parameters. They are always associated with bearer channel 0.
+*/
+typedef struct CMD_RTX_US_FrameDataGet CMD_RTX_US_FrameDataGet_t;
+
+/** Message ID for ACK_RTX_US_FrameDataGet */
+#define ACK_RTX_US_FRAMEDATAGET 0xED03
+
+/**
+   Delivers upstream retransmission specific framing parameters and other status
+   parameters, as requested by CMD_RTX_US_FrameDataGet. They are always
+   associated with bearer channel 0.In addition, the usual framing parameters
+   are to be retrieved with CMD_FrameDataExt2US_Get.
+*/
+typedef struct ACK_RTX_US_FrameDataGet ACK_RTX_US_FrameDataGet_t;
+
+/** Message ID for CMD_RTX_US_Roundtrip_Get */
+#define CMD_RTX_US_ROUNDTRIP_GET 0xEF03
+
+/**
+   Requests the G.INP upstream retransmission measured roundtrip.
+*/
+typedef struct CMD_RTX_US_Roundtrip_Get CMD_RTX_US_Roundtrip_Get_t;
+
+/** Message ID for ACK_RTX_US_Roundtrip_Get */
+#define ACK_RTX_US_ROUNDTRIP_GET 0xEF03
+
+/**
+   Provides the G.INP upstream retransmission measured roundtrip delay. For
+   measuring the roundtrip, following difference is built when a correct RRC
+   codeword has been received: AbsoluteDTUCount of transmitter for next possible
+   DTU transmission minus AbsoluteDTUCount as received in RRC codeword.
+*/
+typedef struct ACK_RTX_US_Roundtrip_Get ACK_RTX_US_Roundtrip_Get_t;
+
+/** Message ID for CMD_DSM_Control */
+#define CMD_DSM_CONTROL 0x5248
+
+/**
+   Enables/Disables support for full vectoring (G.993.5) and full vector-
+   friendly operation (G.993.2 Annex Y). In case of ADSL, this only means the
+   indication of the (VDSL) vectoring capabilities during G.Handshake.
+*/
+typedef struct CMD_DSM_Control CMD_DSM_Control_t;
+
+/** Message ID for ACK_DSM_Control */
+#define ACK_DSM_CONTROL 0x5248
+
+/**
+   Acknowledgement to CMD_DSM_Control.
+*/
+typedef struct ACK_DSM_Control ACK_DSM_Control_t;
+
+/** Message ID for EVT_DSM_ErrorVectorReady */
+#define EVT_DSM_ERRORVECTORREADY 0x1109
+
+/**
+   This autononmous message indicates that new downstream DSM error vector data
+   were written by the DSL FW into the SDRAM. Generation of this EVT message is
+   enabled/disabled together with the G.993.5 vectoring functionality itself, by
+   means of CMD_DSM_Control, parameter "Vector".
+*/
+typedef struct EVT_DSM_ErrorVectorReady EVT_DSM_ErrorVectorReady_t;
+
+/** Message ID for CMD_DSM_StatsGet */
+#define CMD_DSM_STATSGET 0x370A
+
+/**
+   Requests vectoring debug counter values.
+*/
+typedef struct CMD_DSM_StatsGet CMD_DSM_StatsGet_t;
+
+/** Message ID for ACK_DSM_StatsGet */
+#define ACK_DSM_STATSGET 0x370A
+
+/**
+   Delivers vectoring debug counters.
+*/
+typedef struct ACK_DSM_StatsGet ACK_DSM_StatsGet_t;
+
+/**
+   Requests information about the bit-allocation per subcarrier in VDSL mode.
+   The values for all subcarriers of both directions can be retrieved. (For ADSL
+   use CMD_BAT_DS_Get and CMD_BAT_US_Get).
+*/
+struct CMD_BAT_TableEntriesGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the bit-allocation per tone for the chosen range of
+   subcarriers.(Section 7.5.1.29.1-2 of G.997.1)
+*/
+struct ACK_BAT_TableEntriesGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Bit Allocation */
+   VRX_BAT_TableEntry_t BAT[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Bit Allocation */
+   VRX_BAT_TableEntry_t BAT[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests information about the Gains per subcarrier. The values for all
+   subcarriers of both directions can be retrieved.(For ADSL use
+   CMD_GainTableDS_Get and CMD_GainTableUS_Get).
+*/
+struct CMD_GainTableEntriesGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the Gain-per-tone for the chosen range of
+   subcarriers.(Section 7.5.1.29.3-4 of G.997.1)
+*/
+struct ACK_GainTableEntriesGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Gains */
+   DSL_uint16_t Gains[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Gains */
+   DSL_uint16_t Gains[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message requests information about the SNR per subcarrier with virtual
+   noise for the near-end side , which means for downstream direction at the
+   CPE. It is the hosts responsibility to select the tone indices
+   accordingly.See also Table 20 "How to Retrieve Test Parameter Data" on Page
+   511.
+*/
+struct CMD_SNR_NE_TableEntriesGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the SNR per subcarrier with virtual noise for the
+   near-end side, meaning for downstream direction.
+*/
+struct ACK_SNR_NE_TableEntriesGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** SNR */
+   DSL_uint16_t SNRps[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** SNR */
+   DSL_uint16_t SNRps[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests information about the downstream bit-allocation per subcarrier in
+   ADSL mode.
+*/
+struct CMD_BAT_DS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the downstream bit-allocation per tone for the
+   chosen range of subcarriers.(Section 7.5.1.29.1 of G.997.1)
+*/
+struct ACK_BAT_DS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Bit Allocation */
+   VRX_BAT_TableEntry_t BAT[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Bit Allocation */
+   VRX_BAT_TableEntry_t BAT[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests information about the upstream bit-allocation per subcarrier in ADSL
+   mode.
+*/
+struct CMD_BAT_US_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the upstream bit-allocation per tone for the chosen
+   range of subcarriers.(Section 7.5.1.29.2 of G.997.1)
+*/
+struct ACK_BAT_US_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Bit Allocation */
+   VRX_BAT_TableEntry_t BAT[32];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Bit Allocation */
+   VRX_BAT_TableEntry_t BAT[32];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests information about the Gains per subcarrier for the downstream
+   direction.
+*/
+struct CMD_GainTableDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the Gain-per-tone for the chosen range of
+   subcarriers for the downstream direction.(Section 7.5.1.29.3 of G.997.1) as
+   requested by CMD_GainTableDS_Get.
+*/
+struct ACK_GainTableDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Gains */
+   DSL_uint16_t Gains[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Gains */
+   DSL_uint16_t Gains[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests information about the Gains per subcarrier for the upstream
+   direction.
+*/
+struct CMD_GainTableUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the Gain-per-tone for the chosen range of
+   subcarriers for the upstream direction.(Section 7.5.1.29.4 of G.997.1)
+*/
+struct ACK_GainTableUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Gains */
+   DSL_uint16_t Gains[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Gains */
+   DSL_uint16_t Gains[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests information about the Excess Margin Reduction needed for the fine
+   gain calculation at the ATU_R.(See also ACK_GainTableDS_Get).
+*/
+struct CMD_ADSL_ExMarginReductionGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the Excess Margin Reduction for the downstream
+   direction.
+*/
+struct ACK_ADSL_ExMarginReductionGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Excess Margin Reduction  */
+   DSL_uint16_t eSnrmReduction;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Excess Margin Reduction  */
+   DSL_uint16_t eSnrmReduction;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests information about the downstream HLOG information per subcarrier
+   group (Section 7.5.1.26.6 of G.997.1).During STEADY_STATE, the command can be
+   used in VDSL to request near-end data only (CPE). For the far-end HLOG to be
+   provided via the EOC channel CMD_TestParamsFE_Request must be used. In ADSL,
+   the command can be applied for near-end as well as far-end parameters.During
+   loop diagnostic mode, the command shall be used to request both near-end and
+   far-end data.
+*/
+struct CMD_HlogDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the downstream HLOG per subcarrier group for the
+   chosen range. (Section 7.5.1.26.6 of G.997.1)
+*/
+struct ACK_HlogDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** HLOG per SG: HLOGpsds */
+   DSL_uint16_t HLOGpsds[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** HLOG per SG: HLOGpsds */
+   DSL_uint16_t HLOGpsds[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests information about the upstream HLOG information per subcarrier group
+   (Section 7.5.1.26.11 of G.997.1).
+*/
+struct CMD_HlogUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the upstream HLOG per subcarrier group for the
+   chosen range. (Section 7.5.1.26.11 of G.997.1)
+*/
+struct ACK_HlogUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** HLOG per SG: HLOGpsus */
+   DSL_uint16_t HLOGpsus[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** HLOG per SG: HLOGpsus */
+   DSL_uint16_t HLOGpsus[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests information about the downstream HLIN information per subcarrier
+   group. (Section 7.5.1.26.3 of G.997.1).The HLIN data are available during
+   loop diagnostic mode only.
+*/
+struct CMD_HlinDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the downstream HLIN per subcarrier group for the
+   chosen range. (Section 7.5.1.26.3 of G.997.1)
+*/
+struct ACK_HlinDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** HLIN per SG: HLINpsds */
+   VRX_HLIN_t HLINpsds[64];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** HLIN per SG: HLINpsds */
+   VRX_HLIN_t HLINpsds[64];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests information about the upstream HLIN information per subcarrier
+   group. (Section 7.5.1.26.9 of G.997.1).The HLIN data are available in loop
+   diagnostic mode only.
+*/
+struct CMD_HlinUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the upstream HLIN per subcarrier group for the
+   chosen range. (Section 7.5.1.26.9 of G.997.1)
+*/
+struct ACK_HlinUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** HLIN per SG: HLINpsus */
+   VRX_HLIN_t HLINpsus[64];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** HLIN per SG: HLINpsus */
+   VRX_HLIN_t HLINpsus[64];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests information about the downstream QLN information (QLNpsds) per
+   subcarrier group (Section 7.5.1.27.3 of G.997.1).During STEADY_STATE, the
+   command can be used in VDSL to request near-end data only (CPE).
+*/
+struct CMD_QLN_DS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the QLN per subcarrier group for the chosen range.
+   (Section 7.5.1.27.3 of G.997.1)
+*/
+struct ACK_QLN_DS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** QLN per SG: QLNpsds */
+   VRX_QLN_NE_t QLNds[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** QLN per SG: QLNpsds */
+   VRX_QLN_NE_t QLNds[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests information about the upstream QLN (QLNpsus) per subcarrier group.
+   (Section 7.5.1.27.6 of G.997.1).
+*/
+struct CMD_QLN_US_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the QLN per subcarrier group for the chosen range.
+   (Section 7.5.1.27.6 of G.997.1)
+*/
+struct ACK_QLN_US_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** QLN per SG: QLNpsus */
+   VRX_QLN_NE_t QLNus[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** QLN per SG: QLNpsus */
+   VRX_QLN_NE_t QLNus[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests information about the downstream SNR per subcarrier group in VDSL or
+   the SNR per subcarrier in ADSL, both without considering virtual noise
+   (Section 7.5.1.28.3 of G.997.1).
+*/
+struct CMD_SNR_DS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the SNR per subcarrier (ADSL) or per subcarrier
+   group (VDSL) for the chosen range without considering virtual noise. (Section
+   7.5.1.28.3 of G.997.1)
+*/
+struct ACK_SNR_DS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** SNR per SG: SNRpsds */
+   VRX_SNR_t SNRpsds[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** SNR per SG: SNRpsds */
+   VRX_SNR_t SNRpsds[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests information about the upstream SNR per subcarrier group (Section
+   7.5.1.28.6 of G.997.1).
+*/
+struct CMD_SNR_US_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns information about the upstream SNR per subcarrier group for the
+   chosen range. (Section 7.5.1.28.6 of G.997.1)
+*/
+struct ACK_SNR_US_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** SNR per SG: SNRpsus */
+   VRX_SNR_t SNRpsus[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** SNR per SG: SNRpsus */
+   VRX_SNR_t SNRpsus[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests test parameter related information for the downstream direction: The
+   HLIN scaling factor (HLINSCds), the subcarrier group size "G" and the
+   measurement times for HLOGpsds, QLNpsds, SNRpsds.(Sections 7.5.1.26.1/2/4/5,
+   7.5.1.27.1/2 and 7.5.1.28.1/2 of G.997.1)
+*/
+struct CMD_TestParamsAuxDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the test-parameter related information as requested by
+   CMD_TestParamsAuxDS_Get: The HLIN scaling factor (HLINSCds), the subcarrier
+   group size "G" and the measurement times for HLOGpsds, QLNpsds,
+   SNRpsds.(Sections 7.5.1.26.1/2/4/5, 7.5.1.27.1/2 and 7.5.1.28.1/2 of G.997.1)
+*/
+struct ACK_TestParamsAuxDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** HLIN Scaling Factor "HLINSCds" */
+   DSL_uint16_t HLINSC;
+   /** HLIN Subcarrier Group Size DS "HLINGds" */
+   DSL_uint16_t HLING;
+   /** HLOG Measurement Time "HLOGMTds" */
+   DSL_uint16_t HLOGMT;
+   /** HLOG Subcarrier Group Size DS "HLOGGds" */
+   DSL_uint16_t HLOGG;
+   /** QLN Measurment Time "QLNMTds" */
+   DSL_uint16_t QLNMT;
+   /** QLN Subcarrier Group Size DS "QLNGds" */
+   DSL_uint16_t QLNG;
+   /** SNR Measurement Time "SNRMTds" */
+   DSL_uint16_t SNRMT;
+   /** SNR Subcarrier Group Size DS "SNRGds" */
+   DSL_uint16_t SNRG;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** HLIN Scaling Factor "HLINSCds" */
+   DSL_uint16_t HLINSC;
+   /** HLIN Subcarrier Group Size DS "HLINGds" */
+   DSL_uint16_t HLING;
+   /** HLOG Measurement Time "HLOGMTds" */
+   DSL_uint16_t HLOGMT;
+   /** HLOG Subcarrier Group Size DS "HLOGGds" */
+   DSL_uint16_t HLOGG;
+   /** QLN Measurment Time "QLNMTds" */
+   DSL_uint16_t QLNMT;
+   /** QLN Subcarrier Group Size DS "QLNGds" */
+   DSL_uint16_t QLNG;
+   /** SNR Measurement Time "SNRMTds" */
+   DSL_uint16_t SNRMT;
+   /** SNR Subcarrier Group Size DS "SNRGds" */
+   DSL_uint16_t SNRG;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests test parameter related information for the upstream direction: The
+   HLIN scaling factor (HLINSCus), the subcarrier group size "G" and the
+   measurement times for HLOGpsus, QLNpsus, SNRpsus.For older VDSL FW versions
+   from w.6.x.y.z.a to 5.8.0.x.y.z: During STEADY_STATE, the command can be used
+   only to retrieve the "group size" parameters. To get the measurement time
+   parameters (via the EOC channel) the message CMD_TestParamsFE_Request must be
+   applied instead.(Sections 7.5.1.26.7/8/10/11, 7.5.1.27.4/5 and 7.5.1.28.4/5
+   of G.997.1)For older VDSL FW versions from w.6.x.y.z.a to 5.8.0.x.y.z: During
+   STEADY_STATE, the command can be used only to retrieve the "group size"
+   parameters. To get the measurement time parameters (via the EOC channel) the
+   message CMD_TestParamsFE_Request must be applied instead.The test parameters
+   can be requested during loop diagnostic mode (VDSL, ADSL) and in ADSL also
+   during STEADY_STATE.For older VDSL FW versions from w.6.x.y.z.a to
+   5.8.0.x.y.z: During STEADY_STATE, the command can be used only to retrieve
+   the "group size" parameters. To get the measurement time parameters (via the
+   EOC channel) the message CMD_TestParamsFE_Request must be applied instead.
+*/
+struct CMD_TestParamsAuxUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the test-parameter related information as requested by
+   CMD_TestParamsAuxUS_Get: The HLIN scaling factor (HLINSCus), the subcarrier
+   group size "G" and the measurement times for HLOGpsus, QLNpsus, SNRpsus.
+*/
+struct ACK_TestParamsAuxUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** HLIN Scaling Factor "HLINSCus" */
+   DSL_uint16_t HLINSC;
+   /** HLIN Subcarrier Group Size US "HLINGus" */
+   DSL_uint16_t HLING;
+   /** HLOG Measurement Time "HLOGMTus" */
+   DSL_uint16_t HLOGMT;
+   /** HLOG Subcarrier Group Size US "HLOGGus" */
+   DSL_uint16_t HLOGG;
+   /** QLN Measurment Time "QLNMTus" */
+   DSL_uint16_t QLNMT;
+   /** QLN Subcarrier Group Size US "QLNGus" */
+   DSL_uint16_t QLNG;
+   /** SNR Measurement Time "SNRMTus" */
+   DSL_uint16_t SNRMT;
+   /** SNR Subcarrier Group Size US "SNRGus" */
+   DSL_uint16_t SNRG;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** HLIN Scaling Factor "HLINSCus" */
+   DSL_uint16_t HLINSC;
+   /** HLIN Subcarrier Group Size US "HLINGus" */
+   DSL_uint16_t HLING;
+   /** HLOG Measurement Time "HLOGMTus" */
+   DSL_uint16_t HLOGMT;
+   /** HLOG Subcarrier Group Size US "HLOGGus" */
+   DSL_uint16_t HLOGG;
+   /** QLN Measurment Time "QLNMTus" */
+   DSL_uint16_t QLNMT;
+   /** QLN Subcarrier Group Size US "QLNGus" */
+   DSL_uint16_t QLNG;
+   /** SNR Measurement Time "SNRMTus" */
+   DSL_uint16_t SNRMT;
+   /** SNR Subcarrier Group Size US "SNRGus" */
+   DSL_uint16_t SNRG;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This message is used to trigger retrieval of the far-end PMD Test Parameters
+   Hlog, SNR and QLN via the EOC channel during Showtime. If StartIndex or
+   EndIndex do not contain values in a valid range then no autonomous message
+   will be sent by the firmware. Once the retrieval process is started, it can
+   also be aborted with this message via the control parameter. The status of
+   the parameter retrieval process can be polled via the CMD_TestParamsFE_Poll
+   message. Once the parameters are retrieved, they are provided with the
+   EVT_PMD_TestParamsGet message.
+*/
+struct CMD_TestParamsFE_Request
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Far-end Retrieval Control */
+   DSL_uint16_t Control;
+   /** Subcarrier Group Start Index */
+   DSL_uint16_t StartIndex;
+   /** Subcarrier Group End Index */
+   DSL_uint16_t EndIndex;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Far-end Retrieval Control */
+   DSL_uint16_t Control;
+   /** Subcarrier Group Start Index */
+   DSL_uint16_t StartIndex;
+   /** Subcarrier Group End Index */
+   DSL_uint16_t EndIndex;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This is the acknowledgement for CMD_TestParamsFE_Request.
+*/
+struct ACK_TestParamsFE_Request
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This message polls the status of the far end parameter retrieval process.
+*/
+struct CMD_TestParamsFE_Poll
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This is the acknowledgement for CMD_TestParamsFE_Poll.
+*/
+struct ACK_TestParamsFE_Poll
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Far-end retrieval status */
+   DSL_uint16_t Status;
+   /** Reserved1 */
+   DSL_uint16_t Res1;
+   /** Reserved2 */
+   DSL_uint16_t Res2;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Far-end retrieval status */
+   DSL_uint16_t Status;
+   /** Reserved1 */
+   DSL_uint16_t Res1;
+   /** Reserved2 */
+   DSL_uint16_t Res2;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This event message provides the far-end data after the far end data retrieval
+   process. This message is a result of the CMD_TestParamsFE_Request message.
+*/
+struct EVT_PMD_TestParamsGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved1 */
+   DSL_uint16_t Res1;
+   /** Subcarrier Group Start Index */
+   DSL_uint16_t StartIndex;
+   /** Subcarrier Group End Index */
+   DSL_uint16_t EndIndex;
+   /** HLOG Measurement Time HLOGMT */
+   DSL_uint16_t hlogTime;
+   /** SNR Measurement Time SNRMT */
+   DSL_uint16_t snrTime;
+   /** QLN Measurment Time QLNMT */
+   DSL_uint16_t qlnTime;
+   /** Testparameter Result */
+   VRX_TestParam_t TestPar[60];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved1 */
+   DSL_uint16_t Res1;
+   /** Subcarrier Group Start Index */
+   DSL_uint16_t StartIndex;
+   /** Subcarrier Group End Index */
+   DSL_uint16_t EndIndex;
+   /** HLOG Measurement Time HLOGMT */
+   DSL_uint16_t hlogTime;
+   /** SNR Measurement Time SNRMT */
+   DSL_uint16_t snrTime;
+   /** QLN Measurment Time QLNMT */
+   DSL_uint16_t qlnTime;
+   /** Testparameter Result */
+   VRX_TestParam_t TestPar[60];
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message is used to configure the autonomous messaging related to Clear
+   EOC transmission.
+*/
+struct CMD_ClearEOC_Configure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+   /** RX Autonomous Clear EOC Data Message Control */
+   DSL_uint16_t RxEVTdata : 1;
+   /** RX Autonomous Status Message Control */
+   DSL_uint16_t RxEVTstatus : 1;
+   /** TX Autonomous Status Message Control */
+   DSL_uint16_t TxEVTstatus : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TX Autonomous Status Message Control */
+   DSL_uint16_t TxEVTstatus : 1;
+   /** RX Autonomous Status Message Control */
+   DSL_uint16_t RxEVTstatus : 1;
+   /** RX Autonomous Clear EOC Data Message Control */
+   DSL_uint16_t RxEVTdata : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This is the acknowledgement for CMD_ClearEOC_Configure.
+*/
+struct ACK_ClearEOC_Configure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message is used to trigger the transmission of  Clear EOC messages that
+   were placed into the Clear EOC transmit buffer before with
+   CMD_ClearEOC_Write.
+*/
+struct CMD_ClearEOC_TxTrigger
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 15;
+   /** Transmit Control Trigger */
+   DSL_uint16_t txTrigger : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Transmit Control Trigger */
+   DSL_uint16_t txTrigger : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 15;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This is the acknowledgement for CMD_ClearEOC_TxTrigger.
+*/
+struct ACK_ClearEOC_TxTrigger
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This message is used to write data to the ClearEOC write buffer of type
+   VRX_ClearEOC_t. When the buffer is filled, the transmission is started
+   applying CMD_ClearEOC_TxTrigger. If the message to transmit is longer than
+   the mailbox size, a sequence of writes to the ClearEOC buffer has to be done
+   before the transmission is started with CMD_ClearEOC_TxTrigger. When
+   autonomous TX status messaging is activated via CMD_ClearEOC_Configure, then
+   the finished transmission is indicated by EVT_ClearEOCStatusGet.
+*/
+struct CMD_ClearEOC_Write
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Data */
+   DSL_uint16_t Data[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Data */
+   DSL_uint16_t Data[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   This message is the acknowledgement for CMD_ClearEOC_Write.
+*/
+struct ACK_ClearEOC_Write
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This message is used to read data from the ClearEOC buffer of type
+   VRX_ClearEOC_t. The length of the actual Clear EOC message can be found in
+   the buffer. Please refer to VRX_ClearEOC_t. The availability of data can
+   either be checked via CMD_ClearEOCStatusGet in polling mode or it can be
+   reported by an autonomous EVT_ClearEOCStatusGet message when data is received
+   (to be enabled using CMD_ClearEOC_Configure).
+*/
+struct CMD_ClearEOC_Read
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This message is the acknowledgement to CMD_ClearEOC_Read.
+*/
+struct ACK_ClearEOC_Read
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Data */
+   DSL_uint16_t Data[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Data */
+   DSL_uint16_t Data[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   This message is an autonomous message that is generated when ClearEOC data
+   was received and autonomous Clear EOC data messaging has been activated via
+   CMD_ClearEOC_Configure. If the ClearEOC data does not fit in one message,
+   then a sequence of messages is generated. The ClearEOC buffer is of type
+   VRX_ClearEOC_t.
+*/
+struct EVT_ClearEOC_Read
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Data */
+   DSL_uint16_t Data[128];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Data */
+   DSL_uint16_t Data[128];
+#endif
+} __PACKED__ ;
+
+
+/**
+   This message is used to retrieve the status of the clear eoc data
+   transmission.
+*/
+struct CMD_ClearEOCStatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This is the acknowledgement for CMD_ClearEOCStatusGet.
+*/
+struct ACK_ClearEOCStatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** Transmit Status */
+   DSL_uint16_t txstat : 2;
+   /** Reserved */
+   DSL_uint16_t Res1 : 14;
+   /** Receive Status */
+   DSL_uint16_t rxstat : 2;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Transmit Status */
+   DSL_uint16_t txstat : 2;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** Receive Status */
+   DSL_uint16_t rxstat : 2;
+   /** Reserved */
+   DSL_uint16_t Res1 : 14;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This autonomous message reports the Clear EOC status. It is sent only if the
+   "Autonomous Status Message Control" was enabled for TX and/or RX direction
+   with CMD_ClearEOC_Configure. If TX direction is enabled, the message is
+   generated when a TX transmission is finished or failed. If RX direction is
+   enabled, the message is generated when the RX status transitions from "Idle"
+   to "Data Available" for retrieval by the host.
+*/
+struct EVT_ClearEOCStatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** Transmit Status */
+   DSL_uint16_t txstat : 2;
+   /** Reserved */
+   DSL_uint16_t Res1 : 14;
+   /** Receive Status */
+   DSL_uint16_t rxstat : 2;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Transmit Status */
+   DSL_uint16_t txstat : 2;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** Receive Status */
+   DSL_uint16_t rxstat : 2;
+   /** Reserved */
+   DSL_uint16_t Res1 : 14;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message is used to reset the transmit or receive status of the clear eoc
+   data transmission to IDLE (for defined states see also
+   CMD_ClearEOCStatusGet). See the description on the Clear EOC handling on Page
+   555 for when it has to be applied. Transmit and receive status are
+   distinguished by the Index parameter.
+*/
+struct CMD_ClearEOCStatusSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** Status */
+   DSL_uint16_t stat : 2;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Status */
+   DSL_uint16_t stat : 2;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This is the acknowledgement for CMD_ClearEOCStatusSet.
+*/
+struct ACK_ClearEOCStatusSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Configuration of options for the overhead handling.
+*/
+struct CMD_OH_OptionsSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** EOC Polling Period Scaling Factor, Bits 15 to 8 */
+   DSL_uint8_t eocPollFactor;
+   /** Reserved */
+   DSL_uint16_t Res0 : 3;
+   /** EOC Polling Control Prio 2: PMD Test Parameters, Bit 4 */
+   DSL_uint16_t eocPoll2 : 1;
+   /** EOC Polling Control Prio 1: Inventory, Counters, Bit 3 */
+   DSL_uint16_t eocPoll1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 3;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res1 : 3;
+   /** EOC Polling Control Prio 1: Inventory, Counters, Bit 3 */
+   DSL_uint16_t eocPoll1 : 1;
+   /** EOC Polling Control Prio 2: PMD Test Parameters, Bit 4 */
+   DSL_uint16_t eocPoll2 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 3;
+   /** EOC Polling Period Scaling Factor, Bits 15 to 8 */
+   DSL_uint8_t eocPollFactor;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for CMD_OH_OptionsSet.
+*/
+struct ACK_OH_OptionsSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests OH polling statistic information.
+*/
+struct CMD_OH_StatsGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reports the OH polling statistics as requested by CMD_OH_StatsGet.
+*/
+struct ACK_OH_StatsGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** EOC CMD TX PRIO1 Sent */
+   DSL_uint16_t eocCMD1;
+   /** EOC ACK RX PRIO1 Count */
+   DSL_uint16_t eocRSP1;
+   /** EOC CMD TX PRIO2 Sent */
+   DSL_uint16_t eocCMD2;
+   /** EOC ACK RX PRIO2 Count */
+   DSL_uint16_t eocRSP2;
+   /** EOC NACK RX PRIO1 Count  */
+   DSL_uint16_t eocNACK1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** EOC CMD TX PRIO1 Sent */
+   DSL_uint16_t eocCMD1;
+   /** EOC ACK RX PRIO1 Count */
+   DSL_uint16_t eocRSP1;
+   /** EOC CMD TX PRIO2 Sent */
+   DSL_uint16_t eocCMD2;
+   /** EOC ACK RX PRIO2 Count */
+   DSL_uint16_t eocRSP2;
+   /** EOC NACK RX PRIO1 Count  */
+   DSL_uint16_t eocNACK1;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests RRC and ROC downstream tones for VDSL2 operated in RTX mode.
+*/
+struct CMD_RRC_ROC_Tones_DS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides RRC and ROC downstream tones for VDSL2 operated in RTX mode.
+*/
+struct ACK_RRC_ROC_Tones_DS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Last RRC Tone DS */
+   DSL_uint16_t LastRrcTone;
+   /** First ROC Tone DS */
+   DSL_uint16_t FirstRocTone;
+   /** Last ROC Tone DS */
+   DSL_uint16_t LastRocTone;
+   /** RRC/ROC Tone Index Array DS */
+   DSL_uint16_t RrcRocTone[61];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Last RRC Tone DS */
+   DSL_uint16_t LastRrcTone;
+   /** First ROC Tone DS */
+   DSL_uint16_t FirstRocTone;
+   /** Last ROC Tone DS */
+   DSL_uint16_t LastRocTone;
+   /** RRC/ROC Tone Index Array DS */
+   DSL_uint16_t RrcRocTone[61];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests RRC and ROC upstream tones for VDSL2 operated in RTX mode.
+*/
+struct CMD_RRC_ROC_Tones_US_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides RRC and ROC upstream tones for VDSL2 operated in RTX mode.
+*/
+struct ACK_RRC_ROC_Tones_US_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Last RRC Tone US */
+   DSL_uint16_t LastRrcTone;
+   /** First ROC Tone US */
+   DSL_uint16_t FirstRocTone;
+   /** Last ROC Tone US */
+   DSL_uint16_t LastRocTone;
+   /** RRC/ROC Tone Index Array US */
+   DSL_uint16_t RrcRocTone[61];
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Last RRC Tone US */
+   DSL_uint16_t LastRrcTone;
+   /** First ROC Tone US */
+   DSL_uint16_t FirstRocTone;
+   /** Last ROC Tone US */
+   DSL_uint16_t LastRocTone;
+   /** RRC/ROC Tone Index Array US */
+   DSL_uint16_t RrcRocTone[61];
+#endif
+} __PACKED__ ;
+
+
+/**
+   Enables/Disables support for OLR events (Bitswaps, SRA, SOS, ROC).An OLR
+   transition is always initiated by the receiving PMD, so the CPE requests the
+   OLR event for downstream direction.
+*/
+struct CMD_OLR_Control
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 4;
+   /** RX Bitswap ROC */
+   DSL_uint16_t RxBitswap_ROC : 1;
+   /** TX Bitswap ROC */
+   DSL_uint16_t TxBitswap_ROC : 1;
+   /** SOS DS */
+   DSL_uint16_t SOS_DS : 1;
+   /** SOS US */
+   DSL_uint16_t SOS_US : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 1;
+   /** SRA Strict Rate Check */
+   DSL_uint16_t SRA_StrictCheck : 1;
+   /** RX Bitswap */
+   DSL_uint16_t RxBitswap : 1;
+   /** TX Bitswap */
+   DSL_uint16_t TxBitswap : 1;
+   /** SRA Rate Check */
+   DSL_uint16_t SRA_RateCheck : 1;
+   /** Auto-SRA DS */
+   DSL_uint16_t autoSRA_DS : 1;
+   /** Auto-SRA US */
+   DSL_uint16_t autoSRA_US : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res2 : 1;
+   /** Auto-SRA US */
+   DSL_uint16_t autoSRA_US : 1;
+   /** Auto-SRA DS */
+   DSL_uint16_t autoSRA_DS : 1;
+   /** SRA Rate Check */
+   DSL_uint16_t SRA_RateCheck : 1;
+   /** TX Bitswap */
+   DSL_uint16_t TxBitswap : 1;
+   /** RX Bitswap */
+   DSL_uint16_t RxBitswap : 1;
+   /** SRA Strict Rate Check */
+   DSL_uint16_t SRA_StrictCheck : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 1;
+   /** SOS US */
+   DSL_uint16_t SOS_US : 1;
+   /** SOS DS */
+   DSL_uint16_t SOS_DS : 1;
+   /** TX Bitswap ROC */
+   DSL_uint16_t TxBitswap_ROC : 1;
+   /** RX Bitswap ROC */
+   DSL_uint16_t RxBitswap_ROC : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 4;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for CMD_OLR_Control.
+*/
+struct ACK_OLR_Control
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the OLR status information on bit swaps, DRR, SRA and SOS events for
+   the upstream direction.
+*/
+struct CMD_OLR_US_StatsGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reports the OLR status information for the upstream direction as requested by
+   CMD_OLR_US_StatsGet.
+*/
+struct ACK_OLR_US_StatsGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** US Bit Swap Requests */
+   DSL_uint16_t BitswapReqs;
+   /** US Extended Bit Swap Requests */
+   DSL_uint16_t ExtBitswapReqs;
+   /** US Bit Swap UTC Responses */
+   DSL_uint16_t BitswapUTCs;
+   /** US "Bit Swaps Performed" Count */
+   DSL_uint16_t BitswapsDone;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** US SOS Requests */
+   DSL_uint16_t SOS_Reqs;
+   /** Reserved */
+   DSL_uint16_t Res1;
+   /** US SOS UTC Responses */
+   DSL_uint16_t SOS_UTCs;
+   /** US "SOS Performed" Count */
+   DSL_uint16_t SOS_Done;
+   /** Reserved */
+   DSL_uint16_t Res2;
+   /** US SRA Requests */
+   DSL_uint16_t SRA_Reqs;
+   /** Reserved */
+   DSL_uint16_t Res3;
+   /** US SRA UTC Responses */
+   DSL_uint16_t SRA_UTCs;
+   /** US "SRA Performed" Count */
+   DSL_uint16_t SRAsDone;
+   /** Reserved */
+   DSL_uint16_t Res4;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** US Bit Swap Requests */
+   DSL_uint16_t BitswapReqs;
+   /** US Extended Bit Swap Requests */
+   DSL_uint16_t ExtBitswapReqs;
+   /** US Bit Swap UTC Responses */
+   DSL_uint16_t BitswapUTCs;
+   /** US "Bit Swaps Performed" Count */
+   DSL_uint16_t BitswapsDone;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** US SOS Requests */
+   DSL_uint16_t SOS_Reqs;
+   /** Reserved */
+   DSL_uint16_t Res1;
+   /** US SOS UTC Responses */
+   DSL_uint16_t SOS_UTCs;
+   /** US "SOS Performed" Count */
+   DSL_uint16_t SOS_Done;
+   /** Reserved */
+   DSL_uint16_t Res2;
+   /** US SRA Requests */
+   DSL_uint16_t SRA_Reqs;
+   /** Reserved */
+   DSL_uint16_t Res3;
+   /** US SRA UTC Responses */
+   DSL_uint16_t SRA_UTCs;
+   /** US "SRA Performed" Count */
+   DSL_uint16_t SRAsDone;
+   /** Reserved */
+   DSL_uint16_t Res4;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the OLR status information on bit swaps, DRR, SRA and SOS events for
+   the downstream direction.
+*/
+struct CMD_OLR_DS_StatsGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reports the OLR status information for the downstream direction as requested
+   by CMD_OLR_DS_StatsGet.
+*/
+struct ACK_OLR_DS_StatsGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** DS Bit Swap Requests */
+   DSL_uint16_t BitswapReqs;
+   /** DS Extended Bit Swap Requests */
+   DSL_uint16_t ExtBitswapReqs;
+   /** DS Bit Swap UTC Responses */
+   DSL_uint16_t BitswapUTCs;
+   /** DS "Bit Swaps Performed" Count */
+   DSL_uint16_t BitswapsDone;
+   /** DS Bitswap Timeouts */
+   DSL_uint16_t BitswapTimeOuts;
+   /** DS SOS Requests */
+   DSL_uint16_t SOS_Reqs;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** DS SOS UTC Responses */
+   DSL_uint16_t SOS_UTCs;
+   /** DS "SOS Performed" Count */
+   DSL_uint16_t SOS_Done;
+   /** DS SOS Timeouts */
+   DSL_uint16_t SOS_TimeOuts;
+   /** DS SRA Requests */
+   DSL_uint16_t SRA_Reqs;
+   /** Reserved */
+   DSL_uint16_t Res1;
+   /** DS SRA UTC Responses */
+   DSL_uint16_t SRA_UTCs;
+   /** DS "SRA Performed" Count */
+   DSL_uint16_t SRAsDone;
+   /** DS SRA Timeouts */
+   DSL_uint16_t SRA_TimeOuts;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** DS Bit Swap Requests */
+   DSL_uint16_t BitswapReqs;
+   /** DS Extended Bit Swap Requests */
+   DSL_uint16_t ExtBitswapReqs;
+   /** DS Bit Swap UTC Responses */
+   DSL_uint16_t BitswapUTCs;
+   /** DS "Bit Swaps Performed" Count */
+   DSL_uint16_t BitswapsDone;
+   /** DS Bitswap Timeouts */
+   DSL_uint16_t BitswapTimeOuts;
+   /** DS SOS Requests */
+   DSL_uint16_t SOS_Reqs;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** DS SOS UTC Responses */
+   DSL_uint16_t SOS_UTCs;
+   /** DS "SOS Performed" Count */
+   DSL_uint16_t SOS_Done;
+   /** DS SOS Timeouts */
+   DSL_uint16_t SOS_TimeOuts;
+   /** DS SRA Requests */
+   DSL_uint16_t SRA_Reqs;
+   /** Reserved */
+   DSL_uint16_t Res1;
+   /** DS SRA UTC Responses */
+   DSL_uint16_t SRA_UTCs;
+   /** DS "SRA Performed" Count */
+   DSL_uint16_t SRAsDone;
+   /** DS SRA Timeouts */
+   DSL_uint16_t SRA_TimeOuts;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the actual active downstream RA mode (ACT-RA-MODEds, Section
+   7.5.1.33.1 of G.997.1).
+*/
+struct CMD_RA_ModeDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reports the actual active downstream RA mode (ACT-RA-MODEds) as requested by
+   CMD_RA_ModeDS_Get.
+*/
+struct ACK_RA_ModeDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** RA Mode DS */
+   DSL_uint16_t actRA_mode;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** RA Mode DS */
+   DSL_uint16_t actRA_mode;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the actual active upstream RA mode (ACT-RA-MODEus, Section
+   7.5.1.33.2 of G.997.1).
+*/
+struct CMD_RA_ModeUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reports the actual active upstream RA mode (ACT-RA-MODEus) as requested by
+   CMD_RA_ModeUS_Get.
+*/
+struct ACK_RA_ModeUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** RA Mode US */
+   DSL_uint16_t actRA_mode;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** RA Mode US */
+   DSL_uint16_t actRA_mode;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Autonomous message indicating a successful upstream OLR event (SRA or SOS).
+*/
+struct EVT_OLR_US_EventGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** SRA Event */
+   DSL_uint16_t SRA_OK : 1;
+   /** SOS Event (VDSL only) */
+   DSL_uint16_t SOS_OK : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** SOS Event (VDSL only) */
+   DSL_uint16_t SOS_OK : 1;
+   /** SRA Event */
+   DSL_uint16_t SRA_OK : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Autonomous message indicating a successful downstream OLR event (SRA or SOS).
+*/
+struct EVT_OLR_DS_EventGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** SRA Event */
+   DSL_uint16_t SRA_OK : 1;
+   /** SOS Event (VDSL only) */
+   DSL_uint16_t SOS_OK : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** SOS Event (VDSL only) */
+   DSL_uint16_t SOS_OK : 1;
+   /** SRA Event */
+   DSL_uint16_t SRA_OK : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Enables/Disables the generation of EVENT messages (EVT) for specific upstream
+   OLR events. If the corresponding Enable bit for an OLR event is set, then the
+   modem firmware will send an autonomous message EVT_OLR_US_EventGet if the OLR
+   event happened in the last 1-second interval.
+*/
+struct CMD_OLR_US_EventConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** SRA Event US, Bit 1 */
+   DSL_uint16_t SRA_OK : 1;
+   /** SOS Event US , Bit 0 (VDSL only) */
+   DSL_uint16_t SOS_OK : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** SOS Event US , Bit 0 (VDSL only) */
+   DSL_uint16_t SOS_OK : 1;
+   /** SRA Event US, Bit 1 */
+   DSL_uint16_t SRA_OK : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknoledgement for CMD_OLR_US_EventConfigure.
+*/
+struct ACK_OLR_US_EventConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Enables/Disables the generation of EVENT messages (EVT) for specific
+   downstream OLR events. If the corresponding Enable bit for an OLR event is
+   set, then the modem firmware will send an autonomous message
+   EVT_OLR_DS_EventGet if the OLR event happened in the last 1-second interval.
+*/
+struct CMD_OLR_DS_EventConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** SRA Event DS, Bit 1 */
+   DSL_uint16_t SRA_OK : 1;
+   /** SOS Event DS , Bit 0 (VDSL only) */
+   DSL_uint16_t SOS_OK : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** SOS Event DS , Bit 0 (VDSL only) */
+   DSL_uint16_t SOS_OK : 1;
+   /** SRA Event DS, Bit 1 */
+   DSL_uint16_t SRA_OK : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknoledgement for CMD_OLR_DS_EventConfigure.
+*/
+struct ACK_OLR_DS_EventConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Configures a link for retransmission of downstream data. For using the RTX
+   function, this message has to be sent.
+*/
+struct CMD_RTX_Control
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 4;
+   /** ROC US */
+   DSL_uint16_t ROC_US : 1;
+   /** ROC DS */
+   DSL_uint16_t ROC_DS : 1;
+   /** Extended Memory for Enhanced Bit Rates (Anx D support, VDSL only) */
+   DSL_uint16_t ExtMem : 1;
+   /** Force Extended Memory for Enhanced Bit Rates (VDSL only) */
+   DSL_uint16_t ExtMemForced : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 3;
+   /** Intra DTU Interleaving US (VDSL only) */
+   DSL_uint16_t DtuInterleavingUs : 1;
+   /** Intra DTU Interleaving DS (VDSL only) */
+   DSL_uint16_t DtuInterleavingDs : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 1;
+   /** Retransmission Control */
+   DSL_uint16_t RtxMode : 2;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Retransmission Control */
+   DSL_uint16_t RtxMode : 2;
+   /** Reserved */
+   DSL_uint16_t Res2 : 1;
+   /** Intra DTU Interleaving DS (VDSL only) */
+   DSL_uint16_t DtuInterleavingDs : 1;
+   /** Intra DTU Interleaving US (VDSL only) */
+   DSL_uint16_t DtuInterleavingUs : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 3;
+   /** Force Extended Memory for Enhanced Bit Rates (VDSL only) */
+   DSL_uint16_t ExtMemForced : 1;
+   /** Extended Memory for Enhanced Bit Rates (Anx D support, VDSL only) */
+   DSL_uint16_t ExtMem : 1;
+   /** ROC DS */
+   DSL_uint16_t ROC_DS : 1;
+   /** ROC US */
+   DSL_uint16_t ROC_US : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 4;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for CMD_RTX_Control.
+*/
+struct ACK_RTX_Control
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests RTX specific status information for the downstream bearer channels
+   if G.INP retransmission is used.
+*/
+struct CMD_RTX_BearerChsDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers status information for the downstream bearer channels when G.INP
+   retransmission is actually used.
+*/
+struct ACK_RTX_BearerChsDS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Expected Throughput ETR of RTX Function, LSW */
+   DSL_uint16_t ETR_LSW;
+   /** Expected Throughput ETR of RTX Function, MSW */
+   DSL_uint16_t ETR_MSW;
+   /** Actual Delay of RTX Function */
+   DSL_uint16_t ActDelay;
+   /** Actual INP SHINE of RTX Function */
+   DSL_uint16_t ActInpSHINE;
+   /** Actual INP REIN of RTX Function */
+   DSL_uint16_t ActInpREIN;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Expected Throughput ETR of RTX Function, LSW */
+   DSL_uint16_t ETR_LSW;
+   /** Expected Throughput ETR of RTX Function, MSW */
+   DSL_uint16_t ETR_MSW;
+   /** Actual Delay of RTX Function */
+   DSL_uint16_t ActDelay;
+   /** Actual INP SHINE of RTX Function */
+   DSL_uint16_t ActInpSHINE;
+   /** Actual INP REIN of RTX Function */
+   DSL_uint16_t ActInpREIN;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests RTX specific status information for the upstream bearer channels if
+   upstream G.INP retransmission is used.
+*/
+struct CMD_RTX_BearerChsUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers status information for the upstream bearer channels when upstream
+   G.INP retransmission is used.
+*/
+struct ACK_RTX_BearerChsUS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Expected Throughput ETR of RTX_us Function, LSW */
+   DSL_uint16_t ETR_LSW;
+   /** Expected Throughput ETR of RTX_us Function, MSW */
+   DSL_uint16_t ETR_MSW;
+   /** Actual Delay of RTX_us Function */
+   DSL_uint16_t ActDelay;
+   /** Actual INP SHINE of RTX_us Function */
+   DSL_uint16_t ActInpSHINE;
+   /** Actual INP REIN of RTX_us Function */
+   DSL_uint16_t ActInpREIN;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Expected Throughput ETR of RTX_us Function, LSW */
+   DSL_uint16_t ETR_LSW;
+   /** Expected Throughput ETR of RTX_us Function, MSW */
+   DSL_uint16_t ETR_MSW;
+   /** Actual Delay of RTX_us Function */
+   DSL_uint16_t ActDelay;
+   /** Actual INP SHINE of RTX_us Function */
+   DSL_uint16_t ActInpSHINE;
+   /** Actual INP REIN of RTX_us Function */
+   DSL_uint16_t ActInpREIN;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests performance monitoring counters for downstream G.INP retransmission.
+*/
+struct CMD_RTX_PM_DS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers performance monitoring counters for downstream G.INP retransmission.
+*/
+struct ACK_RTX_PM_DS_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** ErrorFreeBitsCNT, LSW */
+   DSL_uint16_t ErrorFreeBits_LSW;
+   /** ErrorFreeBitsCNT, MSW */
+   DSL_uint16_t ErrorFreeBits_MSW;
+   /** Reserved */
+   DSL_uint16_t Res0[2];
+   /** EFTR_min reported to CO, LSW */
+   DSL_uint16_t EFTR_min_LSW;
+   /** EFTR_min reported to CO, MSW */
+   DSL_uint16_t EFTR_min_MSW;
+   /** Reserved */
+   DSL_uint16_t Res1[2];
+   /** "leftr" Count, LSW */
+   DSL_uint16_t leftr_LSW;
+   /** "leftr" Count, MSW */
+   DSL_uint16_t leftr_MSW;
+   /** EFTR, LSW */
+   DSL_uint16_t EFTR_LSW;
+   /** EFTR, MSW */
+   DSL_uint16_t EFTR_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** ErrorFreeBitsCNT, LSW */
+   DSL_uint16_t ErrorFreeBits_LSW;
+   /** ErrorFreeBitsCNT, MSW */
+   DSL_uint16_t ErrorFreeBits_MSW;
+   /** Reserved */
+   DSL_uint16_t Res0[2];
+   /** EFTR_min reported to CO, LSW */
+   DSL_uint16_t EFTR_min_LSW;
+   /** EFTR_min reported to CO, MSW */
+   DSL_uint16_t EFTR_min_MSW;
+   /** Reserved */
+   DSL_uint16_t Res1[2];
+   /** "leftr" Count, LSW */
+   DSL_uint16_t leftr_LSW;
+   /** "leftr" Count, MSW */
+   DSL_uint16_t leftr_MSW;
+   /** EFTR, LSW */
+   DSL_uint16_t EFTR_LSW;
+   /** EFTR, MSW */
+   DSL_uint16_t EFTR_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests performance monitoring counters for upstream G.INP retransmission.
+*/
+struct CMD_RTX_PM_US_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers performance monitoring counters for upstream G.INP retransmission.
+   They are all far-end parameters received from CO.
+*/
+struct ACK_RTX_PM_US_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** ErrorFreeBitsCNT, LSW */
+   DSL_uint16_t ErrorFreeBits_LSW;
+   /** ErrorFreeBitsCNT, MSW */
+   DSL_uint16_t ErrorFreeBits_MSW;
+   /** EFTR_min, LSW */
+   DSL_uint16_t EFTR_min_LSW;
+   /** EFTR_min, MSW */
+   DSL_uint16_t EFTR_min_MSW;
+   /** "leftr" Count, LSW */
+   DSL_uint16_t leftr_LSW;
+   /** "leftr" Count, MSW */
+   DSL_uint16_t leftr_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** ErrorFreeBitsCNT, LSW */
+   DSL_uint16_t ErrorFreeBits_LSW;
+   /** ErrorFreeBitsCNT, MSW */
+   DSL_uint16_t ErrorFreeBits_MSW;
+   /** EFTR_min, LSW */
+   DSL_uint16_t EFTR_min_LSW;
+   /** EFTR_min, MSW */
+   DSL_uint16_t EFTR_min_MSW;
+   /** "leftr" Count, LSW */
+   DSL_uint16_t leftr_LSW;
+   /** "leftr" Count, MSW */
+   DSL_uint16_t leftr_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests DTU counters for G.INP downstream retransmission.
+*/
+struct CMD_RTX_DS_StatsGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers DTU counters for G.INP downstream retransmission. The counters are
+   Non-TR1 wrap-around counters, which are reset at reboot only.
+*/
+struct ACK_RTX_DS_StatsGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TxDtuRetransmitted Count (rtx-tx), LSW */
+   DSL_uint16_t TxDtuRTX_LSW;
+   /** TxDtuRetransmitted Count (rtx-tx), MSW */
+   DSL_uint16_t TxDtuRTX_MSW;
+   /** RxDtuCorrected Count (rtx-c), LSW */
+   DSL_uint16_t RxDtuCorr_LSW;
+   /** RxDtuCorrected Count (rtx-c), MSW */
+   DSL_uint16_t RxDtuCorr_MSW;
+   /** RxDtuUncorrected Count (rtx-uc), LSW */
+   DSL_uint16_t RxDtuNoCorr_LSW;
+   /** RxDtuUncorrected Count (rtx-uc), MSW */
+   DSL_uint16_t RxDtuNoCorr_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TxDtuRetransmitted Count (rtx-tx), LSW */
+   DSL_uint16_t TxDtuRTX_LSW;
+   /** TxDtuRetransmitted Count (rtx-tx), MSW */
+   DSL_uint16_t TxDtuRTX_MSW;
+   /** RxDtuCorrected Count (rtx-c), LSW */
+   DSL_uint16_t RxDtuCorr_LSW;
+   /** RxDtuCorrected Count (rtx-c), MSW */
+   DSL_uint16_t RxDtuCorr_MSW;
+   /** RxDtuUncorrected Count (rtx-uc), LSW */
+   DSL_uint16_t RxDtuNoCorr_LSW;
+   /** RxDtuUncorrected Count (rtx-uc), MSW */
+   DSL_uint16_t RxDtuNoCorr_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests DTU counters for G.INP upstream retransmission, which is defined for
+   VDSL only.
+*/
+struct CMD_RTX_US_StatsGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers DTU counters for G.INP upstream retransmission. The counters are
+   Non-TR1 wrap-around counters, which are reset at reboot only.
+*/
+struct ACK_RTX_US_StatsGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TxDtuRetransmitted Count (rtx-tx), LSW */
+   DSL_uint16_t TxDtuRTX_LSW;
+   /** TxDtuRetransmitted Count (rtx-tx), MSW */
+   DSL_uint16_t TxDtuRTX_MSW;
+   /** RxDtuCorrected Count (rtx-c), LSW */
+   DSL_uint16_t RxDtuCorr_LSW;
+   /** RxDtuCorrected Count rtx-c), MSW */
+   DSL_uint16_t RxDtuCorr_MSW;
+   /** RxDtuUncorrected Count (rtx-uc), LSW */
+   DSL_uint16_t RxDtuNoCorr_LSW;
+   /** RxDtuUncorrected Count (rtx-uc), MSW */
+   DSL_uint16_t RxDtuNoCorr_MSW;
+   /** TxDtuRetransmitted On OLR Count, LSW */
+   DSL_uint16_t TxDtuRTXOlr_LSW;
+   /** TxDtuRetransmitted On OLR Count, MSW */
+   DSL_uint16_t TxDtuRTXOlr_MSW;
+   /** TxDtuRetransmitted On NACK Count, LSW */
+   DSL_uint16_t TxDtuRTXNACK_LSW;
+   /** TxDtuRetransmitted On NACK Count, MSW */
+   DSL_uint16_t TxDtuRTXNACK_MSW;
+   /** TxDtuRetransmitted On Timeout Count, LSW */
+   DSL_uint16_t TxDtuRTXTimeout_LSW;
+   /** TxDtuRetransmitted On Timeout Count, LSW */
+   DSL_uint16_t TxDtuRTXTimeout_MSW;
+   /** Uncorrected Rx RRC CW Count, LSW */
+   DSL_uint16_t GolayErr_LSW;
+   /** Uncorrected Rx RRC CW Count, LSW */
+   DSL_uint16_t GolayErr_MSW;
+   /** Roundtrip Error Count, LSW */
+   DSL_uint16_t RoundtripErr_LSW;
+   /** Roundtrip Error Count, MSW */
+   DSL_uint16_t RoundtripErr_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TxDtuRetransmitted Count (rtx-tx), LSW */
+   DSL_uint16_t TxDtuRTX_LSW;
+   /** TxDtuRetransmitted Count (rtx-tx), MSW */
+   DSL_uint16_t TxDtuRTX_MSW;
+   /** RxDtuCorrected Count (rtx-c), LSW */
+   DSL_uint16_t RxDtuCorr_LSW;
+   /** RxDtuCorrected Count rtx-c), MSW */
+   DSL_uint16_t RxDtuCorr_MSW;
+   /** RxDtuUncorrected Count (rtx-uc), LSW */
+   DSL_uint16_t RxDtuNoCorr_LSW;
+   /** RxDtuUncorrected Count (rtx-uc), MSW */
+   DSL_uint16_t RxDtuNoCorr_MSW;
+   /** TxDtuRetransmitted On OLR Count, LSW */
+   DSL_uint16_t TxDtuRTXOlr_LSW;
+   /** TxDtuRetransmitted On OLR Count, MSW */
+   DSL_uint16_t TxDtuRTXOlr_MSW;
+   /** TxDtuRetransmitted On NACK Count, LSW */
+   DSL_uint16_t TxDtuRTXNACK_LSW;
+   /** TxDtuRetransmitted On NACK Count, MSW */
+   DSL_uint16_t TxDtuRTXNACK_MSW;
+   /** TxDtuRetransmitted On Timeout Count, LSW */
+   DSL_uint16_t TxDtuRTXTimeout_LSW;
+   /** TxDtuRetransmitted On Timeout Count, LSW */
+   DSL_uint16_t TxDtuRTXTimeout_MSW;
+   /** Uncorrected Rx RRC CW Count, LSW */
+   DSL_uint16_t GolayErr_LSW;
+   /** Uncorrected Rx RRC CW Count, LSW */
+   DSL_uint16_t GolayErr_MSW;
+   /** Roundtrip Error Count, LSW */
+   DSL_uint16_t RoundtripErr_LSW;
+   /** Roundtrip Error Count, MSW */
+   DSL_uint16_t RoundtripErr_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the actually used G.INP retransmission status.
+*/
+struct CMD_RTX_StatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the actually used G.INP retransmission status.
+*/
+struct ACK_RTX_StatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 7;
+   /** RTX US disabled against Intel(c) VDSL Chipset  due to wrong Config.  */
+   DSL_uint16_t RtxUsOffCfgErr : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 3;
+   /** Intra DTU Interleaving US (VDSL only) */
+   DSL_uint16_t DtuInterleavingUs : 1;
+   /** Intra DTU Interleaving DS (VDSL only) */
+   DSL_uint16_t DtuInterleavingDs : 1;
+   /** Extended Memory */
+   DSL_uint16_t ExtMem : 1;
+   /** Retransmission US Used ("RTX_USED_us", VDSL only) */
+   DSL_uint16_t RtxUsedUs : 1;
+   /** Retransmission DS Used ("RTX_USED_ds") */
+   DSL_uint16_t RtxUsedDs : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Retransmission DS Used ("RTX_USED_ds") */
+   DSL_uint16_t RtxUsedDs : 1;
+   /** Retransmission US Used ("RTX_USED_us", VDSL only) */
+   DSL_uint16_t RtxUsedUs : 1;
+   /** Extended Memory */
+   DSL_uint16_t ExtMem : 1;
+   /** Intra DTU Interleaving DS (VDSL only) */
+   DSL_uint16_t DtuInterleavingDs : 1;
+   /** Intra DTU Interleaving US (VDSL only) */
+   DSL_uint16_t DtuInterleavingUs : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 3;
+   /** RTX US disabled against Intel(c) VDSL Chipset  due to wrong Config.  */
+   DSL_uint16_t RtxUsOffCfgErr : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 7;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests upstream G.INP retransmission specific framing parameters and other
+   status parameters. They are always associated with bearer channel 0.
+*/
+struct CMD_RTX_US_FrameDataGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers upstream retransmission specific framing parameters and other status
+   parameters, as requested by CMD_RTX_US_FrameDataGet. They are always
+   associated with bearer channel 0.In addition, the usual framing parameters
+   are to be retrieved with CMD_FrameDataExt2US_Get.
+*/
+struct ACK_RTX_US_FrameDataGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Framing Type of LP1 RTX_us Framing */
+   DSL_uint16_t FT;
+   /** FEC Codewords per DTU of LP1 RTX_us Framing */
+   DSL_uint16_t Q;
+   /** Padding Bytes per DTU of LP1 RTX_usFraming */
+   DSL_uint16_t V;
+   /** RTX Queue Length in DTUs of RTX_us Function */
+   DSL_uint16_t Qtx;
+   /** Look-Back Value for RRC Codeword Evaluation of RTX_us Function */
+   DSL_uint16_t lb;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Framing Type of LP1 RTX_us Framing */
+   DSL_uint16_t FT;
+   /** FEC Codewords per DTU of LP1 RTX_us Framing */
+   DSL_uint16_t Q;
+   /** Padding Bytes per DTU of LP1 RTX_usFraming */
+   DSL_uint16_t V;
+   /** RTX Queue Length in DTUs of RTX_us Function */
+   DSL_uint16_t Qtx;
+   /** Look-Back Value for RRC Codeword Evaluation of RTX_us Function */
+   DSL_uint16_t lb;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the G.INP upstream retransmission measured roundtrip.
+*/
+struct CMD_RTX_US_Roundtrip_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the G.INP upstream retransmission measured roundtrip delay. For
+   measuring the roundtrip, following difference is built when a correct RRC
+   codeword has been received: AbsoluteDTUCount of transmitter for next possible
+   DTU transmission minus AbsoluteDTUCount as received in RRC codeword.
+*/
+struct ACK_RTX_US_Roundtrip_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Minimum Measured Roundtrip in DTUs */
+   DSL_uint16_t MinRt;
+   /** Maximum Measured Roundtrip in DTUs */
+   DSL_uint16_t MaxRt;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Minimum Measured Roundtrip in DTUs */
+   DSL_uint16_t MinRt;
+   /** Maximum Measured Roundtrip in DTUs */
+   DSL_uint16_t MaxRt;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Enables/Disables support for full vectoring (G.993.5) and full vector-
+   friendly operation (G.993.2 Annex Y). In case of ADSL, this only means the
+   indication of the (VDSL) vectoring capabilities during G.Handshake.
+*/
+struct CMD_DSM_Control
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+   /** Supported Vectoring Mode */
+   DSL_uint16_t VectoringMode : 2;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Supported Vectoring Mode */
+   DSL_uint16_t VectoringMode : 2;
+   /** Reserved */
+   DSL_uint16_t Res0 : 14;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_DSM_Control.
+*/
+struct ACK_DSM_Control
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This autononmous message indicates that new downstream DSM error vector data
+   were written by the DSL FW into the SDRAM. Generation of this EVT message is
+   enabled/disabled together with the G.993.5 vectoring functionality itself, by
+   means of CMD_DSM_Control, parameter "Vector".
+*/
+struct EVT_DSM_ErrorVectorReady
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** ERB Event Result Code */
+   DSL_uint16_t ErrVecProcResult;
+   /** L2 Backchannel Error Vector Date Size */
+   DSL_uint16_t ErrVecSize;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** ERB Event Result Code */
+   DSL_uint16_t ErrVecProcResult;
+   /** L2 Backchannel Error Vector Date Size */
+   DSL_uint16_t ErrVecSize;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests vectoring debug counter values.
+*/
+struct CMD_DSM_StatsGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers vectoring debug counters.
+*/
+struct ACK_DSM_StatsGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Discarded Error Vectors, LSW */
+   DSL_uint16_t ErrVecDiscard_LSW;
+   /** Discarded Error Vectors, MSW */
+   DSL_uint16_t ErrVecDiscard_MSW;
+   /** Transmitted Error Vectors, LSW */
+   DSL_uint16_t ErrVecTransmitted_LSW;
+   /** Transmitted Error Vectors, MSW */
+   DSL_uint16_t ErrVecTransmitted_MSW;
+   /** Total Error Vectors Requested, LSW */
+   DSL_uint16_t ErrVecTotalReq_LSW;
+   /** Total Error Vectors Requested, MSW */
+   DSL_uint16_t ErrVecTotalReq_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Discarded Error Vectors, LSW */
+   DSL_uint16_t ErrVecDiscard_LSW;
+   /** Discarded Error Vectors, MSW */
+   DSL_uint16_t ErrVecDiscard_MSW;
+   /** Transmitted Error Vectors, LSW */
+   DSL_uint16_t ErrVecTransmitted_LSW;
+   /** Transmitted Error Vectors, MSW */
+   DSL_uint16_t ErrVecTransmitted_MSW;
+   /** Total Error Vectors Requested, LSW */
+   DSL_uint16_t ErrVecTotalReq_LSW;
+   /** Total Error Vectors Requested, MSW */
+   DSL_uint16_t ErrVecTotalReq_MSW;
+#endif
+} __PACKED__ ;
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#ifdef __PACKED_DEFINED__
+   #if !(defined (__GNUC__) || defined (__GNUG__))
+      #pragma pack()
+   #endif
+   #undef __PACKED_DEFINED__
+#endif /* __PACKED_DEFINED__ */
+
+/** @} */
+
+#endif /** _DRV_DSL_CPE_VRX_MSG_OLR_H_*/
--- /dev/null
+++ b/src/include/mcat3.2/drv_dsl_cpe_vrx_msg_perf_pmd.h
@@ -0,0 +1,1756 @@
+/******************************************************************************
+
+         Copyright 2016 - 2018 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+
+#ifndef _DRV_DSL_CPE_VRX_MSG_PERF_PMD_H_
+#define _DRV_DSL_CPE_VRX_MSG_PERF_PMD_H_
+
+/** \file
+
+*/
+
+#ifndef __PACKED__
+   #if defined (__GNUC__) || defined (__GNUG__)
+      /* GNU C or C++ compiler */
+      #define __PACKED__ __attribute__ ((packed))
+   #else
+      /* Byte alignment adjustment */
+      #pragma pack(1)
+      #define __PACKED__      /* nothing */
+   #endif
+   #define __PACKED_DEFINED__ 1
+#endif
+
+
+/** @defgroup _PERF_PMD_
+ *  @{
+ */
+
+#ifdef __cplusplus
+   extern "C" {
+#endif
+
+/* ----- Message Specific Constants Definition section ----- */
+/* ----- Message Specific Constants Definition section (End) ----- */
+
+/** Message ID for CMD_CounterControlSet */
+#define CMD_COUNTERCONTROLSET 0x004A
+
+/**
+   Controls the behaviour of the performance counters.
+*/
+typedef struct CMD_CounterControlSet CMD_CounterControlSet_t;
+
+/** Message ID for ACK_CounterControlSet */
+#define ACK_COUNTERCONTROLSET 0x004A
+
+/**
+   Acknowledgement for message CMD_CounterControlSet.
+*/
+typedef struct ACK_CounterControlSet ACK_CounterControlSet_t;
+
+/** Message ID for CMD_PM_OptionsSet */
+#define CMD_PM_OPTIONSSET 0x1662
+
+/**
+   Configures options for performance monitoring functions.
+*/
+typedef struct CMD_PM_OptionsSet CMD_PM_OptionsSet_t;
+
+/** Message ID for ACK_PM_OptionsSet */
+#define ACK_PM_OPTIONSSET 0x1662
+
+/**
+   Acknowledgement for message ACK_PM_OptionsSet.
+*/
+typedef struct ACK_PM_OptionsSet ACK_PM_OptionsSet_t;
+
+/** Message ID for ALM_LineFailureNE_Get */
+#define ALM_LINEFAILURENE_GET 0x0007
+
+/**
+   This autonomous message indicates near-end line failures.
+*/
+typedef struct ALM_LineFailureNE_Get ALM_LineFailureNE_Get_t;
+
+/** Message ID for CMD_LineFailureNE_Get */
+#define CMD_LINEFAILURENE_GET 0x0007
+
+/**
+   Requests the near-end line failure status.
+*/
+typedef struct CMD_LineFailureNE_Get CMD_LineFailureNE_Get_t;
+
+/** Message ID for ACK_LineFailureNE_Get */
+#define ACK_LINEFAILURENE_GET 0x0007
+
+/**
+   Provides the near-end line failure status requested by the command
+   CMD_LineFailureNE_Get.
+*/
+typedef struct ACK_LineFailureNE_Get ACK_LineFailureNE_Get_t;
+
+/** Message ID for ALM_LineFailureFE_Get */
+#define ALM_LINEFAILUREFE_GET 0x0107
+
+/**
+   This autonomous message indicates far-end line failures.
+*/
+typedef struct ALM_LineFailureFE_Get ALM_LineFailureFE_Get_t;
+
+/** Message ID for CMD_LineFailureFE_Get */
+#define CMD_LINEFAILUREFE_GET 0x0107
+
+/**
+   Requests the far-end line failure status.
+*/
+typedef struct CMD_LineFailureFE_Get CMD_LineFailureFE_Get_t;
+
+/** Message ID for ACK_LineFailureFE_Get */
+#define ACK_LINEFAILUREFE_GET 0x0107
+
+/**
+   Provides the far-end line failure status requested by the command
+   CMD_LineFailureFE_Get.
+*/
+typedef struct ACK_LineFailureFE_Get ACK_LineFailureFE_Get_t;
+
+/** Message ID for CMD_Failure_Trigger */
+#define CMD_FAILURE_TRIGGER 0x0562
+
+/**
+   Host initiated "loss of power". Triggers indicating an lpr primitive to the
+   remote side via the indicator bits ("IB bits").The host writes the message to
+   the FW e.g. after detecting LPR by an alternative detection scheme.
+*/
+typedef struct CMD_Failure_Trigger CMD_Failure_Trigger_t;
+
+/** Message ID for ACK_Failure_Trigger */
+#define ACK_FAILURE_TRIGGER 0x0562
+
+/**
+   Acknowledgement for CMD_Failure_Trigger.
+*/
+typedef struct ACK_Failure_Trigger ACK_Failure_Trigger_t;
+
+/** Message ID for CMD_LinePerfCountNE_Get */
+#define CMD_LINEPERFCOUNTNE_GET 0x020A
+
+/**
+   Requests near-end line performance counter values (Section 7.2.1.1 of
+   G.997.1). These are wrap-around counters which are not affected by the
+   TR1-period.
+*/
+typedef struct CMD_LinePerfCountNE_Get CMD_LinePerfCountNE_Get_t;
+
+/** Message ID for ACK_LinePerfCountNE_Get */
+#define ACK_LINEPERFCOUNTNE_GET 0x020A
+
+/**
+   Provides near-end line performance counter values requested by
+   CMD_LinePerfCountNE_Get (Section 7.2.1.1 of G.997.1). These are wrap-around
+   counters which are not affected by the TR1-period.
+*/
+typedef struct ACK_LinePerfCountNE_Get ACK_LinePerfCountNE_Get_t;
+
+/** Message ID for CMD_LinePerfCountFE_Get */
+#define CMD_LINEPERFCOUNTFE_GET 0x040A
+
+/**
+   Requests far-end line performance counter values (Section 7.2.1.2 of
+   G.997.1). These are wrap-around counters which are not affected by the
+   TR1-period.
+*/
+typedef struct CMD_LinePerfCountFE_Get CMD_LinePerfCountFE_Get_t;
+
+/** Message ID for ACK_LinePerfCountFE_Get */
+#define ACK_LINEPERFCOUNTFE_GET 0x040A
+
+/**
+   Provides far-end line performance counter values requested by
+   CMD_LinePerfCountFE_Get (Section 7.2.1.2 of G.997.1). These are wrap-around
+   counters which are not affected by the TR1-period.
+*/
+typedef struct ACK_LinePerfCountFE_Get ACK_LinePerfCountFE_Get_t;
+
+/** Message ID for CMD_CRC_StatsNE_Get */
+#define CMD_CRC_STATSNE_GET 0x080A
+
+/**
+   Requests near-end CRC counter values. These are wrap-around counters which
+   are not affected by the TR1-period.
+*/
+typedef struct CMD_CRC_StatsNE_Get CMD_CRC_StatsNE_Get_t;
+
+/** Message ID for ACK_CRC_StatsNE_Get */
+#define ACK_CRC_STATSNE_GET 0x080A
+
+/**
+   Returns near-end CRC counter values. (Section 7.2.2.1.1 of G.997.1). These
+   are wrap-around counters which are not affected by the TR1-period.The
+   "LP1/Fast Path" parameters are fed only in ADSL1 and ADSL1 Lite mode with
+   selected fast path and in VDSL/ADSL with RTX mode.
+*/
+typedef struct ACK_CRC_StatsNE_Get ACK_CRC_StatsNE_Get_t;
+
+/** Message ID for CMD_CRC_StatsFE_Get */
+#define CMD_CRC_STATSFE_GET 0x0C0A
+
+/**
+   Requests far-end CRC counter values. These are wrap-around counters which are
+   not affected by the TR1-period.
+*/
+typedef struct CMD_CRC_StatsFE_Get CMD_CRC_StatsFE_Get_t;
+
+/** Message ID for ACK_CRC_StatsFE_Get */
+#define ACK_CRC_STATSFE_GET 0x0C0A
+
+/**
+   Returns far-end CRC counter values. (Section 7.2.2.2.1 of G.997.1). These are
+   wrap-around counters which are not affected by the TR1-period.The "LP1/Fast
+   Path" parameters are fed in ADSL1 and ADSL1 Lite mode with selected fast path
+   and in VDSL with RTX mode.
+*/
+typedef struct ACK_CRC_StatsFE_Get ACK_CRC_StatsFE_Get_t;
+
+/** Message ID for CMD_FEC_StatsNE_Get */
+#define CMD_FEC_STATSNE_GET 0x0A0A
+
+/**
+   Requests near-end FEC counter values. These are wrap-around counters which
+   are not affected by the TR1-period.
+*/
+typedef struct CMD_FEC_StatsNE_Get CMD_FEC_StatsNE_Get_t;
+
+/** Message ID for ACK_FEC_StatsNE_Get */
+#define ACK_FEC_STATSNE_GET 0x0A0A
+
+/**
+   Returns near-end FEC counter values (Section 7.2.2.1.2 of G.997.1). These are
+   wrap-around counters which are not affected by the TR1-period.The "LP1/Fast
+   Path" parameters are fed only in ADSL1 and ADSL1 Lite mode with selected fast
+   path and in VDSL/ADSL with RTX mode.
+*/
+typedef struct ACK_FEC_StatsNE_Get ACK_FEC_StatsNE_Get_t;
+
+/** Message ID for CMD_FEC_StatsFE_Get */
+#define CMD_FEC_STATSFE_GET 0x0E0A
+
+/**
+   Requests far-end FEC counter values. These are wrap-around counters which are
+   not affected by the TR1-period.
+*/
+typedef struct CMD_FEC_StatsFE_Get CMD_FEC_StatsFE_Get_t;
+
+/** Message ID for ACK_FEC_StatsFE_Get */
+#define ACK_FEC_STATSFE_GET 0x0E0A
+
+/**
+   Returns far-end FEC counter values (Section 7.2.2.2.2 of G.997.1). These are
+   wrap-around counters which are not affected by the TR1-period.The "LP1/Fast
+   Path" parameters are fed in ADSL1 and ADSL1 Lite mode with selected fast path
+   and in VDSL with RTX mode.
+*/
+typedef struct ACK_FEC_StatsFE_Get ACK_FEC_StatsFE_Get_t;
+
+/** Message ID for CMD_SOS_StatsNE_Get */
+#define CMD_SOS_STATSNE_GET 0x290A
+
+/**
+   Requests the near-end 15 minutes SOS counter values.
+*/
+typedef struct CMD_SOS_StatsNE_Get CMD_SOS_StatsNE_Get_t;
+
+/** Message ID for ACK_SOS_StatsNE_Get */
+#define ACK_SOS_STATSNE_GET 0x290A
+
+/**
+   Returns near-end SOS counter values. (Section 7.2.1.6.1 of G.997.1)
+*/
+typedef struct ACK_SOS_StatsNE_Get ACK_SOS_StatsNE_Get_t;
+
+/** Message ID for CMD_SOS_StatsFE_Get */
+#define CMD_SOS_STATSFE_GET 0x2A0A
+
+/**
+   Requests the far-end 15 minutes SOS counter values. These are wrap-around
+   counters which are not affected by the TR1-period.
+*/
+typedef struct CMD_SOS_StatsFE_Get CMD_SOS_StatsFE_Get_t;
+
+/** Message ID for ACK_SOS_StatsFE_Get */
+#define ACK_SOS_STATSFE_GET 0x2A0A
+
+/**
+   Returns far-end SOS counter values. (Section 7.2.1.7.1 of G.997.1)
+*/
+typedef struct ACK_SOS_StatsFE_Get ACK_SOS_StatsFE_Get_t;
+
+/** Message ID for CMD_OHC_StatsGet  */
+#define CMD_OHC_STATSGET  0x410A
+
+/**
+   Requests error counters for the overhead channel. Applicable for cases where
+   the data and overhead channel are in different latency paths: RTX mode or/and
+   ROC used. These are wrap-around counters which are not affected by the
+   TR1-period.
+*/
+typedef struct CMD_OHC_StatsGet  CMD_OHC_StatsGet_t;
+
+/** Message ID for ACK_OHC_StatsGet */
+#define ACK_OHC_STATSGET 0x410A
+
+/**
+   Provides error counters for the LP carrying the overhead channel (EOC, RRC,
+   ROC). Useful only for cases where the data and overhead channel are in
+   separate latency paths: RTX mode or/and ROC used.
+*/
+typedef struct ACK_OHC_StatsGet ACK_OHC_StatsGet_t;
+
+/** Message ID for CMD_LinePerfCountNE_Set */
+#define CMD_LINEPERFCOUNTNE_SET 0x024A
+
+/**
+   Writes near-end line performance counter values (total wrap-around)(Section
+   7.2.1.1 of G.997.1).
+*/
+typedef struct CMD_LinePerfCountNE_Set CMD_LinePerfCountNE_Set_t;
+
+/** Message ID for ACK_LinePerfCountNE_Set */
+#define ACK_LINEPERFCOUNTNE_SET 0x024A
+
+/**
+   Acknowledgement for CMD_LinePerfCountNE_Set.
+*/
+typedef struct ACK_LinePerfCountNE_Set ACK_LinePerfCountNE_Set_t;
+
+/** Message ID for CMD_CRC_StatsNE_Set */
+#define CMD_CRC_STATSNE_SET 0x084A
+
+/**
+   Writes the near-end CRC counter values (Section 7.2.2.1.1 of G.997.1)The
+   "LP1/Fast Path" parameters are used only in ADSL1 and ADSL1 Lite mode with
+   selected "Fast Path".
+*/
+typedef struct CMD_CRC_StatsNE_Set CMD_CRC_StatsNE_Set_t;
+
+/** Message ID for ACK_CRC_StatsNE_Set */
+#define ACK_CRC_STATSNE_SET 0x084A
+
+/**
+   Acknowledgement for the message CMD_CRC_StatsNE_Set.
+*/
+typedef struct ACK_CRC_StatsNE_Set ACK_CRC_StatsNE_Set_t;
+
+/** Message ID for CMD_FEC_StatsNE_Set */
+#define CMD_FEC_STATSNE_SET 0x0A4A
+
+/**
+   Writes near-end FEC counter values. (Section 7.2.2.1.2 of G.997.1)The
+   "LP1/Fast Path" parameters are used only in ADSL1 and ADSL1 Lite mode with
+   selected "Fast Path".
+*/
+typedef struct CMD_FEC_StatsNE_Set CMD_FEC_StatsNE_Set_t;
+
+/** Message ID for ACK_FEC_StatsNE_Set */
+#define ACK_FEC_STATSNE_SET 0x0A4A
+
+/**
+   Acknowledgement for the message CMD_FEC_StatsNE_Set.
+*/
+typedef struct ACK_FEC_StatsNE_Set ACK_FEC_StatsNE_Set_t;
+
+/** Message ID for  CMD_SOS_StatsNE_Set */
+#define  CMD_SOS_STATSNE_SET 0x294A
+
+/**
+   Writes near-end SOS counter values. ("SOS-SUCCESS-NE", Section 7.2.1.6.1 of
+   G.997.1).
+*/
+typedef struct  CMD_SOS_StatsNE_Set CMD_SOS_StatsNE_Set_t;
+
+/** Message ID for  ACK_SOS_StatsNE_Set */
+#define  ACK_SOS_STATSNE_SET 0x294A
+
+/**
+   Acknowledgement for CMD_SOS_StatsNE_Set.
+*/
+typedef struct  ACK_SOS_StatsNE_Set ACK_SOS_StatsNE_Set_t;
+
+/** Message ID for CMD_TimeSet */
+#define CMD_TIMESET 0x6143
+
+/**
+   Sets the running time since midnightModifying the Time does not affect the
+   TR1 supervision period and the TR1-counters.
+*/
+typedef struct CMD_TimeSet CMD_TimeSet_t;
+
+/** Message ID for ACK_TimeSet */
+#define ACK_TIMESET 0x6143
+
+/**
+   Acknowledgement for message CMD_TimeSet.
+*/
+typedef struct ACK_TimeSet ACK_TimeSet_t;
+
+/** Message ID for CMD_TimeGet */
+#define CMD_TIMEGET 0x6103
+
+/**
+   Requests the status of the "Set Time and Read Time" EOC messages.
+*/
+typedef struct CMD_TimeGet CMD_TimeGet_t;
+
+/** Message ID for ACK_TimeGet */
+#define ACK_TIMEGET 0x6103
+
+/**
+   Provides the status of the "Set Time and Read Time" EOC messages.
+*/
+typedef struct ACK_TimeGet ACK_TimeGet_t;
+
+/**
+   Controls the behaviour of the performance counters.
+*/
+struct CMD_CounterControlSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+   /** Counter Inhibiting Enable */
+   DSL_uint16_t CntInhibitEnable : 1;
+   /** Fixed value: VRX_DISABLE */
+   DSL_uint16_t Res1 : 2;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Fixed value: VRX_DISABLE */
+   DSL_uint16_t Res1 : 2;
+   /** Counter Inhibiting Enable */
+   DSL_uint16_t CntInhibitEnable : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 13;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for message CMD_CounterControlSet.
+*/
+struct ACK_CounterControlSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Configures options for performance monitoring functions.
+*/
+struct CMD_PM_OptionsSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 15;
+   /** Supress CRC/FEC Counter-Writeback (ADSL only) */
+   DSL_uint16_t CrcFecWrProtect : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Supress CRC/FEC Counter-Writeback (ADSL only) */
+   DSL_uint16_t CrcFecWrProtect : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 15;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for message ACK_PM_OptionsSet.
+*/
+struct ACK_PM_OptionsSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This autonomous message indicates near-end line failures.
+*/
+struct ALM_LineFailureNE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 2;
+   /** ESE Failure NE */
+   DSL_uint16_t ESE_NE : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 9;
+   /** LOM Failure NE */
+   DSL_uint16_t LOM_NE : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 1;
+   /** LOF Failure NE */
+   DSL_uint16_t LOF_NE : 1;
+   /** LOS Failure NE */
+   DSL_uint16_t LOS_NE : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** LOS Failure NE */
+   DSL_uint16_t LOS_NE : 1;
+   /** LOF Failure NE */
+   DSL_uint16_t LOF_NE : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 1;
+   /** LOM Failure NE */
+   DSL_uint16_t LOM_NE : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 9;
+   /** ESE Failure NE */
+   DSL_uint16_t ESE_NE : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 2;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the near-end line failure status.
+*/
+struct CMD_LineFailureNE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the near-end line failure status requested by the command
+   CMD_LineFailureNE_Get.
+*/
+struct ACK_LineFailureNE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 2;
+   /** ESE Failure NE */
+   DSL_uint16_t ESE_NE : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 9;
+   /** LOM Failure NE */
+   DSL_uint16_t LOM_NE : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 1;
+   /** LOF Failure NE */
+   DSL_uint16_t LOF_NE : 1;
+   /** LOS Failure NE */
+   DSL_uint16_t LOS_NE : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** LOS Failure NE */
+   DSL_uint16_t LOS_NE : 1;
+   /** LOF Failure NE */
+   DSL_uint16_t LOF_NE : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 1;
+   /** LOM Failure NE */
+   DSL_uint16_t LOM_NE : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 9;
+   /** ESE Failure NE */
+   DSL_uint16_t ESE_NE : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 2;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This autonomous message indicates far-end line failures.
+*/
+struct ALM_LineFailureFE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 2;
+   /** ESE Failure FE */
+   DSL_uint16_t ESE_FE : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 9;
+   /** LOM Failure FE */
+   DSL_uint16_t LOM_FE : 1;
+   /** LPR Failure FE */
+   DSL_uint16_t LPR_FE : 1;
+   /** LOF Failure FE */
+   DSL_uint16_t LOF_FE : 1;
+   /** LOS Failure FE */
+   DSL_uint16_t LOS_FE : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** LOS Failure FE */
+   DSL_uint16_t LOS_FE : 1;
+   /** LOF Failure FE */
+   DSL_uint16_t LOF_FE : 1;
+   /** LPR Failure FE */
+   DSL_uint16_t LPR_FE : 1;
+   /** LOM Failure FE */
+   DSL_uint16_t LOM_FE : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 9;
+   /** ESE Failure FE */
+   DSL_uint16_t ESE_FE : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 2;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the far-end line failure status.
+*/
+struct CMD_LineFailureFE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the far-end line failure status requested by the command
+   CMD_LineFailureFE_Get.
+*/
+struct ACK_LineFailureFE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 2;
+   /** ESE Failure FE */
+   DSL_uint16_t ESE_FE : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 9;
+   /** LOM Failure FE */
+   DSL_uint16_t LOM_FE : 1;
+   /** LPR Failure FE */
+   DSL_uint16_t LPR_FE : 1;
+   /** LOF Failure FE */
+   DSL_uint16_t LOF_FE : 1;
+   /** LOS Failure FE */
+   DSL_uint16_t LOS_FE : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** LOS Failure FE */
+   DSL_uint16_t LOS_FE : 1;
+   /** LOF Failure FE */
+   DSL_uint16_t LOF_FE : 1;
+   /** LPR Failure FE */
+   DSL_uint16_t LPR_FE : 1;
+   /** LOM Failure FE */
+   DSL_uint16_t LOM_FE : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 9;
+   /** ESE Failure FE */
+   DSL_uint16_t ESE_FE : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 2;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Host initiated "loss of power". Triggers indicating an lpr primitive to the
+   remote side via the indicator bits ("IB bits").The host writes the message to
+   the FW e.g. after detecting LPR by an alternative detection scheme.
+*/
+struct CMD_Failure_Trigger
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 15;
+   /** LPR Trigger */
+   DSL_uint16_t lpr_Trigger : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** LPR Trigger */
+   DSL_uint16_t lpr_Trigger : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 15;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for CMD_Failure_Trigger.
+*/
+struct ACK_Failure_Trigger
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests near-end line performance counter values (Section 7.2.1.1 of
+   G.997.1). These are wrap-around counters which are not affected by the
+   TR1-period.
+*/
+struct CMD_LinePerfCountNE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides near-end line performance counter values requested by
+   CMD_LinePerfCountNE_Get (Section 7.2.1.1 of G.997.1). These are wrap-around
+   counters which are not affected by the TR1-period.
+*/
+struct ACK_LinePerfCountNE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End FECS Count, LSW */
+   DSL_uint16_t  cntFECS_LSW;
+   /** Near-End FECS Count, MSW */
+   DSL_uint16_t  cntFECS_MSW;
+   /** Near-End ES Count, LSW */
+   DSL_uint16_t  cntES_LSW;
+   /** Near-End ES Count, MSW */
+   DSL_uint16_t  cntES_MSW;
+   /** Near-End SES Count, LSW */
+   DSL_uint16_t  cntSES_LSW;
+   /** Near-End SES Count, MSW */
+   DSL_uint16_t  cntSES_MSW;
+   /** Near-End LOSS Count, LSW */
+   DSL_uint16_t  cntLOSS_LSW;
+   /** Near-End LOSS Count, MSW */
+   DSL_uint16_t  cntLOSS_MSW;
+   /** Near-End UAS Count, LSW */
+   DSL_uint16_t  cntUAS_LSW;
+   /** Near-End UAS Count, MSW */
+   DSL_uint16_t  cntUAS_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End FECS Count, LSW */
+   DSL_uint16_t  cntFECS_LSW;
+   /** Near-End FECS Count, MSW */
+   DSL_uint16_t  cntFECS_MSW;
+   /** Near-End ES Count, LSW */
+   DSL_uint16_t  cntES_LSW;
+   /** Near-End ES Count, MSW */
+   DSL_uint16_t  cntES_MSW;
+   /** Near-End SES Count, LSW */
+   DSL_uint16_t  cntSES_LSW;
+   /** Near-End SES Count, MSW */
+   DSL_uint16_t  cntSES_MSW;
+   /** Near-End LOSS Count, LSW */
+   DSL_uint16_t  cntLOSS_LSW;
+   /** Near-End LOSS Count, MSW */
+   DSL_uint16_t  cntLOSS_MSW;
+   /** Near-End UAS Count, LSW */
+   DSL_uint16_t  cntUAS_LSW;
+   /** Near-End UAS Count, MSW */
+   DSL_uint16_t  cntUAS_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests far-end line performance counter values (Section 7.2.1.2 of
+   G.997.1). These are wrap-around counters which are not affected by the
+   TR1-period.
+*/
+struct CMD_LinePerfCountFE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides far-end line performance counter values requested by
+   CMD_LinePerfCountFE_Get (Section 7.2.1.2 of G.997.1). These are wrap-around
+   counters which are not affected by the TR1-period.
+*/
+struct ACK_LinePerfCountFE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Far-End FECS Count, LSW */
+   DSL_uint16_t  cntFECS_LSW;
+   /** Far-End FECS Count, MSW */
+   DSL_uint16_t  cntFECS_MSW;
+   /** Far-End ES Count, LSW */
+   DSL_uint16_t  cntES_LSW;
+   /** Far-End ES Count, MSW */
+   DSL_uint16_t  cntES_MSW;
+   /** Far-End SES Count, LSW */
+   DSL_uint16_t  cntSES_LSW;
+   /** Far-End SES Count, MSW */
+   DSL_uint16_t  cntSES_MSW;
+   /** Far-End LOSS Count, LSW */
+   DSL_uint16_t  cntLOSS_LSW;
+   /** Far-End LOSS Count, MSW */
+   DSL_uint16_t  cntLOSS_MSW;
+   /** Near-End UAS Count, LSW */
+   DSL_uint16_t  cntUAS_LSW;
+   /** Near-End UAS Count, MSW */
+   DSL_uint16_t  cntUAS_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Far-End FECS Count, LSW */
+   DSL_uint16_t  cntFECS_LSW;
+   /** Far-End FECS Count, MSW */
+   DSL_uint16_t  cntFECS_MSW;
+   /** Far-End ES Count, LSW */
+   DSL_uint16_t  cntES_LSW;
+   /** Far-End ES Count, MSW */
+   DSL_uint16_t  cntES_MSW;
+   /** Far-End SES Count, LSW */
+   DSL_uint16_t  cntSES_LSW;
+   /** Far-End SES Count, MSW */
+   DSL_uint16_t  cntSES_MSW;
+   /** Far-End LOSS Count, LSW */
+   DSL_uint16_t  cntLOSS_LSW;
+   /** Far-End LOSS Count, MSW */
+   DSL_uint16_t  cntLOSS_MSW;
+   /** Near-End UAS Count, LSW */
+   DSL_uint16_t  cntUAS_LSW;
+   /** Near-End UAS Count, MSW */
+   DSL_uint16_t  cntUAS_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests near-end CRC counter values. These are wrap-around counters which
+   are not affected by the TR1-period.
+*/
+struct CMD_CRC_StatsNE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns near-end CRC counter values. (Section 7.2.2.1.1 of G.997.1). These
+   are wrap-around counters which are not affected by the TR1-period.The
+   "LP1/Fast Path" parameters are fed only in ADSL1 and ADSL1 Lite mode with
+   selected fast path and in VDSL/ADSL with RTX mode.
+*/
+struct ACK_CRC_StatsNE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End CRC Count LP0, LSW */
+   DSL_uint16_t cntCVI_LSW;
+   /** Near-End CRC Count LP0, MSW */
+   DSL_uint16_t cntCVI_MSW;
+   /** Near-End CRC Count LP1, LSW */
+   DSL_uint16_t cntCVF_LSW;
+   /** Near-End CRC Count LP1, MSW */
+   DSL_uint16_t cntCVF_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End CRC Count LP0, LSW */
+   DSL_uint16_t cntCVI_LSW;
+   /** Near-End CRC Count LP0, MSW */
+   DSL_uint16_t cntCVI_MSW;
+   /** Near-End CRC Count LP1, LSW */
+   DSL_uint16_t cntCVF_LSW;
+   /** Near-End CRC Count LP1, MSW */
+   DSL_uint16_t cntCVF_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests far-end CRC counter values. These are wrap-around counters which are
+   not affected by the TR1-period.
+*/
+struct CMD_CRC_StatsFE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns far-end CRC counter values. (Section 7.2.2.2.1 of G.997.1). These are
+   wrap-around counters which are not affected by the TR1-period.The "LP1/Fast
+   Path" parameters are fed in ADSL1 and ADSL1 Lite mode with selected fast path
+   and in VDSL with RTX mode.
+*/
+struct ACK_CRC_StatsFE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Far-End CRC Count LP0, LSW */
+   DSL_uint16_t cntCVI_LSW;
+   /** Far-End CRC Count LP0, MSW */
+   DSL_uint16_t cntCVI_MSW;
+   /** Far-End CRC Count LP1, LSW */
+   DSL_uint16_t cntCVF_LSW;
+   /** Far-End CRC Count LP1, MSW */
+   DSL_uint16_t cntCVF_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Far-End CRC Count LP0, LSW */
+   DSL_uint16_t cntCVI_LSW;
+   /** Far-End CRC Count LP0, MSW */
+   DSL_uint16_t cntCVI_MSW;
+   /** Far-End CRC Count LP1, LSW */
+   DSL_uint16_t cntCVF_LSW;
+   /** Far-End CRC Count LP1, MSW */
+   DSL_uint16_t cntCVF_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests near-end FEC counter values. These are wrap-around counters which
+   are not affected by the TR1-period.
+*/
+struct CMD_FEC_StatsNE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns near-end FEC counter values (Section 7.2.2.1.2 of G.997.1). These are
+   wrap-around counters which are not affected by the TR1-period.The "LP1/Fast
+   Path" parameters are fed only in ADSL1 and ADSL1 Lite mode with selected fast
+   path and in VDSL/ADSL with RTX mode.
+*/
+struct ACK_FEC_StatsNE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End FEC Count LP0, LSW */
+   DSL_uint16_t cntECI_LSW;
+   /** Near-End FEC Count LP0, MSW */
+   DSL_uint16_t cntECI_MSW;
+   /** Near-End FEC Count LP1, LSW */
+   DSL_uint16_t cntFEC_LSW;
+   /** Near-End FEC Count LP1, MSW */
+   DSL_uint16_t cntFEC_MSW;
+   /** Near-End FEC Uncorrectable Count LP0, LSW */
+   DSL_uint16_t cntECI_NoCorrLSW;
+   /** Near-End FEC Uncorrectable Count LP0, MSW */
+   DSL_uint16_t cntECI_NoCorrMSW;
+   /** Near-End FEC Uncorrectable Count LP1, LSW */
+   DSL_uint16_t cntECF_NoCorrLSW;
+   /** Near-End FEC Uncorrectable Count LP1, MSW */
+   DSL_uint16_t cntECF_NoCorrMSW;
+   /** Near-End Total RS CW Count LP0, LSW */
+   DSL_uint16_t cntECI_CW_LSW;
+   /** Near-End Total RS CW Count LP0, MSW */
+   DSL_uint16_t cntECI_CW_MSW;
+   /** Near-End Total RS CW Count LP1, LSW */
+   DSL_uint16_t cntECF_CW_LSW;
+   /** Near-End Total RS CW Count LP1, MSW */
+   DSL_uint16_t cntECF_CW_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End FEC Count LP0, LSW */
+   DSL_uint16_t cntECI_LSW;
+   /** Near-End FEC Count LP0, MSW */
+   DSL_uint16_t cntECI_MSW;
+   /** Near-End FEC Count LP1, LSW */
+   DSL_uint16_t cntFEC_LSW;
+   /** Near-End FEC Count LP1, MSW */
+   DSL_uint16_t cntFEC_MSW;
+   /** Near-End FEC Uncorrectable Count LP0, LSW */
+   DSL_uint16_t cntECI_NoCorrLSW;
+   /** Near-End FEC Uncorrectable Count LP0, MSW */
+   DSL_uint16_t cntECI_NoCorrMSW;
+   /** Near-End FEC Uncorrectable Count LP1, LSW */
+   DSL_uint16_t cntECF_NoCorrLSW;
+   /** Near-End FEC Uncorrectable Count LP1, MSW */
+   DSL_uint16_t cntECF_NoCorrMSW;
+   /** Near-End Total RS CW Count LP0, LSW */
+   DSL_uint16_t cntECI_CW_LSW;
+   /** Near-End Total RS CW Count LP0, MSW */
+   DSL_uint16_t cntECI_CW_MSW;
+   /** Near-End Total RS CW Count LP1, LSW */
+   DSL_uint16_t cntECF_CW_LSW;
+   /** Near-End Total RS CW Count LP1, MSW */
+   DSL_uint16_t cntECF_CW_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests far-end FEC counter values. These are wrap-around counters which are
+   not affected by the TR1-period.
+*/
+struct CMD_FEC_StatsFE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns far-end FEC counter values (Section 7.2.2.2.2 of G.997.1). These are
+   wrap-around counters which are not affected by the TR1-period.The "LP1/Fast
+   Path" parameters are fed in ADSL1 and ADSL1 Lite mode with selected fast path
+   and in VDSL with RTX mode.
+*/
+struct ACK_FEC_StatsFE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Far-End FEC Count LP0, LSW */
+   DSL_uint16_t cntECI_LSW;
+   /** Far-End FEC Count LP0, MSW */
+   DSL_uint16_t cntECI_MSW;
+   /** Far-End FEC Count LP1, LSW */
+   DSL_uint16_t cntFEC_LSW;
+   /** Far-End FEC Count LP1, MSW */
+   DSL_uint16_t cntFEC_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Far-End FEC Count LP0, LSW */
+   DSL_uint16_t cntECI_LSW;
+   /** Far-End FEC Count LP0, MSW */
+   DSL_uint16_t cntECI_MSW;
+   /** Far-End FEC Count LP1, LSW */
+   DSL_uint16_t cntFEC_LSW;
+   /** Far-End FEC Count LP1, MSW */
+   DSL_uint16_t cntFEC_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the near-end 15 minutes SOS counter values.
+*/
+struct CMD_SOS_StatsNE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns near-end SOS counter values. (Section 7.2.1.6.1 of G.997.1)
+*/
+struct ACK_SOS_StatsNE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End SOS Success Count LP0, LSW */
+   DSL_uint16_t cntSOS_SUC_LSW;
+   /** Near-End SOS Success Count LP0, MSW */
+   DSL_uint16_t cntSOS_SUC_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End SOS Success Count LP0, LSW */
+   DSL_uint16_t cntSOS_SUC_LSW;
+   /** Near-End SOS Success Count LP0, MSW */
+   DSL_uint16_t cntSOS_SUC_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the far-end 15 minutes SOS counter values. These are wrap-around
+   counters which are not affected by the TR1-period.
+*/
+struct CMD_SOS_StatsFE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Returns far-end SOS counter values. (Section 7.2.1.7.1 of G.997.1)
+*/
+struct ACK_SOS_StatsFE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Far-End SOS Success Count LP0, LSW */
+   DSL_uint16_t cntSOS_SUC_LSW;
+   /** Far-End SOS Success Count LP0, MSW */
+   DSL_uint16_t cntSOS_SUC_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Far-End SOS Success Count LP0, LSW */
+   DSL_uint16_t cntSOS_SUC_LSW;
+   /** Far-End SOS Success Count LP0, MSW */
+   DSL_uint16_t cntSOS_SUC_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests error counters for the overhead channel. Applicable for cases where
+   the data and overhead channel are in different latency paths: RTX mode or/and
+   ROC used. These are wrap-around counters which are not affected by the
+   TR1-period.
+*/
+struct CMD_OHC_StatsGet 
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides error counters for the LP carrying the overhead channel (EOC, RRC,
+   ROC). Useful only for cases where the data and overhead channel are in
+   separate latency paths: RTX mode or/and ROC used.
+*/
+struct ACK_OHC_StatsGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End CRC Count LP0, LSW */
+   DSL_uint16_t cntCRC_LSW;
+   /** Near-End CRC Count LP0, MSW */
+   DSL_uint16_t cntCRC_MSW;
+   /** Near-End FEC Count LP0, LSW */
+   DSL_uint16_t cntFEC_LSW;
+   /** Near-End FEC Count LP0, MSW */
+   DSL_uint16_t cntFEC_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End CRC Count LP0, LSW */
+   DSL_uint16_t cntCRC_LSW;
+   /** Near-End CRC Count LP0, MSW */
+   DSL_uint16_t cntCRC_MSW;
+   /** Near-End FEC Count LP0, LSW */
+   DSL_uint16_t cntFEC_LSW;
+   /** Near-End FEC Count LP0, MSW */
+   DSL_uint16_t cntFEC_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Writes near-end line performance counter values (total wrap-around)(Section
+   7.2.1.1 of G.997.1).
+*/
+struct CMD_LinePerfCountNE_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End FECS Count, LSW */
+   DSL_uint16_t  cntFECS_LSW;
+   /** Near-End FECS Count, MSW */
+   DSL_uint16_t  cntFECS_MSW;
+   /** Near-End ES Count, LSW */
+   DSL_uint16_t  cntES_LSW;
+   /** Near-End ES Count, MSW */
+   DSL_uint16_t  cntES_MSW;
+   /** Near-End SES Count, LSW */
+   DSL_uint16_t  cntSES_LSW;
+   /** Near-End SES Count, MSW */
+   DSL_uint16_t  cntSES_MSW;
+   /** Near-End LOSS Count, LSW */
+   DSL_uint16_t  cntLOSS_LSW;
+   /** Near-End LOSS Count, MSW */
+   DSL_uint16_t  cntLOSS_MSW;
+   /** Near-End UAS Count, LSW */
+   DSL_uint16_t  cntUAS_LSW;
+   /** Near-End UAS Count, MSW */
+   DSL_uint16_t  cntUAS_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End FECS Count, LSW */
+   DSL_uint16_t  cntFECS_LSW;
+   /** Near-End FECS Count, MSW */
+   DSL_uint16_t  cntFECS_MSW;
+   /** Near-End ES Count, LSW */
+   DSL_uint16_t  cntES_LSW;
+   /** Near-End ES Count, MSW */
+   DSL_uint16_t  cntES_MSW;
+   /** Near-End SES Count, LSW */
+   DSL_uint16_t  cntSES_LSW;
+   /** Near-End SES Count, MSW */
+   DSL_uint16_t  cntSES_MSW;
+   /** Near-End LOSS Count, LSW */
+   DSL_uint16_t  cntLOSS_LSW;
+   /** Near-End LOSS Count, MSW */
+   DSL_uint16_t  cntLOSS_MSW;
+   /** Near-End UAS Count, LSW */
+   DSL_uint16_t  cntUAS_LSW;
+   /** Near-End UAS Count, MSW */
+   DSL_uint16_t  cntUAS_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for CMD_LinePerfCountNE_Set.
+*/
+struct ACK_LinePerfCountNE_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Writes the near-end CRC counter values (Section 7.2.2.1.1 of G.997.1)The
+   "LP1/Fast Path" parameters are used only in ADSL1 and ADSL1 Lite mode with
+   selected "Fast Path".
+*/
+struct CMD_CRC_StatsNE_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End CRC Count LP0, LSW */
+   DSL_uint16_t cntCVI_LSW;
+   /** Near-End CRC Count LP0, MSW */
+   DSL_uint16_t cntCVI_MSW;
+   /** Near-End CRC Count LP1, LSW */
+   DSL_uint16_t cntCVF_LSW;
+   /** Near-End CRC Count LP1, MSW */
+   DSL_uint16_t cntCVF_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End CRC Count LP0, LSW */
+   DSL_uint16_t cntCVI_LSW;
+   /** Near-End CRC Count LP0, MSW */
+   DSL_uint16_t cntCVI_MSW;
+   /** Near-End CRC Count LP1, LSW */
+   DSL_uint16_t cntCVF_LSW;
+   /** Near-End CRC Count LP1, MSW */
+   DSL_uint16_t cntCVF_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for the message CMD_CRC_StatsNE_Set.
+*/
+struct ACK_CRC_StatsNE_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Writes near-end FEC counter values. (Section 7.2.2.1.2 of G.997.1)The
+   "LP1/Fast Path" parameters are used only in ADSL1 and ADSL1 Lite mode with
+   selected "Fast Path".
+*/
+struct CMD_FEC_StatsNE_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End FEC Count LP0, LSW */
+   DSL_uint16_t cntECI_LSW;
+   /** Near-End FEC Count LP0, MSW */
+   DSL_uint16_t cntECI_MSW;
+   /** Near-End FEC Count LP1, LSW */
+   DSL_uint16_t cntFEC_LSW;
+   /** Near-End FEC Count LP1, MSW */
+   DSL_uint16_t cntFEC_MSW;
+   /** Near-End FEC Uncorrectable Count LP0, LSW */
+   DSL_uint16_t cntECI_NoCorrLSW;
+   /** Near-End FEC Uncorrectable Count LP0, MSW */
+   DSL_uint16_t cntECI_NoCorrMSW;
+   /** Near-End FEC Uncorrectable Count LP1, LSW */
+   DSL_uint16_t cntECF_NoCorrLSW;
+   /** Near-End FEC Uncorrectable Count LP1, MSW */
+   DSL_uint16_t cntECF_NoCorrMSW;
+   /** Near-End Total RS CW Count LP0, LSW */
+   DSL_uint16_t cntECI_CW_LSW;
+   /** Near-End Total RS CW Count LP0, MSW */
+   DSL_uint16_t cntECI_CW_MSW;
+   /** Near-End Total RS CW Count LP1, LSW */
+   DSL_uint16_t cntECF_CW_LSW;
+   /** Near-End Total RS CW Count LP1, MSW */
+   DSL_uint16_t cntECF_CW_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End FEC Count LP0, LSW */
+   DSL_uint16_t cntECI_LSW;
+   /** Near-End FEC Count LP0, MSW */
+   DSL_uint16_t cntECI_MSW;
+   /** Near-End FEC Count LP1, LSW */
+   DSL_uint16_t cntFEC_LSW;
+   /** Near-End FEC Count LP1, MSW */
+   DSL_uint16_t cntFEC_MSW;
+   /** Near-End FEC Uncorrectable Count LP0, LSW */
+   DSL_uint16_t cntECI_NoCorrLSW;
+   /** Near-End FEC Uncorrectable Count LP0, MSW */
+   DSL_uint16_t cntECI_NoCorrMSW;
+   /** Near-End FEC Uncorrectable Count LP1, LSW */
+   DSL_uint16_t cntECF_NoCorrLSW;
+   /** Near-End FEC Uncorrectable Count LP1, MSW */
+   DSL_uint16_t cntECF_NoCorrMSW;
+   /** Near-End Total RS CW Count LP0, LSW */
+   DSL_uint16_t cntECI_CW_LSW;
+   /** Near-End Total RS CW Count LP0, MSW */
+   DSL_uint16_t cntECI_CW_MSW;
+   /** Near-End Total RS CW Count LP1, LSW */
+   DSL_uint16_t cntECF_CW_LSW;
+   /** Near-End Total RS CW Count LP1, MSW */
+   DSL_uint16_t cntECF_CW_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for the message CMD_FEC_StatsNE_Set.
+*/
+struct ACK_FEC_StatsNE_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Writes near-end SOS counter values. ("SOS-SUCCESS-NE", Section 7.2.1.6.1 of
+   G.997.1).
+*/
+struct  CMD_SOS_StatsNE_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End SOS Success Count LP0, LSW */
+   DSL_uint16_t cntSOS_SUC_LSW;
+   /** Near-End SOS Success Count LP0, MSW */
+   DSL_uint16_t cntSOS_SUC_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-End SOS Success Count LP0, LSW */
+   DSL_uint16_t cntSOS_SUC_LSW;
+   /** Near-End SOS Success Count LP0, MSW */
+   DSL_uint16_t cntSOS_SUC_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for CMD_SOS_StatsNE_Set.
+*/
+struct  ACK_SOS_StatsNE_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Sets the running time since midnightModifying the Time does not affect the
+   TR1 supervision period and the TR1-counters.
+*/
+struct CMD_TimeSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0[3];
+   /** NE Time */
+   VRX_TIME_t timeNE;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0[3];
+   /** NE Time */
+   VRX_TIME_t timeNE;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for message CMD_TimeSet.
+*/
+struct ACK_TimeSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the status of the "Set Time and Read Time" EOC messages.
+*/
+struct CMD_TimeGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the status of the "Set Time and Read Time" EOC messages.
+*/
+struct ACK_TimeGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** FE Time */
+   VRX_TIME_t timeFE;
+   /** NE Time */
+   VRX_TIME_t timeNE;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0;
+   /** FE Time */
+   VRX_TIME_t timeFE;
+   /** NE Time */
+   VRX_TIME_t timeNE;
+#endif
+} __PACKED__ ;
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#ifdef __PACKED_DEFINED__
+   #if !(defined (__GNUC__) || defined (__GNUG__))
+      #pragma pack()
+   #endif
+   #undef __PACKED_DEFINED__
+#endif /* __PACKED_DEFINED__ */
+
+/** @} */
+
+#endif /** _DRV_DSL_CPE_VRX_MSG_PERF_PMD_H_*/
--- /dev/null
+++ b/src/include/mcat3.2/drv_dsl_cpe_vrx_msg_tc_counters.h
@@ -0,0 +1,2218 @@
+/******************************************************************************
+
+         Copyright 2016 - 2019 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
+
+  For licensing information, see the file 'LICENSE' in the root folder of
+  this software module.
+
+******************************************************************************/
+
+
+#ifndef _DRV_DSL_CPE_VRX_MSG_TC_COUNTERS_H_
+#define _DRV_DSL_CPE_VRX_MSG_TC_COUNTERS_H_
+
+/** \file
+
+*/
+
+#ifndef __PACKED__
+   #if defined (__GNUC__) || defined (__GNUG__)
+      /* GNU C or C++ compiler */
+      #define __PACKED__ __attribute__ ((packed))
+   #else
+      /* Byte alignment adjustment */
+      #pragma pack(1)
+      #define __PACKED__      /* nothing */
+   #endif
+   #define __PACKED_DEFINED__ 1
+#endif
+
+
+/** @defgroup _TC_COUNTERS_
+ *  @{
+ */
+
+#ifdef __cplusplus
+   extern "C" {
+#endif
+
+/* ----- Message Specific Constants Definition section ----- */
+#define ACK_TC_StatusGet_UNKNOWN_TC 0x0
+#define ACK_TC_StatusGet_EFM_TC 0x1
+#define ACK_TC_StatusGet_ATM_TC 0x2
+#define EVT_TC_StatusGet_EFM_TC 0x1
+#define EVT_TC_StatusGet_ATM_TC 0x2
+#define CMD_TC_FW_InfoSet_EFM_TC 0x1
+#define CMD_TC_FW_InfoSet_ATM_TC 0x2
+#define ACK_VersionInfoGet_VRX518 0x0
+#define ACK_VersionInfoGet_VRX517 0x1
+#define ACK_VersionInfoGet_HW_VER11 0x0
+#define ACK_VersionInfoGet_HW_VER12 0x1
+#define ACK_VersionInfoGet_VRX200 0x05
+#define ACK_VersionInfoGet_VRX300 0x07
+#define ACK_VersionInfoGet_VRX500 0x08
+#define ACK_VersionInfoGet_R3 10
+#define ACK_VersionInfoGet_R4 11
+#define ACK_VersionInfoGet_R5 12
+#define ACK_VersionInfoGet_R6 13
+#define ACK_VersionInfoGet_RELEASE 0
+#define ACK_VersionInfoGet_PRERELEASE 1
+#define ACK_VersionInfoGet_DEVELOP 3
+#define ACK_VersionInfoGet_ADSL_A 1
+#define ACK_VersionInfoGet_ADSL_BJ 2
+#define ACK_VersionInfoGet_VDSL2 6
+#define CMD_PAF_HS_Continue_WAIT 0x0
+#define CMD_PAF_HS_Continue_CONTINUE 0x1
+/* ----- Message Specific Constants Definition section (End) ----- */
+
+/** Message ID for CMD_TC_StatusGet */
+#define CMD_TC_STATUSGET 0x0E22
+
+/**
+   The message reads the used TC.In ADSL the TC type is selected during G.HS and
+   thus known when entering FULL_INIT. In VDSL it is selected later, during
+   FULL_INIT. Before this point the FW will report the TC as "unknown".
+*/
+typedef struct CMD_TC_StatusGet CMD_TC_StatusGet_t;
+
+/** Message ID for ACK_TC_StatusGet */
+#define ACK_TC_STATUSGET 0x0E22
+
+/**
+   Reporting of the used TC mode.
+*/
+typedef struct ACK_TC_StatusGet ACK_TC_StatusGet_t;
+
+/** Message ID for EVT_TC_StatusGet */
+#define EVT_TC_STATUSGET 0x0E22
+
+/**
+   This autonomous Event reports the to be used TC mode after being known. In R7
+   FW (w.7.x.y.z.a) only generated when enabled in CMD_Misc_ConfigSet TcTypeEvt.
+*/
+typedef struct EVT_TC_StatusGet EVT_TC_StatusGet_t;
+
+/** Message ID for CMD_TC_FW_InfoSet */
+#define CMD_TC_FW_INFOSET 0x1762
+
+/**
+   The message informs the DSL-FW about the currently loaded TC FW driver.
+*/
+typedef struct CMD_TC_FW_InfoSet CMD_TC_FW_InfoSet_t;
+
+/** Message ID for ACK_TC_FW_InfoSet */
+#define ACK_TC_FW_INFOSET 0x1762
+
+/**
+   Acknowledgement to CMD_TC_FW_InfoSet.
+*/
+typedef struct ACK_TC_FW_InfoSet ACK_TC_FW_InfoSet_t;
+
+/** Message ID for CMD_MAC_FrameConfigure */
+#define CMD_MAC_FRAMECONFIGURE 0x5348
+
+/**
+   The message configures Ethernet properties, currently the MAC address of the
+   device only.The MAC address is needed in the FW as "MAC source address"for
+   PDUs not built by the host, like e.g. for the Ethernet encapsulated
+   Backchannel Data ERB in Vectoring.
+*/
+typedef struct CMD_MAC_FrameConfigure CMD_MAC_FrameConfigure_t;
+
+/** Message ID for ACK_MAC_FrameConfigure */
+#define ACK_MAC_FRAMECONFIGURE 0x5348
+
+/**
+   Acknowledgement to CMD_MAC_FrameConfigure.
+*/
+typedef struct ACK_MAC_FrameConfigure ACK_MAC_FrameConfigure_t;
+
+/** Message ID for CMD_DataPathFailuresAlarmConfigure */
+#define CMD_DATAPATHFAILURESALARMCONFIGURE 0x1249
+
+/**
+   Enables/Disables the generation of ALARM messages (ALM) for specific data-
+   path failures. If the corresponding Enable bit for a failure is set, then the
+   modem firmware will send an autonomous message ALM_DataPathFailuresGet if
+   this failure occurs.
+*/
+typedef struct CMD_DataPathFailuresAlarmConfigure CMD_DataPathFailuresAlarmConfigure_t;
+
+/** Message ID for ACK_DataPathFailuresAlarmConfigure */
+#define ACK_DATAPATHFAILURESALARMCONFIGURE 0x1249
+
+/**
+   Acknowledgement to CMD_DataPathFailuresAlarmConfigure.
+*/
+typedef struct ACK_DataPathFailuresAlarmConfigure ACK_DataPathFailuresAlarmConfigure_t;
+
+/** Message ID for CMD_DataPathFailuresGet */
+#define CMD_DATAPATHFAILURESGET 0x0507
+
+/**
+   Requests the data-path failure status.
+*/
+typedef struct CMD_DataPathFailuresGet CMD_DataPathFailuresGet_t;
+
+/** Message ID for ACK_DataPathFailuresGet */
+#define ACK_DATAPATHFAILURESGET 0x0507
+
+/**
+   Provides the data path failure status as requested by the command
+   CMD_DataPathFailuresGet.
+*/
+typedef struct ACK_DataPathFailuresGet ACK_DataPathFailuresGet_t;
+
+/** Message ID for ALM_DataPathFailuresGet */
+#define ALM_DATAPATHFAILURESGET 0x0507
+
+/**
+   This autonomous message reports the data-path failure status. It is sent only
+   if the message generation was enabled for the corresponding failure with
+   CMD_DataPathFailuresAlarmConfigure.
+*/
+typedef struct ALM_DataPathFailuresGet ALM_DataPathFailuresGet_t;
+
+/** Message ID for CMD_PTM_BC0_StatsNE_Get */
+#define CMD_PTM_BC0_STATSNE_GET 0x2D0A
+
+/**
+   Requests the values of the near-end PTM data path performance counters for
+   bearer channel 0 (BC0) as defined in G.997.1 (Section 7.2.5.1. of [11]).The
+   counters are total counters.
+*/
+typedef struct CMD_PTM_BC0_StatsNE_Get CMD_PTM_BC0_StatsNE_Get_t;
+
+/** Message ID for ACK_PTM_BC0_StatsNE_Get */
+#define ACK_PTM_BC0_STATSNE_GET 0x2D0A
+
+/**
+   Delivers the near-end total TPS-TC counter values for bearer channel 0 (BC0)
+   as requested by CMD_PTM_BC0_StatsNE_Get. (Section 7.2.5.1. of [11])
+*/
+typedef struct ACK_PTM_BC0_StatsNE_Get ACK_PTM_BC0_StatsNE_Get_t;
+
+/** Message ID for CMD_PTM_BC0_StatsNE_Set */
+#define CMD_PTM_BC0_STATSNE_SET 0x2D4A
+
+/**
+   Writes the TPS-TC CRC error and TPS-TC coding violation counters (Section
+   7.2.5.1. of G.997.1 [11]).Why writing these counters? For "automoding",
+   meaning modems configured to support both ADSL and VDLS with automatic mode
+   selection. The first retrain is always done with an ADSL FW independent of
+   what was loaded before. Therefore, the counters must be saved by the host
+   before destroying them by the FW download and are written back before the
+   next link start of a FW that supports PTM.
+*/
+typedef struct CMD_PTM_BC0_StatsNE_Set CMD_PTM_BC0_StatsNE_Set_t;
+
+/** Message ID for ACK_PTM_BC0_StatsNE_Set */
+#define ACK_PTM_BC0_STATSNE_SET 0x2D4A
+
+/**
+   Acknowledgement for the message CMD_PTM_BC0_StatsNE_Set.
+*/
+typedef struct ACK_PTM_BC0_StatsNE_Set ACK_PTM_BC0_StatsNE_Set_t;
+
+/** Message ID for CMD_ATM_BC0_StatsNE_Get */
+#define CMD_ATM_BC0_STATSNE_GET 0x2E0A
+
+/**
+   This command is used to request the near-end data-path performance counters
+   for BC0 of an ATM-TC link as defined in Section 7.2.4. of G.997.1 [11].
+*/
+typedef struct CMD_ATM_BC0_StatsNE_Get CMD_ATM_BC0_StatsNE_Get_t;
+
+/** Message ID for ACK_ATM_BC0_StatsNE_Get */
+#define ACK_ATM_BC0_STATSNE_GET 0x2E0A
+
+/**
+   Provides the total near-end ATM-TC performance counters for bearer channel 0
+   (BC0) as requested by the command CMD_ATM_BC0_StatsNE_Get.ADSL1/ADSL1 Lite
+   Fast Path reports its ATM -TC counters in this message too.
+*/
+typedef struct ACK_ATM_BC0_StatsNE_Get ACK_ATM_BC0_StatsNE_Get_t;
+
+/** Message ID for CMD_ATM_BC0_StatsFE_Get */
+#define CMD_ATM_BC0_STATSFE_GET 0x330A
+
+/**
+   This command is used to request the far-end data-path performance counters
+   for BC0 of an ATM-TC link as defined in Section 7.2.4.2 of G.997.1 [11].
+*/
+typedef struct CMD_ATM_BC0_StatsFE_Get CMD_ATM_BC0_StatsFE_Get_t;
+
+/** Message ID for ACK_ATM_BC0_StatsFE_Get */
+#define ACK_ATM_BC0_STATSFE_GET 0x330A
+
+/**
+   Provides the total near-end ATM-TC performance counters for bearer channel 0
+   (BC0) as requested by the command CMD_ATM_BC0_StatsFE_Get.
+*/
+typedef struct ACK_ATM_BC0_StatsFE_Get ACK_ATM_BC0_StatsFE_Get_t;
+
+/** Message ID for CMD_ATM_BC0_StatsNE_Set */
+#define CMD_ATM_BC0_STATSNE_SET 0x2E4A
+
+/**
+   Writes the data-path performance counters for bearer channel 0 (BC0) of an
+   ATM-TC link (Section 7.2.4. of G.997.1 [11]).Why writing counters? The ADSL
+   FW of the VRX destroys the performance counters at the beginning of a re-
+   initialization since it starts with a FW download. Therefore the host has to
+   save the counters in FAIL state before triggering a re-init. When
+   reconfiguring the system in RESET state, the host writes the saved values as
+   start values back into the counters. To do this for the ATM-TC counters, this
+   message is used.
+*/
+typedef struct CMD_ATM_BC0_StatsNE_Set CMD_ATM_BC0_StatsNE_Set_t;
+
+/** Message ID for ACK_ATM_BC0_StatsNE_Set */
+#define ACK_ATM_BC0_STATSNE_SET 0x2E4A
+
+/**
+   Acknowledgement for the message CMD_ATM_BC0_StatsNE_Set.
+*/
+typedef struct ACK_ATM_BC0_StatsNE_Set ACK_ATM_BC0_StatsNE_Set_t;
+
+/** Message ID for CMD_ATM_BC0_TxStatsNE_Get */
+#define CMD_ATM_BC0_TXSTATSNE_GET 0x350A
+
+/**
+   Requests near-end ATM datapath performance transmit counters for bearer
+   channel 0 (BC0).
+*/
+typedef struct CMD_ATM_BC0_TxStatsNE_Get CMD_ATM_BC0_TxStatsNE_Get_t;
+
+/** Message ID for ACK_ATM_BC0_TxStatsNE_Get */
+#define ACK_ATM_BC0_TXSTATSNE_GET 0x350A
+
+/**
+   Provides the ATM-TC transmit counters for beare channel 0 (BC0) as requested
+   by the command CMD_ATM_BC0_TxStatsNE_Get.ADSL1/ADSL1 Lite Fast Path reports
+   its ATM -TC counters in this message too.
+*/
+typedef struct ACK_ATM_BC0_TxStatsNE_Get ACK_ATM_BC0_TxStatsNE_Get_t;
+
+/** Message ID for CMD_ATM_BC0_TxStatsNE_Set */
+#define CMD_ATM_BC0_TXSTATSNE_SET 0x354A
+
+/**
+   Writes the transmit data-path counters for BC0 of an ATM-TC link.For "Why
+   writing performance counters" see Page 690.
+*/
+typedef struct CMD_ATM_BC0_TxStatsNE_Set CMD_ATM_BC0_TxStatsNE_Set_t;
+
+/** Message ID for ACK_ATM_BC0_TxStatsNE_Set */
+#define ACK_ATM_BC0_TXSTATSNE_SET 0x354A
+
+/**
+   Acknowledgement for the message CMD_ATM_BC0_TxStatsNE_Set.
+*/
+typedef struct ACK_ATM_BC0_TxStatsNE_Set ACK_ATM_BC0_TxStatsNE_Set_t;
+
+/** Message ID for CMD_VersionInfoGet */
+#define CMD_VERSIONINFOGET 0x0010
+
+/**
+   Requests version information from the VDSL2-Modem.
+*/
+typedef struct CMD_VersionInfoGet CMD_VersionInfoGet_t;
+
+/** Message ID for ACK_VersionInfoGet */
+#define ACK_VERSIONINFOGET 0x0010
+
+/**
+   Provides version information about hardware and firmware. The FW version
+   numbering scheme has a long and a short form (Table 378).
+*/
+typedef struct ACK_VersionInfoGet ACK_VersionInfoGet_t;
+
+/** Message ID for CMD_PPA_FwVersionSet */
+#define CMD_PPA_FWVERSIONSET 0x2362
+
+/**
+   Writes the PPA subsystem version to the DSL FW.
+*/
+typedef struct CMD_PPA_FwVersionSet CMD_PPA_FwVersionSet_t;
+
+/** Message ID for ACK_PPA_FwVersionSet */
+#define ACK_PPA_FWVERSIONSET 0x2362
+
+/**
+   Acknowledgement for message CMD_PPA_FwVersionSet.
+*/
+typedef struct ACK_PPA_FwVersionSet ACK_PPA_FwVersionSet_t;
+
+/** Message ID for CMD_PPA_FwVersionGet */
+#define CMD_PPA_FWVERSIONGET 0x2322
+
+/**
+   Requests the PPA Subsystem Version number (Read-back).
+*/
+typedef struct CMD_PPA_FwVersionGet CMD_PPA_FwVersionGet_t;
+
+/** Message ID for ACK_PPA_FwVersionGet */
+#define ACK_PPA_FWVERSIONGET 0x2322
+
+/**
+   Provides the PPA subsystem version. Read back of the value previously written
+   by CMD_PPA_FwVersionSet.
+*/
+typedef struct ACK_PPA_FwVersionGet ACK_PPA_FwVersionGet_t;
+
+/** Message ID for CMD_PPE_FwVersionGet */
+#define CMD_PPE_FWVERSIONGET 0x2422
+
+/**
+   Requests the PPE FW Version number.
+*/
+typedef struct CMD_PPE_FwVersionGet CMD_PPE_FwVersionGet_t;
+
+/** Message ID for ACK_PPE_FwVersionGet */
+#define ACK_PPE_FWVERSIONGET 0x2422
+
+/**
+   Provides the PPE FW version number.
+*/
+typedef struct ACK_PPE_FwVersionGet ACK_PPE_FwVersionGet_t;
+
+/** Message ID for CMD_ADSL_FeatureMapGet */
+#define CMD_ADSL_FEATUREMAPGET 0x1322
+
+/**
+   Requests the feature map indicating the ADSL FW features supported by this
+   binary.
+*/
+typedef struct CMD_ADSL_FeatureMapGet CMD_ADSL_FeatureMapGet_t;
+
+/** Message ID for ACK_ADSL_FeatureMapGet */
+#define ACK_ADSL_FEATUREMAPGET 0x1322
+
+/**
+   Reports the feature map indicating the ADSL FW features supported by this
+   binary.
+*/
+typedef struct ACK_ADSL_FeatureMapGet ACK_ADSL_FeatureMapGet_t;
+
+/** Message ID for CMD_VDSL_FeatureMapGet */
+#define CMD_VDSL_FEATUREMAPGET 0x1422
+
+/**
+   Requests the feature map indicating the VDSL FW features supported by this
+   binary.
+*/
+typedef struct CMD_VDSL_FeatureMapGet CMD_VDSL_FeatureMapGet_t;
+
+/** Message ID for ACK_VDSL_FeatureMapGet */
+#define ACK_VDSL_FEATUREMAPGET 0x1422
+
+/**
+   Reports the feature map indicating the VDSL FW features supported by this
+   binary.
+*/
+typedef struct ACK_VDSL_FeatureMapGet ACK_VDSL_FeatureMapGet_t;
+
+/** Message ID for CMD_PAF_HS_Control */
+#define CMD_PAF_HS_CONTROL 0x1148
+
+/**
+   The message is used to enable bonding (PAF) and to control the GHS
+   aggregation discovery and aggregation processes. The register numbers
+   referenced refer to IEEE 802.3ah [14], Clause 45.
+*/
+typedef struct CMD_PAF_HS_Control CMD_PAF_HS_Control_t;
+
+/** Message ID for ACK_PAF_HS_Control */
+#define ACK_PAF_HS_CONTROL 0x1148
+
+/**
+   The message acknowledges CMD_PAF_HS_Control.
+*/
+typedef struct ACK_PAF_HS_Control ACK_PAF_HS_Control_t;
+
+/** Message ID for CMD_PAF_HS_ControlGet */
+#define CMD_PAF_HS_CONTROLGET 0x1108
+
+/**
+   The message reads back settings for bonding configured with
+   CMD_PAF_HS_Control.
+*/
+typedef struct CMD_PAF_HS_ControlGet CMD_PAF_HS_ControlGet_t;
+
+/** Message ID for ACK_PAF_HS_ControlGet */
+#define ACK_PAF_HS_CONTROLGET 0x1108
+
+/**
+   The message acknowledges CMD_PAF_HS_ControlGet providing PAF bonding
+   parameters used in handshake as configured with CMD_PAF_HS_Control.
+*/
+typedef struct ACK_PAF_HS_ControlGet ACK_PAF_HS_ControlGet_t;
+
+/** Message ID for CMD_PAF_HS_StatusGet */
+#define CMD_PAF_HS_STATUSGET 0xDD03
+
+/**
+   The message requests aggregation discovery and aggregation status information
+   for EFM bonding.
+*/
+typedef struct CMD_PAF_HS_StatusGet CMD_PAF_HS_StatusGet_t;
+
+/** Message ID for ACK_PAF_HS_StatusGet */
+#define ACK_PAF_HS_STATUSGET 0xDD03
+
+/**
+   The message reports discovery and aggregation status information for EFM
+   bonding after request by CMD_PAF_HS_StatusGet.At the CPE side, the Host SW
+   concludes on a GET request if none of the following 4 bits are set:
+   discoveryClearIfSame, discoverySetIfClear, aggregClear , aggregSet. It does
+   not distinguish between "discovery GET" and "aggregation GET"; in case of any
+   "GET" both the discovery and the aggregation code are sent to the CO with the
+   CLR.
+*/
+typedef struct ACK_PAF_HS_StatusGet ACK_PAF_HS_StatusGet_t;
+
+/** Message ID for CMD_PAF_HS_Continue */
+#define CMD_PAF_HS_CONTINUE 0x0C62
+
+/**
+   The message writes the aggregation discovery code and the aggregation data
+   down to the FW and is used to trigger the CPE-FW to proceed in handshake
+   (sending CLR) after it had been waiting in GHS_BONDING_CLR state for the
+   necessary host interactions to be finished. These actions depend on the
+   request type (see ACK_PAF_HS_StatusGet): the processing of the remote
+   discovery register (for an aggregation discovery "Set If Clear" or "Clear If
+   Same" command) or PME Aggregate register (for an aggregation "Set" or "Clear"
+   command) in the SW and -in any case including a "Get" command - then updating
+   the local representations of both in the FW (which are sent to the CO in a
+   CLR).
+*/
+typedef struct CMD_PAF_HS_Continue CMD_PAF_HS_Continue_t;
+
+/** Message ID for ACK_PAF_HS_Continue */
+#define ACK_PAF_HS_CONTINUE 0x0C62
+
+/**
+   The message acknowledges CMD_PAF_HS_Continue.
+*/
+typedef struct ACK_PAF_HS_Continue ACK_PAF_HS_Continue_t;
+
+/** Message ID for CMD_PAF_PME_ID_Set */
+#define CMD_PAF_PME_ID_SET 0x5948
+
+/**
+   Sets the PME identification number. This number is transferred with the CLR
+   message to the CO.
+*/
+typedef struct CMD_PAF_PME_ID_Set CMD_PAF_PME_ID_Set_t;
+
+/** Message ID for ACK_PAF_PME_ID_Set */
+#define ACK_PAF_PME_ID_SET 0x5948
+
+/**
+   The message acknowledges CMD_PAF_PME_ID_Set.
+*/
+typedef struct ACK_PAF_PME_ID_Set ACK_PAF_PME_ID_Set_t;
+
+/**
+   The message reads the used TC.In ADSL the TC type is selected during G.HS and
+   thus known when entering FULL_INIT. In VDSL it is selected later, during
+   FULL_INIT. Before this point the FW will report the TC as "unknown".
+*/
+struct CMD_TC_StatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reporting of the used TC mode.
+*/
+struct ACK_TC_StatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TC Used */
+   DSL_uint16_t TC;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TC Used */
+   DSL_uint16_t TC;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This autonomous Event reports the to be used TC mode after being known. In R7
+   FW (w.7.x.y.z.a) only generated when enabled in CMD_Misc_ConfigSet TcTypeEvt.
+*/
+struct EVT_TC_StatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TC Used */
+   DSL_uint16_t TC;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TC Used */
+   DSL_uint16_t TC;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message informs the DSL-FW about the currently loaded TC FW driver.
+*/
+struct CMD_TC_FW_InfoSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TC Loaded */
+   DSL_uint16_t loadedTC;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TC Loaded */
+   DSL_uint16_t loadedTC;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_TC_FW_InfoSet.
+*/
+struct ACK_TC_FW_InfoSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message configures Ethernet properties, currently the MAC address of the
+   device only.The MAC address is needed in the FW as "MAC source address"for
+   PDUs not built by the host, like e.g. for the Ethernet encapsulated
+   Backchannel Data ERB in Vectoring.
+*/
+struct CMD_MAC_FrameConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Source MAC Address Octets 0 to 1 */
+   DSL_uint16_t SrcMacAddrB0_1;
+   /** Source MAC Address Octets 2 to 3 */
+   DSL_uint16_t SrcMacAddrB2_3;
+   /** Source MAC Address Octets 4 to 5 */
+   DSL_uint16_t SrcMacAddrB4_5;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Source MAC Address Octets 0 to 1 */
+   DSL_uint16_t SrcMacAddrB0_1;
+   /** Source MAC Address Octets 2 to 3 */
+   DSL_uint16_t SrcMacAddrB2_3;
+   /** Source MAC Address Octets 4 to 5 */
+   DSL_uint16_t SrcMacAddrB4_5;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_MAC_FrameConfigure.
+*/
+struct ACK_MAC_FrameConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Enables/Disables the generation of ALARM messages (ALM) for specific data-
+   path failures. If the corresponding Enable bit for a failure is set, then the
+   modem firmware will send an autonomous message ALM_DataPathFailuresGet if
+   this failure occurs.
+*/
+struct CMD_DataPathFailuresAlarmConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 6;
+   /** OOS Failure FE, BC0 */
+   DSL_uint16_t OOS_FE_BC1 : 1;
+   /** OOS Failure FE, BC0 */
+   DSL_uint16_t OOS_FE_BC0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 6;
+   /** OOS Failure NE, BC1 */
+   DSL_uint16_t OOS_NE_BC1 : 1;
+   /** OOS Failure NE, BC0 */
+   DSL_uint16_t OOS_NE_BC0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 4;
+   /** LCD Failure FE, BC1 */
+   DSL_uint16_t LCD_FE_BC1 : 1;
+   /** NCD Failure FE, BC1 */
+   DSL_uint16_t NCD_FE_BC1 : 1;
+   /** LCD Failure FE, BC0 */
+   DSL_uint16_t LCD_FE_BC0 : 1;
+   /** NCD Failure FE, BC0 */
+   DSL_uint16_t NCD_FE_BC0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 4;
+   /** LCD Failure NE, BC1 */
+   DSL_uint16_t LCD_NE_BC1 : 1;
+   /** NCD Failure NE, BC1 */
+   DSL_uint16_t NCD_NE_BC1 : 1;
+   /** LCD Failure NE, BC0 */
+   DSL_uint16_t LCD_NE_BC0 : 1;
+   /** NCD Failure NE, BC0 */
+   DSL_uint16_t NCD_NE_BC0 : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** OOS Failure NE, BC0 */
+   DSL_uint16_t OOS_NE_BC0 : 1;
+   /** OOS Failure NE, BC1 */
+   DSL_uint16_t OOS_NE_BC1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 6;
+   /** OOS Failure FE, BC0 */
+   DSL_uint16_t OOS_FE_BC0 : 1;
+   /** OOS Failure FE, BC0 */
+   DSL_uint16_t OOS_FE_BC1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 6;
+   /** NCD Failure NE, BC0 */
+   DSL_uint16_t NCD_NE_BC0 : 1;
+   /** LCD Failure NE, BC0 */
+   DSL_uint16_t LCD_NE_BC0 : 1;
+   /** NCD Failure NE, BC1 */
+   DSL_uint16_t NCD_NE_BC1 : 1;
+   /** LCD Failure NE, BC1 */
+   DSL_uint16_t LCD_NE_BC1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 4;
+   /** NCD Failure FE, BC0 */
+   DSL_uint16_t NCD_FE_BC0 : 1;
+   /** LCD Failure FE, BC0 */
+   DSL_uint16_t LCD_FE_BC0 : 1;
+   /** NCD Failure FE, BC1 */
+   DSL_uint16_t NCD_FE_BC1 : 1;
+   /** LCD Failure FE, BC1 */
+   DSL_uint16_t LCD_FE_BC1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 4;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement to CMD_DataPathFailuresAlarmConfigure.
+*/
+struct ACK_DataPathFailuresAlarmConfigure
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the data-path failure status.
+*/
+struct CMD_DataPathFailuresGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the data path failure status as requested by the command
+   CMD_DataPathFailuresGet.
+*/
+struct ACK_DataPathFailuresGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 6;
+   /** OOS Failure FE, BC0 */
+   DSL_uint16_t OOS_FE_BC1 : 1;
+   /** OOS Failure FE, BC0 */
+   DSL_uint16_t OOS_FE_BC0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 6;
+   /** OOS Failure NE, BC1 */
+   DSL_uint16_t OOS_NE_BC1 : 1;
+   /** OOS Failure NE, BC0 */
+   DSL_uint16_t OOS_NE_BC0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 4;
+   /** LCD Failure FE, BC1 */
+   DSL_uint16_t LCD_FE_BC1 : 1;
+   /** NCD Failure FE, BC1 */
+   DSL_uint16_t NCD_FE_BC1 : 1;
+   /** LCD Failure FE, BC0 */
+   DSL_uint16_t LCD_FE_BC0 : 1;
+   /** NCD Failure FE, BC0 */
+   DSL_uint16_t NCD_FE_BC0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 4;
+   /** LCD Failure NE, BC1 */
+   DSL_uint16_t LCD_NE_BC1 : 1;
+   /** NCD Failure NE, BC1 */
+   DSL_uint16_t NCD_NE_BC1 : 1;
+   /** LCD Failure NE, BC0 */
+   DSL_uint16_t LCD_NE_BC0 : 1;
+   /** NCD Failure NE, BC0 */
+   DSL_uint16_t NCD_NE_BC0 : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** OOS Failure NE, BC0 */
+   DSL_uint16_t OOS_NE_BC0 : 1;
+   /** OOS Failure NE, BC1 */
+   DSL_uint16_t OOS_NE_BC1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 6;
+   /** OOS Failure FE, BC0 */
+   DSL_uint16_t OOS_FE_BC0 : 1;
+   /** OOS Failure FE, BC0 */
+   DSL_uint16_t OOS_FE_BC1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 6;
+   /** NCD Failure NE, BC0 */
+   DSL_uint16_t NCD_NE_BC0 : 1;
+   /** LCD Failure NE, BC0 */
+   DSL_uint16_t LCD_NE_BC0 : 1;
+   /** NCD Failure NE, BC1 */
+   DSL_uint16_t NCD_NE_BC1 : 1;
+   /** LCD Failure NE, BC1 */
+   DSL_uint16_t LCD_NE_BC1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 4;
+   /** NCD Failure FE, BC0 */
+   DSL_uint16_t NCD_FE_BC0 : 1;
+   /** LCD Failure FE, BC0 */
+   DSL_uint16_t LCD_FE_BC0 : 1;
+   /** NCD Failure FE, BC1 */
+   DSL_uint16_t NCD_FE_BC1 : 1;
+   /** LCD Failure FE, BC1 */
+   DSL_uint16_t LCD_FE_BC1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 4;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This autonomous message reports the data-path failure status. It is sent only
+   if the message generation was enabled for the corresponding failure with
+   CMD_DataPathFailuresAlarmConfigure.
+*/
+struct ALM_DataPathFailuresGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 6;
+   /** OOS Failure FE, BC0 */
+   DSL_uint16_t OOS_FE_BC1 : 1;
+   /** OOS Failure FE, BC0 */
+   DSL_uint16_t OOS_FE_BC0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 6;
+   /** OOS Failure NE, BC1 */
+   DSL_uint16_t OOS_NE_BC1 : 1;
+   /** OOS Failure NE, BC0 */
+   DSL_uint16_t OOS_NE_BC0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 4;
+   /** LCD Failure FE, BC1 */
+   DSL_uint16_t LCD_FE_BC1 : 1;
+   /** NCD Failure FE, BC1 */
+   DSL_uint16_t NCD_FE_BC1 : 1;
+   /** LCD Failure FE, BC0 */
+   DSL_uint16_t LCD_FE_BC0 : 1;
+   /** NCD Failure FE, BC0 */
+   DSL_uint16_t NCD_FE_BC0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 4;
+   /** LCD Failure NE, BC1 */
+   DSL_uint16_t LCD_NE_BC1 : 1;
+   /** NCD Failure NE, BC1 */
+   DSL_uint16_t NCD_NE_BC1 : 1;
+   /** LCD Failure NE, BC0 */
+   DSL_uint16_t LCD_NE_BC0 : 1;
+   /** NCD Failure NE, BC0 */
+   DSL_uint16_t NCD_NE_BC0 : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** OOS Failure NE, BC0 */
+   DSL_uint16_t OOS_NE_BC0 : 1;
+   /** OOS Failure NE, BC1 */
+   DSL_uint16_t OOS_NE_BC1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 6;
+   /** OOS Failure FE, BC0 */
+   DSL_uint16_t OOS_FE_BC0 : 1;
+   /** OOS Failure FE, BC0 */
+   DSL_uint16_t OOS_FE_BC1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 6;
+   /** NCD Failure NE, BC0 */
+   DSL_uint16_t NCD_NE_BC0 : 1;
+   /** LCD Failure NE, BC0 */
+   DSL_uint16_t LCD_NE_BC0 : 1;
+   /** NCD Failure NE, BC1 */
+   DSL_uint16_t NCD_NE_BC1 : 1;
+   /** LCD Failure NE, BC1 */
+   DSL_uint16_t LCD_NE_BC1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 4;
+   /** NCD Failure FE, BC0 */
+   DSL_uint16_t NCD_FE_BC0 : 1;
+   /** LCD Failure FE, BC0 */
+   DSL_uint16_t LCD_FE_BC0 : 1;
+   /** NCD Failure FE, BC1 */
+   DSL_uint16_t NCD_FE_BC1 : 1;
+   /** LCD Failure FE, BC1 */
+   DSL_uint16_t LCD_FE_BC1 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 4;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the values of the near-end PTM data path performance counters for
+   bearer channel 0 (BC0) as defined in G.997.1 (Section 7.2.5.1. of [11]).The
+   counters are total counters.
+*/
+struct CMD_PTM_BC0_StatsNE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Delivers the near-end total TPS-TC counter values for bearer channel 0 (BC0)
+   as requested by CMD_PTM_BC0_StatsNE_Get. (Section 7.2.5.1. of [11])
+*/
+struct ACK_PTM_BC0_StatsNE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TPS-TC CRC Counter (CRC-P), NE, BC0, LSW */
+   DSL_uint16_t cntCRC_LSW;
+   /** TPS-TC CRC Counter (CRC-P), NE, BC0, MSW */
+   DSL_uint16_t cntCRC_MSW;
+   /** TPS-TC CV Counter (CV-P), NE, BC0, LSW */
+   DSL_uint16_t cntCV_LSW;
+   /** TPS-TC CV Counter (CV-P), NE, BC0, MSW */
+   DSL_uint16_t cntCV_MSW;
+   /** TPS-TC CRC Counter (CRCP-P), NE, BC0, LSW */
+   DSL_uint16_t cntCRCP_LSW;
+   /** TPS-TC CRC Counter (CRCP-P), NE, BC0, MSW */
+   DSL_uint16_t cntCRCP_MSW;
+   /** TPS-TC CV Counter (CVP-P), NE, BC0, LSW */
+   DSL_uint16_t cntCVP_LSW;
+   /** TPS-TC CV Counter (CVP-P), NE, BC0, MSW */
+   DSL_uint16_t cntCVP_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TPS-TC CRC Counter (CRC-P), NE, BC0, LSW */
+   DSL_uint16_t cntCRC_LSW;
+   /** TPS-TC CRC Counter (CRC-P), NE, BC0, MSW */
+   DSL_uint16_t cntCRC_MSW;
+   /** TPS-TC CV Counter (CV-P), NE, BC0, LSW */
+   DSL_uint16_t cntCV_LSW;
+   /** TPS-TC CV Counter (CV-P), NE, BC0, MSW */
+   DSL_uint16_t cntCV_MSW;
+   /** TPS-TC CRC Counter (CRCP-P), NE, BC0, LSW */
+   DSL_uint16_t cntCRCP_LSW;
+   /** TPS-TC CRC Counter (CRCP-P), NE, BC0, MSW */
+   DSL_uint16_t cntCRCP_MSW;
+   /** TPS-TC CV Counter (CVP-P), NE, BC0, LSW */
+   DSL_uint16_t cntCVP_LSW;
+   /** TPS-TC CV Counter (CVP-P), NE, BC0, MSW */
+   DSL_uint16_t cntCVP_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Writes the TPS-TC CRC error and TPS-TC coding violation counters (Section
+   7.2.5.1. of G.997.1 [11]).Why writing these counters? For "automoding",
+   meaning modems configured to support both ADSL and VDLS with automatic mode
+   selection. The first retrain is always done with an ADSL FW independent of
+   what was loaded before. Therefore, the counters must be saved by the host
+   before destroying them by the FW download and are written back before the
+   next link start of a FW that supports PTM.
+*/
+struct CMD_PTM_BC0_StatsNE_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TPS-TC CRC Counter (CRC-P), NE, BC0, LSW */
+   DSL_uint16_t cntCRC_LSW;
+   /** TPS-TC CRC Counter (CRC-P), NE, BC0, MSW */
+   DSL_uint16_t cntCRC_MSW;
+   /** TPS-TC CV Counter (CV-P), NE, BC0, LSW */
+   DSL_uint16_t cntCV_LSW;
+   /** TPS-TC CV Counter (CV-P), NE, BC0, MSW */
+   DSL_uint16_t cntCV_MSW;
+   /** TPS-TC CRC Counter (CRCP-P), NE, BC0, LSW */
+   DSL_uint16_t cntCRCP_LSW;
+   /** TPS-TC CRC Counter (CRCP-P), NE, BC0, MSW */
+   DSL_uint16_t cntCRCP_MSW;
+   /** TPS-TC CV Counter (CVP-P), NE, BC0, LSW */
+   DSL_uint16_t cntCVP_LSW;
+   /** TPS-TC CV Counter (CVP-P), NE, BC0, MSW */
+   DSL_uint16_t cntCVP_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** TPS-TC CRC Counter (CRC-P), NE, BC0, LSW */
+   DSL_uint16_t cntCRC_LSW;
+   /** TPS-TC CRC Counter (CRC-P), NE, BC0, MSW */
+   DSL_uint16_t cntCRC_MSW;
+   /** TPS-TC CV Counter (CV-P), NE, BC0, LSW */
+   DSL_uint16_t cntCV_LSW;
+   /** TPS-TC CV Counter (CV-P), NE, BC0, MSW */
+   DSL_uint16_t cntCV_MSW;
+   /** TPS-TC CRC Counter (CRCP-P), NE, BC0, LSW */
+   DSL_uint16_t cntCRCP_LSW;
+   /** TPS-TC CRC Counter (CRCP-P), NE, BC0, MSW */
+   DSL_uint16_t cntCRCP_MSW;
+   /** TPS-TC CV Counter (CVP-P), NE, BC0, LSW */
+   DSL_uint16_t cntCVP_LSW;
+   /** TPS-TC CV Counter (CVP-P), NE, BC0, MSW */
+   DSL_uint16_t cntCVP_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for the message CMD_PTM_BC0_StatsNE_Set.
+*/
+struct ACK_PTM_BC0_StatsNE_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This command is used to request the near-end data-path performance counters
+   for BC0 of an ATM-TC link as defined in Section 7.2.4. of G.997.1 [11].
+*/
+struct CMD_ATM_BC0_StatsNE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the total near-end ATM-TC performance counters for bearer channel 0
+   (BC0) as requested by the command CMD_ATM_BC0_StatsNE_Get.ADSL1/ADSL1 Lite
+   Fast Path reports its ATM -TC counters in this message too.
+*/
+struct ACK_ATM_BC0_StatsNE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** NE HEC Violation Count (HEC-P), LSW */
+   DSL_uint16_t hecp_LSW;
+   /** NE HEC Violation Count (HEC-P), MSW */
+   DSL_uint16_t hecp_MSW;
+   /** NE Delineated Total Cell Count (CD-P), LSW */
+   DSL_uint16_t cdp_LSW;
+   /** NE Delineated Total Cell Count (CD-P), MSW */
+   DSL_uint16_t cdp_MSW;
+   /** NE User Total Cell Count (CU-P), LSW */
+   DSL_uint16_t cup_LSW;
+   /** NE User Total Cell Count (CU-P), MSW */
+   DSL_uint16_t cup_MSW;
+   /** NE Idle Cell Bit Error Count (IBE-P), LSW */
+   DSL_uint16_t ibep_LSW;
+   /** NE Idle Cell Bit Error Count (IBE-P), MSW */
+   DSL_uint16_t ibep_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** NE HEC Violation Count (HEC-P), LSW */
+   DSL_uint16_t hecp_LSW;
+   /** NE HEC Violation Count (HEC-P), MSW */
+   DSL_uint16_t hecp_MSW;
+   /** NE Delineated Total Cell Count (CD-P), LSW */
+   DSL_uint16_t cdp_LSW;
+   /** NE Delineated Total Cell Count (CD-P), MSW */
+   DSL_uint16_t cdp_MSW;
+   /** NE User Total Cell Count (CU-P), LSW */
+   DSL_uint16_t cup_LSW;
+   /** NE User Total Cell Count (CU-P), MSW */
+   DSL_uint16_t cup_MSW;
+   /** NE Idle Cell Bit Error Count (IBE-P), LSW */
+   DSL_uint16_t ibep_LSW;
+   /** NE Idle Cell Bit Error Count (IBE-P), MSW */
+   DSL_uint16_t ibep_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   This command is used to request the far-end data-path performance counters
+   for BC0 of an ATM-TC link as defined in Section 7.2.4.2 of G.997.1 [11].
+*/
+struct CMD_ATM_BC0_StatsFE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the total near-end ATM-TC performance counters for bearer channel 0
+   (BC0) as requested by the command CMD_ATM_BC0_StatsFE_Get.
+*/
+struct ACK_ATM_BC0_StatsFE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** FE HEC Violation Count (HEC-PFE), LSW */
+   DSL_uint16_t hecpfe_LSW;
+   /** FE HEC Violation Count (HEC-PFE), MSW */
+   DSL_uint16_t hecpfe_MSW;
+   /** FE Delineated Total Cell Count (CD-PFE), LSW */
+   DSL_uint16_t cdpfe_LSW;
+   /** FE Delineated Total Cell Count (CD-PFE), MSW */
+   DSL_uint16_t cdpfe_MSW;
+   /** FE User Total Cell Count (CU-PFE), LSW */
+   DSL_uint16_t cupfe_LSW;
+   /** FE User Total Cell Count (CU-PFE), MSW */
+   DSL_uint16_t cupfe_MSW;
+   /** FE Idle Cell Bit Error Count (IBE-PFE), LSW */
+   DSL_uint16_t ibepfe_LSW;
+   /** FE Idle Cell Bit Error Count (IBE-PFE), MSW */
+   DSL_uint16_t ibepfe_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** FE HEC Violation Count (HEC-PFE), LSW */
+   DSL_uint16_t hecpfe_LSW;
+   /** FE HEC Violation Count (HEC-PFE), MSW */
+   DSL_uint16_t hecpfe_MSW;
+   /** FE Delineated Total Cell Count (CD-PFE), LSW */
+   DSL_uint16_t cdpfe_LSW;
+   /** FE Delineated Total Cell Count (CD-PFE), MSW */
+   DSL_uint16_t cdpfe_MSW;
+   /** FE User Total Cell Count (CU-PFE), LSW */
+   DSL_uint16_t cupfe_LSW;
+   /** FE User Total Cell Count (CU-PFE), MSW */
+   DSL_uint16_t cupfe_MSW;
+   /** FE Idle Cell Bit Error Count (IBE-PFE), LSW */
+   DSL_uint16_t ibepfe_LSW;
+   /** FE Idle Cell Bit Error Count (IBE-PFE), MSW */
+   DSL_uint16_t ibepfe_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Writes the data-path performance counters for bearer channel 0 (BC0) of an
+   ATM-TC link (Section 7.2.4. of G.997.1 [11]).Why writing counters? The ADSL
+   FW of the VRX destroys the performance counters at the beginning of a re-
+   initialization since it starts with a FW download. Therefore the host has to
+   save the counters in FAIL state before triggering a re-init. When
+   reconfiguring the system in RESET state, the host writes the saved values as
+   start values back into the counters. To do this for the ATM-TC counters, this
+   message is used.
+*/
+struct CMD_ATM_BC0_StatsNE_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** NE HEC Violation Count (HEC-P), LSW */
+   DSL_uint16_t hecp_LSW;
+   /** NE HEC Violation Count (HEC-P), MSW */
+   DSL_uint16_t hecp_MSW;
+   /** NE Delineated Total Cell Count (CD-P), LSW */
+   DSL_uint16_t cdp_LSW;
+   /** NE Delineated Total Cell Count (CD-P), MSW */
+   DSL_uint16_t cdp_MSW;
+   /** NE User Total Cell Count (CU-P), LSW */
+   DSL_uint16_t cup_LSW;
+   /** NE User Total Cell Count (CU-P), MSW */
+   DSL_uint16_t cup_MSW;
+   /** NE Idle Cell Bit Error Count (IBE-P), LSW */
+   DSL_uint16_t ibep_LSW;
+   /** NE Idle Cell Bit Error Count (IBE-P), MSW */
+   DSL_uint16_t ibep_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** NE HEC Violation Count (HEC-P), LSW */
+   DSL_uint16_t hecp_LSW;
+   /** NE HEC Violation Count (HEC-P), MSW */
+   DSL_uint16_t hecp_MSW;
+   /** NE Delineated Total Cell Count (CD-P), LSW */
+   DSL_uint16_t cdp_LSW;
+   /** NE Delineated Total Cell Count (CD-P), MSW */
+   DSL_uint16_t cdp_MSW;
+   /** NE User Total Cell Count (CU-P), LSW */
+   DSL_uint16_t cup_LSW;
+   /** NE User Total Cell Count (CU-P), MSW */
+   DSL_uint16_t cup_MSW;
+   /** NE Idle Cell Bit Error Count (IBE-P), LSW */
+   DSL_uint16_t ibep_LSW;
+   /** NE Idle Cell Bit Error Count (IBE-P), MSW */
+   DSL_uint16_t ibep_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for the message CMD_ATM_BC0_StatsNE_Set.
+*/
+struct ACK_ATM_BC0_StatsNE_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests near-end ATM datapath performance transmit counters for bearer
+   channel 0 (BC0).
+*/
+struct CMD_ATM_BC0_TxStatsNE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the ATM-TC transmit counters for beare channel 0 (BC0) as requested
+   by the command CMD_ATM_BC0_TxStatsNE_Get.ADSL1/ADSL1 Lite Fast Path reports
+   its ATM -TC counters in this message too.
+*/
+struct ACK_ATM_BC0_TxStatsNE_Get
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-end TX User Cell Count (TxCU), Current Period, LSW */
+   DSL_uint16_t TxCU_LSW;
+   /** Near-end TX User Cell Count (TxCU), Current Period, MSW */
+   DSL_uint16_t TxCU_MSW;
+   /** Near-end TX Idle Cell Count (TxIdle), Current Period, LSW */
+   DSL_uint16_t TxIdle_LSW;
+   /** Near-end TX Idle Cell Count (TxIdle), Current Period, MSW */
+   DSL_uint16_t TxIdle_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-end TX User Cell Count (TxCU), Current Period, LSW */
+   DSL_uint16_t TxCU_LSW;
+   /** Near-end TX User Cell Count (TxCU), Current Period, MSW */
+   DSL_uint16_t TxCU_MSW;
+   /** Near-end TX Idle Cell Count (TxIdle), Current Period, LSW */
+   DSL_uint16_t TxIdle_LSW;
+   /** Near-end TX Idle Cell Count (TxIdle), Current Period, MSW */
+   DSL_uint16_t TxIdle_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Writes the transmit data-path counters for BC0 of an ATM-TC link.For "Why
+   writing performance counters" see Page 690.
+*/
+struct CMD_ATM_BC0_TxStatsNE_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-end TX User Cell Count (TxCU), Current Period, LSW */
+   DSL_uint16_t TxCU_LSW;
+   /** Near-end TX User Cell Count (TxCU), Current Period, MSW */
+   DSL_uint16_t TxCU_MSW;
+   /** Near-end TX Idle Cell Count (TxIdle), Current Period, LSW */
+   DSL_uint16_t TxIdle_LSW;
+   /** Near-end TX Idle Cell Count (TxIdle), Current Period, MSW */
+   DSL_uint16_t TxIdle_MSW;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Near-end TX User Cell Count (TxCU), Current Period, LSW */
+   DSL_uint16_t TxCU_LSW;
+   /** Near-end TX User Cell Count (TxCU), Current Period, MSW */
+   DSL_uint16_t TxCU_MSW;
+   /** Near-end TX Idle Cell Count (TxIdle), Current Period, LSW */
+   DSL_uint16_t TxIdle_LSW;
+   /** Near-end TX Idle Cell Count (TxIdle), Current Period, MSW */
+   DSL_uint16_t TxIdle_MSW;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for the message CMD_ATM_BC0_TxStatsNE_Set.
+*/
+struct ACK_ATM_BC0_TxStatsNE_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests version information from the VDSL2-Modem.
+*/
+struct CMD_VersionInfoGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides version information about hardware and firmware. The FW version
+   numbering scheme has a long and a short form (Table 378).
+*/
+struct ACK_VersionInfoGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Hardware Version Number */
+   DSL_uint32_t HW_Version;
+   /** Reserved */
+   DSL_uint32_t Res0;
+   /** Firmware Version Number (Long) */
+   DSL_uint32_t FW_Version;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Hardware Version Number */
+   DSL_uint32_t HW_Version;
+   /** Reserved */
+   DSL_uint32_t Res0;
+   /** Firmware Version Number (Long) */
+   DSL_uint32_t FW_Version;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Writes the PPA subsystem version to the DSL FW.
+*/
+struct CMD_PPA_FwVersionSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PPA Subsystem Version Number, LSW, 3. Digit */
+   DSL_uint16_t SubSysVer3 : 8;
+   /** PPA Subsystem Version Number, LSW, 4. Digit */
+   DSL_uint16_t SubSysVer4 : 8;
+   /** PPA Subsystem Version Number, MSW, 1. Digit */
+   DSL_uint16_t SubSysVer1 : 8;
+   /** PPA Subsystem Version Number, MSW, 2. Digit */
+   DSL_uint16_t SubSysVer2 : 8;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PPA Subsystem Version Number, LSW, 4. Digit */
+   DSL_uint16_t SubSysVer4 : 8;
+   /** PPA Subsystem Version Number, LSW, 3. Digit */
+   DSL_uint16_t SubSysVer3 : 8;
+   /** PPA Subsystem Version Number, MSW, 2. Digit */
+   DSL_uint16_t SubSysVer2 : 8;
+   /** PPA Subsystem Version Number, MSW, 1. Digit */
+   DSL_uint16_t SubSysVer1 : 8;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Acknowledgement for message CMD_PPA_FwVersionSet.
+*/
+struct ACK_PPA_FwVersionSet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the PPA Subsystem Version number (Read-back).
+*/
+struct CMD_PPA_FwVersionGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the PPA subsystem version. Read back of the value previously written
+   by CMD_PPA_FwVersionSet.
+*/
+struct ACK_PPA_FwVersionGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PPA Subsystem Version Number, LSW, 3. Digit */
+   DSL_uint16_t SubSysVer3 : 8;
+   /** PPA Subsystem Version Number, LSW, 4. Digit */
+   DSL_uint16_t SubSysVer4 : 8;
+   /** PPA Subsystem Version Number, MSW, 1. Digit */
+   DSL_uint16_t SubSysVer1 : 8;
+   /** PPA Subsystem Version Number, MSW, 2. Digit */
+   DSL_uint16_t SubSysVer2 : 8;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PPA Subsystem Version Number, LSW, 4. Digit */
+   DSL_uint16_t SubSysVer4 : 8;
+   /** PPA Subsystem Version Number, LSW, 3. Digit */
+   DSL_uint16_t SubSysVer3 : 8;
+   /** PPA Subsystem Version Number, MSW, 2. Digit */
+   DSL_uint16_t SubSysVer2 : 8;
+   /** PPA Subsystem Version Number, MSW, 1. Digit */
+   DSL_uint16_t SubSysVer1 : 8;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the PPE FW Version number.
+*/
+struct CMD_PPE_FwVersionGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Provides the PPE FW version number.
+*/
+struct ACK_PPE_FwVersionGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 8;
+   /** PPE FW Version Number, 1. Digit */
+   DSL_uint16_t PpeFwVer1 : 8;
+   /** PPE FW Version Number, 2. Digit */
+   DSL_uint16_t PpeFwVer2 : 8;
+   /** PPE FW Version Number, 3. Digit */
+   DSL_uint16_t PpeFwVer3 : 8;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PPE FW Version Number, 1. Digit */
+   DSL_uint16_t PpeFwVer1 : 8;
+   /** Reserved */
+   DSL_uint16_t Res0 : 8;
+   /** PPE FW Version Number, 3. Digit */
+   DSL_uint16_t PpeFwVer3 : 8;
+   /** PPE FW Version Number, 2. Digit */
+   DSL_uint16_t PpeFwVer2 : 8;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the feature map indicating the ADSL FW features supported by this
+   binary.
+*/
+struct CMD_ADSL_FeatureMapGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reports the feature map indicating the ADSL FW features supported by this
+   binary.
+*/
+struct ACK_ADSL_FeatureMapGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Feature Map Length */
+   DSL_uint16_t FeatMapLen;
+   /** Reserved */
+   DSL_uint16_t Res0 : 1;
+   /** Feature-Bit14 of Word 0: OHC Error Counters */
+   DSL_uint16_t W0F14 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 1;
+   /** Feature-Bit12 of Word 0: Power Down */
+   DSL_uint16_t W0F12 : 1;
+   /** Feature-Bit11 of Word 0: NTR */
+   DSL_uint16_t W0F11 : 1;
+   /** Feature-Bit10 of Word 0:  CIPolicy */
+   DSL_uint16_t W0F10 : 1;
+   /** Feature-Bit9 of Word 0:  Pre-emption & Short Packets  */
+   DSL_uint16_t W0F09 : 1;
+   /** Feature-Bit8 of Word 0:  Counter Inhibiting */
+   DSL_uint16_t W0F08 : 1;
+   /** Feature-Bit7 of Word 0: Short Init */
+   DSL_uint16_t W0F07 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 1;
+   /** Feature-Bit5 of Word 0:  G.INP Retransmission DS + SRA */
+   DSL_uint16_t W0F05 : 1;
+   /** Feature-Bit4 of Word 0:  G.INP Retransmission DS + Bonding (EFM) */
+   DSL_uint16_t W0F04 : 1;
+   /** Feature-Bit3 of Word 0:PTM Off-chip Bonding BACP */
+   DSL_uint16_t W0F03 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 2;
+   /** Feature-Bit0 of Word 0: Annex I */
+   DSL_uint16_t W0F00 : 1;
+   /** Reserved */
+   DSL_uint16_t Res4 : 16;
+   /** Reserved  */
+   DSL_uint16_t Res5 : 16;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Feature Map Length */
+   DSL_uint16_t FeatMapLen;
+   /** Feature-Bit0 of Word 0: Annex I */
+   DSL_uint16_t W0F00 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 2;
+   /** Feature-Bit3 of Word 0:PTM Off-chip Bonding BACP */
+   DSL_uint16_t W0F03 : 1;
+   /** Feature-Bit4 of Word 0:  G.INP Retransmission DS + Bonding (EFM) */
+   DSL_uint16_t W0F04 : 1;
+   /** Feature-Bit5 of Word 0:  G.INP Retransmission DS + SRA */
+   DSL_uint16_t W0F05 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 1;
+   /** Feature-Bit7 of Word 0: Short Init */
+   DSL_uint16_t W0F07 : 1;
+   /** Feature-Bit8 of Word 0:  Counter Inhibiting */
+   DSL_uint16_t W0F08 : 1;
+   /** Feature-Bit9 of Word 0:  Pre-emption & Short Packets  */
+   DSL_uint16_t W0F09 : 1;
+   /** Feature-Bit10 of Word 0:  CIPolicy */
+   DSL_uint16_t W0F10 : 1;
+   /** Feature-Bit11 of Word 0: NTR */
+   DSL_uint16_t W0F11 : 1;
+   /** Feature-Bit12 of Word 0: Power Down */
+   DSL_uint16_t W0F12 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 1;
+   /** Feature-Bit14 of Word 0: OHC Error Counters */
+   DSL_uint16_t W0F14 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 1;
+   /** Reserved */
+   DSL_uint16_t Res4 : 16;
+   /** Reserved  */
+   DSL_uint16_t Res5 : 16;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Requests the feature map indicating the VDSL FW features supported by this
+   binary.
+*/
+struct CMD_VDSL_FeatureMapGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Reports the feature map indicating the VDSL FW features supported by this
+   binary.
+*/
+struct ACK_VDSL_FeatureMapGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Feature Map Length */
+   DSL_uint16_t FeatMapLen;
+   /** Feature-Bit15 of Word 0: ROC in RTX Mode */
+   DSL_uint16_t W0F15 : 1;
+   /** Feature-Bit14 of Word 0: OHC Error Counters */
+   DSL_uint16_t W0F14 : 1;
+   /** Feature-Bit13 of Word 0: SOS in RTX Mode */
+   DSL_uint16_t W0F13 : 1;
+   /** Feature-Bit12 of Word 0: Power Down */
+   DSL_uint16_t W0F12 : 1;
+   /** Feature-Bit11 of Word 0: NTR */
+   DSL_uint16_t W0F11 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 1;
+   /** Feature-Bit9 of Word 0: Pre-emption & Short Packets  */
+   DSL_uint16_t W0F09 : 1;
+   /** Feature-Bit8 of Word 0: Erasure Decoding /FORCEINP */
+   DSL_uint16_t W0F08 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 1;
+   /** Feature-Bit6 of Word 0: Intra DTU Interleaving US */
+   DSL_uint16_t W0F06 : 1;
+   /** Feature-Bit5 of Word 0: Intra DTU Interleaving DS */
+   DSL_uint16_t W0F05 : 1;
+   /** Feature-Bit4 of Word 0: G.INP Retransmission US + DS + PAF (VDSL only) */
+   DSL_uint16_t W0F04 : 1;
+   /** Feature-Bit3 of Word 0: PTM Off-chip Bonding BACP */
+   DSL_uint16_t W0F03 : 1;
+   /** Feature-Bit2 of Word 2: Microfilter Detection and Hybrid Data */
+   DSL_uint16_t W2F02 : 1;
+   /** Reserved */
+   DSL_uint16_t Res2 : 2;
+   /** Reserved */
+   DSL_uint16_t Res3 : 16;
+   /** Reserved  */
+   DSL_uint16_t Res4 : 16;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Feature Map Length */
+   DSL_uint16_t FeatMapLen;
+   /** Reserved */
+   DSL_uint16_t Res2 : 2;
+   /** Feature-Bit2 of Word 2: Microfilter Detection and Hybrid Data */
+   DSL_uint16_t W2F02 : 1;
+   /** Feature-Bit3 of Word 0: PTM Off-chip Bonding BACP */
+   DSL_uint16_t W0F03 : 1;
+   /** Feature-Bit4 of Word 0: G.INP Retransmission US + DS + PAF (VDSL only) */
+   DSL_uint16_t W0F04 : 1;
+   /** Feature-Bit5 of Word 0: Intra DTU Interleaving DS */
+   DSL_uint16_t W0F05 : 1;
+   /** Feature-Bit6 of Word 0: Intra DTU Interleaving US */
+   DSL_uint16_t W0F06 : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 1;
+   /** Feature-Bit8 of Word 0: Erasure Decoding /FORCEINP */
+   DSL_uint16_t W0F08 : 1;
+   /** Feature-Bit9 of Word 0: Pre-emption & Short Packets  */
+   DSL_uint16_t W0F09 : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 1;
+   /** Feature-Bit11 of Word 0: NTR */
+   DSL_uint16_t W0F11 : 1;
+   /** Feature-Bit12 of Word 0: Power Down */
+   DSL_uint16_t W0F12 : 1;
+   /** Feature-Bit13 of Word 0: SOS in RTX Mode */
+   DSL_uint16_t W0F13 : 1;
+   /** Feature-Bit14 of Word 0: OHC Error Counters */
+   DSL_uint16_t W0F14 : 1;
+   /** Feature-Bit15 of Word 0: ROC in RTX Mode */
+   DSL_uint16_t W0F15 : 1;
+   /** Reserved */
+   DSL_uint16_t Res3 : 16;
+   /** Reserved  */
+   DSL_uint16_t Res4 : 16;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message is used to enable bonding (PAF) and to control the GHS
+   aggregation discovery and aggregation processes. The register numbers
+   referenced refer to IEEE 802.3ah [14], Clause 45.
+*/
+struct CMD_PAF_HS_Control
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 15;
+   /** PCS Control Register (Register 3.61, Bit 0) */
+   DSL_uint16_t PAF_Enable : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PCS Control Register (Register 3.61, Bit 0) */
+   DSL_uint16_t PAF_Enable : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 15;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message acknowledges CMD_PAF_HS_Control.
+*/
+struct ACK_PAF_HS_Control
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message reads back settings for bonding configured with
+   CMD_PAF_HS_Control.
+*/
+struct CMD_PAF_HS_ControlGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message acknowledges CMD_PAF_HS_ControlGet providing PAF bonding
+   parameters used in handshake as configured with CMD_PAF_HS_Control.
+*/
+struct ACK_PAF_HS_ControlGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 15;
+   /** PCS Control Register (Register 3.61, Bit 0) */
+   DSL_uint16_t PAF_Enable : 1;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PCS Control Register (Register 3.61, Bit 0) */
+   DSL_uint16_t PAF_Enable : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 15;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message requests aggregation discovery and aggregation status information
+   for EFM bonding.
+*/
+struct CMD_PAF_HS_StatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message reports discovery and aggregation status information for EFM
+   bonding after request by CMD_PAF_HS_StatusGet.At the CPE side, the Host SW
+   concludes on a GET request if none of the following 4 bits are set:
+   discoveryClearIfSame, discoverySetIfClear, aggregClear , aggregSet. It does
+   not distinguish between "discovery GET" and "aggregation GET"; in case of any
+   "GET" both the discovery and the aggregation code are sent to the CO with the
+   CLR.
+*/
+struct ACK_PAF_HS_StatusGet
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 9;
+   /** Discovery Clear-If-Same */
+   DSL_uint16_t discoveryClearIfSame : 1;
+   /** Discovery Set-If-Clear */
+   DSL_uint16_t discoverySetIfClear : 1;
+   /** Aggregation Clear */
+   DSL_uint16_t aggregClear : 1;
+   /** Aggregation Set */
+   DSL_uint16_t aggregSet : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 2;
+   /** PCS Control Register (Register 3.60, Bit 12) */
+   DSL_uint16_t PAF_Enable : 1;
+   /** Aggregation Discovery Code (Register 6.18) */
+   DSL_uint16_t discoveryCode1;
+   /** Aggregation Discovery Code (Registers 6.19) */
+   DSL_uint16_t discoveryCode2;
+   /** Aggregation Discovery Code (Registers 6.20) */
+   DSL_uint16_t discoveryCode3;
+   /** Partner PME Aggregate Data (Registers 6.22) */
+   DSL_uint16_t aggregateData1;
+   /** Partner PME Aggregate Data (Registers 6.23) */
+   DSL_uint16_t aggregateData2;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PCS Control Register (Register 3.60, Bit 12) */
+   DSL_uint16_t PAF_Enable : 1;
+   /** Reserved */
+   DSL_uint16_t Res1 : 2;
+   /** Aggregation Set */
+   DSL_uint16_t aggregSet : 1;
+   /** Aggregation Clear */
+   DSL_uint16_t aggregClear : 1;
+   /** Discovery Set-If-Clear */
+   DSL_uint16_t discoverySetIfClear : 1;
+   /** Discovery Clear-If-Same */
+   DSL_uint16_t discoveryClearIfSame : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 9;
+   /** Aggregation Discovery Code (Register 6.18) */
+   DSL_uint16_t discoveryCode1;
+   /** Aggregation Discovery Code (Registers 6.19) */
+   DSL_uint16_t discoveryCode2;
+   /** Aggregation Discovery Code (Registers 6.20) */
+   DSL_uint16_t discoveryCode3;
+   /** Partner PME Aggregate Data (Registers 6.22) */
+   DSL_uint16_t aggregateData1;
+   /** Partner PME Aggregate Data (Registers 6.23) */
+   DSL_uint16_t aggregateData2;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message writes the aggregation discovery code and the aggregation data
+   down to the FW and is used to trigger the CPE-FW to proceed in handshake
+   (sending CLR) after it had been waiting in GHS_BONDING_CLR state for the
+   necessary host interactions to be finished. These actions depend on the
+   request type (see ACK_PAF_HS_StatusGet): the processing of the remote
+   discovery register (for an aggregation discovery "Set If Clear" or "Clear If
+   Same" command) or PME Aggregate register (for an aggregation "Set" or "Clear"
+   command) in the SW and -in any case including a "Get" command - then updating
+   the local representations of both in the FW (which are sent to the CO in a
+   CLR).
+*/
+struct CMD_PAF_HS_Continue
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Reserved */
+   DSL_uint16_t Res0 : 15;
+   /** Continue Trigger */
+   DSL_uint16_t trigger : 1;
+   /** Aggregation Discovery Code (Register 6.18) */
+   DSL_uint16_t discoveryCode1;
+   /** Aggregation Discovery Code (Registers 6.19) */
+   DSL_uint16_t discoveryCode2;
+   /** Aggregation Discovery Code (Registers 6.20) */
+   DSL_uint16_t discoveryCode3;
+   /** Partner PME Aggregate Data (Registers 6.22) */
+   DSL_uint16_t aggregateData1;
+   /** Partner PME Aggregate Data (Registers 6.23) */
+   DSL_uint16_t aggregateData2;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** Continue Trigger */
+   DSL_uint16_t trigger : 1;
+   /** Reserved */
+   DSL_uint16_t Res0 : 15;
+   /** Aggregation Discovery Code (Register 6.18) */
+   DSL_uint16_t discoveryCode1;
+   /** Aggregation Discovery Code (Registers 6.19) */
+   DSL_uint16_t discoveryCode2;
+   /** Aggregation Discovery Code (Registers 6.20) */
+   DSL_uint16_t discoveryCode3;
+   /** Partner PME Aggregate Data (Registers 6.22) */
+   DSL_uint16_t aggregateData1;
+   /** Partner PME Aggregate Data (Registers 6.23) */
+   DSL_uint16_t aggregateData2;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message acknowledges CMD_PAF_HS_Continue.
+*/
+struct ACK_PAF_HS_Continue
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+/**
+   Sets the PME identification number. This number is transferred with the CLR
+   message to the CO.
+*/
+struct CMD_PAF_PME_ID_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PME ID */
+   DSL_uint16_t PmeId;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+   /** PME ID */
+   DSL_uint16_t PmeId;
+#endif
+} __PACKED__ ;
+
+
+/**
+   The message acknowledges CMD_PAF_PME_ID_Set.
+*/
+struct ACK_PAF_PME_ID_Set
+{
+#if DSL_BYTE_ORDER == DSL_BIG_ENDIAN
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#else
+   /** Index */
+   DSL_uint16_t Index;
+   /** Length */
+   DSL_uint16_t Length;
+#endif
+} __PACKED__ ;
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#ifdef __PACKED_DEFINED__
+   #if !(defined (__GNUC__) || defined (__GNUG__))
+      #pragma pack()
+   #endif
+   #undef __PACKED_DEFINED__
+#endif /* __PACKED_DEFINED__ */
+
+/** @} */
+
+#endif /** _DRV_DSL_CPE_VRX_MSG_TC_COUNTERS_H_*/
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -19,7 +19,7 @@ endif
 if FW_R9
 VRX_HEADER_DIR = include/mcat2.7
 else
-VRX_HEADER_DIR = include/mcat3.1
+VRX_HEADER_DIR = include/mcat3.2
 endif
 
 
@@ -88,6 +88,7 @@ drv_common_extra = \
 	include/drv_dsl_cpe_api_ioctl.h \
 	include/drv_dsl_cpe_api_types.h \
 	include/drv_dsl_cpe_autoboot.h \
+	include/drv_dsl_cpe_configuration.h \
 	include/drv_dsl_cpe_debug.h \
 	include/drv_dsl_cpe_device.h \
 	include/drv_dsl_cpe_timeout.h \
@@ -159,13 +160,13 @@ drv_vrx_specific_extra = \
 	include/mcat2.7/drv_dsl_cpe_vrx_msg_olr.h \
 	include/mcat2.7/drv_dsl_cpe_vrx_msg_perf_pmd.h \
 	include/mcat2.7/drv_dsl_cpe_vrx_msg_tc_counters.h \
-	include/mcat3.1/drv_dsl_cpe_vrx_msg_config_pmd.h \
-	include/mcat3.1/drv_dsl_cpe_vrx_msg_const.h \
-	include/mcat3.1/drv_dsl_cpe_vrx_msg_dmt_scope.h \
-	include/mcat3.1/drv_dsl_cpe_vrx_msg_ghs_status.h \
-	include/mcat3.1/drv_dsl_cpe_vrx_msg_olr.h \
-	include/mcat3.1/drv_dsl_cpe_vrx_msg_perf_pmd.h \
-	include/mcat3.1/drv_dsl_cpe_vrx_msg_tc_counters.h \
+	include/mcat3.2/drv_dsl_cpe_vrx_msg_config_pmd.h \
+	include/mcat3.2/drv_dsl_cpe_vrx_msg_const.h \
+	include/mcat3.2/drv_dsl_cpe_vrx_msg_dmt_scope.h \
+	include/mcat3.2/drv_dsl_cpe_vrx_msg_ghs_status.h \
+	include/mcat3.2/drv_dsl_cpe_vrx_msg_olr.h \
+	include/mcat3.2/drv_dsl_cpe_vrx_msg_perf_pmd.h \
+	include/mcat3.2/drv_dsl_cpe_vrx_msg_tc_counters.h \
 	include/drv_dsl_cpe_vrx_ctx.h \
 	../scripts/inst_drv_dsl_cpe_api_vrx.sh
 
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -479,7 +479,7 @@ top_srcdir = @top_srcdir@
 @DSL_CPE_API_LIBRARY_BUILD_2_6_TRUE@@KERNEL_2_6_TRUE@noinst_LIBRARIES = lib_dsl_cpe_api.a
 @KERNEL_2_6_FALSE@noinst_LIBRARIES = lib_dsl_cpe_api.a
 @DEVICE_DANUBE_TRUE@bin_SCRIPTS = ../scripts/inst_drv_dsl_cpe_api_danube.sh
-@FW_R9_FALSE@VRX_HEADER_DIR = include/mcat3.1
+@FW_R9_FALSE@VRX_HEADER_DIR = include/mcat3.2
 @FW_R9_TRUE@VRX_HEADER_DIR = include/mcat2.7
 drv_dsl_cpe_api_includedir = $(includedir)
 drv_dsl_cpe_api_include_HEADERS = include/drv_dsl_cpe*.h
@@ -534,6 +534,7 @@ drv_common_extra = \
 	include/drv_dsl_cpe_api_ioctl.h \
 	include/drv_dsl_cpe_api_types.h \
 	include/drv_dsl_cpe_autoboot.h \
+	include/drv_dsl_cpe_configuration.h \
 	include/drv_dsl_cpe_debug.h \
 	include/drv_dsl_cpe_device.h \
 	include/drv_dsl_cpe_timeout.h \
@@ -591,13 +592,13 @@ drv_vrx_specific_extra = \
 	include/mcat2.7/drv_dsl_cpe_vrx_msg_olr.h \
 	include/mcat2.7/drv_dsl_cpe_vrx_msg_perf_pmd.h \
 	include/mcat2.7/drv_dsl_cpe_vrx_msg_tc_counters.h \
-	include/mcat3.1/drv_dsl_cpe_vrx_msg_config_pmd.h \
-	include/mcat3.1/drv_dsl_cpe_vrx_msg_const.h \
-	include/mcat3.1/drv_dsl_cpe_vrx_msg_dmt_scope.h \
-	include/mcat3.1/drv_dsl_cpe_vrx_msg_ghs_status.h \
-	include/mcat3.1/drv_dsl_cpe_vrx_msg_olr.h \
-	include/mcat3.1/drv_dsl_cpe_vrx_msg_perf_pmd.h \
-	include/mcat3.1/drv_dsl_cpe_vrx_msg_tc_counters.h \
+	include/mcat3.2/drv_dsl_cpe_vrx_msg_config_pmd.h \
+	include/mcat3.2/drv_dsl_cpe_vrx_msg_const.h \
+	include/mcat3.2/drv_dsl_cpe_vrx_msg_dmt_scope.h \
+	include/mcat3.2/drv_dsl_cpe_vrx_msg_ghs_status.h \
+	include/mcat3.2/drv_dsl_cpe_vrx_msg_olr.h \
+	include/mcat3.2/drv_dsl_cpe_vrx_msg_perf_pmd.h \
+	include/mcat3.2/drv_dsl_cpe_vrx_msg_tc_counters.h \
 	include/drv_dsl_cpe_vrx_ctx.h \
 	../scripts/inst_drv_dsl_cpe_api_vrx.sh
 
--- a/src/pm/drv_dsl_cpe_api_pm.c
+++ b/src/pm/drv_dsl_cpe_api_pm.c
@@ -11,6 +11,9 @@
 #define DSL_INTERN
 
 #include "drv_dsl_cpe_api.h"
+#ifdef __LINUX__
+#include <linux/capability.h>
+#endif /* __LINUX__ */
 
 #if defined(INCLUDE_DSL_PM)
 
@@ -19,6 +22,8 @@
 
 #undef DSL_DBG_BLOCK
 #define DSL_DBG_BLOCK DSL_DBG_PM
+#include <linux/delay.h>
+#define DSL_PM_THREAD_COUNT  50
 
 /** \addtogroup DRV_DSL_CPE_PM
  @{ */
@@ -34,6 +39,14 @@ DSL_Error_t DSL_DRV_PM_ConfigSet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pConfig);
    DSL_CHECK_ERR_CODE();
 
@@ -122,6 +135,14 @@ DSL_Error_t DSL_DRV_PM_ConfigGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pConfig);
    DSL_CHECK_ERR_CODE();
 
@@ -160,7 +181,7 @@ DSL_Error_t DSL_DRV_PM_Start(
 #if defined(INCLUDE_DSL_CPE_PM_OPTIONAL_PARAMETERS) && defined (INCLUDE_DSL_CPE_PM_RETX_THRESHOLDS)
    DSL_XTUDir_t dir;
 #endif
-
+   unsigned int count = DSL_PM_THREAD_COUNT;
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
 
@@ -557,16 +578,30 @@ DSL_Error_t DSL_DRV_PM_Start(
    }
 
    /* Check the PM module Near-End and Far-End thread active flag */
-   if( DSL_DRV_PM_CONTEXT(pContext)->pmThreadFe.bRun == DSL_FALSE &&
-       DSL_DRV_PM_CONTEXT(pContext)->pmThreadNe.bRun == DSL_FALSE )
+   while(count > 0)
    {
-      DSL_DEBUG(DSL_DBG_ERR,
-         (pContext, SYS_DBG_ERR"DSL[%02d]: ERROR - PM module NE and FE threads start failed!"
-         DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+      count--;
+      msleep (100);
 
-      DSL_DRV_MemFree(DSL_DRV_PM_CONTEXT(pContext)->pCounters);
-      DSL_DRV_MemFree(DSL_DRV_PM_CONTEXT(pContext)->pCountersDump);
-      DSL_DRV_MemFree(pContext->PM);
+      if ((DSL_DRV_PM_CONTEXT(pContext)->pmThreadFe.bRun == DSL_TRUE) &&
+         (DSL_DRV_PM_CONTEXT(pContext)->pmThreadNe.bRun == DSL_TRUE))
+      {
+            DSL_DEBUG(DSL_DBG_MSG,
+               (pContext, SYS_DBG_MSG"DSL[%02d]: PM module NE and FE threads start success!"
+               DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+            break;
+      }
+
+      if (count == 0)
+      {
+         DSL_DEBUG(DSL_DBG_ERR,
+            (pContext, SYS_DBG_ERR"DSL[%02d]: ERROR - PM module NE and FE threads start failed!"
+            DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+
+         DSL_DRV_MemFree(DSL_DRV_PM_CONTEXT(pContext)->pCounters);
+         DSL_DRV_MemFree(DSL_DRV_PM_CONTEXT(pContext)->pCountersDump);
+         DSL_DRV_MemFree(pContext->PM);
+      }
    }
 
    DSL_DEBUG(DSL_DBG_MSG,
@@ -685,6 +720,14 @@ DSL_Error_t DSL_DRV_PM_Reset(
    DSL_PM_EpType_t nEp2Reset[DSL_PM_COUNTER_LAST];
    DSL_uint8_t nEpCount = 0, nEpIdx = 0;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pResetType);
    DSL_CHECK_ERR_CODE();
 
@@ -787,6 +830,14 @@ DSL_Error_t DSL_DRV_PM_15MinElapsedExtTr
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_boolean_t b15min = DSL_FALSE, b1day = DSL_FALSE;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pTrigger);
    DSL_CHECK_ERR_CODE();
 
@@ -875,6 +926,14 @@ DSL_Error_t DSL_DRV_PM_ElapsedTimeReset(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pReset);
    DSL_CHECK_ERR_CODE();
 
@@ -936,6 +995,14 @@ DSL_Error_t DSL_DRV_PM_SyncModeSet(
    DSL_PM_SyncModeType_t mode;
    DSL_DRV_TimeVal_t currTime;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pMode);
    DSL_CHECK_ERR_CODE();
 
@@ -1016,6 +1083,14 @@ DSL_Error_t DSL_DRV_PM_SyncModeGet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pMode);
    DSL_CHECK_ERR_CODE();
 
@@ -1062,6 +1137,14 @@ DSL_Error_t DSL_DRV_PM_BurninModeSet(
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pBurninMode);
    DSL_CHECK_ERR_CODE();
 
@@ -1161,6 +1244,14 @@ DSL_Error_t DSL_DRV_PM_ChannelHistorySta
    DSL_uint32_t histFillLevel = 0, histInv = 0, prevInvIntervals = 0;
    DSL_int_t histIdx = -1;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pStats);
    DSL_CHECK_ERR_CODE();
 
@@ -1261,6 +1352,14 @@ DSL_Error_t DSL_DRV_PM_ChannelHistorySta
    DSL_uint32_t histFillLevel = 0, histInv = 0, prevInvIntervals = 0;
    DSL_int_t histIdx = -1;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pStats);
    DSL_CHECK_ERR_CODE();
 
@@ -1360,6 +1459,14 @@ DSL_Error_t DSL_DRV_PM_ChannelCounters15
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
 
@@ -1418,6 +1525,14 @@ DSL_Error_t DSL_DRV_PM_ChannelCounters1D
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
 
@@ -1479,6 +1594,14 @@ DSL_Error_t DSL_DRV_PM_ChannelCountersTo
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_PM_ChannelData_t *pChCounters;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pCounters);
    DSL_CHECK_ERR_CODE();
 
@@ -1598,6 +1721,14 @@ DSL_Error_t DSL_DRV_PM_ChannelThresholds
    DSL_PM_ChannelData_t *pChCounters, *pThresholds;
    DSL_pmChannelThresholdCrossingData_t *pInd ;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -1677,6 +1808,14 @@ DSL_Error_t DSL_DRV_PM_ChannelThresholds
    DSL_PM_ChannelData_t *pChCounters, *pThresholds;
    DSL_pmChannelThresholdCrossingData_t *pInd ;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -1756,6 +1895,14 @@ DSL_Error_t DSL_DRV_PM_ChannelThresholds
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_PM_ChannelData_t *pThresholds;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -1827,6 +1974,14 @@ DSL_Error_t DSL_DRV_PM_ChannelThresholds
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_PM_ChannelData_t *pThresholds;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -1907,6 +2062,14 @@ DSL_Error_t DSL_DRV_PM_ChannelCountersSh
    DSL_pmBF_IntervalFailures_t nCurrFailures;
    DSL_PM_ChannelData_t *pChCounters;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pCounters);
    DSL_CHECK_ERR_CODE();
 
@@ -2067,6 +2230,14 @@ DSL_Error_t DSL_DRV_PM_ChannelCountersEx
    DSL_pmBF_IntervalFailures_t nCurrFailures;
    DSL_PM_ChannelDataExt_t *pChCounters;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pCounters);
    DSL_CHECK_ERR_CODE();
 
@@ -2231,6 +2402,14 @@ DSL_Error_t DSL_DRV_PM_DataPathHistorySt
    DSL_uint32_t histFillLevel = 0, histInv = 0, prevInvIntervals = 0;
    DSL_int_t histIdx = -1;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pStats);
    DSL_CHECK_ERR_CODE();
 
@@ -2331,6 +2510,14 @@ DSL_Error_t DSL_DRV_PM_DataPathHistorySt
    DSL_uint32_t histFillLevel = 0, histInv = 0, prevInvIntervals = 0;
    DSL_int_t histIdx = -1;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pStats);
    DSL_CHECK_ERR_CODE();
 
@@ -2427,6 +2614,14 @@ DSL_Error_t DSL_DRV_PM_DataPathCounters1
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
 
@@ -2473,6 +2668,14 @@ DSL_Error_t DSL_DRV_PM_DataPathCounters1
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
 
@@ -2522,6 +2725,14 @@ DSL_Error_t DSL_DRV_PM_DataPathCountersT
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_PM_DataPathData_t *pDpCounters;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pCounters);
    DSL_CHECK_ERR_CODE();
 
@@ -2600,6 +2811,14 @@ DSL_Error_t DSL_DRV_PM_DataPathThreshold
    DSL_PM_DataPathData_t *pDpCounters, *pThresholds;
    DSL_pmDataPathThresholdCrossingData_t *pInd ;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -2682,6 +2901,14 @@ DSL_Error_t DSL_DRV_PM_DataPathThreshold
    DSL_PM_DataPathData_t *pDpCounters, *pThresholds;
    DSL_pmDataPathThresholdCrossingData_t *pInd ;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -2761,6 +2988,14 @@ DSL_Error_t DSL_DRV_PM_DataPathThreshold
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_PM_DataPathData_t *pThresholds;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -2832,6 +3067,14 @@ DSL_Error_t DSL_DRV_PM_DataPathThreshold
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_PM_DataPathData_t *pThresholds;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -2911,6 +3154,14 @@ DSL_Error_t DSL_DRV_PM_DataPathCountersS
    DSL_pmBF_IntervalFailures_t nCurrFailures;
    DSL_PM_DataPathData_t *pDpCounters;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pCounters);
    DSL_CHECK_ERR_CODE();
 
@@ -3101,6 +3352,14 @@ DSL_Error_t DSL_DRV_PM_DataPathFailureHi
    DSL_uint32_t histFillLevel = 0, histInv = 0, prevInvIntervals = 0;
    DSL_int_t histIdx = -1;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pStats);
    DSL_CHECK_ERR_CODE();
 
@@ -3201,6 +3460,14 @@ DSL_Error_t DSL_DRV_PM_DataPathFailureHi
    DSL_uint32_t histFillLevel = 0, histInv = 0, prevInvIntervals = 0;
    DSL_int_t histIdx = -1;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pStats);
    DSL_CHECK_ERR_CODE();
 
@@ -3297,6 +3564,14 @@ DSL_Error_t DSL_DRV_PM_DataPathFailureCo
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
 
@@ -3325,6 +3600,14 @@ DSL_Error_t DSL_DRV_PM_DataPathFailureCo
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
 
@@ -3356,6 +3639,14 @@ DSL_Error_t DSL_DRV_PM_DataPathFailureCo
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_PM_DataPathFailureData_t *pDpCounters;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pCounters);
    DSL_CHECK_ERR_CODE();
 
@@ -3416,6 +3707,14 @@ DSL_Error_t DSL_DRV_PM_DataPathFailureCo
    DSL_pmBF_IntervalFailures_t nCurrFailures;
    DSL_PM_DataPathFailureData_t *pDpCounters;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pCounters);
    DSL_CHECK_ERR_CODE();
 
@@ -3581,6 +3880,14 @@ DSL_Error_t DSL_DRV_PM_LineSecHistorySta
    DSL_uint32_t histFillLevel = 0, histInv = 0, prevInvIntervals = 0;
    DSL_int_t histIdx = -1;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pStats);
    DSL_CHECK_ERR_CODE();
 
@@ -3681,6 +3988,14 @@ DSL_Error_t DSL_DRV_PM_LineSecHistorySta
    DSL_uint32_t histFillLevel = 0, histInv = 0, prevInvIntervals = 0;
    DSL_int_t histIdx = -1;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pStats);
    DSL_CHECK_ERR_CODE();
 
@@ -3780,6 +4095,14 @@ DSL_Error_t DSL_DRV_PM_LineSecCounters15
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
 
@@ -3808,6 +4131,14 @@ DSL_Error_t DSL_DRV_PM_LineSecCounters1D
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
 
@@ -3841,6 +4172,14 @@ DSL_Error_t DSL_DRV_PM_LineSecThresholds
    DSL_PM_LineSecData_t *pLineSecCounters, *pThresholds;
    DSL_pmLineThresholdCrossingData_t *pInd ;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -3920,6 +4259,14 @@ DSL_Error_t DSL_DRV_PM_LineSecThresholds
    DSL_PM_LineSecData_t *pLineSecCounters, *pThresholds;
    DSL_pmLineThresholdCrossingData_t *pInd ;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -3997,6 +4344,14 @@ DSL_Error_t DSL_DRV_PM_LineSecThresholds
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_PM_LineSecData_t *pThresholds;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -4065,6 +4420,14 @@ DSL_Error_t DSL_DRV_PM_LineSecThresholds
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_PM_LineSecData_t *pThresholds;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -4137,6 +4500,14 @@ DSL_Error_t DSL_DRV_PM_LineSecCountersTo
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_PM_LineSecData_t *pLineCounters;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pCounters);
    DSL_CHECK_ERR_CODE();
 
@@ -4202,6 +4573,14 @@ DSL_Error_t DSL_DRV_PM_LineSecCountersSh
    DSL_pmBF_IntervalFailures_t nCurrFailures;
    DSL_PM_LineSecData_t *pLineCounters;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pCounters);
    DSL_CHECK_ERR_CODE();
 
@@ -4369,6 +4748,14 @@ DSL_Error_t DSL_DRV_PM_LineInitHistorySt
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_uint32_t histFillLevel = 0;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pStats);
    DSL_CHECK_ERR_CODE();
 
@@ -4416,6 +4803,14 @@ DSL_Error_t DSL_DRV_PM_LineInitHistorySt
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_uint32_t histFillLevel = 0;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pStats);
    DSL_CHECK_ERR_CODE();
 
@@ -4463,6 +4858,14 @@ DSL_Error_t DSL_DRV_PM_LineInitCounters1
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
 
@@ -4491,6 +4894,14 @@ DSL_Error_t DSL_DRV_PM_LineInitCounters1
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
 
@@ -4524,6 +4935,14 @@ DSL_Error_t DSL_DRV_PM_LineInitThreshold
    DSL_PM_LineInitData_t *pLineInitCounters, *pThresholds;
    DSL_pmLineThresholdCrossingData_t *pInd ;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -4600,6 +5019,14 @@ DSL_Error_t DSL_DRV_PM_LineInitThreshold
    DSL_PM_LineInitData_t *pLineInitCounters, *pThresholds;
    DSL_pmLineThresholdCrossingData_t *pInd ;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -4673,6 +5100,14 @@ DSL_Error_t DSL_DRV_PM_LineInitThreshold
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_PM_LineInitData_t *pThresholds;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -4733,6 +5168,14 @@ DSL_Error_t DSL_DRV_PM_LineInitThreshold
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_PM_LineInitData_t *pThresholds;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -4797,6 +5240,14 @@ DSL_Error_t DSL_DRV_PM_LineInitCountersT
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_PM_LineInitData_t *pLinitCounters;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pCounters);
    DSL_CHECK_ERR_CODE();
 
@@ -4844,6 +5295,14 @@ DSL_Error_t DSL_DRV_PM_LineInitCountersS
    DSL_uint32_t histFillLevel = 0, histInv = 0;
    DSL_PM_LineInitData_t *pLineCounters;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pCounters);
    DSL_CHECK_ERR_CODE();
 
@@ -4990,6 +5449,14 @@ DSL_Error_t DSL_DRV_PM_LineEventShowtime
    DSL_uint32_t histFillLevel = 0, histInv = 0, prevInvIntervals = 0;
    DSL_int_t histIdx = -1;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pStats);
    DSL_CHECK_ERR_CODE();
 
@@ -5090,6 +5557,14 @@ DSL_Error_t DSL_DRV_PM_LineEventShowtime
    DSL_uint32_t histFillLevel = 0, histInv = 0, prevInvIntervals = 0;
    DSL_int_t histIdx = -1;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pStats);
    DSL_CHECK_ERR_CODE();
 
@@ -5187,6 +5662,14 @@ DSL_Error_t DSL_DRV_PM_LineEventShowtime
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
 
@@ -5215,6 +5698,14 @@ DSL_Error_t DSL_DRV_PM_LineEventShowtime
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
 
@@ -5247,6 +5738,14 @@ DSL_Error_t DSL_DRV_PM_LineEventShowtime
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_PM_LineEventShowtimeData_t *pLfCounters;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pCounters);
    DSL_CHECK_ERR_CODE();
 
@@ -5305,6 +5804,14 @@ DSL_Error_t DSL_DRV_PM_LineEventShowtime
    DSL_pmBF_IntervalFailures_t nCurrFailures;
    DSL_PM_LineEventShowtimeData_t *pLfCounters;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pCounters);
    DSL_CHECK_ERR_CODE();
 
@@ -5469,6 +5976,14 @@ DSL_Error_t DSL_DRV_PM_ReTxHistoryStats1
    DSL_uint32_t histFillLevel = 0, histInv = 0, prevInvIntervals = 0;
    DSL_int_t histIdx = -1;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pStats);
    DSL_CHECK_ERR_CODE();
 
@@ -5569,6 +6084,14 @@ DSL_Error_t DSL_DRV_PM_ReTxHistoryStats1
    DSL_uint32_t histFillLevel = 0, histInv = 0, prevInvIntervals = 0;
    DSL_int_t histIdx = -1;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pStats);
    DSL_CHECK_ERR_CODE();
 
@@ -5668,6 +6191,14 @@ DSL_Error_t DSL_DRV_PM_ReTxCounters15Min
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
 
@@ -5696,6 +6227,14 @@ DSL_Error_t DSL_DRV_PM_ReTxCounters1DayG
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_CTX_POINTER(pContext);
    DSL_CHECK_ERR_CODE();
 
@@ -5727,6 +6266,14 @@ DSL_Error_t DSL_DRV_PM_ReTxCountersTotal
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_PM_ReTxData_t *pReTxCounters;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pCounters);
    DSL_CHECK_ERR_CODE();
 
@@ -5784,6 +6331,14 @@ DSL_Error_t DSL_DRV_PM_ReTxThresholds15M
    DSL_PM_ReTxData_t *pReTxCounters, *pThresholds;
    DSL_pmReTxThresholdCrossingData_t *pInd ;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -5863,6 +6418,14 @@ DSL_Error_t DSL_DRV_PM_ReTxThresholds1Da
    DSL_PM_ReTxData_t *pReTxCounters, *pThresholds;
    DSL_pmReTxThresholdCrossingData_t *pInd ;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -5939,6 +6502,14 @@ DSL_Error_t DSL_DRV_PM_ReTxThresholds15M
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_PM_ReTxData_t *pThresholds;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -6007,6 +6578,14 @@ DSL_Error_t DSL_DRV_PM_ReTxThresholds1Da
    DSL_Error_t nErrCode = DSL_SUCCESS;
    DSL_PM_ReTxData_t *pThresholds;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pThreshs);
    DSL_CHECK_ERR_CODE();
 
@@ -6083,6 +6662,14 @@ DSL_Error_t DSL_DRV_PM_ReTxCountersShowt
    DSL_pmBF_IntervalFailures_t nCurrFailures;
    DSL_PM_ReTxData_t *pReTxCounters;
 
+#ifdef __LINUX__
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk("Permission denied");
+      return -EPERM;
+   }
+#endif /* __LINUX__ */
+
    DSL_CHECK_POINTER(pContext, pCounters);
    DSL_CHECK_ERR_CODE();
 
--- a/src/pm/drv_dsl_cpe_api_pm_vrx.c
+++ b/src/pm/drv_dsl_cpe_api_pm_vrx.c
@@ -1,7 +1,9 @@
 /******************************************************************************
 
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2016 - 2019 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
 
   For licensing information, see the file 'LICENSE' in the root folder of
   this software module.
@@ -1265,11 +1267,8 @@ DSL_Error_t DSL_DRV_PM_DEV_LineEventShow
    DSL_PM_LineEventShowtimeData_t *pCounters)
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
-#if 0
-   /* VRx SOS counter not supported by the FW yet, set to 0*/
    CMD_SOS_StatsNE_Get_t sCmd;
    ACK_SOS_StatsNE_Get_t sAck;
-#endif
 
    DSL_DEBUG( DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_PM_DEV_LineEventShowtimeCountersGet"
@@ -1297,7 +1296,6 @@ DSL_Error_t DSL_DRV_PM_DEV_LineEventShow
 
    DSL_DRV_MUTEX_UNLOCK(pContext->dataMutex);
 
-#if 0
    memset(&sCmd, 0x0, sizeof(CMD_SOS_StatsNE_Get_t));
    memset(&sAck, 0x0, sizeof(ACK_SOS_StatsNE_Get_t));
 
@@ -1323,10 +1321,6 @@ DSL_Error_t DSL_DRV_PM_DEV_LineEventShow
 
    pCounters->nSosSuccess = (((DSL_uint32_t)sAck.cntSOS_SUC_MSW) << 16) |
                              ((DSL_uint32_t)sAck.cntSOS_SUC_LSW);
-#else
-   /* VRx SOS counter not supported by the FW yet, set to 0*/
-   pCounters->nSosSuccess = 0;
-#endif
 
    DSL_DEBUG( DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: OUT - DSL_DRV_PM_DEV_LineEventShowtimeCountersGet (retCode=%d)"
--- a/src/pm/drv_dsl_cpe_pm_core.c
+++ b/src/pm/drv_dsl_cpe_pm_core.c
@@ -778,6 +778,7 @@ DSL_int_t DSL_DRV_PM_ThreadNe(DSL_DRV_Th
    DSL_int_t nOsRet = 0;
    DSL_Context_t *pContext = (DSL_Context_t*)param->nArg1;
    DSL_uint32_t startTime, stopTime;
+   DSL_boolean_t bPowerDown = DSL_FALSE;
 
    DSL_DEBUG( DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_PM_ThreadNe"
@@ -814,6 +815,10 @@ DSL_int_t DSL_DRV_PM_ThreadNe(DSL_DRV_Th
       if (DSL_DRV_SIGNAL_PENDING)
          break;
 
+      DSL_CTX_READ_SCALAR(pContext, nErrCode, bPowerDown, bPowerDown);
+      if (bPowerDown)
+         break;
+
       /* Get Start Time*/
       startTime = DSL_DRV_PM_TIME_GET();
 
@@ -906,6 +911,7 @@ DSL_int_t DSL_DRV_PM_ThreadFe(DSL_DRV_Th
    DSL_int_t nOsRet = 0;
    DSL_Context_t *pContext = (DSL_Context_t*)param->nArg1;
    DSL_uint32_t startTime, stopTime;
+   DSL_boolean_t bPowerDown = DSL_FALSE;
 
    DSL_DEBUG( DSL_DBG_MSG,
       (pContext, SYS_DBG_MSG"DSL[%02d]: IN - DSL_DRV_PM_ThreadFe"
@@ -940,6 +946,10 @@ DSL_int_t DSL_DRV_PM_ThreadFe(DSL_DRV_Th
       if (DSL_DRV_SIGNAL_PENDING)
          break;
 
+      DSL_CTX_READ_SCALAR(pContext, nErrCode, bPowerDown, bPowerDown);
+      if (bPowerDown)
+         break;
+
       /* Get Start Time*/
       startTime = DSL_DRV_PM_TIME_GET();
 
@@ -6748,10 +6758,41 @@ DSL_Error_t DSL_DRV_PM_Resume(
    DSL_Context_t *pContext)
 {
    DSL_Error_t nErrCode = DSL_SUCCESS;
+   unsigned int i = 3;
+
+   /* Loop for 3 iterations at max with sleep of max 3 secs to avoid contention between
+   PM thread not getting initialized, when autoboot thread is trying to do PM_RESUME
+   Probably the best way will be to synchronize autoboot thread and PM_thread during init
+   In our tests we see that it passes in 1 loop itself at max, but 3 for safeside
+   This is a workqround, needs a proper fix. */
 
-   if (DSL_DRV_PM_CONTEXT(pContext) == DSL_NULL)
+   while(i > 0)
    {
-      return DSL_ERR_POINTER;
+      i--;
+
+      if (DSL_DRV_PM_CONTEXT(pContext) == DSL_NULL)
+      {
+         DSL_DEBUG(DSL_DBG_ERR,
+            (pContext, SYS_DBG_ERR"DSL[%02d]: ERROR - PM context NULL Retry after 1 sec"
+            DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+      }
+      else
+      {
+         break;
+      }
+
+      /* Didn't find it even after three iterations, something really wrong, so exit */
+      if (i == 0)
+      {
+         DSL_DEBUG(DSL_DBG_ERR,
+            (pContext, SYS_DBG_ERR"DSL[%02d]: ERROR - PM context NULL Returning"
+            DSL_DRV_CRLF, DSL_DEV_NUM(pContext)));
+
+         return DSL_ERR_POINTER;
+      }
+
+      /* Sleep for 1 sec and check again */
+      msleep(1000);
    }
 
    if (DSL_DRV_PM_CONTEXT(pContext)->bPmLock)
