--- a/ChangeLog
+++ b/ChangeLog
@@ -1,6 +1,25 @@
 NEXT VERSION
 
+V1.9.3 - 2019-05-20
+common:
+- VRX (DSLCPE_SW-1181) Switching BND->Single via WebUI results in kernel crash
+- VRX (DSLCPE_SW-1180) Functionality of VRX518 shall be given also without using
+   safe-c library (V3)
+- VRX (DSLCPE_SW-1183) Add additional security to avoid HW/FW access in case of
+   Power Down
+
+V1.9.2 - 2019-02-14
+common:
+- VRX (GFASTSW-621) SDL: capability checks (procfs)
+- VRX (DSLCPE_SW-1166) SDL: driver autoload, CDEV and hotplug
+- (DSLCPE_SW-1139) Generation of UMPR for API 4.19.x / R5 release
+   Make sure that IOCtl's which shall be part of the API UMPR are classified
+- VRX (DSLCPE_SW-1097) Message dump printout within MEI Driver is not as expected
+- VRX (DSLCPE_SW-1173) [VRX518][Power Saving] Switching BND->Single
+- VRX (GFASTSW-709) SDL: update to new safe-c library version in UGW
+
 V1.9.1 - 2018-10-29
+common:
 - VRX (DSLCPE_SW-1149) Debug stream segmentation fault fix
 - VRX (DSLCPE_SW-1163) IRQ mode is possible to used within UGW-8.x again
 
--- /dev/null
+++ b/config.rpath
@@ -0,0 +1,666 @@
+#! /bin/sh
+# Output a system dependent set of variables, describing how to set the
+# run time search path of shared libraries in an executable.
+#
+#   Copyright 1996-2007 Free Software Foundation, Inc.
+#   Taken from GNU libtool, 2001
+#   Originally by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+#
+#   This file is free software; the Free Software Foundation gives
+#   unlimited permission to copy and/or distribute it, with or without
+#   modifications, as long as this notice is preserved.
+#
+# The first argument passed to this file is the canonical host specification,
+#    CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or
+#    CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# The environment variables CC, GCC, LDFLAGS, LD, with_gnu_ld
+# should be set by the caller.
+#
+# The set of defined variables is at the end of this script.
+
+# Known limitations:
+# - On IRIX 6.5 with CC="cc", the run time search patch must not be longer
+#   than 256 bytes, otherwise the compiler driver will dump core. The only
+#   known workaround is to choose shorter directory names for the build
+#   directory and/or the installation directory.
+
+# All known linkers require a `.a' archive for static linking (except MSVC,
+# which needs '.lib').
+libext=a
+shrext=.so
+
+host="$1"
+host_cpu=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+# Code taken from libtool.m4's _LT_CC_BASENAME.
+
+for cc_temp in $CC""; do
+  case $cc_temp in
+    compile | *[\\/]compile | ccache | *[\\/]ccache ) ;;
+    distcc | *[\\/]distcc | purify | *[\\/]purify ) ;;
+    \-*) ;;
+    *) break;;
+  esac
+done
+cc_basename=`echo "$cc_temp" | sed -e 's%^.*/%%'`
+
+# Code taken from libtool.m4's AC_LIBTOOL_PROG_COMPILER_PIC.
+
+wl=
+if test "$GCC" = yes; then
+  wl='-Wl,'
+else
+  case "$host_os" in
+    aix*)
+      wl='-Wl,'
+      ;;
+    darwin*)
+      case $cc_basename in
+        xlc*)
+          wl='-Wl,'
+          ;;
+      esac
+      ;;
+    mingw* | cygwin* | pw32* | os2*)
+      ;;
+    hpux9* | hpux10* | hpux11*)
+      wl='-Wl,'
+      ;;
+    irix5* | irix6* | nonstopux*)
+      wl='-Wl,'
+      ;;
+    newsos6)
+      ;;
+    linux* | k*bsd*-gnu)
+      case $cc_basename in
+        icc* | ecc*)
+          wl='-Wl,'
+          ;;
+        pgcc | pgf77 | pgf90)
+          wl='-Wl,'
+          ;;
+        ccc*)
+          wl='-Wl,'
+          ;;
+        como)
+          wl='-lopt='
+          ;;
+        *)
+          case `$CC -V 2>&1 | sed 5q` in
+            *Sun\ C*)
+              wl='-Wl,'
+              ;;
+          esac
+          ;;
+      esac
+      ;;
+    osf3* | osf4* | osf5*)
+      wl='-Wl,'
+      ;;
+    rdos*)
+      ;;
+    solaris*)
+      wl='-Wl,'
+      ;;
+    sunos4*)
+      wl='-Qoption ld '
+      ;;
+    sysv4 | sysv4.2uw2* | sysv4.3*)
+      wl='-Wl,'
+      ;;
+    sysv4*MP*)
+      ;;
+    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
+      wl='-Wl,'
+      ;;
+    unicos*)
+      wl='-Wl,'
+      ;;
+    uts4*)
+      ;;
+  esac
+fi
+
+# Code taken from libtool.m4's AC_LIBTOOL_PROG_LD_SHLIBS.
+
+hardcode_libdir_flag_spec=
+hardcode_libdir_separator=
+hardcode_direct=no
+hardcode_minus_L=no
+
+case "$host_os" in
+  cygwin* | mingw* | pw32*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  interix*)
+    # we just hope/assume this is gcc and not c89 (= MSVC++)
+    with_gnu_ld=yes
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+esac
+
+ld_shlibs=yes
+if test "$with_gnu_ld" = yes; then
+  # Set some defaults for GNU ld with shared library support. These
+  # are reset later if shared libraries are not supported. Putting them
+  # here allows them to be overridden if necessary.
+  # Unlike libtool, we use -rpath here, not --rpath, since the documented
+  # option of GNU ld is called -rpath, not --rpath.
+  hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+  case "$host_os" in
+    aix3* | aix4* | aix5*)
+      # On AIX/PPC, the GNU linker is very broken
+      if test "$host_cpu" != ia64; then
+        ld_shlibs=no
+      fi
+      ;;
+    amigaos*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      # Samuel A. Falvo II <kc5tja@dolphin.openprojects.net> reports
+      # that the semantics of dynamic libraries on AmigaOS, at least up
+      # to version 4, is to share data among multiple programs linked
+      # with the same dynamic library.  Since this doesn't match the
+      # behavior of shared libraries on other platforms, we cannot use
+      # them.
+      ld_shlibs=no
+      ;;
+    beos*)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    cygwin* | mingw* | pw32*)
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec='-L$libdir'
+      if $LD --help 2>&1 | grep 'auto-import' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    interix[3-9]*)
+      hardcode_direct=no
+      hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+      ;;
+    gnu* | linux* | k*bsd*-gnu)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    netbsd*)
+      ;;
+    solaris*)
+      if $LD -v 2>&1 | grep 'BFD 2\.8' > /dev/null; then
+        ld_shlibs=no
+      elif $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
+      case `$LD -v 2>&1` in
+        *\ [01].* | *\ 2.[0-9].* | *\ 2.1[0-5].*)
+          ld_shlibs=no
+          ;;
+        *)
+          if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+            hardcode_libdir_flag_spec='`test -z "$SCOABSPATH" && echo ${wl}-rpath,$libdir`'
+          else
+            ld_shlibs=no
+          fi
+          ;;
+      esac
+      ;;
+    sunos4*)
+      hardcode_direct=yes
+      ;;
+    *)
+      if $LD --help 2>&1 | grep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+  esac
+  if test "$ld_shlibs" = no; then
+    hardcode_libdir_flag_spec=
+  fi
+else
+  case "$host_os" in
+    aix3*)
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      hardcode_minus_L=yes
+      if test "$GCC" = yes; then
+        # Neither direct hardcoding nor static linking is supported with a
+        # broken collect2.
+        hardcode_direct=unsupported
+      fi
+      ;;
+    aix4* | aix5*)
+      if test "$host_cpu" = ia64; then
+        # On IA64, the linker does run time linking by default, so we don't
+        # have to do anything special.
+        aix_use_runtimelinking=no
+      else
+        aix_use_runtimelinking=no
+        # Test if we are trying to use run time linking or normal
+        # AIX style linking. If -brtl is somewhere in LDFLAGS, we
+        # need to do runtime linking.
+        case $host_os in aix4.[23]|aix4.[23].*|aix5*)
+          for ld_flag in $LDFLAGS; do
+            if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+              aix_use_runtimelinking=yes
+              break
+            fi
+          done
+          ;;
+        esac
+      fi
+      hardcode_direct=yes
+      hardcode_libdir_separator=':'
+      if test "$GCC" = yes; then
+        case $host_os in aix4.[012]|aix4.[012].*)
+          collect2name=`${CC} -print-prog-name=collect2`
+          if test -f "$collect2name" && \
+            strings "$collect2name" | grep resolve_lib_name >/dev/null
+          then
+            # We have reworked collect2
+            :
+          else
+            # We have old collect2
+            hardcode_direct=unsupported
+            hardcode_minus_L=yes
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_libdir_separator=
+          fi
+          ;;
+        esac
+      fi
+      # Begin _LT_AC_SYS_LIBPATH_AIX.
+      echo 'int main () { return 0; }' > conftest.c
+      ${CC} ${LDFLAGS} conftest.c -o conftest
+      aix_libpath=`dump -H conftest 2>/dev/null | sed -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+      if test -z "$aix_libpath"; then
+        aix_libpath=`dump -HX64 conftest 2>/dev/null | sed -n -e '/Import File Strings/,/^$/ { /^0/ { s/^0  *\(.*\)$/\1/; p; }
+}'`
+      fi
+      if test -z "$aix_libpath"; then
+        aix_libpath="/usr/lib:/lib"
+      fi
+      rm -f conftest.c conftest
+      # End _LT_AC_SYS_LIBPATH_AIX.
+      if test "$aix_use_runtimelinking" = yes; then
+        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+      else
+        if test "$host_cpu" = ia64; then
+          hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
+        else
+          hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
+        fi
+      fi
+      ;;
+    amigaos*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      # see comment about different semantics on the GNU ld section
+      ld_shlibs=no
+      ;;
+    bsdi[45]*)
+      ;;
+    cygwin* | mingw* | pw32*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec=' '
+      libext=lib
+      ;;
+    darwin* | rhapsody*)
+      hardcode_direct=no
+      if test "$GCC" = yes ; then
+        :
+      else
+        case $cc_basename in
+          xlc*)
+            ;;
+          *)
+            ld_shlibs=no
+            ;;
+        esac
+      fi
+      ;;
+    dgux*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      ;;
+    freebsd1*)
+      ld_shlibs=no
+      ;;
+    freebsd2.2*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    freebsd2*)
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      ;;
+    freebsd* | dragonfly*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    hpux9*)
+      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_direct=yes
+      # hardcode_minus_L: Not really in the search PATH,
+      # but as the default location of the library.
+      hardcode_minus_L=yes
+      ;;
+    hpux10*)
+      if test "$with_gnu_ld" = no; then
+        hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+        hardcode_libdir_separator=:
+        hardcode_direct=yes
+        # hardcode_minus_L: Not really in the search PATH,
+        # but as the default location of the library.
+        hardcode_minus_L=yes
+      fi
+      ;;
+    hpux11*)
+      if test "$with_gnu_ld" = no; then
+        hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+        hardcode_libdir_separator=:
+        case $host_cpu in
+          hppa*64*|ia64*)
+            hardcode_direct=no
+            ;;
+          *)
+            hardcode_direct=yes
+            # hardcode_minus_L: Not really in the search PATH,
+            # but as the default location of the library.
+            hardcode_minus_L=yes
+            ;;
+        esac
+      fi
+      ;;
+    irix5* | irix6* | nonstopux*)
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    netbsd*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    newsos6)
+      hardcode_direct=yes
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    openbsd*)
+      if test -f /usr/libexec/ld.so; then
+        hardcode_direct=yes
+        if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+          hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+        else
+          case "$host_os" in
+            openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+              hardcode_libdir_flag_spec='-R$libdir'
+              ;;
+            *)
+              hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+              ;;
+          esac
+        fi
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    os2*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      ;;
+    osf3*)
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    osf4* | osf5*)
+      if test "$GCC" = yes; then
+        hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      else
+        # Both cc and cxx compiler support -rpath directly
+        hardcode_libdir_flag_spec='-rpath $libdir'
+      fi
+      hardcode_libdir_separator=:
+      ;;
+    solaris*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      ;;
+    sunos4*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      ;;
+    sysv4)
+      case $host_vendor in
+        sni)
+          hardcode_direct=yes # is this really true???
+          ;;
+        siemens)
+          hardcode_direct=no
+          ;;
+        motorola)
+          hardcode_direct=no #Motorola manual says yes, but my tests say they lie
+          ;;
+      esac
+      ;;
+    sysv4.3*)
+      ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+        ld_shlibs=yes
+      fi
+      ;;
+    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
+      ;;
+    sysv5* | sco3.2v5* | sco5v6*)
+      hardcode_libdir_flag_spec='`test -z "$SCOABSPATH" && echo ${wl}-R,$libdir`'
+      hardcode_libdir_separator=':'
+      ;;
+    uts4*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      ;;
+    *)
+      ld_shlibs=no
+      ;;
+  esac
+fi
+
+# Check dynamic linker characteristics
+# Code taken from libtool.m4's AC_LIBTOOL_SYS_DYNAMIC_LINKER.
+# Unlike libtool.m4, here we don't care about _all_ names of the library, but
+# only about the one the linker finds when passed -lNAME. This is the last
+# element of library_names_spec in libtool.m4, or possibly two of them if the
+# linker has special search rules.
+library_names_spec=      # the last element of library_names_spec in libtool.m4
+libname_spec='lib$name'
+case "$host_os" in
+  aix3*)
+    library_names_spec='$libname.a'
+    ;;
+  aix4* | aix5*)
+    library_names_spec='$libname$shrext'
+    ;;
+  amigaos*)
+    library_names_spec='$libname.a'
+    ;;
+  beos*)
+    library_names_spec='$libname$shrext'
+    ;;
+  bsdi[45]*)
+    library_names_spec='$libname$shrext'
+    ;;
+  cygwin* | mingw* | pw32*)
+    shrext=.dll
+    library_names_spec='$libname.dll.a $libname.lib'
+    ;;
+  darwin* | rhapsody*)
+    shrext=.dylib
+    library_names_spec='$libname$shrext'
+    ;;
+  dgux*)
+    library_names_spec='$libname$shrext'
+    ;;
+  freebsd1*)
+    ;;
+  freebsd* | dragonfly*)
+    case "$host_os" in
+      freebsd[123]*)
+        library_names_spec='$libname$shrext$versuffix' ;;
+      *)
+        library_names_spec='$libname$shrext' ;;
+    esac
+    ;;
+  gnu*)
+    library_names_spec='$libname$shrext'
+    ;;
+  hpux9* | hpux10* | hpux11*)
+    case $host_cpu in
+      ia64*)
+        shrext=.so
+        ;;
+      hppa*64*)
+        shrext=.sl
+        ;;
+      *)
+        shrext=.sl
+        ;;
+    esac
+    library_names_spec='$libname$shrext'
+    ;;
+  interix[3-9]*)
+    library_names_spec='$libname$shrext'
+    ;;
+  irix5* | irix6* | nonstopux*)
+    library_names_spec='$libname$shrext'
+    case "$host_os" in
+      irix5* | nonstopux*)
+        libsuff= shlibsuff=
+        ;;
+      *)
+        case $LD in
+          *-32|*"-32 "|*-melf32bsmip|*"-melf32bsmip ") libsuff= shlibsuff= ;;
+          *-n32|*"-n32 "|*-melf32bmipn32|*"-melf32bmipn32 ") libsuff=32 shlibsuff=N32 ;;
+          *-64|*"-64 "|*-melf64bmip|*"-melf64bmip ") libsuff=64 shlibsuff=64 ;;
+          *) libsuff= shlibsuff= ;;
+        esac
+        ;;
+    esac
+    ;;
+  linux*oldld* | linux*aout* | linux*coff*)
+    ;;
+  linux* | k*bsd*-gnu)
+    library_names_spec='$libname$shrext'
+    ;;
+  knetbsd*-gnu)
+    library_names_spec='$libname$shrext'
+    ;;
+  netbsd*)
+    library_names_spec='$libname$shrext'
+    ;;
+  newsos6)
+    library_names_spec='$libname$shrext'
+    ;;
+  nto-qnx*)
+    library_names_spec='$libname$shrext'
+    ;;
+  openbsd*)
+    library_names_spec='$libname$shrext$versuffix'
+    ;;
+  os2*)
+    libname_spec='$name'
+    shrext=.dll
+    library_names_spec='$libname.a'
+    ;;
+  osf3* | osf4* | osf5*)
+    library_names_spec='$libname$shrext'
+    ;;
+  rdos*)
+    ;;
+  solaris*)
+    library_names_spec='$libname$shrext'
+    ;;
+  sunos4*)
+    library_names_spec='$libname$shrext$versuffix'
+    ;;
+  sysv4 | sysv4.3*)
+    library_names_spec='$libname$shrext'
+    ;;
+  sysv4*MP*)
+    library_names_spec='$libname$shrext'
+    ;;
+  sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
+    library_names_spec='$libname$shrext'
+    ;;
+  uts4*)
+    library_names_spec='$libname$shrext'
+    ;;
+esac
+
+sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
+escaped_wl=`echo "X$wl" | sed -e 's/^X//' -e "$sed_quote_subst"`
+shlibext=`echo "$shrext" | sed -e 's,^\.,,'`
+escaped_libname_spec=`echo "X$libname_spec" | sed -e 's/^X//' -e "$sed_quote_subst"`
+escaped_library_names_spec=`echo "X$library_names_spec" | sed -e 's/^X//' -e "$sed_quote_subst"`
+escaped_hardcode_libdir_flag_spec=`echo "X$hardcode_libdir_flag_spec" | sed -e 's/^X//' -e "$sed_quote_subst"`
+
+LC_ALL=C sed -e 's/^\([a-zA-Z0-9_]*\)=/acl_cv_\1=/' <<EOF
+
+# How to pass a linker flag through the compiler.
+wl="$escaped_wl"
+
+# Static library suffix (normally "a").
+libext="$libext"
+
+# Shared library suffix (normally "so").
+shlibext="$shlibext"
+
+# Format of library name prefix.
+libname_spec="$escaped_libname_spec"
+
+# Library names that the linker finds when passed -lNAME.
+library_names_spec="$escaped_library_names_spec"
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec="$escaped_hardcode_libdir_flag_spec"
+
+# Whether we need a single -rpath flag with a separated argument.
+hardcode_libdir_separator="$hardcode_libdir_separator"
+
+# Set to yes if using DIR/libNAME.so during linking hardcodes DIR into the
+# resulting binary.
+hardcode_direct="$hardcode_direct"
+
+# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
+# resulting binary.
+hardcode_minus_L="$hardcode_minus_L"
+
+EOF
--- a/configure
+++ b/configure
@@ -1,7 +1,7 @@
 #! /bin/sh
 # From configure.in Revision: 1.21 .
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.69 for IFX MEI CPE Driver 1.9.1.
+# Generated by GNU Autoconf 2.69 for IFX MEI CPE Driver 1.9.3.
 #
 #
 # Copyright (C) 1992-1996, 1998-2012 Free Software Foundation, Inc.
@@ -578,8 +578,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='IFX MEI CPE Driver'
 PACKAGE_TARNAME='drv_mei_cpe'
-PACKAGE_VERSION='1.9.1'
-PACKAGE_STRING='IFX MEI CPE Driver 1.9.1'
+PACKAGE_VERSION='1.9.3'
+PACKAGE_STRING='IFX MEI CPE Driver 1.9.3'
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
@@ -682,7 +682,6 @@ SELECT_DEVICE_SUPPORT_FALSE
 SELECT_DEVICE_SUPPORT_TRUE
 SAFEC_LIB_PATH
 SAFEC_INCL_PATH
-SAFEC_LIB_FUNC
 SAFEC_LIB_NAME
 EGREP
 GREP
@@ -1363,7 +1362,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures IFX MEI CPE Driver 1.9.1 to adapt to many kinds of systems.
+\`configure' configures IFX MEI CPE Driver 1.9.3 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1429,7 +1428,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of IFX MEI CPE Driver 1.9.1:";;
+     short | recursive ) echo "Configuration of IFX MEI CPE Driver 1.9.3:";;
    esac
   cat <<\_ACEOF
 
@@ -1583,7 +1582,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-IFX MEI CPE Driver configure 1.9.1
+IFX MEI CPE Driver configure 1.9.3
 generated by GNU Autoconf 2.69
 
 Copyright (C) 2012 Free Software Foundation, Inc.
@@ -1881,7 +1880,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by IFX MEI CPE Driver $as_me 1.9.1, which was
+It was created by IFX MEI CPE Driver $as_me 1.9.3, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
@@ -2714,8 +2713,7 @@ fi
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_make_support_nested_variables" >&5
 $as_echo "$am_cv_make_support_nested_variables" >&6; }
-#if test $am_cv_make_support_nested_variables = yes; then
-if false; then
+if test $am_cv_make_support_nested_variables = yes; then
     AM_V='$(V)'
   AM_DEFAULT_V='$(AM_DEFAULT_VERBOSITY)'
 else
@@ -2746,7 +2744,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='drv_mei_cpe'
- VERSION='1.9.1'
+ VERSION='1.9.3'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -4494,18 +4492,15 @@ fi
 
 done
 
-            SAFEC_LIB_NAME=safec-1.0
 
-            SAFEC_LIB_FUNC=strcat_s
-
-            as_ac_Lib=`$as_echo "ac_cv_lib_$SAFEC_LIB_NAME''_$SAFEC_LIB_FUNC" | $as_tr_sh`
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $SAFEC_LIB_FUNC in -l$SAFEC_LIB_NAME" >&5
-$as_echo_n "checking for $SAFEC_LIB_FUNC in -l$SAFEC_LIB_NAME... " >&6; }
-if eval \${$as_ac_Lib+:} false; then :
+            if test "x$safec_header_support" = "xyes"; then
+                { $as_echo "$as_me:${as_lineno-$LINENO}: checking for _strcat_s_chk in -lsafec-3.3" >&5
+$as_echo_n "checking for _strcat_s_chk in -lsafec-3.3... " >&6; }
+if ${ac_cv_lib_safec_3_3__strcat_s_chk+:} false; then :
   $as_echo_n "(cached) " >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-l$SAFEC_LIB_NAME  $LIBS"
+LIBS="-lsafec-3.3  $LIBS"
 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
@@ -4515,36 +4510,80 @@ cat confdefs.h - <<_ACEOF >conftest.$ac_
 #ifdef __cplusplus
 extern "C"
 #endif
-char $SAFEC_LIB_FUNC ();
+char _strcat_s_chk ();
 int
 main ()
 {
-return $SAFEC_LIB_FUNC ();
+return _strcat_s_chk ();
   ;
   return 0;
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
-  eval "$as_ac_Lib=yes"
+  ac_cv_lib_safec_3_3__strcat_s_chk=yes
 else
-  eval "$as_ac_Lib=no"
+  ac_cv_lib_safec_3_3__strcat_s_chk=no
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-eval ac_res=\$$as_ac_Lib
-	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
-$as_echo "$ac_res" >&6; }
-if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
-  safec_lib_support=yes; break;
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_safec_3_3__strcat_s_chk" >&5
+$as_echo "$ac_cv_lib_safec_3_3__strcat_s_chk" >&6; }
+if test "x$ac_cv_lib_safec_3_3__strcat_s_chk" = xyes; then :
+  safec_lib_ver=3; break;
 fi
 
 
-            if test "x$safec_header_support" = "xyes"; then
-                if test "x$safec_lib_support" = "xyes"; then
+                if test "x$safec_lib_ver" = "x3"; then
+                    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for C/C++ restrict keyword" >&5
+$as_echo_n "checking for C/C++ restrict keyword... " >&6; }
+if ${ac_cv_c_restrict+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_cv_c_restrict=no
+   # The order here caters to the fact that C++ does not require restrict.
+   for ac_kw in __restrict __restrict__ _Restrict restrict; do
+     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+typedef int * int_ptr;
+	int foo (int_ptr $ac_kw ip) {
+	return ip[0];
+       }
+int
+main ()
+{
+int s[1];
+	int * $ac_kw t = s;
+	t[0] = 0;
+	return foo(t)
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_c_restrict=$ac_kw
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+     test "$ac_cv_c_restrict" != no && break
+   done
 
-$as_echo "#define SAFEC_SUPPORT 1" >>confdefs.h
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_restrict" >&5
+$as_echo "$ac_cv_c_restrict" >&6; }
+
+ case $ac_cv_c_restrict in
+   restrict) ;;
+   no) $as_echo "#define restrict /**/" >>confdefs.h
+ ;;
+   *)  cat >>confdefs.h <<_ACEOF
+#define restrict $ac_cv_c_restrict
+_ACEOF
+ ;;
+ esac
+
+
+$as_echo "#define SAFEC_SUPPORT 3" >>confdefs.h
 
                      if true; then
   SAFEC_SUPPORT_TRUE=
@@ -4556,6 +4595,8 @@ fi
 
                     SAFEC_SUPPORT=yes
 
+                    SAFEC_LIB_NAME=safec-3.3
+
                 fi
             fi
         fi
@@ -6428,7 +6469,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_wri
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by IFX MEI CPE Driver $as_me 1.9.1, which was
+This file was extended by IFX MEI CPE Driver $as_me 1.9.3, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -6494,7 +6535,7 @@ _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-IFX MEI CPE Driver config.status 1.9.1
+IFX MEI CPE Driver config.status 1.9.3
 configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
--- a/configure.in
+++ b/configure.in
@@ -1,7 +1,7 @@
 
 AC_REVISION($Revision: 1.21 $)
 
-AC_INIT(IFX MEI CPE Driver, 1.9.1, , drv_mei_cpe)
+AC_INIT(IFX MEI CPE Driver, 1.9.3, , drv_mei_cpe)
 AC_CONFIG_SRCDIR(src/Makefile.am)
 AM_INIT_AUTOMAKE([tar-pax])
 
@@ -28,15 +28,16 @@ AC_ARG_ENABLE(safec-support,
     [
         if test "$enableval" = yes; then
             AC_CHECK_HEADERS([safe_lib.h],[safec_header_support=yes; break;],,)
-            AC_SUBST([SAFEC_LIB_NAME],[safec-1.0])
-            AC_SUBST([SAFEC_LIB_FUNC],[strcat_s])
-            AC_CHECK_LIB($SAFEC_LIB_NAME, $SAFEC_LIB_FUNC,[safec_lib_support=yes; break;],,,)
 
             if test "x$safec_header_support" = "xyes"; then
-                if test "x$safec_lib_support" = "xyes"; then
-                    AC_DEFINE([SAFEC_SUPPORT], [1], [Safe-C supported])
+                AC_CHECK_LIB([safec-3.3], [_strcat_s_chk], [safec_lib_ver=3; break;],,,)
+
+                if test "x$safec_lib_ver" = "x3"; then
+                    AC_C_RESTRICT
+                    AC_DEFINE([SAFEC_SUPPORT], [3], [Safe-C lib ver3.3 support])
                     AM_CONDITIONAL(SAFEC_SUPPORT, true)
-                    AC_SUBST([SAFEC_SUPPORT],[yes])
+                    AC_SUBST([SAFEC_SUPPORT], [yes])
+                    AC_SUBST([SAFEC_LIB_NAME], [safec-3.3])
                 fi
             fi
         fi
--- a/doc/doxyconfig
+++ b/doc/doxyconfig
@@ -22,7 +22,7 @@ PROJECT_NAME           = "MEI CPE Driver
 # This could be handy for archiving the generated documentation or
 # if some version control system is used.
 
-PROJECT_NUMBER         = 1.9.1
+PROJECT_NUMBER         = 1.9.3
 
 # The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute)
 # base path where the generated documentation will be put.
--- a/LICENSE
+++ b/LICENSE
@@ -3,7 +3,8 @@ Please choose the appropriate license fo
 
 1. BSD license (2-clause BSD license)
 
-Copyright 2017, Intel Corporation
+Copyright (c) 2009-2015, LANTIQ BETEILIGUNGS-GMBH & CO. KG
+All rights reserved.
 
 Redistribution and use in source and binary forms, with or without modification,
 are permitted provided that the following conditions are met:
--- a/Makefile.in
+++ b/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15 from Makefile.am.
+# Makefile.in generated by automake 1.15.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2014 Free Software Foundation, Inc.
+# Copyright (C) 1994-2017 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -185,7 +185,8 @@ CTAGS = ctags
 CSCOPE = cscope
 DIST_SUBDIRS = $(SUBDIRS)
 am__DIST_COMMON = $(srcdir)/Makefile.in ABOUT-NLS AUTHORS COPYING \
-	ChangeLog NEWS README TODO compile depcomp install-sh missing
+	ChangeLog NEWS README TODO compile config.rpath depcomp \
+	install-sh missing
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 distdir = $(PACKAGE)-$(VERSION)
 top_distdir = $(distdir)
@@ -296,7 +297,6 @@ PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
 SAFEC_INCL_PATH = @SAFEC_INCL_PATH@
-SAFEC_LIB_FUNC = @SAFEC_LIB_FUNC@
 SAFEC_LIB_NAME = @SAFEC_LIB_NAME@
 SAFEC_LIB_PATH = @SAFEC_LIB_PATH@
 SAFEC_SUPPORT = @SAFEC_SUPPORT@
@@ -600,7 +600,7 @@ distdir: $(DISTFILES)
 	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
 	|| chmod -R a+r "$(distdir)"
 dist-gzip: distdir
-	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
+	tardir=$(distdir) && $(am__tar) | eval GZIP= gzip $(GZIP_ENV) -c >$(distdir).tar.gz
 	$(am__post_remove_distdir)
 
 dist-bzip2: distdir
@@ -626,7 +626,7 @@ dist-shar: distdir
 	@echo WARNING: "Support for shar distribution archives is" \
 	               "deprecated." >&2
 	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
-	shar $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).shar.gz
+	shar $(distdir) | eval GZIP= gzip $(GZIP_ENV) -c >$(distdir).shar.gz
 	$(am__post_remove_distdir)
 dist-zip: distdir
 	-rm -f $(distdir).zip
@@ -643,7 +643,7 @@ dist dist-all:
 distcheck: dist
 	case '$(DIST_ARCHIVES)' in \
 	*.tar.gz*) \
-	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).tar.gz | $(am__untar) ;;\
+	  eval GZIP= gzip $(GZIP_ENV) -dc $(distdir).tar.gz | $(am__untar) ;;\
 	*.tar.bz2*) \
 	  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\
 	*.tar.lz*) \
@@ -653,7 +653,7 @@ distcheck: dist
 	*.tar.Z*) \
 	  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\
 	*.shar.gz*) \
-	  GZIP=$(GZIP_ENV) gzip -dc $(distdir).shar.gz | unshar ;;\
+	  eval GZIP= gzip $(GZIP_ENV) -dc $(distdir).shar.gz | unshar ;;\
 	*.zip*) \
 	  unzip $(distdir).zip ;;\
 	esac
--- a/README
+++ b/README
@@ -1,5 +1,5 @@
 ******************************************************************************
-       Copyright 2017, Intel Corporation
+       Copyright (c) 2003, Infineon Technologies.  All rights reserved.
 
                                No Warranty
    Because the program is licensed free of charge, there is no warranty for 
--- a/src/debug_stream_dump/mei_cpe_drv_dbg_strm_dmp.c
+++ b/src/debug_stream_dump/mei_cpe_drv_dbg_strm_dmp.c
@@ -1,7 +1,9 @@
 /******************************************************************************
 
-               Copyright (c) 2007-2018
-            Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2016 - 2019 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
 
    For licensing information, see the file 'LICENSE' in the root folder of
    this software module.
@@ -112,7 +114,7 @@ static unsigned short g_nStartPattern[ME
 static unsigned short g_nStopPattern[MEI_DBG_STREAM_MAX_COMPARE_SIZE_IN_WORDS]
    = { 0 };
 static unsigned long  g_nFileLength = DBG_STRM_DMP_MEI_DEFAULT_FILE_SIZE;
-static char dumpFileName[256];
+static char dumpFileName[256] = { 0 };
 static unsigned int   g_nInternalMask[DBG_STRM_DMP_MEI_INT_MASK_MAX_NUM]={ 0 };
 static unsigned short g_nSnapshotLengthInSec=DBG_STRM_DMP_MEI_SNAPSHOT_LEN_SEC;
 static unsigned int   g_nInterval = DBG_STRM_DMP_MEI_INACTIVE_MS;
--- a/src/drv_mei_cpe_api_atm_ptm_intern.c
+++ b/src/drv_mei_cpe_api_atm_ptm_intern.c
@@ -1,7 +1,9 @@
 /******************************************************************************
 
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2016 - 2019 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
 
   For licensing information, see the file 'LICENSE' in the root folder of
   this software module.
@@ -265,7 +267,7 @@ IFX_int32_t MEI_TcRequest(void *data)
       MEI_DynCntrlStructFree(&pMeiDynCntrl);
    }
 
-#ifdef IRQ_POLLING_FORCE 
+#ifdef IRQ_POLLING_FORCE
    do_exit(retVal);
 #endif /* IRQ_POLLING_FORCE */
 
@@ -328,7 +330,10 @@ IFX_int32_t MEI_InternalTcRequest(
    }
 
 #if MEI_SUPPORT_DEVICE_VR11 == 1
-   MEI_CGU_PPLOMCFG_print(&(pMeiDynCntrl->pMeiDev->meiDrvCntrl));
+   if (request_type != MEI_TC_REQUEST_OFF)
+   {
+      MEI_CGU_PPLOMCFG_print(&(pMeiDynCntrl->pMeiDev->meiDrvCntrl));
+   }
 #endif /* MEI_SUPPORT_DEVICE_VR11 */
 #else
    PRN_DBG_USR_NL( MEI_NOTIFICATIONS, MEI_DRV_PRN_LEVEL_ERR,
@@ -339,7 +344,12 @@ IFX_int32_t MEI_InternalTcRequest(
    return retVal;
 }
 
-IFX_int32_t MEI_InternalLineTCModeSwitch(IFX_int8_t nEntity, IFX_int8_t nInstance, IFX_boolean_t bPowerUp) {
+IFX_int32_t MEI_InternalLineTCModeSwitch(
+                              IFX_int8_t nEntity,
+                              IFX_int8_t nInstance,
+                              IFX_boolean_t bPowerUp,
+                              IFX_boolean_t bKillMEIControlThread)
+{
    IFX_int32_t retVal = IFX_SUCCESS;
 
 #if defined(PPA_SUPPORTS_CALLBACKS) && defined(PPA_SUPPORTS_TC_CALLBACKS)
@@ -349,7 +359,7 @@ IFX_int32_t MEI_InternalLineTCModeSwitch
 #endif /* defined(PPA_SUPPORTS_CALLBACKS) && defined(PPA_SUPPORTS_TC_CALLBACKS) */
 
 #if (MEI_SUPPORT_PERIODIC_TASK == 1)
-   if (bPowerUp == IFX_FALSE)
+   if (bKillMEIControlThread == IFX_TRUE)
    {
       if ( MEI_DrvCntrlThreadParams.bValid == IFX_TRUE)
       {
@@ -365,7 +375,7 @@ IFX_int32_t MEI_InternalLineTCModeSwitch
    pMeiDynCntrl = NULL;
    nLineNum = MEIX_Cntrl[nEntity]->MeiDevice[nInstance]->meiDrvCntrl.dslLineNum;
    MEI_DynCntrlStructAlloc(nLineNum, &pMeiDynCntrl);
- 
+
    if (pMeiDynCntrl != NULL)
    {
       pMeiDynCntrl->openInstance = 0xFF;
@@ -377,7 +387,15 @@ IFX_int32_t MEI_InternalLineTCModeSwitch
 
       retVal = MEI_InternalTcRequest(pMeiDynCntrl, &argsTcRequest);
 
-      MEI_DRVOS_Wait_ms(200); 
+      if (bPowerUp == IFX_FALSE)
+      {
+         MEI_DRV_STATE_SET(MEIX_Cntrl[nEntity]->MeiDevice[nInstance], e_MEI_DRV_STATE_POWER_DOWN);
+         PRN_DBG_USR_NL( MEI_DRV, MEI_DRV_PRN_LEVEL_HIGH,
+            ("MEI_DRV[%02d]: Set driver state to %d" MEI_DRV_CRLF,
+            nLineNum, MEI_DRV_STATE_GET(MEIX_Cntrl[nEntity]->MeiDevice[nInstance])));
+      }
+
+      MEI_DRVOS_Wait_ms(200);
 
       MEI_DynCntrlStructFree(&pMeiDynCntrl);
 
@@ -407,7 +425,7 @@ IFX_int32_t MEI_InternalLineTCModeSwitch
       ("MEI_DRV[%02d]: PPA Callbacks disabled by compile option, "
        "to use this functionality you will need to enable them"
       MEI_DRV_CRLF, nEntity));
-      
+
 #endif /* defined(PPA_SUPPORTS_CALLBACKS) && defined(PPA_SUPPORTS_TC_CALLBACKS) */
 
    return retVal;
--- a/src/drv_mei_cpe_api_atm_ptm_intern.h
+++ b/src/drv_mei_cpe_api_atm_ptm_intern.h
@@ -75,10 +75,10 @@ extern IFX_int32_t MEI_InternalErbAddrUp
                               MEI_DYN_CNTRL_T        *pMeiDynCntrl);
 
 extern IFX_int32_t MEI_InternalLineTCModeSwitch(
-                              IFX_int8_t nEntity, 
-                              IFX_int8_t nInstance, 
-                              IFX_boolean_t bPowerUp);
-
+                              IFX_int8_t nEntity,
+                              IFX_int8_t nInstance,
+                              IFX_boolean_t bPowerUp,
+                              IFX_boolean_t bKillMEIControlThread);
 
 #ifdef PPA_SUPPORTS_CALLBACKS
 extern int ppa_callback_set(e_ltq_mei_cb_type type, void *func);
--- a/src/drv_mei_cpe_api_intern.c
+++ b/src/drv_mei_cpe_api_intern.c
@@ -1,7 +1,6 @@
 /******************************************************************************
-
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
+          Copyright 2018 Intel Corporation
+          Copyright 2007 - 2015 Lantiq Beteiligungs-GmbH & Co. KG
 
   For licensing information, see the file 'LICENSE' in the root folder of
   this software module.
@@ -434,6 +433,13 @@ static IFX_void_t MEI_Internal_DumpMessa
    static const IFX_uint32_t *pMsg32;
    IFX_boolean_t bDirSet = IFX_FALSE;
    IFX_uint8_t i;
+   const IFX_uint32_t nCommonPayloadSize = 5*nSize/2;
+   const IFX_uint8_t nInfoSize = 35;
+   const IFX_uint8_t nBufSize = 10;
+   IFX_uint32_t nMsgSize = nCommonPayloadSize + nInfoSize;
+   IFX_uint32_t nCharsWrittenToBuf = 0;
+   char msg[nMsgSize];
+   char buf[nBufSize];
 
    if((pData == IFX_NULL) || (nSize < 4))
    {
@@ -445,11 +451,12 @@ static IFX_void_t MEI_Internal_DumpMessa
 
    bDirSet = (nMsgId & 0x40) ? IFX_TRUE : IFX_FALSE;
 
-   PRN_DBG_USR_RAW(MEI_MSG_DUMP_API, dbg_level,
-                  ("MEI[%02d/%s]: 0x%04x 0x%04x 0x%04x",
-                  MEI_DRV_DYN_LINENUM_GET(pMeiDynCntrl),
-                  (bReceive == IFX_TRUE ? "rx" : "tx"), nMsgId,
-                  pData[0], pData[1]));
+   snprintf(msg, nInfoSize,
+              "MEI[%02d/%s]: 0x%04x 0x%04x 0x%04x",
+              MEI_DRV_DYN_LINENUM_GET(pMeiDynCntrl),
+              (bReceive == IFX_TRUE ? "rx" : "tx"), nMsgId,
+              pData[0], pData[1]);
+   nMsgSize -= nInfoSize;
 
    /* decide wether to interpret the rest as 16 or 32 bit */
    if (nMsgId & 0x0010)
@@ -457,7 +464,9 @@ static IFX_void_t MEI_Internal_DumpMessa
       /* 32-bit payload elements */
       for (i=0; i<((nSize-4)/4); i++)
       {
-         PRN_DBG_USR_RAW(MEI_MSG_DUMP_API, dbg_level, (" %08X", pMsg32[i]));
+         nCharsWrittenToBuf = snprintf(buf, nBufSize, " %08X", pMsg32[i]);
+         strncat(msg, buf, nMsgSize);
+         nMsgSize -= nCharsWrittenToBuf;
       }
    }
    else
@@ -465,11 +474,14 @@ static IFX_void_t MEI_Internal_DumpMessa
       /* 16-bit payload elements */
       for (i=0; i<((nSize-4)/2); i++)
       {
-         PRN_DBG_USR_RAW(MEI_MSG_DUMP_API, dbg_level, (" %04X", pMsg16[i]));
+         nCharsWrittenToBuf = snprintf(buf, nBufSize, " %04X", pMsg16[i]);
+         strncat(msg, buf, nMsgSize);
+         nMsgSize -= nCharsWrittenToBuf;
       }
    }
+   strncat(msg, MEI_DRV_CRLF, nMsgSize);
 
-   PRN_DBG_USR_RAW(MEI_MSG_DUMP_API, dbg_level, (MEI_DRV_CRLF));
+   PRN_DBG_USR_RAW(MEI_MSG_DUMP_API, dbg_level, (msg));
 }
 
 IFX_int32_t MEI_InternalSendMessage(
@@ -501,7 +513,7 @@ IFX_int32_t MEI_InternalSendMessage(
    {
       MEI_Internal_DumpMessage(pMeiDynCntrl, msg.ack_msg.msgId,
          (IFX_uint16_t *)msg.ack_msg.pPayload, msg.ack_msg.paylSize_byte,
-         IFX_TRUE, MEI_DRV_PRN_LEVEL_LOW);
+         IFX_TRUE, MEI_DRV_PRN_LEVEL_NORMAL);
    }
 
    return ret;
--- a/src/drv_mei_cpe_common.c
+++ b/src/drv_mei_cpe_common.c
@@ -1,7 +1,9 @@
 /******************************************************************************
 
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2016 - 2019 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
 
   For licensing information, see the file 'LICENSE' in the root folder of
   this software module.
@@ -1166,6 +1168,37 @@ IFX_int32_t MEI_CheckIoctlCmdInitState(
          }
    }
 
+   if (MEI_DRV_STATE_GET(pMeiDev) == e_MEI_DRV_STATE_POWER_DOWN)
+   {
+      switch (ioctlCmd)
+      {
+         case FIO_MEI_DEBUGLEVEL:
+         case FIO_MEI_VERSION_GET:
+         case FIO_MEI_DRV_DEVINFO_GET:
+         case FIO_MEI_REQ_CONFIG:
+         case FIO_MEI_REQ_STAT:
+         case FIO_MEI_MAC_CONFIG_GET:
+         case FIO_MEI_DSM_CONFIG_GET:
+         case FIO_MEI_PLL_OFFSET_CONFIG_GET:
+         case FIO_MEI_DEBUG_STREAM_CONFIG_GET:
+         case FIO_MEI_DEBUG_STREAM_CONFIG_SET:
+         case FIO_MEI_DEBUG_STREAM_RELEASE:
+         case FIO_MEI_DEBUG_STREAM_CONTROL:
+         case FIO_MEI_DEBUG_STREAM_STATISTIC_GET:
+         case FIO_MEI_DEBUG_STREAM_DATA_GET:
+         case FIO_MEI_DEBUG_STREAM_MASK_SET:
+            /* ioctl cmd is also valid within the power down state */
+            break;
+
+         default:
+            PRN_ERR_USR_NL( MEI_DRV, MEI_DRV_PRN_LEVEL_ERR,
+               ("MEI_DRV[%02d-%02d] Error ioctl - device powered down, invalid cmd !!!" MEI_DRV_CRLF,
+               MEI_DRV_LINENUM_GET(pMeiDev), pMeiDynCntrl->openInstance));
+
+               retVal = -e_MEI_ERR_INVAL_STATE;
+      }
+   }
+
    return retVal;
 }
 
@@ -1992,7 +2025,8 @@ IFX_int32_t MEI_DevPollAllIrq (MEI_DEV_A
           ((pMeiDev = (MEIX_Cntrl[entity])->MeiDevice[rel_ch]) != NULL))
       {
          if ( (MEI_DRV_STATE_GET(pMeiDev) != e_MEI_DRV_STATE_NOT_INIT) &&
-              (MEI_DRV_STATE_GET(pMeiDev) != e_MEI_DRV_STATE_DFE_RESET) )
+              (MEI_DRV_STATE_GET(pMeiDev) != e_MEI_DRV_STATE_DFE_RESET)  &&
+              (MEI_DRV_STATE_GET(pMeiDev) != e_MEI_DRV_STATE_POWER_DOWN) )
          {
             /* in polling mode: protect the read access */
             MEI_PollIntPerVrxLine(pMeiDev, eAccessMode);
--- a/src/drv_mei_cpe_config_auto.h.in
+++ b/src/drv_mei_cpe_config_auto.h.in
@@ -51,7 +51,7 @@
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
-/* Safe-C supported */
+/* Safe-C lib ver3.3 support */
 #undef SAFEC_SUPPORT
 
 /* Define to 1 if you have the ANSI C header files. */
@@ -59,3 +59,17 @@
 
 /* Version number of package */
 #undef VERSION
+
+/* Define to the equivalent of the C99 'restrict' keyword, or to
+   nothing if this is not supported.  Do not define if restrict is
+   supported directly.  */
+#undef restrict
+/* Work around a bug in Sun C++: it does not support _Restrict or
+   __restrict__, even though the corresponding Sun C compiler ends up with
+   "#define restrict _Restrict" or "#define restrict __restrict__" in the
+   previous line.  Perhaps some future version of Sun C++ will work with
+   restrict; if so, hopefully it defines __RESTRICT like Sun C does.  */
+#if defined __SUNPRO_CC && !defined __RESTRICT
+# define _Restrict
+# define __restrict__
+#endif
--- a/src/drv_mei_cpe_interface.h
+++ b/src/drv_mei_cpe_interface.h
@@ -2,8 +2,10 @@
 #define _DRV_MEI_CPE_INTERFACE_H
 /******************************************************************************
 
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2016 - 2019 Intel Corporation
+         Copyright 2015 - 2016 Lantiq Beteiligungs-GmbH & Co. KG
+         Copyright 2009 - 2014 Lantiq Deutschland GmbH
+         Copyright 2007 - 2008 Infineon Technologies AG
 
   For licensing information, see the file 'LICENSE' in the root folder of
   this software module.
@@ -73,6 +75,18 @@
    \ingroup MEI_CEOC
 */
 
+/** \defgroup MEI_API Functions for common usage within Linux user space
+    This Group contains all the common functions for general purpose that might
+    be used from within Linux user space, independent from DSL CPE API Driver
+    usage.
+    \ingroup MEI_INTERFACE
+*/
+
+/**
+   \defgroup MEI_API_IOCTL IOCtl's
+   \ingroup MEI_API
+*/
+
 /** \defgroup MEI_DSM Functions for Digital Spectrum Management (DSM/vectoring)
     This Group contains all the commonly used functions for configuration,
     control and status request of the [D]igital [S]pectrum [M]anagement related
@@ -248,6 +262,7 @@
    \ingroup MEI_COMMON_IOCTL              */
 #define FIO_MEI_DRV_INIT               _IO(MEI_IOC_MAGIC, 4)
 
+#endif /* #ifndef DSL_DOC_GENERATION_EXCLUDE_UNWANTED */
 
 /** This returns information about the successfully detected respective
     available devices/lines.
@@ -269,9 +284,10 @@
      memset(&devInfo, 0x00, sizeof(IOCTL_MEI_drvDevinfoGet_t));
      ret = ioctl(fd, FIO_MEI_DRV_DEVINFO_GET, &devInfo)
    \endcode
-   \ingroup MEI_COMMON_IOCTL              */
+   \ingroup MEI_API_IOCTL              */
 #define FIO_MEI_DRV_DEVINFO_GET            _IO(MEI_IOC_MAGIC, 5)
 
+#ifndef DSL_DOC_GENERATION_EXCLUDE_UNWANTED
 
 /** This service resets the MEI CPE Device Driver and optional the
     device blocks via MEI register.
@@ -2133,6 +2149,7 @@ typedef struct
    unsigned int bmWaitStates;
 } IOCTL_MEI_drvInit_t;
 
+#endif /* #ifndef DSL_DOC_GENERATION_EXCLUDE_UNWANTED */
 
 /** ioctl structure to get the device/line availibility. */
 typedef struct
@@ -2150,6 +2167,7 @@ typedef struct
    unsigned int entitiesEnabled;
 } IOCTL_MEI_devinfo_t ;
 
+#ifndef DSL_DOC_GENERATION_EXCLUDE_UNWANTED
 
 /** modem Driver Reset Modes */
 typedef enum
@@ -3859,6 +3877,8 @@ typedef enum
    e_MEI_DRV_STATE_DFE_RESET,
    /** driver config error - base init error */
    e_MEI_DRV_STATE_CFG_ERROR,
+   /** driver powered down */
+   e_MEI_DRV_STATE_POWER_DOWN,
    /** unused last state - for state machine control */
    e_MEI_DRV_STATE_STATE_LAST
 }  MEI_DRV_STATE_E;
--- a/src/drv_mei_cpe_linux.c
+++ b/src/drv_mei_cpe_linux.c
@@ -1,7 +1,6 @@
 /******************************************************************************
-
-                          Copyright (c) 2007-2015
-                     Lantiq Beteiligungs-GmbH & Co. KG
+           Copyright (c) 2018      Intel Corporation
+           Copyright (c) 2007-2015 Lantiq Beteiligungs-GmbH & Co. KG
 
   For licensing information, see the file 'LICENSE' in the root folder of
   this software module.
@@ -46,6 +45,7 @@
    #endif
 #endif
 #include <linux/init.h>
+#include <linux/cdev.h>
 
 #include <linux/ioport.h>
 #include <linux/irq.h>
@@ -62,6 +62,7 @@
 #if CONFIG_PROC_FS
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
+#include <linux/capability.h>
 #endif
 
 #if (MEI_SUPPORT_DEBUG_LOGGER == 1)
@@ -216,7 +217,8 @@ static void MEI_NlSendMsg(IFX_char_t* pM
 /* Local variables (LINUX)             */
 /* =================================== */
 static IFX_uint8_t major_number = 0;
-static struct class *mei_class;
+static struct class *mei_class = NULL;
+static struct cdev *p_mei_cdevs[MEI_MAX_SUPPORTED_DFEX_ENTITIES];
 #ifdef MODULE
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
 MODULE_PARM(major_number, "b");
@@ -1540,6 +1542,12 @@ struct proc_entry {
 */
 static void MEI_GetVersionProc(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%s" MEI_DRV_CRLF, &MEI_WHATVERSION[4]);
    seq_printf(s, "Compiled on %s, %s for Linux kernel %s (jiffies: %ld)" MEI_DRV_CRLF,
                                     __DATE__, __TIME__, UTS_RELEASE, jiffies);
@@ -1556,6 +1564,12 @@ static void MEI_GetVersionProc(struct se
 */
 static void MEI_GetDevInfoProc(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "MaxDeviceNumber=%d\n",MEI_DFEX_ENTITIES);
    seq_printf(s, "LinesPerDevice=%d\n",MEI_DFE_INSTANCE_PER_ENTITY);
    seq_printf(s, "ChannelsPerLine=%d\n",MEI_DEVICE_CFG_VALUE_GET(ChannelsPerLine));
@@ -1581,6 +1595,12 @@ static void MEI_GetStatusProcPerDev(stru
    struct proc_entry *p = s->private;
    int entity = p->entity;
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    if (entity < MEI_DFEX_ENTITIES)
    {
       seq_printf(s, "********************************" MEI_DRV_CRLF);
@@ -1693,6 +1713,12 @@ static void MEI_GetNfcProcPerDev(struct
    int entity = p->entity;
    char* nfcDisplay;
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    nfcDisplay = MEI_DRVOS_Malloc(MEI_NFC_DISPLAY_BUFFER_SIZE);
    if (!nfcDisplay)
    {
@@ -1754,6 +1780,12 @@ static void MEI_MeminfoProcPerDevGet(str
       (IFX_uint8_t *)(MEI_INTERNAL_ADDRESS_BASE + MEI_PDBRAM_OFFSET);
 #endif
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    printk ("\n++++++++++++++++++ MEI_MeminfoProcPerDevGet ++++++++++++++++++\n\n");
    if ((entity < MEI_DFEX_ENTITIES) && (MEIX_Cntrl[entity] != NULL))
    {
@@ -1868,6 +1900,12 @@ static int MEI_BarUsrDbgProcPerDevSet(st
    int barIdx = -1;
    uint32_t bar_addr = 0;
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    if ((entity < MEI_DFEX_ENTITIES) && (MEIX_Cntrl[entity] != NULL))
    {
       for (devNum=0; devNum<MEI_DFE_INSTANCE_PER_ENTITY; devNum++)
@@ -1937,8 +1975,16 @@ static int MEI_EntitiesEnableCtrl(struct
    char proc_str[16] = { '\0' };
    int nEntity = 0, nInstance = 0, ret = 0;
    int nEntitiesEnableCtrl = 0, nEntitiesEnabled = MEI_DEVICE_CFG_VALUE_GET(EntitiesEnabled);
+   IFX_uint8_t nDisabledLinesCounter = 0;
+   IFX_boolean_t bKillMEIControlThread = IFX_FALSE;
    MEIX_CNTRL_T *pXCntrl;
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    if (count > sizeof(proc_str) - 1)
    {
       return -EINVAL;
@@ -1952,7 +1998,7 @@ static int MEI_EntitiesEnableCtrl(struct
    proc_str[count] = 0;
    sscanf(proc_str, "%d", &nEntitiesEnableCtrl);
 
-   if(nEntitiesEnableCtrl > MEI_DFEX_ENTITIES || nEntitiesEnableCtrl < 0) 
+   if(nEntitiesEnableCtrl > MEI_DFEX_ENTITIES || nEntitiesEnableCtrl < 0)
    {
       PRN_DBG_USR_NL( MEI_DRV,MEI_DRV_PRN_LEVEL_HIGH,
          ("MEI_DRV: Incorrect parameter" MEI_DRV_CRLF));
@@ -1960,15 +2006,23 @@ static int MEI_EntitiesEnableCtrl(struct
       return e_MEI_ERR_INVAL_ARG;
    }
 
-   if(nEntitiesEnableCtrl < nEntitiesEnabled) 
+   if(nEntitiesEnableCtrl < nEntitiesEnabled)
    {
-      for(nEntity = nEntitiesEnabled - 1; nEntity >= nEntitiesEnableCtrl; --nEntity) 
+      nDisabledLinesCounter = 0;
+      for(nEntity = nEntitiesEnabled - 1; nEntity >= nEntitiesEnableCtrl; --nEntity)
       {
+         ++nDisabledLinesCounter;
+
+         if (nEntitiesEnabled == nDisabledLinesCounter)
+         {
+            bKillMEIControlThread = IFX_TRUE;
+         }
+
          if ((pXCntrl = MEIX_Cntrl[nEntity]) != NULL)
          {
             for (nInstance = 0; nInstance < MEI_DFE_INSTANCE_PER_ENTITY; ++nInstance)
             {
-               ret = MEI_InternalLineTCModeSwitch(nEntity, nInstance, IFX_FALSE);
+               ret = MEI_InternalLineTCModeSwitch(nEntity, nInstance, IFX_FALSE, bKillMEIControlThread);
             }
          }
       }
@@ -1981,7 +2035,7 @@ static int MEI_EntitiesEnableCtrl(struct
          {
             for (nInstance = 0; nInstance < MEI_DFE_INSTANCE_PER_ENTITY; ++nInstance)
             {
-               ret = MEI_InternalLineTCModeSwitch(nEntity, nInstance, IFX_TRUE);
+               ret = MEI_InternalLineTCModeSwitch(nEntity, nInstance, IFX_TRUE, bKillMEIControlThread);
             }
          }
       }
@@ -1991,7 +2045,7 @@ static int MEI_EntitiesEnableCtrl(struct
    {
       MEI_DEVICE_CFG_VALUE_SET(EntitiesEnabled, nEntitiesEnableCtrl);
    }
-   
+
    return count;
 }
 
@@ -2525,11 +2579,18 @@ static void MEI_driver_exit (void)
    {
       mei_devt = MKDEV(major_number, entity);
       device_destroy(mei_class, mei_devt);
+
+      if (p_mei_cdevs[entity])
+      {
+         cdev_del(p_mei_cdevs[entity]);
+         p_mei_cdevs[entity] = IFX_NULL;
+      }
    }
    class_destroy(mei_class);
    mei_class = NULL;
 
-   unregister_chrdev ( major_number , DRV_MEI_NAME );
+   mei_devt = MKDEV(major_number, 0);
+   unregister_chrdev_region(mei_devt, MEI_DFEX_ENTITIES);
 #endif
 
 #if CONFIG_PROC_FS
@@ -2589,7 +2650,6 @@ static int MEI_InitModuleRegCharDev(cons
    int entity, dfe_ch;
    char buf[10];
 
-
    if (!(MEI_base_dir_handle = devfs_mk_dir(NULL, devName, NULL)))
    {
       PRN_DBG_USR_NL( MEI_DRV,MEI_DRV_PRN_LEVEL_HIGH,
@@ -2655,37 +2715,88 @@ static int MEI_InitModuleRegCharDev(cons
 
    int result;
    static dev_t mei_devt;
-   if (major_number == 0)
+   struct device *tmp_dev = NULL;
+
+   if (mei_class == NULL)
    {
-      result = register_chrdev( major_number , DRV_MEI_NAME, &MEI_fops);
-      if ( result < 0 )
+      memset(&(p_mei_cdevs), 0x00, sizeof(struct cdev *) * MEI_MAX_SUPPORTED_DFEX_ENTITIES);
+
+      if (major_number != 0)
+      {
+         mei_devt = MKDEV(major_number, 0);
+         result = register_chrdev_region(mei_devt, MEI_DFEX_ENTITIES, DRV_MEI_NAME);
+      }
+      else
+      {
+         result = alloc_chrdev_region(&mei_devt, 0, MEI_DFEX_ENTITIES, DRV_MEI_NAME);
+      }
+
+      if (result < 0)
       {
          PRN_DBG_USR_NL( MEI_DRV,MEI_DRV_PRN_LEVEL_HIGH,
-                         ("MEI_DRV: device %s - can't get major %d" MEI_DRV_CRLF,
-                          devName, major_number));
+            ("MEI_DRV: device %s - can't get major %d" MEI_DRV_CRLF,
+            devName, MAJOR(mei_devt)));
          return result;
       }
-      /* dynamic major                       */
-      if ( major_number == 0 )
+      else
       {
-         major_number = result;
+         major_number = MAJOR(mei_devt);
          PRN_DBG_USR_NL( MEI_DRV,MEI_DRV_PRN_LEVEL_HIGH,
-                         ("Using major number %d" MEI_DRV_CRLF, major_number));
+            ("Using major number %d" MEI_DRV_CRLF, MAJOR(mei_devt)));
       }
 
-      /* create a device class used for createing /dev/ entries */
       mei_class = class_create(THIS_MODULE, devName);
-      if (IS_ERR(mei_class)) {
+      if (IS_ERR(mei_class))
+      {
          PRN_DBG_USR_NL( MEI_DRV,MEI_DRV_PRN_LEVEL_HIGH,
-                         ("MEI_DRV: can not create class for %s" MEI_DRV_CRLF, devName));
+            ("MEI_DRV: can not create class for %s" MEI_DRV_CRLF, devName));
          return PTR_ERR(mei_class);
       }
    }
+   else
+   {
+      mei_devt = MKDEV(major_number, entity);
+   }
+
+   if (entity >= MEI_DFEX_ENTITIES || entity < 0)
+   {
+      PRN_DBG_USR_NL( MEI_DRV,MEI_DRV_PRN_LEVEL_HIGH,
+         ("MEI_DRV: Wrong number of entities: %d" MEI_DRV_CRLF,
+         entity));
+      return -e_MEI_ERR_DEV_INIT;
+   }
+
+   p_mei_cdevs[entity] = cdev_alloc();
+   if (p_mei_cdevs[entity] != IFX_NULL)
+   {
+      p_mei_cdevs[entity]->ops = &MEI_fops;
+      p_mei_cdevs[entity]->owner = THIS_MODULE;
+   }
+   else
+   {
+      PRN_DBG_USR_NL( MEI_DRV,MEI_DRV_PRN_LEVEL_HIGH,
+         ("MEI_DRV: can't alloc cdev <dev_node=%d>" MEI_DRV_CRLF, MINOR(mei_devt)));
+      return -e_MEI_ERR_DEV_INIT;
+   }
 
-   /* create /dev/ entry for each device */
-   mei_devt = MKDEV(major_number, entity);
-   device_create(mei_class, NULL, mei_devt, NULL, "%s/%i", devName, entity);
+   result = cdev_add(p_mei_cdevs[entity], mei_devt, 1);
+   if (result < 0)
+   {
+      PRN_DBG_USR_NL( MEI_DRV,MEI_DRV_PRN_LEVEL_HIGH,
+         ("MEI_DRV: can't add cdev <dev_node=%d> to system (result=%d)" MEI_DRV_CRLF,
+          MINOR(mei_devt), result));
+      return -e_MEI_ERR_DEV_INIT;
+   }
+
+   tmp_dev = device_create(mei_class, NULL, mei_devt, NULL, "%s/%i", devName, entity);
 
+   if (IS_ERR(tmp_dev))
+   {
+      PRN_DBG_USR_NL( MEI_DRV,MEI_DRV_PRN_LEVEL_HIGH,
+         ("MEI_DRV: cannot create device node <%s/%i>" MEI_DRV_CRLF,
+          devName, MINOR(mei_devt)));
+      return -e_MEI_ERR_DEV_INIT;
+   }
 #endif      /* CONFIG_DEVFS_FS */
 
 #if CONFIG_PROC_FS
--- a/src/drv_mei_cpe_linux_proc_config.c
+++ b/src/drv_mei_cpe_linux_proc_config.c
@@ -51,6 +51,7 @@
 #include <linux/ctype.h>
 #include <linux/ioport.h>
 #include <linux/irq.h>
+#include <linux/capability.h>
 #include <asm/io.h>
 
 #ifdef CONFIG_DEVFS_FS
@@ -317,6 +318,12 @@ static int MEI_ProcWriteConfigGlobalDbgC
    unsigned int glDbgLevelCntrl[7] = {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF,
                                       0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    if (pArg == NULL)
    {
       PRN_ERR_USR_NL( MEI_DRV, MEI_DRV_PRN_LEVEL_ERR,
@@ -360,6 +367,11 @@ static int MEI_ProcWriteConfigGlobalDbgC
 */
 static void MEI_ProcReadConfigGlobalDbgConfig(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
 
    seq_printf(s, "%2d: %s \tT = %d L = %d \tCnt = 0x%X, Mask[0..3] = 0x%X 0x%X 0x%X 0x%X" MEI_DRV_CRLF,
                     e_PROCFS_CONFIG_G_DBG_CONFIG,
@@ -381,6 +393,12 @@ static int MEI_ProcWriteConfigLog(char *
 {
    unsigned long level;
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    level = (IFX_int32_t)MEI_GetDigitValue(pArg, 0);
 
    if ( (level>=MEI_DRV_PRN_LEVEL_LOW) &&  (level<=MEI_DRV_PRN_LEVEL_OFF) )
@@ -402,6 +420,12 @@ static int MEI_ProcWriteConfigLog(char *
 */
 static void MEI_ProcReadConfigLog(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%2d: %s \t= %2d" MEI_DRV_CRLF,
                     e_PROCFS_CONFIG_LOG,
                     arrVrxDfeProcFsConfigTable[e_PROCFS_CONFIG_LOG].pName,
@@ -415,6 +439,12 @@ static int MEI_ProcWriteConfigTrace(char
 {
    unsigned long level;
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    level = (IFX_int32_t)MEI_GetDigitValue(pArg, 0);
 
    if ( (level>=MEI_DRV_PRN_LEVEL_LOW) &&  (level<=MEI_DRV_PRN_LEVEL_OFF) )
@@ -437,6 +467,12 @@ static int MEI_ProcWriteConfigTrace(char
 */
 static void MEI_ProcReadConfigTrace(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%2d: %s \t= %2d" MEI_DRV_CRLF,
                     e_PROCFS_CONFIG_TRACE,
                     arrVrxDfeProcFsConfigTable[e_PROCFS_CONFIG_TRACE].pName,
@@ -450,6 +486,12 @@ static int MEI_ProcWriteConfigLogMei(cha
 {
    unsigned long level;
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    level = (IFX_int32_t)MEI_GetDigitValue(pArg, 0);
 
    if ( (level>=MEI_DRV_PRN_LEVEL_LOW) &&  (level<=MEI_DRV_PRN_LEVEL_OFF) )
@@ -472,6 +514,12 @@ static int MEI_ProcWriteConfigLogMei(cha
 */
 static void MEI_ProcReadConfigLogMei(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%2d: %s \t= %2d" MEI_DRV_CRLF,
                     e_PROCFS_CONFIG_LOG_MEI,
                     arrVrxDfeProcFsConfigTable[e_PROCFS_CONFIG_LOG_MEI].pName,
@@ -486,6 +534,12 @@ static int MEI_ProcWriteConfigTraceMei(c
 {
    unsigned long level;
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    level = (IFX_int32_t)MEI_GetDigitValue(pArg, 0);
 
    if ( (level>=MEI_DRV_PRN_LEVEL_LOW) &&  (level<=MEI_DRV_PRN_LEVEL_OFF) )
@@ -508,6 +562,12 @@ static int MEI_ProcWriteConfigTraceMei(c
 */
 static void MEI_ProcReadConfigTraceMei(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%2d: %s \t= %2d" MEI_DRV_CRLF,
                     e_PROCFS_CONFIG_TRACE_MEI,
                     arrVrxDfeProcFsConfigTable[e_PROCFS_CONFIG_TRACE_MEI].pName,
@@ -522,6 +582,12 @@ static int MEI_ProcWriteConfigMailboxME2
 {
    unsigned long addr = 0;
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    addr = (IFX_int32_t)MEI_GetDigitValue(pArg, 16);
 
    MEI_MailboxBase_ME2ARC = addr;
@@ -535,6 +601,12 @@ static int MEI_ProcWriteConfigMailboxME2
 */
 static void MEI_ProcReadConfigMailboxME2ARC(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%2d: %s \t= 0x%08X" MEI_DRV_CRLF,
                     e_PROCFS_CONFIG_MB_ME2ARC,
                     arrVrxDfeProcFsConfigTable[e_PROCFS_CONFIG_MB_ME2ARC].pName,
@@ -549,6 +621,12 @@ static int MEI_ProcWriteConfigMailboxARC
 {
    unsigned long addr = 0;
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    addr = (IFX_int32_t)MEI_GetDigitValue(pArg, 16);
 
    MEI_MailboxBase_ARC2ME = addr;
@@ -562,6 +640,12 @@ static int MEI_ProcWriteConfigMailboxARC
 */
 static void MEI_ProcReadConfigMailboxARC2ME(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%2d: %s \t= 0x%08X" MEI_DRV_CRLF,
                     e_PROCFS_CONFIG_MB_ARC2ME,
                     arrVrxDfeProcFsConfigTable[e_PROCFS_CONFIG_MB_ARC2ME].pName,
@@ -578,6 +662,12 @@ static int MEI_ProcWriteConfigTraceRom(c
 {
    unsigned long level;
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    level = (IFX_int32_t)MEI_GetDigitValue(pArg, 0);
 
    if ( (level>=MEI_DRV_PRN_LEVEL_LOW) &&  (level<=MEI_DRV_PRN_LEVEL_OFF) )
@@ -600,6 +690,12 @@ static int MEI_ProcWriteConfigTraceRom(c
 */
 static void MEI_ProcReadConfigTraceRom(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%2d: %s \t= %2d" MEI_DRV_CRLF,
                     e_PROCFS_CONFIG_TRACE_DL_ROM,
                     arrVrxDfeProcFsConfigTable[e_PROCFS_CONFIG_TRACE_DL_ROM].pName,
@@ -615,6 +711,12 @@ static int MEI_ProcWriteConfigBlockTimeo
 {
    unsigned long block = 0;
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    block = MEI_GetDigitValue(pArg, 10);
 
    MEI_BlockTimeout = (block==0)? 0 : 1;
@@ -628,6 +730,12 @@ static int MEI_ProcWriteConfigBlockTimeo
 */
 static void MEI_ProcReadConfigBlockTimeout(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%2d: %s \t= %d" MEI_DRV_CRLF,
                     e_PROCFS_CONFIG_BLOCK_TOUT,
                     arrVrxDfeProcFsConfigTable[e_PROCFS_CONFIG_BLOCK_TOUT].pName,
@@ -642,6 +750,12 @@ static int MEI_ProcWriteConfigMaxWaitMod
 {
    unsigned long max_wait_ms = 0;
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    max_wait_ms = MEI_GetDigitValue(pArg, 10);
    MEI_MaxWaitForModemReady_ms = max_wait_ms | MEI_CFG_DEF_WAIT_PROTECTION_FLAG;
 
@@ -653,6 +767,12 @@ static int MEI_ProcWriteConfigMaxWaitMod
 */
 static void MEI_ProcReadConfigMaxWaitModemOnline(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%2d: %s \t= %s%d [ms]\n\r",
                     e_PROCFS_CONFIG_W_MODEM_ONLINE,
                     arrVrxDfeProcFsConfigTable[e_PROCFS_CONFIG_W_MODEM_ONLINE].pName,
@@ -668,6 +788,12 @@ static int MEI_ProcWriteConfigMaxWaitDfe
 {
    unsigned long max_wait_ms = 0;
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    max_wait_ms = MEI_GetDigitValue(pArg, 10);
 
    MEI_MaxWaitDfeResponce_ms = max_wait_ms;
@@ -681,6 +807,12 @@ static int MEI_ProcWriteConfigMaxWaitDfe
 */
 static void MEI_ProcReadConfigMaxWaitDfeResp(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%2d: %s \t= %d [ms]" MEI_DRV_CRLF,
                     e_PROCFS_CONFIG_W_DFE_RESP,
                     arrVrxDfeProcFsConfigTable[e_PROCFS_CONFIG_W_DFE_RESP].pName,
@@ -696,6 +828,12 @@ static int MEI_ProcWriteConfigFwSelect(c
 {
    unsigned long fwmode = 0;
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    fwmode = MEI_GetDigitValue(pArg, 0x10);
 
    MEI_fwModeSelect = (IFX_int32_t)(fwmode);
@@ -709,6 +847,12 @@ static int MEI_ProcWriteConfigFwSelect(c
 */
 static void MEI_ProcReadConfigFwSelect(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%2d: %s \t= 0x%02X " MEI_DRV_CRLF,
                     e_PROCFS_CONFIG_FW_SELECT,
                     arrVrxDfeProcFsConfigTable[e_PROCFS_CONFIG_FW_SELECT].pName,
@@ -725,6 +869,12 @@ static int MEI_ProcWriteConfigFsmSetPreA
 {
    unsigned long actionFlags = 0;
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    actionFlags = MEI_GetDigitValue(pArg, 0x10);
 
    MEI_FsmStateSetMsgPreAction = (IFX_int32_t)(actionFlags);
@@ -737,6 +887,12 @@ static int MEI_ProcWriteConfigFsmSetPreA
 */
 static void MEI_ProcReadConfigFsmSetPreAct(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%2d: %s \t= 0x%02X " MEI_DRV_CRLF,
                     e_PROCFS_CONFIG_FSM_SET_PRE_ACT,
                     arrVrxDfeProcFsConfigTable[e_PROCFS_CONFIG_FSM_SET_PRE_ACT].pName,
@@ -750,6 +906,13 @@ static void MEI_ProcReadConfigFsmSetPreA
 static int MEI_ProcWriteConfigMsgDumpEnable(char *pArg)
 {
    unsigned long tmpVal;
+
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    tmpVal = (IFX_int32_t)MEI_GetDigitValue(pArg, 16);
 
    /*
@@ -776,6 +939,12 @@ static void MEI_ProcReadConfigMsgDumpEna
 {
    unsigned long tmpVal;
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    tmpVal = ( MEI_msgDumpEnable | (MEI_msgDumpSetLabel ? 0x00000080 : 0x0) |
               (MEI_msgDumpOutCntrl << 8) |
               ( ((IFX_uint32_t)MEI_msgDumpLine) << 16) );
@@ -788,12 +957,24 @@ static void MEI_ProcReadConfigMsgDumpEna
 
 static int MEI_ProcWriteConfigMsgDumpId(char *pArg)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    MEI_msgDumpId = (IFX_int16_t)MEI_GetDigitValue(pArg, 10);
    return 0;
 }
 
 static void MEI_ProcReadConfigMsgDumpId(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%2d: %s \t= 0x%02X " MEI_DRV_CRLF,
                     e_PROCFS_CONFIG_MDMP_ID,
                     arrVrxDfeProcFsConfigTable[e_PROCFS_CONFIG_MDMP_ID].pName,
@@ -812,6 +993,12 @@ static int MEI_ProcWriteConfigMeiAccCse(
           the top of this file !!! */
    unsigned int meiDmyCnt[3] = {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    MEI_GetDigitArray(pArg, meiDmyCnt, 2, 16);
 
    if ( (meiDmyCnt[0] != 0xFFFFFFFF) &&
@@ -829,6 +1016,12 @@ static int MEI_ProcWriteConfigMeiAccCse(
 */
 static void MEI_ProcReadConfigMeiAccCse(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%2d: %s \tRd=%d \tWr=%d\n\r",
                     e_PROCFS_CONFIG_MEI_ACCESS_ADD_CSE,
                     arrVrxDfeProcFsConfigTable[e_PROCFS_CONFIG_MEI_ACCESS_ADD_CSE].pName,
@@ -842,6 +1035,12 @@ static void MEI_ProcReadConfigMeiAccCse(
 */
 static int MEI_ProcWriteConfigDebugFlags(char *pArg)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    MEI_DbgFlags = MEI_GetDigitValue(pArg, 10);
 
    return 0;
@@ -853,6 +1052,12 @@ static int MEI_ProcWriteConfigDebugFlags
 */
 static void MEI_ProcReadConfigDebugFlags(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%2d: %s \t= %d" MEI_DRV_CRLF
                  "\tBit0    : 0 = NOP, 1 = ARC HALT" MEI_DRV_CRLF
                  "\tBit1    : 0 = NOP, 1 = PMU/PLL on" MEI_DRV_CRLF
@@ -869,6 +1074,12 @@ static void MEI_ProcReadConfigDebugFlags
 */
 static int MEI_ProcWriteConfigDebugLogger(char *pArg)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    MEI_DbgLogger = MEI_GetDigitValue(pArg, 10);
 
    return 0;
@@ -879,6 +1090,12 @@ static int MEI_ProcWriteConfigDebugLogge
 */
 static void MEI_ProcReadConfigDebugLogger(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%2d: %s \t= %d" MEI_DRV_CRLF
                  "\t0: Logger is not used" MEI_DRV_CRLF
                  "\t1: Logger is used" MEI_DRV_CRLF,
@@ -896,6 +1113,12 @@ static int MEI_ProcWriteConfigDTestCntrl
 {
    unsigned int testCntrl[3] = {0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF};
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    MEI_GetDigitArray(pArg, testCntrl, 3, 16);
 
    if (testCntrl[0] != 0xFFFFFFFF)
@@ -916,6 +1139,12 @@ static int MEI_ProcWriteConfigDTestCntrl
 */
 static void MEI_ProcReadConfigDTestCntrl(struct seq_file *s)
 {
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return;
+   }
+
    seq_printf(s, "%2d: %s \t= 0x%08X min = 0x%08X max = 0x%08X" MEI_DRV_CRLF,
                     e_PROCFS_CONFIG_DTEST_CNTRL,
                     arrVrxDfeProcFsConfigTable[e_PROCFS_CONFIG_DTEST_CNTRL].pName,
--- a/src/drv_mei_cpe_safec_wrapper.h
+++ b/src/drv_mei_cpe_safec_wrapper.h
@@ -1,7 +1,6 @@
 /******************************************************************************
 
-               Copyright (c) 2018
-            Lantiq Beteiligungs-GmbH & Co. KG
+               Copyright (c) 2018 - 2019 Intel Corporation
 
    For licensing information, see the file 'LICENSE' in the root folder of
    this software module.
@@ -11,9 +10,11 @@
 #ifndef _DRV_MEI_CPE_SAFEC_WRAPPER_H
 #define _DRV_MEI_CPE_SAFEC_WRAPPER_H
 
-#if defined SAFEC_SUPPORT && (SAFEC_SUPPORT == 1)
-#include "safe_lib.h"
-#define MEI_strncpy_s          strncpy_s
+#if defined (SAFEC_SUPPORT) && (SAFEC_SUPPORT == 3)
+#include "safe_str_lib.h"
+
+#define MEI_strncpy_s strncpy_s
+
 #else
 
 #warning "Opensource Safe C library is not available!"
@@ -25,6 +26,8 @@ static __inline__ size_t MEI_min(const s
 }
 
 #define MEI_strncpy_s(dest, destsz, src, srcsz)        strncpy(dest, src, MEI_min(destsz, srcsz))
-#endif /* defined (SAFEC_SUPPORT) && (SAFEC_SUPPORT == 1) */
 
-#endif /* _DRV_MEI_CPE_SAFEC_WRAPPER_H */
\ No newline at end of file
+#endif /* defined (SAFEC_SUPPORT) && (SAFEC_SUPPORT == 3) */
+
+#endif /* _DRV_MEI_CPE_SAFEC_WRAPPER_H */
+
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -329,6 +329,10 @@ mei_cpe_drv_test_CPPFLAGS = -I@srcdir@\
 				-I@srcdir@/auto_header\
 				-I@KERNEL_INCL_PATH@ $(IFXOS_INCLUDE_PATH)
 
+if SAFEC_SUPPORT
+mei_cpe_drv_test_CPPFLAGS += @SAFEC_INCL_PATH@
+endif
+
 mei_cpe_drv_test_CFLAGS = $(mei_cpe_app_common_cflags) \
 				$(mei_cpe_appl_cflags) $(MEI_DRV_TARGET_OPTIONS)
 
@@ -346,6 +350,11 @@ test_mei_cpe_intern_LDADD = -lifxos $(ds
 mei_cpe_drv_dbg_strm_dmp_CPPFLAGS = -I@srcdir@\
 				-I@srcdir@/auto_header\
 				-I@KERNEL_INCL_PATH@ $(IFXOS_INCLUDE_PATH)
+
+if SAFEC_SUPPORT
+mei_cpe_drv_dbg_strm_dmp_CPPFLAGS += @SAFEC_INCL_PATH@
+endif
+
 mei_cpe_drv_dbg_strm_dmp_CFLAGS = $(mei_cpe_app_common_cflags) \
 				$(mei_cpe_appl_cflags) $(MEI_DRV_TARGET_OPTIONS)
 mei_cpe_drv_dbg_strm_dmp_LDFLAGS = $(mei_cpe_appl_ldflags) -Bstatic -dn -static @IFXOS_LIBRARY_PATH@ \
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -1,7 +1,7 @@
-# Makefile.in generated by automake 1.15 from Makefile.am.
+# Makefile.in generated by automake 1.15.1 from Makefile.am.
 # @configure_input@
 
-# Copyright (C) 1994-2014 Free Software Foundation, Inc.
+# Copyright (C) 1994-2017 Free Software Foundation, Inc.
 
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -116,6 +116,8 @@ POST_UNINSTALL = :
 # with void pointers (which is allowed for gcc!)
 @ADD_DRV_CFLAGS_SET_FALSE@@KERNEL_2_6_FALSE@@TARGET_ADM5120_MIPSEL_FALSE@am__append_6 = -Wpointer-arith
 @SAFEC_SUPPORT_TRUE@am__append_7 = @SAFEC_INCL_PATH@
+@MEI_TEST_APPL_ENABLE_TRUE@@SAFEC_SUPPORT_TRUE@am__append_8 = @SAFEC_INCL_PATH@
+@SAFEC_SUPPORT_TRUE@am__append_9 = @SAFEC_INCL_PATH@
 subdir = src
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/configure.in
@@ -421,7 +423,6 @@ PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
 SAFEC_INCL_PATH = @SAFEC_INCL_PATH@
-SAFEC_LIB_FUNC = @SAFEC_LIB_FUNC@
 SAFEC_LIB_NAME = @SAFEC_LIB_NAME@
 SAFEC_LIB_PATH = @SAFEC_LIB_PATH@
 SAFEC_SUPPORT = @SAFEC_SUPPORT@
@@ -619,11 +620,9 @@ AM_CFLAGS = -Wall -Wimplicit -Wunused -W
 @IFXOS_ENABLE_TRUE@AM_LDFLAGS = \
 @IFXOS_ENABLE_TRUE@	-Bstatic -dn -static @IFXOS_LIBRARY_PATH@
 
-@ENABLE_ECOS_FALSE@drv_mei_cpe_common_cflags = $(AM_CFLAGS) \
-@ENABLE_ECOS_FALSE@	-D__KERNEL__ -DLINUX -D__linux__ -DMODULE \
-@ENABLE_ECOS_FALSE@	-DEXPORT_SYMTAB -pipe -Wall -Wimplicit \
-@ENABLE_ECOS_FALSE@	-Wunused -Wuninitialized -Wstrict-aliasing \
-@ENABLE_ECOS_FALSE@	-Wno-date-time $(am__append_6)
+@ENABLE_ECOS_FALSE@drv_mei_cpe_common_cflags = -D__KERNEL__ -DLINUX \
+@ENABLE_ECOS_FALSE@	-D__linux__ -DMODULE -DEXPORT_SYMTAB \
+@ENABLE_ECOS_FALSE@	$(am__append_6)
 
 #
 # common driver cflags
@@ -687,10 +686,11 @@ mei_cpe_app_common_cflags = -DLINUX -ans
 dsl_cpe_mei_LDFLAGS = \
 $(dsl_cpe_mei_safec_ldflags)
 
-@MEI_TEST_APPL_ENABLE_TRUE@mei_cpe_drv_test_CPPFLAGS = -I@srcdir@\
-@MEI_TEST_APPL_ENABLE_TRUE@				-I@srcdir@/auto_header\
-@MEI_TEST_APPL_ENABLE_TRUE@				-I@KERNEL_INCL_PATH@ $(IFXOS_INCLUDE_PATH)
-
+@MEI_TEST_APPL_ENABLE_TRUE@mei_cpe_drv_test_CPPFLAGS = -I@srcdir@ \
+@MEI_TEST_APPL_ENABLE_TRUE@	-I@srcdir@/auto_header \
+@MEI_TEST_APPL_ENABLE_TRUE@	-I@KERNEL_INCL_PATH@ \
+@MEI_TEST_APPL_ENABLE_TRUE@	$(IFXOS_INCLUDE_PATH) \
+@MEI_TEST_APPL_ENABLE_TRUE@	$(am__append_8)
 @MEI_TEST_APPL_ENABLE_TRUE@mei_cpe_drv_test_CFLAGS = $(mei_cpe_app_common_cflags) \
 @MEI_TEST_APPL_ENABLE_TRUE@				$(mei_cpe_appl_cflags) $(MEI_DRV_TARGET_OPTIONS)
 
@@ -703,10 +703,8 @@ test_mei_cpe_intern_CFLAGS = $(mei_cpe_a
 
 test_mei_cpe_intern_LDFLAGS = $(mei_cpe_appl_ldflags) $(dsl_cpe_mei_LDFLAGS)
 test_mei_cpe_intern_LDADD = -lifxos $(dsl_cpe_mei_LDADD)
-mei_cpe_drv_dbg_strm_dmp_CPPFLAGS = -I@srcdir@\
-				-I@srcdir@/auto_header\
-				-I@KERNEL_INCL_PATH@ $(IFXOS_INCLUDE_PATH)
-
+mei_cpe_drv_dbg_strm_dmp_CPPFLAGS = -I@srcdir@ -I@srcdir@/auto_header \
+	-I@KERNEL_INCL_PATH@ $(IFXOS_INCLUDE_PATH) $(am__append_9)
 mei_cpe_drv_dbg_strm_dmp_CFLAGS = $(mei_cpe_app_common_cflags) \
 				$(mei_cpe_appl_cflags) $(MEI_DRV_TARGET_OPTIONS)
 
--- a/src/test_internal/drv_test_mei_cpe_linux.c
+++ b/src/test_internal/drv_test_mei_cpe_linux.c
@@ -44,6 +44,7 @@
 
 #if CONFIG_PROC_FS
 #include <linux/proc_fs.h>
+#include <linux/capability.h>
 #endif
 
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
@@ -879,6 +880,12 @@ static int MEI_TEST_GetVersionProc(char
 {
     int len;
 
+    if (!capable(CAP_NET_ADMIN))
+    {
+       printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+       return -EPERM;
+    }
+
     len = sprintf(buf, "%s" MEI_DRV_CRLF, &MEI_TEST_DRV_WHAT_STR[4]);
 
     len += sprintf(buf + len, "Compiled on %s, %s for Linux kernel %s (jiffies: %ld)" MEI_DRV_CRLF,
@@ -896,9 +903,14 @@ static int MEI_TEST_ReadProc(char *page,
                               int count, int *eof, void *data)
 {
    int len;
-
    int (*fn)(char *buf);
 
+   if (!capable(CAP_NET_ADMIN))
+   {
+      printk(KERN_ERR "Permission denied" MEI_DRV_CRLF);
+      return -EPERM;
+   }
+
    if (data != NULL)
    {
        fn = (int (*)(char*))data;
