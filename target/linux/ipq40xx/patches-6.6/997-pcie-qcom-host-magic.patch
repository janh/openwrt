This hack is based on code from the FRITZ!Box 7530 GPL archive for
firmware version 07.50.

If the device tree contains the "avm,host_magic" property, it changes
the PCIe vendor/device ID to the values from Lantiq GRX500 SoCs. It also
programs the ATU to present a buffer containing a magic value to PCIe
devices. This appears to emulate a Lantiq CPU ID register.

Without this hack, some VRX518 modems fail to initialize properly (error
"dc_ep_clk_on failed"), and the DSL data path doesn't work.
--- a/drivers/pci/controller/dwc/pcie-qcom.c
+++ b/drivers/pci/controller/dwc/pcie-qcom.c
@@ -151,6 +151,8 @@
 
 #define QCOM_PCIE_CRC8_POLYNOMIAL		(BIT(2) | BIT(1) | BIT(0))
 
+#define PCIE_MAGIC_SIZE				0x10000
+
 #define QCOM_PCIE_1_0_0_MAX_CLOCKS		4
 struct qcom_pcie_resources_1_0_0 {
 	struct clk_bulk_data clks[QCOM_PCIE_1_0_0_MAX_CLOCKS];
@@ -243,6 +245,8 @@ struct qcom_pcie {
 	const struct qcom_pcie_cfg *cfg;
 	struct dentry *debugfs;
 	bool suspended;
+	void *magic_cpu_addr;
+	dma_addr_t magic_dma_handle;
 };
 
 #define to_qcom_pcie(x)		dev_get_drvdata((x)->dev)
@@ -1224,9 +1228,102 @@ static void qcom_pcie_host_deinit(struct
 	pcie->cfg->ops->deinit(pcie);
 }
 
+static int qcom_pcie_magic_prog_atu(struct qcom_pcie *pcie,
+				    u32 addr, u32 phys, u32 size)
+{
+	struct dw_pcie *pci = pcie->pci;
+	struct device *dev = pci->dev;
+	int index;
+	int ret;
+
+	if (!pci->num_ib_windows) {
+		dev_err(dev, "No inbound ATU window available for magic\n");
+		return -1;
+	}
+
+	/*
+	 * Use highest window index and reduce window count so the driver
+	 * won't overwrite the entry later.
+	 */
+	index = --pci->num_ib_windows;
+
+	/* The order of the arguments phys and addr is intentional. */
+	ret = dw_pcie_prog_inbound_atu(pci, index, PCIE_ATU_TYPE_MEM,
+	                               phys, addr, size);
+
+	if (ret)
+		dev_err(dev, "Failed to program ATU for magic: %d\n", ret);
+
+	return ret;
+}
+
+static void qcom_pcie_magic_deinit(struct qcom_pcie *pcie)
+{
+	struct dw_pcie *pci = pcie->pci;
+	struct device *dev = pci->dev;
+
+	if (pcie->magic_cpu_addr) {
+		dma_free_coherent(dev, PCIE_MAGIC_SIZE,
+				  pcie->magic_cpu_addr,
+				  pcie->magic_dma_handle);
+
+		pcie->magic_cpu_addr = NULL;
+	}
+}
+
+static void qcom_pcie_magic_init(struct qcom_pcie *pcie)
+{
+	struct dw_pcie *pci = pcie->pci;
+	struct device *dev = pci->dev;
+	u32 *virt;
+	u32 phys;
+	int ret;
+
+	if (!of_property_read_bool(dev->of_node, "avm,host_magic"))
+		return;
+
+	dev_info(dev, "Applying PCIe host magic\n");
+
+	virt = dma_alloc_coherent(dev, PCIE_MAGIC_SIZE, &phys, GFP_ATOMIC);
+	BUG_ON(virt == NULL);
+
+	pcie->magic_cpu_addr = virt;
+	pcie->magic_dma_handle = phys;
+
+	/*
+	 * This value is the manufacturer ID of Lantiq. The address where
+	 * it will be visible for the PCIe device matches the location of
+	 * CPU ID registers on Lantiq SocS (MPS base address is 0x1f107000).
+	 */
+	virt[0x7340/4] = 0x389 << 5;
+
+	/* Make it visible to PCIe devices using address translation unit */
+	ret = qcom_pcie_magic_prog_atu(pcie, 0x1f100000, phys, PCIE_MAGIC_SIZE);
+
+	dw_pcie_dbi_ro_wr_en(pci);
+
+	/* Set vendor/device ID of GRX500 PCIe host */
+	dw_pcie_writew_dbi(pci, PCI_VENDOR_ID, 0x1bef);
+	dw_pcie_writew_dbi(pci, PCI_DEVICE_ID, 0x0030);
+
+	dw_pcie_dbi_ro_wr_dis(pci);
+
+	if (ret)
+		qcom_pcie_magic_deinit(pcie);
+}
+
+static void qcom_pcie_atu_hack(struct dw_pcie_rp *pp)
+{
+	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
+	struct qcom_pcie *pcie = to_qcom_pcie(pci);
+
+	qcom_pcie_magic_init(pcie);
+}
+
 static const struct dw_pcie_host_ops qcom_pcie_dw_ops = {
 	.host_init	= qcom_pcie_host_init,
 	.host_deinit	= qcom_pcie_host_deinit,
+	.atu_hack	= qcom_pcie_atu_hack,
 };
 
 /* Qcom IP rev.: 2.1.0	Synopsys IP rev.: 4.01a */
@@ -1546,6 +1643,7 @@ static int qcom_pcie_probe(struct platfo
 
 err_phy_exit:
 	phy_exit(pcie->phy);
+	qcom_pcie_magic_deinit(pcie);
 err_pm_runtime_put:
 	pm_runtime_put(dev);
 	pm_runtime_disable(dev);
--- a/drivers/pci/controller/dwc/pcie-designware-host.c
+++ b/drivers/pci/controller/dwc/pcie-designware-host.c
@@ -479,6 +479,14 @@ int dw_pcie_host_init(struct dw_pcie_rp
 
 	dw_pcie_iatu_detect(pci);
 
+	/*
+	 * This needs to be called after ATU detection, but before the driver
+	 * sets up any ATU entries, to avoid any ATU entry programmed in the
+	 * hack being overwritten by the driver later.
+	 */
+	if (pp->ops->atu_hack)
+		pp->ops->atu_hack(pp);
+
 	ret = dw_pcie_edma_detect(pci);
 	if (ret)
 		goto err_free_msi;
--- a/drivers/pci/controller/dwc/pcie-designware.h
+++ b/drivers/pci/controller/dwc/pcie-designware.h
@@ -301,6 +301,7 @@ enum dw_pcie_ltssm {
 struct dw_pcie_host_ops {
 	int (*host_init)(struct dw_pcie_rp *pp);
 	void (*host_deinit)(struct dw_pcie_rp *pp);
+	void (*atu_hack)(struct dw_pcie_rp *pp);
 	int (*msi_host_init)(struct dw_pcie_rp *pp);
 	void (*pme_turn_off)(struct dw_pcie_rp *pp);
 };
